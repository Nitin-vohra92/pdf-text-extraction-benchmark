Weak Kleene Algebra is Sound and (Possibly) Complete for Simulation

Introduction

Kleene algebra [\cite=Kozen] completely axiomatizes (the equational theory of) regular expressions modulo trace equivalence. Here, we show that Weak Kleene Algebra (WKA) completely axiomatizes regular expressions modulo simulation equivalence, assuming that they are complete for the equational theory of monodic trees. Their completeness for monodic trees was claimed by Takai and Furusawa [\cite=MTKA], but later errors in their proof were discovered and have not yet been fixed.

By contrast, Horn axiomatization of regular expressions modulo bisimulation equivalence remains an open problem.

Regular Expressions and Simulation

Milner [\cite=Milner] proposed the following process interpretation of regular expressions, typically presented as a structured operational semantics over the relations [formula] (meaning that x is in an "accepting" state) and [formula] (meaning that state x can evolve into state y through an a-labeled transition), where a is a metavariable ranging over transition labels. We present the theory using calculus notation: x' is the set of terms y such that [formula]. (The transition rules and proofs are uniform in the transition label, so proofs are given only for a.) As usual, we omit the product operator in writing regular expressions (i.e., we write x  ·  y as x..y). We extend the regular expression operators to sets of terms by pointwise application, and cast terms to singleton sets when necessary. Finally, we extend [formula] to a prefix operator on sets: [formula] is S if [formula], and is the empty set otherwise. Using these conventions, Milner's semantics (as presented in [\cite=Baeten]) is as follows:

[formula]

(Note that x' is always finite (by structural induction on x).) A binary relation R is a simulation iff

[formula]

where R has been extended to sets by

[formula]

Define <   as the maximal simulation relation, and simulation equivalence =   by x = y <  =  > x < y / |y < x. Note that simulation equivalence is weaker than bisimulation equivalence, which requires the two simulations to be inverses. For example, a..b  +  a..(b + c) and a..(b + c) are simulation equivalent, but not bisimulation equivalent.

Weak Kleene Algebra

Weak Kleene algebra (WKA) is given by the following axioms over the language of regular expressions (where x < y abbreviates x + y = y).

[formula]

We write | - x = y to mean that x = y is provable from the WKA axioms. It is easy to prove using these axioms that <   is a partial order, and that the regular operators are monotonic wrt. <  . A number of similar process algebras and Kleene-like algebras (e.g. [\cite=LKA]) have been proposed, but lacking the weak right induction law ([\ref=RInduc]), which was first proposed in [\cite=CohenTalk99]. The WKA axioms were independently proposed for probabilistic programs [\cite=CohenTalk] and for monodic regular tree languages [\cite=MTKA].

Soundness

We prove that the WKA axioms are sound for simulation --

[formula]

-- as follows. Given a set of axioms, take the set of instances of these axioms whose hypotheses are satisfied by <  , and in each conclusion replace x < y with xRy and replace x = y with xRy / |yRx, where R is a fresh binary relation symbol. Let R be the weakest relation satisfied by these conclusions; we prove [formula] (which implies that <   is closed under the axioms, and hence the axioms are sound). Defining

[formula]

we show R   ⊆     <   as follows:

R ⊆ <=R ⊆ ⊆ <= def < << is a simulation<=def simulation (A: x,y: x<<y -> (x -> y) /| (A: a: x' << y')) <= transitivity (A: x,y: x y -> (x -> y) /| (A: a: x' << y')) <= < a sim, ⊆ (A: x,y: x R y -> (x -> y) /| (A: a: x' << y'))

Thus, to show soundness of H| - x < y for simulation, we assume H and show [formula] and x' <  < y'. We do this (for all instances of) one axiom at a time, so we can use instances of earlier axioms (since we have already proved that they are sound for simulation). Since H| - xRy (by definition of R), we can also use instances of the axiom being proved, but with <   and =   in the conclusion replaced with <  <  and ~  . Note also that while ' is <  -monotonic (by the definition of <  ), we cannot assume ' is <  < -monotonic.

With this preparation, the soundness proofs (presented in section ([\ref=SoundnessAppendix])) are mostly routine, except for the right-induction axiom ([\ref=RInduc]), whose proof we give here (even though it occurs logically after the others). This axiom is the most interesting because its soundness depends on the finiteness of x'. To see why, suppose x is constructed as an infinite sum x  =  ( + n:(a + 1)n), and let y be a. Then x..(y + 1)  <  x, but it is not the case that x..y:s  <  x. (x..y:s has infinite derivation chains, while x does not.)

The proof of ([\ref=RInduc]) is as follows: assuming x..(y + 1)  <  x,

(x..y:s) -> x

(x..y:s)' =(u..v)' x'..y:s ..y:s =distr (x' )..y:s <x' = x'..1<x'..(y+1) ([\ref=SeqOne]),([\ref=SeqPlus]) (x'..(y+1) )..y:s =def of  ' (x..(y+1))'..y:s <x..(1+y)<x (hyp); monotonicity x'..y:s <<proof below x'

To prove x'..y:s <  < x', define the binary relation Q on (the set) x' by

[formula]

Note uQv -  > u < v / |u..(y + 1) < v (by monotonicity), and that Q is total:

x'..(y+1) <def  < x'..(y+1) =def of  ' (x..(y+1))' <x..(y+1) < x (hyp) x'

Because Q is a total, transitive relation on a finite set, for each u∈x', there is a v such that uQv / |vQv; hence u..y:s <  < v:

u..y:s <u Q v,  so  u<v v..y:s << v Q v,  so  v..(y+1)<v; ([\ref=RInduc]) v

Thus, for every u∈x', u..y:s <  < x', so x'..y:s <  < x'.

Monodic Tree Languages

A monodic tree language is a set of first-order terms over a first order language with a single variable [formula]. For a term t and set of terms S, t(S) is the set of terms obtained from t by replacing each variable instance with an element of S. (Thus, if t has n variable instances and S is finite, t(S) is a set of |S|n terms.) Extend this to sets by [formula].

An interpretation (notation: I,J) is a function from regular expression symbols to tree languages. Extend interpretations to regular expressions as follows (when applied to tree languages, =   denotes ordinary set equality):

[formula]

In [\cite=MTKA], Takai and Furusawa prove that the WKA axioms are sound and complete for the equational theory of regular expressions interpreted as tree languages:

[formula]

Interpretation Respects Simulation

Our last observation is that interpretation respects simulation equivalence:

[formula]

The proof depends on the following property of interpretations (proved in section ([\ref=InterpretationNormal]) by induction on x):

[formula]

To prove ([\ref=InterpretationRespectsSimulation]), we first switch to an interpretation J where [formula]. Let f be a fresh unary function symbol, and define J by

[formula]

For any regular expression z, it is easy to show that I(z) can be computed from J(z) by repeatedly replacing f(t) with t. Thus, it suffices to prove x = y -  > J(x) = J(y).

We prove this by proving the more general [formula], by induction on |t|. For [formula],

∈ J(x) ->([\ref=IntNormal]) x ? (E: a,u: u ∈' /| ∈ J(a)(J(u))) -> ∉ J(a) x -> J(y), ([\ref=IntNormal]) x /| -> def  < x< y

For [formula],

t ∈ J(x)-J(y) -> ([\ref=IntNormal]), t≠ t ∈ ( J(a)(J(z))) /| t∉ ( J(a)(J(z))) -> -> ∉ J(a) ->induc hyp (E:a,u: u ∈' /| (A: v ∈': u< v)) ->def  < x'<y' ->def  < x<y

Completeness

The completeness of WKA for simulation

[formula]

now follows:

x = y -> ([\ref=InterpretationRespectsSimulation]) (A: I: I(x) = I(y)) ->([\ref=mtCompleteness]) |- x = y

Acknowledgements

Bernhard Möller provided useful feedback on the model theory for WKA. Georg Struth first suggested looking into [\cite=MTKA]. Annabelle McIver first proposed using the weak right induction law ([\ref=RInduc]). An anonymous referee found a number of typos, minor errors, and a significant error in the original soundness proof of ([\ref=LInduc]).

Soundness of WKA for Simulation

([\ref=PlusAssoc]): (x+(y+z)) <=> x ? y ? z <=> ((x+y)+z)

(x+(y+z))'=(u+v)' x' ' ' =(u+v)' ((x+y)+z)'

([\ref=PlusIdem]): (x+x)<=>(u+v)' x

(x+x)'=(u+v)' x'

([\ref=PlusComm]): (x+y)<=> x ? y<=> (y+x)

(x+y)'=(u+v)' x' ' =(u+v)' (y+x)'

([\ref=PlusZero]): (x+0) <=> x ? 0 <=>(0) x

(x+0)' =(u+v)' x' ' =0' x'

([\ref=OneSeq]): (1..x)<=>, 1 x

(1..x)'=(u..v)', 1',  x'

([\ref=SeqOne]): (x..1)<=>,  x

(x..1)'=(u..v)', 1' x'..1  ([\ref=SeqOne]) x'

([\ref=ZeroSeq]): (0..x) <=> 0 /| x <=>(0) 0

(0..x)' =(u..v)' 0'..x =0', (0) {} =0' 0'

([\ref=SeqAssoc]): ((x..y)..z)<=> x /| y /| z<=> (x..(y..z))

((x..y)..z)'=(u..v)' (x..y)'..z =(u..v)',  (x'..y )..z =distr (x'..y)..z  ([\ref=SeqAssoc]) x'..(y..z) =(u..v)' x'..(y..z) =(u..v)' (x..(y..z))'

([\ref=PlusSeq]): ((x+y)..z) <=>, (u+v) (x ? y) /| z <=>logic (x /| z) ? (y /| z) <=>, (u+v) (x..z+y..z)

((x+y)..z)' = (u..v)' (x+y)'..z =(u+v)', ,  (x' ')..z =distr (x'..z ) (y'..z ) =(u..v)' (x..z)' '=(u+v)' (x..z + y..z)'

([\ref=SeqPlus]): (x..y+x..z)<=>, (u..v) (x /| y) ? (x /| z)<=> logic x /| (y ? z)<=>, (u..v) (x..(y+z))

(x..y + x..z)' =(u:s)' x'..y '..z = x'..y '..z =distr x'..y '..z <<([\ref=SeqPlus]) x'..(y+z) =(u..v)' (x..(y+z))'

([\ref=StarExp]): x:s <=> <=>, 1 (1 + x..x:s)

x:s' =u =   u ⊆ u x:s' =u:s' x'..x:s =(u..v)' (x..x:s)' =1' 1' ' =(u+v)' (1+x..x:s)'

[formula]

(z..(y:s:x)) <=>, u:s z /| x <=> (z..x)

(z..(y:s:x))' =(u..v)', distr z'..(y:s:x) ..y:s'..x z..y:s..x' =u:s', u:s z'..(y:s:x) ..(y'..y:s)..x ..x' <([\ref=SeqAssoc]) z'..(y:s:x) ..y'..(y:s..x) ..x' <<y..x < x; ([\ref=LInduc])' z'..x ..y'..x ..x' < y..x<x,  so  y'..x < x' z'..x ..x' = (u..v)' (z..x)'

Interpretations as Trees

Here, we prove ([\ref=IntNormal]):

[formula]

where

[formula]

We prove this by induction on the structure of x.

x = 0: I(0) = def  I {} = (0)   {} = 0' = {},  so  I(0) = {}   {} ( I(0))

x = 1: I(1) = def  I {} =1   {} = 1' = {},  so  I(0) = {}   {} ( I(1))

x = b: I(b) =def  () I(b)({}) = ( I(a)({})) =a=b -> b' = {} ( I(a)(b')) = ( ( I(a)(I(z))))=a ≠ b -> b' = {} ( ( I(a)(I(z))))=def  I ( I(b)) =(b)   {} ( I(b))

x = u+v: I(u+v) =def  I I(u) I(v)=induc hyp (   {} ( I(u))) (   {} ( I(v))) = (   {} ) (( I(u)) ( I(v))) =distr,    {} ( I(u)) ( I(v))=   {} ( (I(u) I(v))) =def  I   {} ( ( I(a)(I(z)))) = (x+y)'   {} ( ( I(a)(I(z)))) = def  I   {} ( I(u+v))

x = u..v: I(u..v) = def  I I(u)(I(v)) = induc hyp (   {} ( I(u)))(I(v)) =distr   {}(I(v)) ( I(u))(I(v)) =(S) = S   I(v) ( I(u))(I(v)) =induc hyp   (   {} ( I(v))) ( I(u))(I(v)) =distr     {} ( I(u))(I(v)) =   {} ( I(u))(I(v)) =(a) below   {} ( I(u..v))

(a): ( I(u))(I(v)) =, def  I ( ( I(a)(I(z))(I(v)))) =() assoc ( ( I(a)(I(z)(I(v))))) =I(x..y) ( ( I(a)(I(z..v)))) = ( ( I(a)(I(z)))) =distr ( ( I(a)(I(z)))) (   I(v)) =distr ( ( I(a)(I(z))) ) =def  I ( ( I(a)(I(z)))) =distr ( ( I(a)(I(z)))) ( I(a)(I(z))) =distr ( ( I(a)(I(z)))) =(x..y)' ( ( I(a)(I(z)))) =def  I ( I(u..v))

I(u:s) =I(x:s) ( U)) =(a) below ( ({} ( I(u))( U))) =distr {} ( ( I(u))( U)) =(b),(a) below {} ( I(u))( ( U)) = {} ( I(u))( U) =I(x:s) {} ( I(u))(I(u:s)) =   {} ( I(u))(I(u:s)) =def  I   {} ( ( I(a)(I(z))))(I(u:s)) =distr   {} ( ( (I(a)(I(z)))(I(u:s)))) =assoc   {} ( ( I(a)(I(z)(I(u:s))))) =I(x..y)   {} ( ( I(a)(I(z..u:s)))) =   {} ( ( I(a)(I(z)))) =x:s'   {} ( ( I(a)(I(z)))) =def  I   {} ( I(u:s))

U =(c) below U ( I(u))(U) =induc hyp {} ( I(u))( U) ( I(u))(U) =U ⊆ U (c) {} ( I(u))( U)

(b): For [formula]-increasing sequence of languages Tn, ( L(T)) = L( T) (because each tree has a finite number of [formula]'s)

U =x = x..x I((1+u)(1+u)) =I(x..y) I(1+u)(U) =I(x+y) (I(1)+I(u))(U) =I(1) ({}+I(u))(U) =induc hyp (above) ({} (   {} ( I(u))))(U) =   {} ⊆{} ({} ( I(u)))(U) =, def  () U ( I(u))(U)