Lemma Corollary Observation

Threshold Load Balancing in Networks

Thomas Sauerwald

Introduction

Load balancing is a fundamental requirement of many distributed systems. The locality of information and communication inherent in many applications like multicore computer systems or wireless networks often render centralized optimization impossible. Instead, these cases require distributed load balancing algorithms that respect locality constraints, but nonetheless rapidly achieve balanced conditions. A successful approach to this problem are load balancing protocols, in which tasks are concurrently migrated in a distributed fashion. A variety of such protocols have been studied in the past, but they usually rely on machines to make migration decisions [\cite=Friedrich09] [\cite=Rabani98] [\cite=Elsaesser06] [\cite=Elsaesser10]. Being a fundamental resource allocation problem the interpretation of "load" and "machine" can greatly vary (e.g., in wireless networks it can mean "interference" and "channel" [\cite=Petrova10], respectively), and in many cases machine-controlled reallocation represent an unreasonable means of centralized control. Protocols that avoid this feature have been popular in the area of algorithmic game theory. Here tasks are controlled by (selfish) users that follow a protocol to migrate their task to a less populated machine, see [\cite=VoeckingChapter07]. While having distributed control, these protocols usually require strong forms of global knowledge, e.g., the number of underloaded/overloaded machines [\cite=EvenDar05], or load differences among machines in the system [\cite=Berenbrink07] [\cite=Berenbrink12] [\cite=Berenbrink11] [\cite=FotakisATOM10]. In many applications of interest, however, such information is unavailable or very difficult to obtain.

An interesting approach towards this problem are threshold-based load balancing protocols initially studied in [\cite=Fischer08], in which reallocation decisions are based on an acceptance threshold. In the simplest variant, there is a uniform threshold T and each user is satisfied if the machine it is currently assigned to has a number of assigned users below T. Otherwise, the user is dissatisfied and decides to migrate to another machine chosen uniformly at random. The great advantage of threshold-based protocols is that they can be implemented using only the information about the currently allocated machine and without having to obtain non-local information about other machines, the current load or migration pattern in the system, etc. Successful balancing obviously also depends on a suitable threshold T. The initial motivation for such an approach comes from wireless networks, where successful operation depends on acceptance thresholds for interference, and the amount of interference rises with the number of users on a channel. Here threshold protocols are necessary as distributed spectrum sensing (i.e., measuring the conditions of different channels) is a challenging and non-trivial problem by itself. In addition, protocols need to be user-controlled, because "machines" are frequency bands and cannot assign users to leave. Other interpretations of threshold balancing models include, e.g., thresholds as deadlines for the completion time of user tasks in a machine scheduling context. In this case, both resource-controlled or user-controlled protocols are of interest.

While threshold load balancing protocols are attractive, their behavior is not well-understood in many standard load balancing scenarios. In particular, previous works [\cite=Fischer08] [\cite=AckermannFHS11] have only addressed the case when every machine is available to every user throughout the whole balancing process (i.e., when a "complete network" exists among resources). In this paper, we advance the understanding of these protocols in scenarios with locality restrictions to user migration. In particular, we assume that there is an undirected graph G = (V,E) and each vertex v∈V is a machine or resource. Users can access machines only depending on their location, i.e., a user on machine v∈V can only move to neighboring machines in G. Load balancing with such an underlying neighborhood structure is frequently studied, but almost exclusively using machine-controlled protocols.

Contribution.

We study protocols for threshold load balancing with resource-controlled and user-controlled migration. We assume thresholds are feasible, i.e., they allow a balanced state in which all users are satisfied and consider the expected convergence time to such a state. Our threshold model is very general and allows to capture a variety of scenarios. For instance, if thresholds represent deadlines in a machine scheduling environment, we can even assume machines to have set-up times and different speeds using an appropriate threshold for each machine and each user. For this case other protocols in the literature require strong means of coordination [\cite=FotakisATOM10] [\cite=Elsaesser06] or achieve only pseudopolynomial convergence time [\cite=Berenbrink11]. In contrast, our protocols achieve rapid convergence in a number of rounds only logarithmic in the number m of users and a polynomial depending on the graph structure. Hence, even in this very decentralized setting, efficient load balancing is still possible. The strong locality of the thresholds represents a challenge for the analysis, as many tools developed for, e.g., diffusion-based algorithms cannot directly be applied. In contrast, we here use potential function arguments in combination with analysis of random walks to prove convergence properties of our protocols.

After a formal introduction of our model in Section [\ref=sec:model], we first concentrate in Section [\ref=sec:resource] on the case when user migration is partly controlled by resources. In particular, for each resource with dissatisfied users, we allow the resource to pick the users that should move. Each of the picked users then moves to an adjacent resource that it chooses uniformly at random. For user-independent thresholds, where for every resource v all users have the same threshold Tv, the protocol converges in [formula] rounds, where (G) is the maximum hitting time between any pair of nodes in G. If thresholds are arbitrary but satisfy an above average property, the same holds and additionally the number of rounds is roughly in the order of [formula]. This is can be a much better bound as the mixing time [formula] of a random walk can be significantly smaller than (G) for many graphs G. This bound is shown to be essentially tight, as there are graphs G, above average thresholds, and initial allocations for which the protocol needs [formula] rounds to reach a balanced state. However, if we somewhat modify the protocol and start with slightly decreased above average thresholds, which are restored to their original value only after some time polynomial in n, we can avoid this lower bound and obtain a number of rounds independent of m.

In Section [\ref=sec:user] we consider a protocol that is fully user-controlled for the case of user-independent thresholds. In this case, each dissatisfied user independently at random decides to migrate to an adjacent resource with a probability depending on the locally observed loads and its intrinsic thresholds. When our aim is to balance approximately, we can establish similar bounds of [formula] and [formula] for the cases of arbitrary and above average user-independent thresholds, respectively. To reach a completely balanced state, we only have to spend an additional [formula] factor by decreasing the migration probability in the protocol.

All our results concern expected running times of the protocols. It is possible to obtain bounds that hold with high probability by spending an additional factor of log n in every bound. Details of this rather straightforward adjustment are omitted here.

Related Work.

In algorithmic game theory several protocols for user-controlled selfish load balancing games have been proposed, using which a set of selfish users can reach a Nash equilibrium in a distributed and concurrent fashion. However, with the exception of [\cite=Berenbrink11] the protocols were studied only for the complete network. Some recent approaches are based on learning algorithms, but they allow to obtain only approximate stability and only as a distribution over states, even if we allow arbitrary finite time [\cite=Blum10] [\cite=KleinbergPT11]. Protocols based on best response dynamics can converge much more rapidly. There are two approaches that yield convergence time of essentially [formula], but either the number of underloaded/overloaded resources must be known [\cite=EvenDar05], or users must be able to inspect load differences among resources in the system [\cite=Berenbrink07] [\cite=Berenbrink12]. The latter is also necessary in [\cite=Berenbrink11] [\cite=Adolphs12], where the protocol from [\cite=Berenbrink07] is extended to arbitrary networks and convergence times of [formula] are shown. Inspection of load differences in the system is also central to protocols proposed for congestion games [\cite=Ackermann09] [\cite=FotakisATOM10].

Our threshold protocols that avoid this problem were proposed and analyzed for the complete network in [\cite=AckermannFHS11], in which convergence in O( log (m)) rounds is shown for both the resource- and user-controlled cases and user-independent and above average thresholds. We remark that there is an interpretation of our scenario as selfish load balancing game by assuming that each user experiences a private cost of 1 whenever the load on their allocated resource exceeds the threshold and 0 otherwise. In this way, our protocols can be interpreted to converge to Nash equilibria (i.e., the balanced states) of the game. For the case of resource-controlled migration, we assume that user thresholds are common knowledge. It is an interesting open problem to derive protocols for users private thresholds.

Load balancing with resource-controlled protocols has also received much interest in the distributed computing literature in recent years. The most prominent approaches are diffusion [\cite=Muthu98] [\cite=Rabani98] and dimension-exchange models [\cite=Rabani98] [\cite=Elsaesser10], and the vast majority of the literature concentrates on the case of m  =  n users. For this case, a wide variety of different bounds for general graphs and special topologies are known. However, in these models even the number of users that migrate from one resource to a specific (adjacent) resource is steered by the two resources.

We note that a different load balancing protocol based on random walks has been analyzed in [\cite=Elsaesser06] [\cite=Elsaesser10]. However, the results there only hold for user-independent thresholds and assume a resource-controlled migration. In addition, not only dissatisfied users perform random walks, but also underloaded resources launch random walks to accelerate the balancing process.

Model

Definition and Potential.

There are n machines or resources, which are nodes in a graph G  =  (V,E), and a set

[formula]

Random Walks.

For an undirected, connected graph G, let Δ, d, and δ be the maximum, average, and minimum degree of G, respectively. For a node v∈V, d(v) is the degree of node v. If a user is continuously dissatisfied, its movements will form a random walk. The transition matrix of the random walk is the n  ×  n-matrix [formula] which is defined by [formula] for {u,v}∈E and Pu,v: = 0 otherwise. Hence, the random walk moves in each step to a randomly chosen neighbor. Let [formula] be the t-th power of [formula]. Then Ptu,v is the probability that a random walk starting from u is located at node v at step t. We denote by [formula] the n eigenvalues of [formula]. We now define

[formula]

(this definition differs slightly from the one of the spectral gap which is 1  -   max 2  ≤  i  ≤  n|λi|.) We further denote the stationary distribution of the random walk by the vector π with πi  =  d(i) / (2|E|), where m is the number of edges in G. For connected graphs, this distribution is the unique vector that satisfies [formula]. However, the distribution of the random walk does not converge towards π on bipartite graphs (as opposed to non-bipartite graphs). Therefore, the next lemma has to distinguish between bipartite and non-bipartite graphs. For a proof see the Appendix.

Let G be any graph, u,v∈V be any two nodes and t  ≥  4 log (n)  /  μ.

If G is non-bipartite, then Ptu,v  =  π(v)  ±  n- 3.

If G is bipartite with partitions V1,V2, then

Based on Lemma [\ref=lem:mixinglemma], we define the mixing time to be [formula]. It is a well-known fact that 1 / μ is always at most polynomial in n, for instance, using the conductance we have [formula]. Note that if the random walks are made lazy, i.e., every walk stays at the current node with a loop probability 1 - α∈(0,1), then the above lemma applies similarly - the only difference is that μ may be decreased by a factor of at most α. Also, the case of bipartite graphs becomes subsumed by the case of non-bipartite graphs, because lazy walks do not suffer from bipartite oscillation.

We denote the hitting time by (u,v) which is the expected time for a random walk to reach v when starting from u ((u,u) = 0). We define the maximum hitting time as (G): =  max u,v∈V(u,v). For further details about random walks and mixing and hitting times, see e.g. [\cite=Levin09] [\cite=Lovasz93].

Resource-Controlled Migration

In this section we consider a protocol with migration being partly resource- and partly user-controlled. In each round, every resource v decides which of its assigned users to evacuate. The evacuation choice of the resource is done in accordance with the definition of the potential. Users currently assigned to v are ordered in non-increasing order of Tiv. Let k be the last position in the ranking at which there is a user i with k  ≤  Tiv. All users ranked after i are assigned to leave the resource. Each user that is assigned to leave picks a neighboring resource uniformly at random and moves to this resource. All movements are concurrent, and there is no coordination between resources. A round ends when all users have moved and each resource has updated its sorted list of currently allocated users. Note that this protocol tries to accommodate as many users as possible on the resource and assigns exactly Φv(x) many users to leave.

For our analysis, we split a single round into two phases - a removal phase, where resources remove the users to be evacuated and an arrival phase, where users arrive on their new resources. After the removal phase, all remaining users are satisfied. For the analysis of the arrival phase, we assume users arrive sequentially on their chosen resources. If the arrival of a single user does not cause the resource to remove an additional user in the next round, this essentially reduces the potential by 1. Otherwise, either it is evacuated again in the next round, because he is ranked too low at its new resource, or it causes at most one user to migrate from the new resource. Hence, in one round of the resource-controlled protocol the potential Φ(x) does not increase.

This insight allows us to view migrating users as random walks. We assume a token is given in the arrival phase from a migrating user to the user it causes to migrate in the next round. The number of tokens in the system for state a with load profile x is exactly Φ(x), and each token performs a random walk over G. If a user causes no other user to migrate in the next round, the token is removed and the random walk is stopped. This reformulation of user migration is used in the proof of our general bounds on the convergence time for thresholds that are user-independent or above average.

For feasible user-independent or above average thresholds, the protocol converges to a balanced state in an expected number of [formula] rounds.

The main idea of the proof captured by the following lemma is to show that every (G) rounds a constant fraction of random walks is stopped.

From every starting state with load profile x and Φ(x)  >  0 we reach after an expected number of rounds [formula] a state with load profile xR such that [formula]

Consider the starting profile x and first assume we want to move all Φ(x) random walks such that the potential reduces to 0. For this purpose, we consider for user-independent thresholds an arbitrary balanced state with load profile x' in which all users assigned for migration are placed on resources that can accommodate them. For above average thresholds, consider x' where each resource has load at most [formula]. Note that in each case the considered state has Φ(x')  =  0. We call a resource v underloaded if xv  <  Tv for user-independent thresholds and define hv  =   max {0,Tv  -  xv} as a lower bound on the number of users that can still be allocated to the underloaded resource v without creating dissatisfied users. Similarly, for above average thresholds v is underloaded when [formula] and define [formula]. Intuitively, we can think of hv as the number of "holes" in a balanced profile. It is easy to see that for feasible user-independent and above-average thresholds [formula].

Hence, in the starting state we match each random walk token to a hole, which it should reach. In particular, we create a complete bipartite graph of Φ(x) nodes in one partition and [formula] nodes in the other partition and compute a maximum matching. In this way, each token gets a resource and a specific position on this resource that it should occupy. If users carrying the tokens were reassigned according to the matching to their positions, a balanced state would be reached. We consider the random walks of tokens starting from x and bound the time needed such that at least half of the tokens reach their corresponding destination resources at least once.

Let us first assume that all the tokens are doing independent random walks that never stop. The expected time until token t reaches its destination vt for the first time is (G) =  max u,v(u,v). Note that after 2(G) rounds, the probability that t has not reached the resource is at most 1 / 2 by Markov inequality. Now define the Bernoulli variable Rt to be 1 if token t has reached vt after 2(G) rounds. Let us say we are ready when at least half of the tokens have visited their destination at least once. In particular, we are ready after 2(G) rounds if [formula]. Using a Chernoff bound, we see that the probability of this event is at least 1 - e-  Φ(x) / 16  ≥  1 - c, for some constant c  <  1. Thus, if we have not successfully brought Φ(x) / 2 random walks to their destination at least once, we restart the process. As k restarts happen only with probability at most c- k, the expected number of restarts is constant. Hence, in expectation [formula] rounds are needed to bring at least half of the tokens to their destinations at least once.

Until now, we have assumed that tokens always keep moving. In our real process, however, random walks might be stopped early because the tokens get removed on their way. This happens when they reach a resource where the user in the arrival phase does not increase the potential. Whenever this happens, we account the potential decrease of 1 towards the removed token. In contrast, a token t might also reach the desired resource vt, but does not stop moving, because other tokens have reached vt earlier and filled all available holes. Then, however, for each such token t there is one other token t' that has taken the spot of t and thereby got removed. In this case, we reaccount 1/2 of the potential decrease for t' towards t. Thus, every token that reaches its destination accounts for potential progress of at least 1/2. Hence, after O((G)) time in expectation, the potential has decreased by at least a fraction of 1/4, and thus the period has ended. This proves the lemma.

We consider the convergence time from an arbitrary initial state with profile x to a balanced state in periods. Period j is the set of rounds r, in which ⌈Φ(x)  ·  (3 / 4)j - 1⌉  ≥  Φ(xr)  >  ⌈Φ(x)  ·  (3 / 4)j⌉, for j = 1 until ⌈Φ(x)  ·  (3 / 4)j⌉  =  1. The last period begins when Φ(xr)  =  1 and ends when a balanced state is reached. Obviously, there are in total [formula] periods, which is at most [formula]. Lemma [\ref=lem:hitProgress] shows that the expected length of each period is [formula]. This proves the theorem.

The following theorem presents a possibly improved bound if all resources have above average thresholds. For these thresholds we define [formula] as the minimum relative surplus over [formula]. In particular, for all the thresholds we have [formula].

For above average thresholds the protocol converges to a balanced state in an expected number of rounds of

[formula]

Our proof below is based on the following lemma that bounds the time for a significant number of random walks to reach a roughly balanced allocation.

Consider [formula] random walks that start at arbitrary positions in V. For each resource v∈V, let X = X(v) be the number of visits of all these random walks to v at step [formula] and [formula]. Then with probability at least 1 - n- 3, it holds for each v∈V that

[formula]

We first prove the statement for non-bipartite graphs. By Lemma [\ref=lem:mixinglemma] we have for [formula],

[formula]

Hence, the number of random walks on resource v at round t can be written as a sum of independent, binary random variables, [formula], where [formula]. Therefore, X is stochastically larger than [formula]. Therefore, we may apply Lemma [\ref=lem:chernoff] to conclude that

[formula]

where we have used the fact that π(v)  ≥  n- 2 and our lower bound on x for the last inequality. Taking the union bound over all n resources yields the claim for non-bipartite graphs.

For bipartite graphs we argue similarly, but depending on whether u or v are in the same partition or not, we either consider the round t or the round t + 1. By this we ensure that Equation [\ref=eq:lower] still holds and we can use exactly the same arguments.

To prove the first term of the bound in Theorem [\ref=thm:centralMix], we use the following lemma.

Given any starting state with profile x and [formula], let R be the first round at which a state with profile xR is reached such that

[formula]

It holds that [formula].

For the starting profile x, we focus on the set [formula] of significantly underloaded resources. In particular, a resource v∈V-(x) can stop an "average" share of the random walks in the system. The following lemma is proved in [\cite=AckermannFHS11].

If Φ(x)  >  0, then |V-(x)|  ≥  n  ·  εmin / 2.

Now consider a starting state with [formula]. Suppose first that the Φ(x) many random walks are not stopped. Let us consider the resources in V-(x), each of which has at least Φ(x) / n "holes". We first prove the lemma for non-bipartite graphs. Note that for non-bipartite graphs, Lemma [\ref=lem:ballsBins] implies that after at most [formula] steps in expectation we reach a single state a* with profile x* in which every resource carries at least [formula] random walks. Suppose we start stopping random walks exactly at state a*, then because δn  ≤  2|E| we have that [formula] walks are removed on each resource in V-(x). In total, we know that

[formula]

Let us now take into account that random walks might stop before reaching their destination in state a*. In particular, we let the system evolve exactly as before, however, we stop a random walk when its token is removed. Whenever a random walk is stopped early, this implies that the potential drops by 1. We account only 1/2 towards the token. Consider all random walk tokens that previously reached a resource V-(x) in the unstopped process and got removed in the last iteration. If such a token t now reaches its destination but is not removed, there is some other token t' that took the spot t on its resource. In this case, we account the other half of the potential decrease towards t. Otherwise, t was removed earlier and potentially took the spot of some other token. Hence, in this case it also gets an accounted potential decrease of at least 1/2. Thus, every such token receives an accounted potential decrease of at least 1/2. We denote by R the random variable that yields the time step at which our process first arrives at a state with potential at most

[formula]

Obviously, we have [formula].

For bipartite graphs, we apply the same reasoning as above, however, we consider a combination of states a*, a*  * described by Lemma [\ref=lem:ballsBins] that are reached after at most [formula] and [formula] steps in expectation. We stop random walks on one partition in a* and on the other partition in a*  * and consider the stopped random walks. By assuming that [formula] random walks are stopped on each resource in V-(x), we overestimate their real number at most by a factor of 2. Thereby, we lose an additional factor of 2 in comparison to the analysis for non-bipartite graphs above and obtain

[formula]

By repeatedly applying the result of Lemma [\ref=lem:mixProgress], it follows that we need in expectation a number of [formula] steps to reduce the potential to below [formula]. When we reach a state with potential below [formula], we apply the ideas of Theorem [\ref=thm:centralHit] and get an additional convergence time of [formula] in expectation. This proves the theorem.

The following theorem shows that the bound in the previous theorem is essentially tight for our protocol. We will describe a class of graphs and starting states such that the convergence time of our protocol is characterized by the problem of moving a large number of users over a relatively sparse cut. This allows us to establish a lower bound using the mixing time. We note that our class of graphs encompasses instances that provide the lower bound of the theorem for every mixing time in Ω(n) and O(n2).

There is a class of graphs such that for above average thresholds the protocol converges to a balanced state in an expected number of [formula] rounds.

Consider a graph G that consists of two cliques V1,V2, each of size n / 2. The two cliques are connected by a total of k edges, where [formula]. The edges between the cliques are distributed evenly, i.e., every vertex in each clique is connected to at least ⌊k / (n / 2)⌋ and to at most ⌈k / (n / 2)⌉ vertices in the other clique. There are m  ≫  n users in the system, and we assume all thresholds of all resources and users are [formula], for some small constant ε  >  0. In the initial assignment a all users are allocated to vertices in V1 as follows. First we allocate to every resource in V1 exactly T users. To one resource v∈V1 with ⌊k / (n / 2)⌋ neighbors we then add all remaining m  -  T  ·  (n / 2) users. For sufficiently large m and small ε, the initial load profile x of this assignment yields Φ(x)∈Ω(m). Thus, there are Θ(m) random walks in the graph, they all start at some vertex in V1 with ⌊k / (n / 2)⌋ neighbors in V2, and to reach a balanced state it is necessary that they all have to enter V2 at least once.

Consider a random walk that starts at a vertex in V1 with ⌊k / (n / 2)⌋ neighbors in V2. Then, for any integer t, the probability that the random walk stays within V1 for t steps is at least

[formula]

We use an accounting argument to show that the random walk on V does the same as a random walk restricted to V1 for the first t steps with the desired probability.

Consider first a random walk restricted to V1. For every visit to a vertex u∈V1, the random walk obtains a credit of [formula]. Intuitively, the credit provides us with a measure on how much the random walk restricted to V1 differs from the one on V as it is closely related to the probability of leaving V1 at vertex u. Let Ct be the credit that a random walk obtains in step t. Our next claim is that [formula]. This is certainly true if k / (n / 2)  ≥  1 / 4, since [formula]. Consider now the case where k / (n / 2)  <  1 / 4. In this case, at most k vertices in V1 are connected to V2, while the other (n / 2) - k vertices in V1 are not connected to V1.

Hence, C0  =  1 and for any [formula]

[formula]

This establishes [formula] and thus by Markov's inequality,

[formula]

Consider now a random walk on V. Then the probability that the random walk on V does the same as the random walk on V1 for the first t steps is at least

[formula]

where in the first inequality we have used that Ci  ≤  n / 4 - 2. Hence, with probability at least [formula] the random walk on V does the same as the random walk on V1 and therefore does not leave V1 during the first t steps.

The probability that a single random walk has entered V2 at least once after t steps is at most [formula]. As walks are independent, with probability at least [formula] at least one walk has remained in V1 for the whole time, in which case we have not reached a balanced state. For

[formula]

the latter probability is [formula]. Therefore, the expected number of rounds needed to move all random walks to V2 is in Ω( ln (Φ(x))  ·  (n2 / k)). Because Φ(x)  =  Θ(m) and [formula] the theorem follows.

This shows that a factor ln (m) cannot be avoided if we want the protocol to reach a balanced state. However, the following theorem shows that, intuitively, the protocol balances most of the random walks on G much faster. Suppose we first decrease all thresholds by a factor of 1 / (1 + n-  γ). We balance with these adjusted thresholds for (G)  ·  γ log n rounds and then continue with the larger original thresholds. This allows the unstopped random walks to balance quickly over the network. By increasing all thresholds we avoid that towards the end of the process many random walks have to reach a small subset of nodes. This allows to obtain a balanced state in a number of rounds that is even independent of m. The result holds for user-independent thresholds and for above average thresholds.

For simplicity, we slightly reformulate the approach. We assume to start with original thresholds and after (G)  ·  γ log n rounds the protocol is allowed to increase all thresholds by a factor of 1 / nγ.

Consider user-independent thresholds or all above average thresholds. Let γ  ≥  1 be any value. For an arbitrary starting state, after

[formula]

rounds we reach a state with profile x', in which Φv(x')  ≤  10Φ(x) / nγ for every v∈V with probability 1 - (e / 10)10Φ(x)  ·  n-  γ. If we increase all thresholds by Φ(x)  ·  n-  γ at this round, we obtain a balanced state after a total of [formula] additional rounds in expectation.

Assign every token a random walk of length [formula]. Each random walk visits all nodes of G with probability 1 - n-  γ. Let A be the event that at most 10Φ(x)  ·  n-  γ: = ρ random walks do not visit all nodes of G. Then,

[formula]

For contradiction, suppose that at step [formula] there is a resource v with potential [formula]. This implies that at least one of the tokens whose associated random walk visits all nodes of G are placed on resource v in [formula]. On the other hand, this also implies that at step [formula] there is at least one resource u  ≠  v with load less than [formula]. If we now consider the random walk who is placed on v the latest (considering only random walks that visit all nodes in G), we obtain a contradiction, as the token of this random walk would have been removed when visiting some other resource, e.g., u instead of v.

For the expected convergence time, we assume Φ(x)  >  n2γ, otherwise the result follows using Theorem [\ref=thm:centralHit]. Note that with a large probability we directly reach a balanced state. Otherwise, with probability [formula] we need additional expected time of only [formula].

User-Controlled Migration

In this section we consider a fully distributed protocol for the case of user-independent thresholds. In our protocol, in each round every user located on resource v decides to migrate away from v with a probability pv(x)  =  α  ·  (Φv(x) / Tv). If a user decides to migrate, it moves to a neighboring resource of v chosen uniformly at random. We will assume α  <  1 in order to avoid trivial examples that may result in an infinite oscillation. This approach has the advantage that resources do not have to sort and control movements of users. Yet, the resulting process closely resembles our resource-controlled protocol analyzed in the last section. We can again consider user migration in terms of random walks, but now the number of walks leaving a resource v in a state is not exactly Φv(x) as in the resource-controlled protocol. In particular, we assume that each resource contains Φv(x) random walk tokens. Each user that decides to migrate, picks a token uniformly at random and takes it to its destination. One challenge of the user-controlled migration is that on certain networks there could be assignments such that expected potential value increases in the next round. This makes the analysis harder than the analysis of resource-controlled migration and also harder than the analysis of user-controlled migration on complete graphs, as in both cases the (expected) potential is always non-increasing.

We begin our analysis with some lemmas. First, the probability of a given token to move to another resource in a round can be bounded by Ω(α). This is straightforward as tokens are indistinguishable and all users on a resource move with the same probability (see Lemma [\ref=lem:Schleife] in the Appendix). Hence, each random walk has a loop probability of [formula].

When more than Φv(x) users migrate from v in a round, this leads to creation of new random walks. We term each random walk created in this manner excess (random) walk which leaves an artificial hole on v. In contrast, we refer to ordinary random walks and holes. Observe that the creation of excess walks becomes quite unlikely, especially if Φv(x) is large.

Let [formula] be any two values. Then with probability at least 1  -  t  ·  n- (C  ·  (1 - α) / 6) + 1, no resource generates more than C log n excess random walks in each of the first t rounds. Hence, in the first t rounds, all resources generate in total at most tn  ·  C log n excess random walks with probability at least 1 - t  ·  n- (C  ·  (1 - α) / 6)  +  1. Moreover, we generate in expectation at most 30α2tn excess random walks in the first t steps.

Consider a resource v at any round 1  ≤  s  ≤  t which is overloaded, i.e., its load is xv  >  Tv. Then the number of agents Zv that leave v has distribution [formula]. So, [formula]. Using Lemma [\ref=lem:chernoff], it follows that

[formula]

Choosing λ  =  (1  -  α)xv  +  C log n for any C  ≥  1 yields

[formula]

Taking the union bound over all resources, [formula]. Finally, taking the union bound over all time-steps up to time t, it follows that the probability that up to time t there is a time step s in which one of the resources v has Zv  ≥  xv  -  Tv  +  C log n is at most

[formula]

This implies the first statement of the theorem. The result for the expected value follows directly from [\cite=AckermannFHS11].

Our proofs rely on the condition that as long as the potential is above some value β, we have a multiplicative expected decrease. This way we obtain a state with potential of β in expected time roughly logarithmic in the size of the initial potential. For a proof of the following lemma see the Appendix.

Let [formula] be a stochastic process with non-negative values such that [formula] with 0  <  γ  <  1 as long as Xt - 1  ≥  β. Let [formula]. Then [formula].

In the following two theorems we assume α  =  1 / (2e) and extend Theorems [\ref=thm:centralHit] and [\ref=thm:centralMix] to the scenario of user-controlled migration. The approach of the proofs is to bound the increase due to excess random walks and show that the potential (i.e., the number of random walks) still drops by a constant factor as long as the potential is sufficiently large.

For feasible user-independent thresholds after [formula] rounds in expectation we reach a state with profile x where [formula].

We first consider only the ordinary random walks in the system and prove that after a fixed time interval, a significant fraction gets removed. Afterwards, we consider the effect of excess random walks and artificial holes during the interval. Let us consider a fixed time-interval of length [formula]. As in the proof of Theorem [\ref=thm:centralHit] we assign tokens to holes and consider the unstopped random walk of a token within [formula] rounds. The expected fraction of the tokens that reach their destination at least once during the interval is at least 1 / 2 by Markov inequality. If k random walks reach their destination, a similar argument as in Lemma [\ref=lem:hitProgress] shows that they contribute k / 2 to the potential decrease. Finally, to account for excess walks and artificial holes, we note that during [formula] rounds there are, in expectation, at most [formula] excess random walks for our choice of α = 1 / (2e) (see Lemma [\ref=lem:holes]). Hence the expected value of the potential satisfies:

[formula]

Conditioned on a load vector x0 with Φ(x0)  ≥  16  ·  n  ·  (G), we have

[formula]

Now we apply Lemma [\ref=lem:stopping] as follows. We consider a new iterative random process Yt. Yt is the value of the potential after exactly [formula] steps of the protocol. Then, the previous arguments show that Yt satisfies Lemma [\ref=lem:stopping] with [formula] and β  =  16  ·  n  ·  H(G). Thus, after at most τ  =  8  ·  (1 +  ln (Φ(x(0)) / (8n(G)))∈O( log (m)) steps, the probability that the potential has dropped below β is at least 1/2. By considering the process in blocks of length τ, we see that the probability after k blocks is at least 1 - 2- k, i.e., in expectation a constant number of blocks are needed. Hence, in expectation, the process Yt takes at most O( log (m)) steps, so our protocol takes only O((G)  ·   log (m)) steps. This proves the theorem.

For user-independent thresholds with [formula], after

[formula]

rounds in expectation we reach a state with profile x where [formula].

The proof is similar to Theorem [\ref=thm:userhit], but this time we take the accounting approach of Theorem [\ref=thm:centralMix]. In particular, we consider a fixed time interval of [formula] steps and let all random walks evolve without stopping. For non-bipartite graphs, Lemma [\ref=lem:ballsBins] shows that after [formula] steps, with probability at least 1 - n- 3, we have a significant load on each resource. Considering the significantly underloaded resources, this shows that if we stop random walks exactly in step [formula], we decrease the number of ordinary random walks by a factor of [formula]. A similar reaccounting argument as in Lemma [\ref=lem:mixProgress] shows that the real process, in which random walks are stopped earlier, achieves at least half of this decrease, i.e., a factor of [formula]. Hence, as the number of ordinary random walks in the system only decreases, we have that, in expectation, after [formula] rounds their number has decreased by a factor of at least [formula]. For bipartite graphs, we consider two consecutive steps, which again leads to a slightly smaller decrease of at least [formula]. Now to account for excess walks we again note that during [formula] rounds with α  =  1 / (2e) there are, in expectation, at most [formula] excess random walks. Hence the expected value of the potential satisfies:

[formula]

Conditioned on a load vector x0 with

[formula]

we have

[formula]

Observe also that initial application of Lemma [\ref=lem:ballsBins] depends on

[formula]

which is asymptotically a smaller bound, as [formula].

Exactly as in the proof of Theorem [\ref=thm:userhit], we can now directly apply Lemma [\ref=lem:stopping] to show the theorem. In particular, we again define a process Yt that measures the potential after [formula] rounds and apply Lemma [\ref=lem:stopping] with suitable bounds to Yt. By observing that in expectation only a constant number of applications of the lemma are needed, the statement in the theorem follows.

The theorems do not guarantee convergence to a balanced state, because with small potential we are likely to create artificial holes and thereby increase the potential. It is, however, straightforward to derive with the proofs of the previous lemmas and theorems that convergence to a balanced state can be achieved by setting α  =  n- 5. Then, by Lemma [\ref=lem:Schleife], for every random walk the hitting time is increased by a factor of 1 / α. Examining the proofs of Theorems [\ref=thm:centralHit] and [\ref=thm:userhit] shows that instead of 2  ·  (G) rounds we get a removal of expected 1/4 of the ordinary random walks after [formula] rounds. On the other hand, observe that the expected number of excess random walks within [formula] rounds is only [formula]. Thus, if we take α  =  n- 5, this implies that the expected number of excess walks generated during [formula] rounds are only [formula]. Hence, we can adjust the lower bound on the potential in the final state in Theorem [\ref=thm:userhit] to 1 and spend an additional (G) / α rounds for the last random walk to find a hole. Thus, we reach a balanced state with an additional factor of n5 in the expected convergence time.

For user-independent thresholds, suppose we set α: = n- 5, then after an expected number of [formula] rounds the protocol reaches a balanced state.

A corresponding result similar to Theorem [\ref=thm:centralMix] holds if we resort to Theorem [\ref=thm:usermix] and combine the result with the above corollary.

If we do not want to slow down the protocol in this way and stick to α  =  1 / (2e), the following theorem shows that the process still rapidly balances all random walk tokens on the graph with high probability. The resulting state is not necessarily balanced. However, the overload in the allocation is balanced, i.e., in the resulting state every resource has a number of users exceeding its threshold by at most an average number.

Suppose the process starts in a state a0 with profile x0. If G is a regular, non-bipartite graph, then after [formula] rounds, with probability 1 - 3n- 1 it holds for every resource v that

[formula]

where [formula]. If G is an arbitrary non-bipartite graph, then after [formula] rounds, with probability 1 - 2n- 1 it holds for every resource v that

[formula]

where λ is defined as above.

The following lemma will be used for the proof of the theorem. In the lemma we focus on regular graphs, as on non-regular graphs a random walks does not converge to a uniform stationary distribution.

Consider a time-interval

[formula]

.

Fix a node u∈V and let Zu denote the number of visits to u. Note that for a regular graph, the matrix [formula] is symmetric and therefore each column sum equals one. This allows us to estimate

[formula]

We now use the following Chernoff bound:

[formula]

which yields for ε  =  6  ·   log n that [formula]. Taking the union bound over all nodes u∈V finishes the proof.

Using Lemma [\ref=lem:holes] and [formula], we see that with probability at least 1 - n- 1, no node generates more than [formula] excess random walks during these t rounds. Applying Lemma [\ref=lem:randomwalkverteilen] with [formula] and [formula] it follows that, with probability at least 1 - 2n- 1, no node is visited by more than [formula] excess random walks.

Consider now an ordinary random walk token that starts in round 1. If the random walk does not stop, we may apply Lemma [\ref=lem:mixinglemma] to conclude that for every node v and starting node u of the random walk,

[formula]

Let Xv be the number of ordinary random walk tokens that are on node v∈V at step t. Note that Xv is stochastically smaller than [formula]. Clearly, [formula]. Using the Chernoff bound

[formula]

and choosing [formula] gives

[formula]

Taking the union bound shows that with probability at least 1 - n- 1, Xu  ≤  Φ(x0)  ·  (π(u)  +  n- 3)  +  λ holds for any node u∈V.

Note that the load at node v at round t can be upper bounded by Xv (if an ordinary random walk stops earlier, it removes a hole) plus the number of excess random walks that visit v during the first t rounds. Taking the union bound, we find that the load at node v at round t satisfies:

[formula]

The proof for non-regular graphs is the same, except that we estimate the number of excess random walks on a node v∈V by the total number of extra random walks generated during the first t rounds.

Conclusion

In this paper, we studied a new load balancing protocol in a decentralized environment, where unsatisfied users decide independently to jump "blindly" to a random neighboring resource. We prove that this simple protocol achieves a convergence time which is logarithmic in m and polynomial in the hitting time (or mixing time) of the underlying network.

The main open problem is to find improved upper bounds on the convergence times for certain graph topologies. While our lower bound in Theorem [\ref=thm:lower] holds for a variety of mixing times, establishing a matching lower bound for every graph structure remains an open problem. For certain networks (like the complete graph), there are protocols with user-controlled migration achieving convergence even in a time of roughly log  log m [\cite=EvenDar05] [\cite=Berenbrink07]. It would be extremely interesting if one can adjust our protocol to obtain similar results or extend these approaches to obtain doubly logarithmic bounds also for arbitrary networks.

Appendix

Technical Lemmas and Omitted Proofs

Let [formula] be a binomially distributed random variable. Then for any λ  >  0,

[formula]

{ Lemma [\ref=lem:mixinglemma]. Let G be any graph, u,v∈V be any two nodes and t  ≥  4 log (n)  /  μ.

If G is non-bipartite, then Ptu,v  =  π(v)  ±  n- 3.

If G is bipartite with partitions V1,V2, then

For the result for non-bipartite graphs, see e.g. [\cite=Levin09]. Let us now prove the result for bipartite graphs, where we follow the arguments from [\cite=Lovasz93] for non-bipartite graphs.

Denote by [formula] is the adjacency matrix of G. Let [formula] be the diagonal matrix with diagonal entries Du,u  =  1 / d(u). Then the matrix [formula] is symmetric. Let [formula] be the eigenvalues of N and [formula] be the corresponding eigenvectors of unit length. Then, [formula] defines an eigenvector of [formula] with eigenvalue 1 (c.f. [\cite=Lovasz93]). Similarly, it can be verified that the vector gn defined by [formula] if u∈V1 and [formula] if v∈V2, is an eigenvector with eigenvalue - 1. The same argument also shows that λn - 1  >   - 1, since λ2  <  1 and λn - 1  =    -  λ2. Then using the spectral representation of Ptu,v we obtain

[formula]

We can bound the last summand by recalling that λn - 1  >   - 1 and using Cauchy-Schwartz inequality,

[formula]

as the eigenvectors gk were chosen to be of unit-length and using the lower bound on t. The other cases, e.g., u∈V2 and v∈V1 are shown similarly.

In one round of the protocol for user-controlled migration starting in a state with profile x, any given random walk token on resource v with xv  >  Tv is moved with probability at least Ω(α).

Note that the number of users that move from resource v is given by a sum over independent Bernoulli variables with expectation α  ·  Φv(x). Hence, Using Lemma [\ref=lem:chernoff] it follows that the probability that at most [formula] users move in one iteration is at most [formula]. Clearly, this probability can be upper bounded by some constant < 1. In turn, this implies that with constant probability at least α  ·  Φv(x) / 2 users migrate in one round, in which case the probability that a particular random walk token is moved is at least α / 2. Thus, the probability that a particular token is moved is Ω(α).

Lemma [\ref=lem:stopping]. Let [formula] be a stochastic process with non-negative values such that [formula] with 0  <  γ  <  1 as long as Xt - 1  ≥  β. Let [formula]. Then [formula].

Let us define auxiliary random variables Yt by Y0: = X0, and for any round t  ≥  1,

[formula]

Then, for any t  ≥  1, it holds [formula]. We have for [formula] an expected value bounded by [formula]. Hence by Markov's inequality [formula]. We consider two cases.

In all cases we have shown that with probability at least 1/2 there exists a step t∈[0,σ] so that Xt  <  β. This completes the proof of the lemma.