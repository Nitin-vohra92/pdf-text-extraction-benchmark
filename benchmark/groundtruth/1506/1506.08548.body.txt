=10000 = 10000

On the Security of MTA-OTIBASs (Multiple-TA One-Time Identity-Based Aggregate Signatures)

Introduction

In [\cite=IEEE-T-ITS] we proposed a new aggregate signature scheme referred to as multiple-TA (trusted authority) one-time identity-based aggregate signature (MTA-OTIBAS). Further, we gave a concrete MTA-OTIBAS scheme. We first recall the notion of MTA-OTIBAS; we then recall its formal definition and the concrete scheme proposed in [\cite=IEEE-T-ITS]. Then, we give the detailed security proof of MTA-OTIBAS (not given in [\cite=IEEE-T-ITS]).

An MTA-OTIBAS scheme has the following features. Firstly, each user's public key is his identity, so no certificate is needed on the public key, which avoids the certificate management overhead. Secondly, a signer's private key (corresponding to an identity and a lower-level TA) is restricted to be used only once; after that, the signer's private key should be updated. Thirdly, the MTA-OTIBAS scheme also allows signature aggregation and fast verification, i.e., n signatures can be aggregated into a single short signature (even signatures generated by signers enrolled by different lower-level TAs), which greatly saves storage space, and can be verified simultaneously.

We recall the formal definition of MTA-OTIBAS in Section [\ref=IBC]. In Section [\ref=specific] we recall the concrete MTA-OTIBAS scheme. Then in Section [\ref=correctness_and_security] we prove that our MTA-OTIBAS concrete scheme is existentially unforgeable against adaptively chosen-message attacks in the random oracle model under the co-CDH problem assumption.

Definition of MTA-OTIBAS

An MTA-OTIBAS scheme consists of six algorithms, i.e., Root.Setup, LowLevel.Setup, Extract, Sign, Aggregate, and Verify. Root.Setup is run by the root TA to generate the global system parameters and system master key. LowLevel.Setup is an interactive protocol run between a lower-level TA and the root TA. It generates the secret key, public key and certificate of the lower-level TA. Extract takes as input a lower-level TA's secret key and a signer's identity, and outputs a private key for the signer. Sign takes as input a signer's identity, his private key, the certificate of the signer's corresponding lower-level TA and any message, and outputs a signature on the message. The signature is only valid under the signer's identity and the certificate of his corresponding lower-level TA. A restriction here is that a private key corresponding to a specific identity issued by a lower-level TA can be used only once. However, the same identity can be enrolled by different lower-level TAs. This implies that the corruption of a lower-level TA does not influence the signers enrolled by other lower-level TAs. Aggregate is used to aggregate n message-signature pairs generated by the Sign procedure into a single signature, i.e., an aggregate signature. Verify is used to check the validity of an aggregate signature. It takes as input n messages, the corresponding aggregate signature, n identities enrolled by l lower-level TAs, and outputs 1 or 0 to represent whether the aggregate signature is valid or not.

A concrete MTA-OTIBAS scheme

Our MTA-OTIBAS scheme is realized using bilinear maps which are widely employed in identity-based cryptosystems. A map [formula] is called a bilinear map if ê(g1,g2)  ≠  1 and ê(gα1,gβ2) = ê(g1,g2)αβ for all [formula], where [formula] are two cyclic groups of prime order q, [formula] is a multiplicative cyclic group of the same order, g1 is a generator of [formula], and g2 is a generator of [formula]. By exploiting bilinear maps, we implement our MTA-OTIBAS scheme.

Root.Setup: The root TA runs this algorithm to generate the system parameters as follows:

Choose [formula], where ψ is a computable isomorphism from [formula] to [formula], with ψ(g2)  =  g1 [\cite=Zhang10].

Pick [formula] as its master secret key, and compute y = gκ2 as its master public key.

Select cryptographic hash functions H0(  ·  ):{0,1}* →   [formula] and [formula].

Publish the system global parameter [formula].

LowerLevel.Setup: In an MTA-OTIBAS scheme, before a lower-level TA can recruit members, it must be enrolled by the root TA. The root TA may add the public information of a lower-level TA (e.g., identity and public key) to the system global parameters. Let the identity of a lower-level TA Ti be IDTi. Ti picks [formula] as its secret key and computes yi = gκi2 as its public key. (IDTi,yi) are submitted to the root TA. On input (IDTi,yi), the root TA generates a certificate certTi which is signed using its master secret key. Finally, certTi is sent to Ti.

Extract: Suppose a signer with identity IDj wants to join the system maintained by Ti whose secret key is κi. On input the signer's identity IDj, Ti generates the private key for the signer as follows:

Compute idj,0 = H0(IDj,0),idj,1 = H0(IDj,1);

Compute sj,i,0 = idκij,0,sj,i,1 = idκij,1, and set sj,i = (sj,i,0,sj,i,1) as the private key of the signer.

Sign: To sign a message mk, a signer with identity IDj enrolled by Ti and private key sj,i = (sj,i,0,sj,i,1) computes hk = H1(mk,IDj,certTi),σk = sj,i,0shkj,i,1. The signer outputs σk as the signature on mk.

Aggregate: This publicly computable algorithm aggregates n signatures into a single signature. Let an entity collect n message-signature pairs [formula] signed by n users with corresponding identities [formula] enrolled by l lower-level TAs [formula]. For simplicity, we assume {ID1,...,IDt1}, {IDt1 + 1,...,IDt2},...,{IDtl - 1 + 1,...,IDtl} are enrolled by [formula] respectively. The message-signature pairs are divided into l sets corresponding to the l lower-level TAs. This algorithm outputs Ω as the resulting aggregate signature, where [formula].

Verify: To verify an aggregate signature Ω on messages {m1,..., mn} under [formula], [formula] enrolled by [formula] respectively, the verifier performs the following steps:

For 1  ≤  j  ≤  n, compute hj = H1(mj,IDj,certTi) and idj,0 = H0(IDj,0), idj,1 = H0(IDj,1).

Define [formula], [formula]. Check [formula] Output 1 if the equation holds; else output 0.

Security proof

An MTA-OTIBAS scheme should be secure. Informally, an MTA-OTIBAS scheme is said to be secure if no polynomial-time attacker not requesting a private key of an entity enrolled by a lower-level TA can forge an aggregate signature that is valid (i.e., such that Verify outputs 1) corresponding to that entity enrolled by the lower-level TA.

In general, the security of an MTA-OTIBAS scheme is modeled via the following EUF-CMA (existential universal forgery under adaptive chosen-message attack) game [\cite=Gentry] and takes place between a challenger [formula] and an adversary A. The game has the following three stages:

Initialize: [formula] runs the Root.Setup algorithm to obtain a master secret key and the system parameters. [formula] then sends the system parameters to A while keeping secret the master secret key.

Attack: A can perform a polynomially bounded number of the following types of queries in an adaptive manner.

LowerLevel.Setup queries: A may ask [formula] to set up a lower-level TA. On input an identity IDTi of a lower-level TA, [formula] generates the secret key and certificate of the lower-level TA.

Corrupt.LowerLevel queries: A can request the secret key of a lower-level TA Ti. On input IDTi, [formula] outputs the corresponding secret key of Ti.

Extract queries: A can request the private key of an entity with identity IDj issued by a lower-level TA Ti. On input (IDj,certTi), [formula] outputs the corresponding private key of the entity.

Sign queries: A can request an entity's signature on a message mk. On receiving a query on (mk,IDj,certTi), [formula] generates a valid signature σj on mk under (IDj,certTi), and replies with σj.

Forgery: A outputs l' sets of identities [formula] ...,ID*t1}, [formula] ID*n} enrolled by l' lower-level TAs with certificates from the set {cert*T1,...,cert*Tl'}, a set of n messages {m*1,...,m*n} and an aggregate signature σ*. For simplicity, we assume m*i corresponds to ID*i for i∈{1,...,n}.

A wins the above game, if all of the following conditions are satisfied:

σ* is a valid aggregate signature on messages {m*1,...,m*n} under [formula], [formula] and {cert*T1,...,cert*Tl'}.

At least, one private key of an entity issued by a lower-level TA is not queried by A during the Extract queries and the lower-level TA is not corrupted. Without loss of generality, we assume the identity of the entity is ID*1 and its corresponding lower-level TA is T1* with certificate cert*T1.

For a message m  ≠  m*1, the query (m,ID*1,cert*T1) can be queried at most once, and (m*1,ID*1,cert*T1) is never queried during the Sign queries.

We can now define the security of an MTA-OTIBAS scheme in terms of the above game.

An MTA-OTIBAS scheme is secure, i.e., secure against existential forgery under adaptive chosen-message attack, iff the success probability of any polynomially bounded adversary in the above EUF-CMA game is negligible.

We next recall the co-CDH assumption on which the security of the signature scheme in Section [\ref=specific] rests.

The co-CDH assumption in two cyclic groups [formula] and [formula] of prime order q equipped with bilinearity states that, given (ga1,gb2) for randomly chosen [formula], it is hard for any polynomial-time algorithm to compute gab1.

Regarding the security of our MTA-OTIBAS scheme, we have the following claim.

Assume an adversary A has an advantage ε in forging an MTA-OTIBAS scheme of Section [\ref=specific] in an attack modeled by the above EUF-OTIBAS-CMA game, within a time span τ̂; the adversary can make at most qHi times Hi(  ·  ) (i = 0,1) queries, qL times LowerLevel.Setup queries, qC times Corrupt.LowerLevel queries, qE times Extract queries, qS times Sign queries. Then the challenger can solve the co-CDH problem with probability [formula] within time τ̂' = τ̂  +  O(4qH0 + qL + qS)τG1, where τG1 is the time to compute a point exponentiation in [formula] and n is the size of the aggregating set.

Proof: Let [formula] be a co-CDH attacker who receives a co-CDH challenge instance (ga1,gb2) and wants to compute the value of gab1. A is an adversary who interacts with [formula] as modeled in the EUF-CMA game. We show how C can use A to break the co-CDH assumption.

Initialize: Firstly, [formula] selects Ψ = (ê, q, [formula], [formula], [formula], g1, g2, y, H0(  ·  ), H1(  ·  ),ψ), where y = gκ2, and κ is the master secret key; then Ψ is sent to A.

Attack: We consider the hash functions H0(  ·  ) and H1(  ·  ) as random oracles. A can perform the following types of queries in an adaptive manner.

H0(  ·  ) queries: [formula] maintains a list Hlist0 of tuples (IDi,αi,0,αi,0',αi,1,αi,1',idi,0,idi,1,coini). This list is initially empty. Whenever [formula] receives an H1 query on (IDi,j) (where j = 0 or 1), [formula] does the following:

If IDi exists in a previous query, find (IDi,αi,0,αi,0', αi,1,αi,1',idi,0,idi,1,coini) on Hlist1 and return idi,j.

Else, first flip a coin coini∈{0,1} that yields 1 with probability δ and 0 with probability 1 - δ. Then do:

If coini = 0, select [formula], compute idi,0 = gαi,01,idi,1 = gαi,11, set αi,0' = αi,1' = 0, return idi,j and add (IDi,αi,0, αi,0',αi,1,αi,1',idi,0,idi,1,coini) to Hlist0.

Else randomly select [formula], set idi,0 = gαi,01ga1αi,0',idi,1 = gαi,11ga1αi,1', and add (IDi,αi,0,αi,0',αi,1,αi,1',idi,0,idi,1,coini) to Hlist0. Return idi,j as the answer.

LowerLevel.Setup queries: [formula] maintains a list TAlist of tuples (IDTi,κi,yi,certTi,coinTi). On input an identity IDTi of a lower-level TA, [formula] does the following:

If there is a tuple (IDTi,κi,yi,certTi,coinTi) on TAlist, return certTi as the answer.

Else, choose [formula], flip a coin coinTi∈{0,1} that yields 1 with probability δ and 0 with probability 1 - δ and do the following:

If coinTi = 0, set κi as the secret key, compute yi = gκi2, generate a certificate certTi corresponding to (IDTi,yi), add (IDTi,κi,yi,certTi,coinTi) to TAlist.

Else, compute yi = gbκi2, generate a certificate certTi corresponding to (IDTi,yi), add (IDTi,κi,yi,certTi,coinTi) to TAlist.

In the rest of this paper, we assume that if a certificate coinTi appears, A has already made a corresponding LowerLevel.Setup query.

H1(  ·  ) queries: [formula] keeps a list Hlist1 of tuples (IDi,mi,certTi,hi,coini'). This list is initially empty. Whenever A issues a query H1(IDi,mi,certTi), [formula] does the following:

If there is a tuple (IDi,mi,certTi,hi,coini') on Hlist1, return hi as the answer.

Else, submit (IDi,0) to H0 and recover the tuple (IDi,αi,0,αi,0',αi,1,αi,1',idi,0,idi,1,coini) from Hlist0, recover the tuple (IDTi,κi,yi,certTi, coinTi) from TAlist, flip a coin coini'∈{0,1} that yields 1 with probability δ and 0 with probability 1 - δ. Then do the following:

If coinTi = coini = 1 and coini' = 1, add (IDi,mi,certTi,hi,coini') to Hlist1 and return hi =  - αi,0' / αi,1' as the answer.

Else, randomly select [formula], add (IDi,mi,certTi,hi,coini') to Hlist1 and return hi as the answer.

Corrupt.LowerLevel queries: On input an identity IDTi of a lower-level TA, [formula] first makes a LowerLevel.Setup query on IDTi, and recovers the tuple (IDTi,κi,yi,certTi,coinTi) on TAlist. If coinTi = 0, [formula] returns κi as the answer; otherwise, C aborts.

Extract queries: When A issues an Extract query on (IDi,certTi), the same answer will be given if the request has been asked before. Otherwise, [formula] recovers (IDTi,κi,yi,certTi,coinTi) from TAlist; C checks whether (IDi,αi,0,αi,0',αi,1,αi,1',idi,0,idi,1,coini) is on Hlist0; if it is not, [formula] submits (IDi,j) to H0(  ·  ) to generate such a tuple, where j = 0 or 1. Finally, if coini = coinTi = 1, [formula] aborts; else if coinTi = 0, it returns (idκii,0,idκii,1); else it returns (ψ(gbκiαi,02),ψ(gbκiαi,12)).

Sign queries: On receiving a Sign query on (IDi,mi,certTi), [formula] first queries H0(IDi,j) (j = 0 or 1), LowerLevel.Setup(IDTi) and H1(IDi,mi,certTi) if they were not queried before, then recovers (IDi,αi,0,αi,0',αi,1,αi,1',idi,0,idi,1,coini) from Hlist0, (IDTi,κi,yi,certTi,coinTi) from TAlist and (IDi,mi,coinTi,hi,coini') from Hlist1. Finally [formula] generates the signature as follows:

If coini = coinTi = coini' = 1, compute and output σi  =  ψ(gbκi(αi,0   -   αi,1αi,0'  /  αi,1')2).

Else if coini = coinTi = 1,coini' = 0, abort.

Else, use the Sign algorithm to generate the signature, since the corresponding private key is known to [formula].

Note that, as defined in our security assumptions, an adversary can only get one signature corresponding to the target identity and lower-level TA. Hence, [formula] aborts if coini = coinTi = 1,coini' = 0.

Forgery: Eventually, A outputs l' sets of identities [formula], [formula] enrolled by l' lower-level TAs with certificates from the set {cert*T1,...,cert*Tl'}, a set of n messages {m*1,...,m*n} and an aggregate signature Ω*. Once A finishes queries and returns its forgery, [formula] proceeds with the following steps.

For all i∈{1,...,n},j∈{1,...,l'}, [formula] finds (ID*i, α*i,0, αi,0'*, α*i,1, αi,1'*, id*i,0, id*i,1, coin*i) on Hlist0 and (ID*Tj,κ*j,y*j,cert*Tj,coin*Tj) on TAlist. For all [formula], [formula] also recovers the tuples (ID*i,m*i,cert*Tj,h*i,coini'*) from Hlist1, where ID*i is enrolled by Tj. It is required that there exists [formula] such that coin*i = coin*Tj = 1. Without loss of generality, we assume i = j = 1. Besides, it is required that for 2  ≤  i  ≤  n,coin*i = 0. In addition, the forged aggregate signature must satisfy [formula] where id*i,0 = H0(ID*i,0),id*i,1 = H0(ID*i,1),h*i = H1(ID*i,m*i,coin*Tj), [formula], [formula]. Otherwise, [formula] aborts.

Since the forged aggregate signature must satisfy [formula] and id1,0 = gα1,01ga1α1,0',id1,1 = gα1,11ga1α1,1', for all i∈{2,...,n}, id*i,0 = gα*i,01,id*i,1 = gα*i,11, we have

[formula]

To complete the proof, we shall show that [formula] solves the given instance of the co-CDH problem with probability at least ε'. First, we analyze the three events needed for C to succeed:

Σ1: [formula] does not abort as a result of any of A's Corrupt.LowerLevel, Extract and Sign queries.

Σ2: A generates a valid and nontrivial aggregate signature forgery.

Σ3: Σ2 occurs, coin*1 = coinT1 = 1,coin1'* = 0 and for 2  ≤  i  ≤  n,coin*i = 0.

[formula] succeeds if all of these events happen. The probability Pr [null] can be decomposed as Pr [null]  =   Pr [null] Pr [null] Pr [null].

Claim 1. The probability that [formula] does not abort as a result of A's Corrupt.LowerLevel, Extract and Sign queries is at least (1 - δ)qC + qE + qS. Hence we have Pr [null]  ≥  (1 - δ)qC + qE + qS.

Proof: For a Corrupt.LowerLevel query, [formula] will abort iff coinTi = 1. It is easy to see that the probability that [formula] does not abort is 1 - δ. Since A can make at most qC times Corrupt.LowerLevel queries, the probability that [formula] does not abort as a result of A's Corrupt.LowerLevel queries is at least (1 - δ)qC.

For an Extract query, [formula] will abort iff coini = coinTi = 1. It is easy to see that the probability that [formula] does not abort for an Extract query is 1 - δ2  >  1 - δ. Since A can make at most qE times Extract queries, the probability that [formula] does not abort as a result of A's Extract queries is at least (1 - δ)qE.

When [formula] receives a Sign query, he will abort iff coini = coinTi = 1,coini' = 0 happen. So for a Sign query, the probability that [formula] does not abort is 1 - δ2(1 - δ) > 1 - δ. Since A makes at most qS times Sign queries, the probability that [formula] does not abort as a result of A's Sign queries is at least (1 - δ)qS.

Overall, we have Pr [null]  >  (1 - δ)qC + qE + qS.

Claim 2. Pr [null]  ≥  ε.

Proof: If [formula] does not abort, then A's view is identical to its view in the real attack. Hence, Pr [null]  ≥  ε.

Claim 3. The probability that [formula] does not abort after A outputting a valid and nontrivial forgery is at least δ(1 - δ)n. Hence Pr [null]  ≥  δ(1 - δ)n.

Proof: Events [formula] and [formula] have occurred, and A has generated a valid and nontrivial forgery (ID*1,...,ID*n;m*1,...,m*n,Ω*). [formula] will abort unless A generates a forgery such that there exists an i∈{1,...,n} such that coin*1 = coin*T1 = 1,coin1'* = 0, and for 2  ≤  i  ≤  n, coin*i = 0. Therefore, Pr [null]  ≥  δ2(1 - δ)n.

In total, we have [formula] where e is Euler's constant.

Conclusion

We have proven that our MTA-OTIBAS concrete scheme is existentially unforgeable against adaptively chosen-message attacks in the random oracle model under the co-CDH problem assumption.