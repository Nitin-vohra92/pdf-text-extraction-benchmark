Definition

PropositionCorollaryLemmaConjecture

Densest Subgraph in Dynamic Graph Streams

University of Massachusetts, Amherst. {mcgregor,dtench,svorotni,hvu}. This work was supported by NSF Awards CCF-0953754, IIS-1251110, CCF-1320719, and a Google Research Award.

Introduction

In the dynamic graph stream model of computation, a sequence of edge insertions and deletions defines an input graph and the goal is to solve a specific problem on the resulting graph given only one-way access to the input sequence and limited working memory. Motivated by the need to design efficient algorithms for processing massive graphs, over the last four years there has been a considerable amount of work designing algorithms in this model[\cite=AhnCGMW15] [\cite=AhnGM12a] [\cite=AhnGM12b] [\cite=AhnGM13] [\cite=KapralovLMMS14] [\cite=KapralovW14] [\cite=GoelKP12] [\cite=KutzkovP14a] [\cite=GuhaMT15] [\cite=BhattacharyaHNT15] [\cite=ChitnisCEHMMV15] [\cite=AssadiKLY15] [\cite=Konrad15] [\cite=BuryS15a]. Specific results include testing edge connectivity [\cite=AhnGM12b] and node connectivity [\cite=GuhaMT15], constructing spectral sparsifiers [\cite=KapralovLMMS14], approximating the densest subgraph [\cite=BhattacharyaHNT15], maximum matching [\cite=ChitnisCEHMMV15] [\cite=AssadiKLY15] [\cite=Konrad15] [\cite=BuryS15a], correlation clustering [\cite=AhnCGMW15], and estimating the number of triangles [\cite=KutzkovP14a]. For a recent survey of the area, see [\cite=McGregor14].

In this paper, we consider the densest subgraph problem. Let GU be the induced subgraph of graph G = (V,E) on nodes U. Then the density of GU is defined as

[formula]

where E(GU) is the set of edges in the induced subgraph. We define the maximum density as

[formula]

and say that the corresponding subgraph is the densest subgraph. The densest subgraph can be found in polynomial time [\cite=GalloGT89] [\cite=Goldberg84] [\cite=Charikar00] [\cite=KhullerS09] and more efficient approximation algorithms have been designed [\cite=Charikar00]. Finding dense subgraphs is an important primitive when analyzing massive graphs; applications include community detection in social networks and identifying link spam on the web, in addition to applications on financial and biological data. See [\cite=densesurvey] for a survey of applications and existing algorithms for the problem.

Our Results and Previous Work

We present a single-pass algorithm that returns a (1 + ε) approximation with high probability. For a graph on n nodes, the algorithm uses the following resources:

Space: [formula]. The space used by our algorithm matches the lower bound of Bahmani et al. [\cite=BahmaniKV12] up to a poly-logarithmic factor for constant ε.

Per-update time: [formula]. We note that this is the worst-case update time rather than amortized over all the edge insertions and deletions.

Post-processing time: [formula]. This will follow by using any exact algorithm for densest subgraph [\cite=GalloGT89] [\cite=Goldberg84] [\cite=Charikar00] on the subgraph generated by our algorithm.

The most relevant previous results for the problem were established recently by Bhattacharya et al. [\cite=BhattacharyaHNT15]. They presented two algorithms that use similar space to our algorithm and process updates in [formula] amortized time. The first algorithm returns a (2 + ε) approximation of the maximum density of the final graph while the second (the more technically challenging result) outputs a (4 + ε) approximation of the current maximum density after every update while still using only [formula] time per-update. Our algorithm improves the approximation factor to (1 + ε) while keeping the same space and update time. It is possible to modify our algorithm to output a (1 + ε) approximation to the current maximum density after each update but the simplest approach would require the post-processing step to be run after every edge update and this would not be efficient.

Bhattacharya et al. were one of the first to combine the space restriction of graph streaming with the fast update and query time requirements of fully-dynamic algorithms from the dynamic graph algorithms community. Epasto, Lattanzi, and Sozio [\cite=EpastoLS15] present a fully-dynamic algorithm that returns a (2 + ε) approximation of the current maximum density. Other relevant work includes papers by Bahmani, Kumar, and Vassilvitskii [\cite=BahmaniKV12] and Bahmani, Goel, and Munagala [\cite=BahmaniGM14]. The focus of these papers is on designing algorithms in the MapReduce model but the resulting algorithms can also be implemented in the data stream model if we allow multiple passes over the data.

Our Approach and Paper Outline

The approach we take in this paper is as follows. In Section [\ref=sec:subsample], we show that if we sample every edge of a graph independently with a specific probability then we generate a graph that is a) sparse and b) can be used to estimate the maximum density of the original graph. This is not difficult to show but requires care since there are an exponential number of subgraphs in the subsampled graph that we will need to consider.

In Section [\ref=sec:streamalg], we show how to perform this sampling in the dynamic graph stream model. This can be done using the [formula] sampling primitive [\cite=JowhariST11] [\cite=CormodeF14] that enables edges to be sampled uniformly from the set of edges that have been inserted but not deleted. However, a naive application of this primitive would necessitate Ω(n) per-update processing. To reduce this to [formula] we reformulate the sampling procedure in such a way that it can be performed more efficiently. This reformulation is based on creating multiple partitions of the set of edges using pairwise independent hash functions and then sampling edges within each group in the partition. The use of multiple partitions is somewhat reminiscent of that used in the Count-Min sketch [\cite=CormodeM05].

Remark.

Independently of our work, Esfandiari, Hajiaghayi, and Woodruff [\cite=EsfandiariHW15] also proved a similar result to that presented in this paper. Their result is also based on uniformly sampling edges but their approach for ensuring fast update time differs and may be of independent interest.

Subsampling Approximately Preserves Maximum Density

In the section, we consider properties of a random subgraph of the input graph G. Specifically, let G' be the graph formed by sampling each edge in G independently with probability p where

[formula]

for some sufficiently large constant c > 0 and 0 < ε < 1 / 2. We may assume that m is sufficiently large such that p < 1 because otherwise we can reconstruct the entire graph in the allotted space using standard results from the sparse recovery literature [\cite=GilbertI10].

We will prove that, with high probability, the maximum density of G can be estimated up to factor (1 + ε) given G'. While it is easy to analyze how the density of a specific subgraph changes after the edge sampling, we will need to consider all 2n possible induced subgraphs and prove properties of the subsampling for all of them.

The next lemma shows that d(G'U) is roughly proportional to d(GU) if d(GU) is "large" whereas if d(GU) is "small" then d(G'U) will also be relatively small.

Let U be an arbitrary set of k nodes. Then,

[formula]

We start by considering the density of the entire graph d(G) = m / n and therefore conclude that the maximum density, d*, is at least m / n. Hence, p  ≥  (cε- 2 log n) / d*.

Let X be the number of edges in G'U and note that [formula]. First assume d(GU)  ≤  d* / 60. Then, by an application of the Chernoff Bound (e.g., [\cite=MitzenmacherE05]), we observe that

[formula]

and this is at most n- 10k for sufficiently large constant c.

Next assume d(GU) > d* / 60. Hence, by an application of an alternative form of the Chernoff Bound (e.g., [\cite=MitzenmacherE05]), we observe that

[formula]

and this is at most 2n- 10k for sufficiently large constant c.

With high probability, for all U  ⊆  V:

[formula]

There are [formula] subsets of V that have size k. Hence, by appealing to Lemma [\ref=lem:ld] and the union bound, with probability at least 1 - 2n- 9k, the following two equations hold,

[formula]

for all U  ⊆  V such that |U| = k. Since (1 - ε)pd*  ≥  pd* / 10, together these two equations imply

[formula]

for all sets U of size k. Taking the union bound over all values of k establishes the corollary.

We next show that the densest subgraph in G' corresponds to a subgraph in G that is almost as dense as the densest subgraph in G.

Let [formula]. Then with high probability,

[formula]

Let [formula]. By appealing to Lemma [\ref=lem:ld], we know that d(G'U*)  ≥  (1  -  ε)pd* with high probability. Therefore and the result follows by appealing to Corollary [\ref=cor:ld].

Implementing in the Dynamic Data Stream Model

In this section, we show how to sample each edge independently with the prescribed probability in the dynamic data stream model. The resulting algorithm uses [formula] space. The near-linear dependence on n almost matches the Ω(n) lower bound proved by Bahmani et al. [\cite=BahmaniKV12]. The main theorem we prove is:

There exists a randomized algorithm in the dynamic graph stream model that returns a (1 + ε)-approximation for the density of the densest subgraph with high probability. The algorithm uses [formula] space and [formula] update time. The post-processing time of the algorithm is polynomial in n.

To sample the edges with probability p in the dynamic data stream model there are two main challenges:

Any edge we sample during the stream may subsequently be deleted.

Since p depends on m, we do not know the value of p until the end of the stream.

To address the first challenge, we appeal to an existing result on the [formula] sampling technique [\cite=JowhariST11]: there exists an algorithm using [formula] space and update time that returns an edge chosen uniformly at random from the final set of edges in the graph. Consequently we may sample r edges uniformly at random using [formula] update time and space. To address the fact we do not know p apriori, we could set r  ≫  pm = cε- 2n log n, and then, at the end of the stream when p and m are known a) choose [formula] where [formula] denotes the binomial distribution and b) randomly pick X distinct random edges amongst the set of r edges sampled (ignoring duplicates). This approach will work with high probability if r is sufficiently large since X is tightly concentrated around [formula]. However, a naive implementation of this algorithm would require ω(n) update time. The main contribution of this section is to demonstrate how to ensure [formula] update time.

Reformulating the Sampling Procedure

We first describe an alternative sampling process that, with high probability, returns a set of edges S where each edge in S has been sampled independently with probability p as required. The purpose of this alternative formulation is that it will allow us to argue that it can be emulated in the dynamic graph stream model efficiently.

Basic Approach.

The basic idea is to partition the set of edges into different groups and then sample edges within groups that do not contain too many edges. We refer to such groups as "small". We determine which of the edges in a small group are to be sampled in two steps:

Fix the number X of edges to sample: Let [formula] where g is the number of edges in the relevant group.

Fix which X edges to sample: We then randomly pick X edges without replacement from the relevant group.

It is not hard to show that this two-step process ensures that each edge in the group is sampled independently with probability p. At this point, the fate of all edges in small groups has been decided: they will either be returned in the final sample or definitely not returned in the final sample.

We next consider another partition of the edges and again consider groups that do not contain many edges. We then determine the fate of the edges in such groups whose fate has not hitherto been determined. We keep on considering different partitions until every edge has been included in a small group and has had its fate determined.

Assume for every edge there exists a partition such that the edge is in a small group. Then the distribution over sets of sampled edges is the same as the distribution had each edge been sampled independently with probability p.

The proof does not depend on the exact definition of "small" and the only property of the partitions that we require is that every edge is in a small group of some partition. We henceforth consider a fixed set of partitions with this property.

We first consider the jth group in the ith partition. Let g be the number of edges in this group. For any subset Q of [formula] edges in this group, we show that the probability that Q is picked by the two-step process above is indeed [formula].

[formula]

and hence edges within the same group are sampled independently with probability p. Furthermore, the edges in different groups of the same partition are sampled independently from each other.

Let f(e) be the first partition in which e is placed in a group that is small and let Wi  =  {e:f(e) = i}. Restricting Q to edges in Wi in the above analysis establishes that edges in each Wi are sampled independently. Since f(e) is determined by the fixed set of partitions rather than the randomness of the sampling procedure, we also conclude that edges in different Wi are sampled independently. As we assume that every edge belongs to at least one small group in some partition, if we let r be the total number of partitions, then {Wi}i∈[r] partition the set of edges E. Hence, all edges in E are sampled independently with probability p.

Details of Alternative Sampling Procedure.

The partitions considered will be determined by pairwise independent hash functions and we will later argue that it is sufficient to consider only O( log n) partitions. Each hash function will partition the m edges into nε- 2 groups. In expectation the number of edges in a group will be ε2m / n and we define a group to be small if it contains at most t = 4ε2m / n edges. We therefore expect to sample less than 4pε2m / n = 4c log n edges from a small group. We will abort the algorithm if we attempt to sample significantly more edges than this from some small group. The procedure is as follows:

Let [formula] be pairwise independent hash functions where r = 10 log n.

Each hi defines a partition of E comprising of sets of the form

[formula]

Say Ei,j is small if it is of size at most t = 4ε2m / n. Let Di be the set of all edges in the small sets determined by hi.

For each small Ei,j, let

[formula]

and abort if

[formula]

Let Si,j be a set of Xi,j edges sampled without replacement from Ei,j.

Let S be set of edges that were sampled among some Di that are not in [formula], i.e., edges whose fate had not already been determined.

[formula]

Analysis.

There are two main things that we need to show to establish that the above process emulates our basic sampling approach with high probability. First, we will show that with high probability for every edge e there exists i and j such that e∈Ei,j and Ei,j is small. This ensures that we will make a decision on whether e is included in the final sample. Second, we will show that it is very unlikely we abort because some Xi,j is too large.

With probability at least 1 - n- 8, for every edge e there exists i such that e∈Ei,j and Ei,j is small.

Fix i∈[r] and let j = hi(e). Then [formula] assuming m  ≥  ε- 2n. By an application of the Markov bound:

[formula]

Since each hi is independent,

[formula]

Therefore by the union bound over all m  ≤  n2 edges there exists a good partition for each e with probability at least 1 - n- 8.

With high probability, all Xi,j are less than τ = 24c log n.

Since Ei,j is small then [formula]. Hence, by an application of the Chernoff bound,

[formula]

Taking the union bound over all 10 log n values of i and ε- 2n values of j establishes the lemma.

The Dynamic Graph Stream Algorithm

We are now ready to present the dynamic graph stream algorithm. To emulate the above sampling process in the dynamic graph stream model, we proceed as follows:

Pre-Processing: Pick the hash functions [formula]. These define the sets Ei,j.

During One Pass:

Compute the size of each Ei,j and m. Note that m is necessary to define p.

Sample τ edges S'i,j uniformly without replacement from each Ei,j.

Post-Processing:

Randomly determine the values Xi,j based on the exact values of |Ei,j| and m for each Ei,j that is small. If Xi,j exceeds τ then abort.

Let Si,j be a random subset of Si,j' of size Xi,j.

Return p- 1 max Ud(G'U) where G' is the graph with edges:

[formula]

Note that is possible to compute |Ei,j| using a counter that is incremented or decremented whenever an edge e is added or removed respectively that satisfies hi(e) = j. We may evaluate pairwise independent hash functions in [formula] time. The exact value of max Ud(G'U) can be determined in polynomial time using the result of Charikar [\cite=Charikar00]. To prove Theorem [\ref=thm:bigthm], it remains to describe how to sample τ edges without replacement from each Ei,j.

Sampling Edges Without Replacement Via [formula]-Sampling.

To do this, we use the [formula]-sampling algorithm of Jowhari et al. [\cite=JowhariST11]. Their algorithm returns, with high probability, a random edge from Ei,j and the space and update time of the algorithm are both [formula]. Running τ independent instantiations of this algorithm immediately enables us to sample τ edges uniformly from Ei,j with replacement.

However, since their algorithm is based on linear sketches, there is an elegant way (at least, more elegant than simply over sampling and removing duplicates) to ensure that all samples are distinct. Specifically, let [formula] be the characteristic vector of the set Ei,j. Then, τ instantiations of the algorithm of Jowhari et al. [\cite=JowhariST11] generate random projections

[formula]

of [formula] such that a random non-zero entry of [formula] (which corresponds to an edge from Ei,j) can be identified by processing each [formula]. Let e1 be the edge reconstructed from [formula]. Rather than reconstructing an edge from [formula], which could be the same as e1, we instead reconstruct an edge e2 from

[formula]

where [formula] is the characteristic vector of the set {e1}. Note that e2 is necessarily different from e1 since [formula] is the characteristic vector of the set [formula]. Similarly we reconstruct ej from

[formula]

and note that ej is necessarily distinct from [formula].

Conclusion

We presented the first algorithm for estimating the density of the densest subgraph up to a (1 + ε) factor in the dynamic graph stream model. Our algorithm used [formula] space, [formula] per-update processing time, and [formula] post-processing to return the estimate. The most relevant previous results, by Bhattacharya et al. [\cite=BhattacharyaHNT15], were a (2 + ε) approximation in similar space and a (4 + ε) approximation with [formula] per-update processing time that also outputs an estimate of the maximum density after each edge insertion or deletion. A natural open question is whether it is possible to use ideas contained in this paper to improve the approximation factor for the problem of maintaining a running estimate of the maximum density.