The weak pigeonhole principle for function classes in S12

Lemma

Introduction

The weak pigeonhole principle for a relation R(x,y) says that R does not represent an injective map from n2 pigeons to n holes. Variants of the weak pigeonhole principle have been shown to be connected with cryptography and circuit lower bounds in several different ways. Krajíek  and Pudlák [\cite=krajicek-pudlak:ic98] have shown that if the theory [formula] can prove the principle for graphs of p-time functions then the cryptographic scheme RSA is insecure. Here [formula] is roughly a theory which has axioms for the symbols of arithmetic and length induction axioms for [formula]-predicates. The surjective (dual) variant of the weak pigeonhole principle states there is no surjective map from n pigeons onto n2 holes. Jeábek [\cite=jerabek:apal04] has shown that the surjective weak pigeonhole principle for p-time functions is equivalent over [formula] to (essentially) the schema that asserts that for each fixed k > 0 that there is a string of length 2nk that cannot be bit-recognized by any circuit of size nk. More recently, Pollett and Danner [\cite=pollett-danner:tcs06] have shown that the multifunction weak pigeonhole principle for iterated p-time relations is equivalent over [formula] to the existence of strings that are hard for an iterated circuit block recognition principle. This implies that if RSA is secure then [formula] cannot prove superpolynomial circuit lower bounds for multifunctions computed by iterated p-time relations. In an attempt to make progress towards making these contingent results non-contingent, the present note investigates whether there are any interesting classes of functions for which [formula] can prove the weak pigeonhole principle.

Proofs of the pigeonhole principle usually start by assuming one has a map that violates the pigeonhole principle, then constructing a submap that also violates the pigeonhole principle and applying induction to get an obvious contradiction, such as an injective map of two objects into one. The weakest theory known to prove the weak pigeonhole principle for graphs of p-time multifunctions is [formula], which is defined like [formula] but with usual induction for [formula]-predicates. This was shown by Maciel et al. [\cite=maciel-etc:wphp] following essentially this paradigm. The authors assume that they have a multifunction mapping n2 pigeons to n holes. The pigeons are split into groups of size n and the holes into two groups of size n / 2. They then argue that either (1) all of one group of pigeons must be mapped into the first group of holes, or (2) one can pick one pigeon from each group so that pigeons from different groups are mapped to different holes (all in the second group). In either case one gets a map from n pigeons to n / 2 holes which is amplified to a map from n2 pigeons to n / 2 holes using the original map. This process is then iterated. The entire argument is carried out in [formula], which is conservative over [formula] for [formula] formulas (an in particular, for the weak pigeonhole principle).

In contrast to the above technique for proving the weak pigeonhole principle, in the current paper we use a technique that clearly illustrates the cryptographic nature of these principles. We consider a function algebra A3 which is the closure of the terms of the language of [formula] under 3-lengths bounded primitive recursion (see Definition [\ref=defn:bpr]). Working in [formula] we show that any function in A3 omits values of the form ⌊(n  #  n - 1) / 3⌋ from its range, where [formula]. Pollett [\cite=pollett:mfn-algebras] [\cite=pollett:aml03] has connected the algebras Am to weak theories of arithmetic, and the techniques of those papers can be used to show that if f(x)∈A4, then [formula]. In this paper we prove the much harder statement that for any n and any a  ≤  n, [formula]; in particular, [formula] is not a surjection from [formula] onto [formula] (which we will refer to as a surjection from n onto n  #  n). Our technique uses a new complexity measure that we call the prefix series for [formula] (Definition [\ref=def:ps]) which might be useful in future work. It should be noted that [formula] can prove the surjective pigeonhole principle for n onto n2 from the principle for n onto n  #  n. However, the amount of iteration takes one (just barely) out of the class A3.

We now discuss the organization of the rest of the paper and give a high-level sketch of the proof. In the next section we introduce the necessary notations from bounded arithmetic and define our function algebras. In Section [\ref=sec:pfx-series] we define the notion of a "prefix series." Roughly speaking, a prefix series for [formula] is a representation of [formula] as a difference of sums of prefixes of the values [formula]. In Theorem [\ref=complexity] we establish a bound on the length of such prefix series. In Section [\ref=sec:bit-series] we convert the prefix series representation to one in which the prefixes are replaced by bits. We compute a bound on the length of such a representation and combine it with Theorem [\ref=complexity] to compute a bound on the number of times the binary representation of [formula] can alternate between 0 and 1 (Lemmas [\ref=convert] and [\ref=numblocks]). For f∈A3 this bound is provably lower than the number of alternations in ⌊(n  #  n - 1) / 3⌋, allowing us to conclude that f is not a surjection from n onto n  #  n (Theorem [\ref=clm:php3]). We conclude with some remarks on generalizations and extensions.

Preliminaries

This paper assumes familiarity with the texts of either Buss [\cite=Buss:Bounded-Arith], Krajíek [\cite=krajicek:Bounded-Arithmetic], or Hájek and Pudlák [\cite=hajek-pudlak:Metamathematics]. For completeness, we review the basic notations of bounded arithmetic. The specific bootstrapping we are following is that of Pollett [\cite=pollett:apal99], but yields equivalent theories to the ones in the books just mentioned. The language L2 contains the non-logical symbols 0, S, +  , ·  , [formula], ≤  , [formula], [formula], [formula], [formula] and #  . The symbols 0, S(x) = x + 1, +  , ·  , and ≤   have the usual meaning. The intended meaning of [formula] is x minus y if this is greater than zero and zero otherwise, [formula] is x divided by 2 rounded down, and [formula] is ⌈ log 2(x + 1)⌉, that is, the length of x in binary notation. [formula] stands for 'most significant part' and is intended to mean ⌊x / 2i⌋. Finally, x  #  y reads 'x smash y' and is intended to mean [formula]. The original formulations of bounded arithmetic do not usually include [formula] and [formula], but instead define them with formulas. One advantage to our approach is that one can define terms in the language to do a limited amount of sequence coding, which allows us to more directly formulate our principles in the language L2.

The bounded formulas of L2 are classified into hierarchies [formula] and [formula] by counting alternations of quantifiers, ignoring sharply-bounded quantifiers, analogous to the hierarchies Σ0i and Π0i of the arithmetic hierarchy. Here sharply bounded means bounded by a term of the form [formula]. Formally, a [formula] ([formula]) formula is one in which all quantifiers are sharply-bounded. The [formula] ([formula]) formulas contain the [formula] formulas and are closed under [formula], A  →  B, [formula], [formula], sharply-bounded quantification, and bounded existential (universal) quantification, where A is [formula] ([formula]) and B and C are [formula] ([formula]).

The theory [formula] is axiomatized by a finite set of quantifier-free axioms for the non-logical symbols of L2. [formula] consists of formulas of the form

[formula]

for [formula] where τ is collection of unary functions. Let id denote the identity function. C-[formula] and -[formula] (length induction) are obtained by taking A∈C and τ to be [formula] and [formula], respectively (we will write [formula] for [formula], etc.). The theories [formula] and [formula] are axiomatized as [formula] together with respectively [formula]-[formula] and [formula]-[formula].

We next briefly consider sequence coding and bit manipulation in our systems of arithmetic. The term [formula] is the i-th bit of w. The ordered pair [formula] can be defined as the binary string [formula] where 〈x〉 is the binary representation of x padded with 0's on the left to have length [formula] and similarly for 〈y〉. Sequences can be defined as ordered pairs in which the first component specifies a block size and the second a concatenation of blocks. The predicate [formula] that is true when s is the code of a sequence can be given a [formula]-definition. The function [formula] is a bound on the value of any sequence of length [formula], each of whose components is ≤  a, and β(b,w) is defined to be the b-th element of the sequence w. β(,)bw can be defined as a term in our language, and the basic properties of [formula] and β(,)bw can be proved using open length induction. We will use sequences of pairs extensively in this paper, so define the term [formula] that is a bound on the value of any sequence of pairs of length [formula] for which each component of each pair is ≤  a.

The theory [formula] can prove the existence of sequences and properties of sequences using length induction if particular elements in the sequence have [formula]-definitions. Sometimes it will be convenient to use other principles more directly connected to sequences. It is known that [formula] can prove the following [formula]-[formula] principle (see [\cite=Buss:Bounded-Arith] or [\cite=pollett:phd]):

[formula]

where A is a [formula]-formula. Using this principle, we can [formula]-define the sequence [formula] where p is a polynomial provided we know f(i,x) is [formula]-definable (see below). Further it can be shown that [formula] can prove basic properties of this sequence. The [formula]-[formula] scheme can be used to prove another useful scheme in [formula], that of [formula]-[formula] which allows one to get a bit-string of values for a [formula]-formula A(i,a).

The [formula] scheme is closely connected with the following type of bounded primitive recursion:

([formula]) Let τ be a set of unary functions. f is defined from functions g, h, t and r by τ-length bounded primitive recursion if:

[formula]

for some r,t∈L2 and [formula].

Let L-2 be the language of L2 where the symbol for multiplication has been replaced with [formula] with intended meaning [formula]. As [formula] is definable with an L2-term any L-2-term can be rewritten as an L2-term. Given a class of formulas Ψ, we say an arithmetic theory T can Ψ-define a function f if there is a formula Af in Ψ such that T proves:

[formula]

[formula]

For a set τ of function symbols, the set Aτ is defined as follows:

The function symbols of L-2 are in Aτ along with symbols πni for 0  ≤  i < n (intended interpretation: projections);

If [formula] and f is r-ary, then [formula] (intended interpretation: the composition of f with [formula]);

If g,h∈Aτ, t,r∈L-2, and [formula], then [formula] (intended interpretation: the function defined by [formula]-bounded primitive recursion from g, h, t, and r).

Aτ of course corresponds to a function algebra and we shall frequently informally refer to it as such. We write Am for [formula]; we shall focus primarily on these classes in all but the last section. Pollett [\cite=pollett:phd] considers these classes where the initial functions also include multiplication. In particular, it is known that A1 corresponds to the polynomial time functions and Pollett shows that A4  ⊂  A1 as A4 cannot define ⌊x / 3⌋. When we refer to terms (formulas, etc.) over Aτ in, e.g., [formula], we assume that the functions in τ are defined by L-2 terms and that the defining axioms of the functions symbols are (conservatively) added to the theory (we shall always have Aτ  ⊆  A1). Using the close connection between [formula] and [formula] Buss [\cite=Buss:Bounded-Arith] shows that the functions in A1 are precisely the functions [formula]-defined in [formula].

A couple of notations that we use frequently in this paper are:

For [formula], [formula] abbreviates [formula].

We will write #  b(n) for [formula] (b - 1 #  's).

For a unary function symbol f, [formula] is the formula [formula].

The weak surjective pigeonhole principle for f, [formula], is the sentence [formula]. If A is a set of function symbols, [formula] is the set of formulas [formula] for unary functions f∈A.

The sentence [formula] is [formula] and [formula] is defined similarly.

If A is a set of function (symbols) closed under [formula], then [formula].

If f0 is a surjection from [formula] onto [formula], define surjections fr from [formula] onto [formula] by setting fr + 1(x) to be the result of replacing each length-[formula] block y of fr(x) by f0(y). Then [formula] is a surjection from [formula] onto [formula].

Prefix series representation

In this section we introduce the notion of a prefix series, which is our main technical tool for proving the weak surjective pigeonhole principle.

A prefix series for M from [formula] of width w and length k is a pair 〈,〉PN of sequences such that:

[formula] and [formula];

[formula];

For all i, [formula];

k  =  kP + kN;

For all i, either ai = 1 or there are j and [formula] such that [formula] and similarly for ci.

A bit series for M from [formula] of width w and length k is a prefix series for M from [formula] of width w and length k in which all ai's and ci's are 1.

For terms [formula] and w(n) let kt,w(n) be the least k such that if mi < n for all i, then there is a prefix series for [formula] from [formula] of width ≤  w(n) and length ≤  k. Then kt,w is the w-summand complexity of t (kt,w(n) may not be defined for all w).

For any function f, if we could define the term [formula], then w(n) itself would be a bound on [formula]: just use the binary representation of [formula] to define a bit-series. Of course, such a term w is problematic; our first goal is to show that for every f∈A3 there is in fact a w such that [formula] has a "tractable" upper bound (and in particular is defined).

[formula] is the predicate

[formula]

that states that S is a prefix series for y from [formula] of width w and length [formula]. Here [formula] is the polynomial-time function that on input 〈,〉PN as in Definition [\ref=def:ps]([\ref=item:ps]) outputs [formula]. Note that [formula] is a [formula] formula. We discuss the parameter δ below.

Let [formula], w(n), k(n), and δ(n) be terms. [formula] is the predicate

[formula]

that states that for sufficiently large n, [formula] is an upper bound on kt,w(n) (and in particular, kt,w(n) is defined).

[formula] is the predicate

[formula]

that states that S is a bit series for y of width w and length [formula]. [formula] is defined analogously to [formula].

The point behind the parameter δ is to ensure that the exponentiation terms in [formula] and [formula] are bounded by L2-terms. Our goal is now the following: given an A3-function symbol f, find L2-terms w, k, and δ such that [formula]; in other words, find a bound on the lengths of the prefix series for [formula]. In fact, the form of k will be made explicit, and this will allow us to take δ = n2 for all function symbols in A3. However, for some preliminary observations which do not rely on the form of k, we must allow this parameter to vary.

[formula] proves the following:

[formula]

In particular, for any terms t, w, w', k, k', and δ,

[formula]

and similarly for the bit-series predicates.

For every [formula] there is an L2-term [formula] without [formula] or [formula] (hence monotone) such that [formula]. In particular, there is a number b such that [formula].

The first part is proved by induction on the definition of f. The base cases are immediate (bound [formula] and [formula] by x) and composition is handled by substitution. Suppose f is defined as in Definition [\ref=defn:bpr]; the induction hypothesis gives us bounds ug, ut, and ur for g, t, and r respectively. Then [formula] and hence [formula]. For the second part, prove that for any L2-term [formula] without [formula] or [formula] there is a number b such that [formula] for sufficiently large n and [formula] by induction on u. For example, if u  =  u1  #  u2, then take b = b1 + b2, where bi is the inductively-given exponent for ui.

[formula]. In particular, for every A1-term [formula] there is a number b such that [formula].

For the first part use [formula]-[formula] to construct the sequence of pairs [formula] such that [formula], which witnesses the claim. For the second part, fix any [formula]; then there is an S such that [formula]. Now take n0 and b as in Lemma [\ref=clm:L2-lh-bd] and apply Lemma [\ref=clm:longer-width-length].

We call the bit series given in Lemma [\ref=clm:bps-bound] the natural bit series for x. We need the following bound for calculating the length of a prefix series for (the function represented by) an [formula]-term:

The following are provable in [formula]: for any [formula], any length k and any length y:

[formula].

[formula].

[formula].

[formula] proves the following:

[formula]

The same claim holds with y + y' replaced with [formula].

Working in [formula], suppose [formula], and [formula] are prefix series for y and y' of widths w and w' and lengths k and k' respectively. If N  ≥  P, then [formula]. If N < P and N'  ≥  P', then [formula]. If N < P and N' < P', then [formula]. In each case, the width and length of the prefix series are at most w + w' and k + k' respectively.

We shall frequently rearrange sums of differences of sums in this way to obtain prefix series; we will not frequently point out that we are doing so.

[formula] proves the following:

[formula]

Suppose [formula] is a prefix series for z from [formula] of width w and length k as in Definition [\ref=def:ps]([\ref=item:ps]). From Lemma [\ref=clm:msp-error] and arithmetic we have that [formula] where [formula]. Thus there is some [formula] such that [formula] or [formula]. Since Q is a prefix series from [formula] of width ≤  w and length ≤  k, by Proposition [\ref=clm:pfx-series-sum] and Lemma [\ref=clm:bps-bound] there is a prefix series for [formula] from [formula] of width [formula] and length [formula].

We now set about showing that for m  ≥  3 and every function symbol f∈Am there is an L2-term wf(n) and a number bf such that if k(n) is the term [formula] then [formula]. More precisely, we will write [formula] for the term [formula] so that k(n) is an L2-term. It is also easy to see that if m  ≥  3, then [formula] proves that [formula] is bounded by [formula], which in turn is bounded above by [formula] for sufficiently large n (where the point at which this holds depends only on b). Thus from now on, we shall simply write [formula] with the bounding term always implicitly n2. The proof is by induction on the definition of f; we separate out the base case into its own proposition.

If f is an L-2-function symbol, then there is an L2-term w and a number b such that [formula].

The proof is a straightforward analysis; most cases are handled by already-proved lemmas and propositions. If f = 0, then wf  =  kf  =  0 and if f = x  #  y then we can take w(n)  =  n  #  n and k = 1 since [formula]. If [formula] then an argument as in Lemma [\ref=clm:bps-bound] applies using Lemma [\ref=clm:L2-lh-bd] to bound f(x) by [formula]. If f(x,y)  =  x + y or [formula] then Proposition [\ref=clm:pfx-series-sum] applies and if [formula] then Proposition [\ref=clm:pfx-series-msp] does. If [formula], then a prefix series for f(x,y) from x,y is given by [formula], which has width [formula] and length 1.

If m  ≥  3 and f is an Am-function symbol then there is an L2-term wf and a number bf such that [formula], where [formula].

The proof is by induction on the definition of f. The base case in which f is an L-2 symbol is handled in Proposition [\ref=functionbounds].

Suppose f has defining equation [formula]. By the induction hypothesis we have terms wh(n), kh(n), wg(n), and kg(n) such that [formula]. Let nh be such that for all n  ≥  nh there is a prefix series for [formula] from [formula] of the given width and length, and define ng similarly. Furthermore take a constant B such that if n  ≥  nh and [formula], then [formula]. Take n0 large (we shall impose constraints as the proof progresses), n  ≥  n0, and [formula]. The induction hypothesis for hi gives us a prefix series Si for [formula] from [formula] of width wh(n) and length kh(n) (assume n0  ≥  nh). Since n0  ≥  nh we also have that [formula]. Now the induction hypothesis for g gives us a prefix series Sg for [formula] from [formula] of width [formula] and length [formula] (assume [formula]). The terms in Sg have the form [formula] for some  i, y and j (the terms with coefficient 1 we leave as they are). Replace each such term with a prefix series for [formula] from [formula]; this is obtained from the inductively-given prefix series by Lemma [\ref=clm:pfx-series-msp] and then padding, and has width at most [formula] and length at most [formula]. After replacing all terms in Sg in this way and rearranging if necessary (dropping expressions that evaluate to 0) we obtain a prefix series S for [formula] from [formula] of width at most [formula] and length [formula]. Finally, by taking n0 large enough, [formula] is bounded above by [formula], from which an upper bound on the length of the correct form is easily obtained, completing the proof for this case.

Suppose f is defined by [formula]-bounded recursion from g, h, t, and r with intermediate function F as in Definition [\ref=defn:bpr]. Let [formula]. Take b and c such that for sufficiently large n and [formula], [formula] and [formula]. Now take a sufficiently large n0, n  ≥  n0, [formula], and show by length-induction on y < n that there is a prefix series for [formula] from [formula] of length [formula]. For the induction step, since [formula] is defined as a composition of h with [formula] (the case in which [formula] is immediate) an argument as in the previous case applies. Now taking [formula] we obtain a prefix series of length [formula] which we can bound by a term of the form [formula] where B  =  bh + 1. Similarly we obtain a bound on the width of the prefix series for [formula] of the form [formula] where w'(n)  =  wh(n)  +  wr(n); when [formula], we obtain an term bounded by an L2-term in n.

Bit series representation and the weak pigeonhole principle

We now extract bounds on lengths of bit series representations from bounds on prefix series representations and use them to determine bounds on the number of times the binary representation of [formula] can alternate between 0's and 1's.

For any terms t, w, k, and δ, [formula].

Given a prefix series for [formula] from [formula], replace each term a2b with [formula], where the [formula] are exactly those i such that [formula]. Since each [formula] for some l, the resulting bit series has width at most [formula]. Since [formula] each term is replaced with a summand of at most [formula] terms. Since there are at most k(n) summands, the resulting bit series for [formula] from [formula] has length at most [formula].

Given the binary expansion of a number y, a block is a substring of all 0's or all 1's of maximal length. Let #  B(y) denote the number of blocks in y's binary expansion. This number can be [formula]-defined in [formula] as [formula]. Here [formula] is the operator which counts the number of [formula] such that B holds. It is known to be [formula]-definable in [formula] provided B is [formula] by Buss [\cite=Buss:Bounded-Arith].

[formula] proves the following:

[formula]

where [formula] is the part of the definition of [formula] (Definition [\ref=def:ps]([\ref=item:bs])) in brackets. In other words, the binary expansion of a number represented by a bit-series of length [formula] has at most [formula] blocks.

Fix w and δ; we prove this [formula] claim by length-induction on k. If k = 0 then [formula] and the claim is immediate, so assume the claim is true for k and that [formula]. Then [formula] for some S' satisfying [formula] and [formula], so the induction hypothesis applies to S'. It is now a matter of exhausting cases on whether [formula] or [formula] and [formula], [formula], and [formula] to show that [formula], from which the claim follows.

For any f∈A3, [formula].

Combining Theorem [\ref=complexity] with Lemmas [\ref=convert] and [\ref=numblocks] we have that for sufficiently large n, if [formula] then [formula] for some fixed number b. Now [formula] proves that [formula] for sufficiently large n and that [formula] for any a; combining these, we have that

[formula]

Thus we conclude that [formula]. Thus [formula]. On the other hand, [formula] proves that if [formula] then [formula] (first show that n  #  n - 1 is a string of all 1's, then analyze the grade-school algorithm for division to show that [formula]; this can be done with open length-induction). Thus [formula]. If [formula] then [formula], so we conclude that [formula].

Finally, we note that the value n0 in Theorem [\ref=clm:php3-prelim] can be calculated explicitly. That is, in each argument of this and the previous section in which the conclusion is of the form [formula], we could have instead computed a closed term N and shown [formula] (adding N into the formalism would have entailed making our already-unpleasant notation even worse). Thus we can improve Theorem [\ref=clm:php3-prelim] as follows:

[formula].

Fix f∈A3. As just discussed, there is a closed term N such that [formula]. Since N is a closed term, for each M < N there is an explicit proof in [formula] of [formula], and hence we conclude that [formula].

Generalizations and extensions

Analyzing the details of the above proofs, we can determine the properties of [formula] that are required in order to generalize the result to function classes τ. The key point is that [formula]:

Let τ consist of unary functions [formula] such that:

For every [formula] there is a constant N such that [formula].

For every [formula], there is [formula] and a number N such that [formula].

For every [formula], there is [formula] and a number N such that [formula].

Then [formula].

The proofs estimating the lengths of the prefix series carry through mutatis mutandis, with the new bound on the length being [formula] for some [formula]; the second two hypotheses are used in the composition and τ-bounded recursion cases of Theorem [\ref=complexity]. The proof of Theorem [\ref=clm:php3-prelim] relies on the fact that [formula]. Now we need [formula], which is the first hypothesis.

Of course, we can add any functions to the algebra Aτ provided that the conclusion of Theorem [\ref=complexity] still holds. In particular, if [formula] proves that for sufficiently large n and [formula], [formula] then the natural bit series for [formula] satisfies the conclusion, so any such functions can be added to Aτ; we leave it to the reader to precisely formulate the corresponding theorem.

Clote [\cite=clote:handbook] gives several interesting function-algebra characterizations of various complexity classes. Most of these rely on so-called concatenation recursion on notation and one other recursion scheme. The function f is defined from g, h0, and h1 by concatenation recursion on notation if

[formula]

Clote then shows that, for example, the log-space functions are exactly the closure of L-2 under composition, concatenation recursion on notation, and sharply-bounded recursion on notation (called doubly-bounded recursion on notation by Clote and Takeuti [\cite=clote-takeuti:FMII]). This latter scheme defines a function f in terms of given functions g, h0, h1, and b by

[formula]

It is easy to see that the scheme of weak bounded recursion on notation preserves the property that for sufficiently large n and [formula], [formula]. Thus, if the techniques of this paper could be extended to handle concatenation recursion on notation (for which [formula] may now grow linearly in [formula]), one could hope to prove some version of the weak pigeonhole principle for these small complexity classes.