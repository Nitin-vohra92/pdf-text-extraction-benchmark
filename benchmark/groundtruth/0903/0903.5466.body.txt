Corollary Conjecture Lemma Proposition Definition Remark Example Fact

Symmetric functions of qubits in an unknown basis

Introduction

Consider the following scenario. Alice is a physicist who has just completed a long quantum computing experiment. Her quantum computer has produced an n qubit state |x〉, corresponding to the bit string x. However, before she can measure the state to determine x, she is called away from the lab. In her absence, Eve sneaks in and sabotages the experiment. First, she applies an arbitrary local rotation to the qubits (the same rotation on each qubit); she then rearranges all the qubits in an arbitrary order.

It is clearly now hopeless for Alice to determine x exactly. Indeed, she cannot even determine an individual bit of x with any probability better than guessing. But what if she only needs to calculate f(x), for some function f? Because of the arbitrary rearrangement of the qubits, she only has a chance of being able to compute symmetric functions, i.e. functions f where f(x) depends only on |x|, the Hamming weight of x. Also, because of the arbitrary local rotation, she can only compute functions f where f(x)  =  f(x̄), with x̄ denoting bitwise negation. This is equivalent to imposing the constraint that |x|  ≤  ⌊n / 2⌋.

The purpose of this note is to show that Alice can in fact compute any f that satisfies these constraints (with some probability, which may be low in the worst case). Indeed, we have the following result.

Let x be an n-bit string with |x|  ≤  ⌊n / 2⌋. Let U be an unknown and arbitrary single qubit unitary operator, and σ be an unknown and arbitrary permutation of n qubits. Then there is a procedure which, given [formula], outputs |x| correctly with probability

[formula]

Assuming that |x| is distributed uniformly at random, for large n this corresponds to an average probability of success of approximately 2(1 -  ln 2)  ≈  0.614.

Previous work has studied the closely related question of communicating without a shared reference frame [\cite=bartlett03]. In this setting, Alice wishes to communicate some (classical or quantum) information to Bob by sending him n qubits, but Bob does not know Alice's basis for each of the qubits. The results of [\cite=bartlett03] show that, by encoding across multiple qubits, Alice can send Bob a number of bits that approaches n, in the large n limit. By contrast, in the present work we do not allow prior encoding of Alice's information. Also note related previous work on the problem of computation in a hidden basis [\cite=ioannou08].

Theorem [\ref=thm:main] can be used to obtain procedures for computing any symmetric function of x. These results can be seen as generalisations of the problem of determining whether n qubits are all in the same state [\cite=jex04] [\cite=kada08], which is in turn a generalisation of the question of determining equality of two qubits, which can be solved using the well-known swap test [\cite=barenco97] [\cite=buhrman01]. For example, we have the following results for the threshold function t (t(x)  =  1  ⇔  |x|  ≥  t) and the parity function ([formula]).

Let x be an n-bit string with |x|  ≤  ⌊n / 2⌋. Let U be an unknown and arbitrary single qubit unitary operator, and σ be an unknown and arbitrary permutation of n qubits. Then there is a procedure which, given [formula], can compute t(x) with success probability at least 1  -  t / (n + 1), and can compute (x) with probability at least 1 / 2  +  1 / (2(n + 1)).

These success probabilities are essentially optimal, as we will show with the following theorem.

Let x be an n-bit string with |x|  ≤  ⌊n / 2⌋. Let U be an unknown and arbitrary single qubit unitary operator, and σ be an unknown and arbitrary permutation of n qubits. Let f(x) be some function such that f(k + 1)  ≠  f(k) for some 0  ≤  k  <  ⌊n / 2⌋. Then any procedure that computes f(x) given access to [formula] succeeds with probability at most 1 - (k + 1) / (2(n - k)) in the worst case.

This implies that, for example, one can determine whether or not |x| = 0 very effectively, but distinguishing |x| = n / 2 from |x| = n / 2 - 1 is hard. Interestingly, this phenomenon also occurs in the study of quantum and classical query complexity [\cite=beals01], and more generally in approximation theory [\cite=petrushev87].

The symmetric group and weak Schur sampling

The results in this note will be proven using some basic representation theory of the symmetric group Sn, which we now outline. Conjugacy classes of Sn are labelled by partitions [formula]. Each partition λ containing k parts can be written as a non-increasing sequence of positive integers [formula], and expressed as a Young diagram. The diagram corresponding to the partition λ is a collection of boxes arranged in left-justified rows, where the number of boxes in row i is given by λi. Irreducible representations (irreps) of the symmetric group are thus in one-to-one correspondence with Young diagrams. We let λ denote both a partition and its corresponding diagram, and Vλ denote the corresponding irrep.

We think of the input to our problem as an n-qubit state |x〉 in a known basis, to which an unknown, and arbitrary, tensor product unitary [formula] has been applied, followed by an unknown permutation of the qubits σ. In order to take advantage of these symmetries, we will use Schur-Weyl duality. This states that the space of n qudits decomposes into a direct sum of tensor products of subspaces corresponding to irreps of the symmetric and unitary groups, as follows:

[formula]

where Pλ and Qdλ correspond to irreps of Sn and Ud, respectively. For good introductions to Schur-Weyl duality in the context of quantum information theory, see the theses [\cite=harrow05] and [\cite=christandl06].

The Schur transform [\cite=harrow05] [\cite=bacon06] [\cite=bacon07] performs an implementation of this decomposition, mapping a state in the computational basis to one of the form |λ〉|p〉|q〉. In this case, as we are indifferent to permutations of the subsystems and local unitaries on each subsystem, we will only measure the |λ〉 register. This is known as weak Schur sampling [\cite=childs07c]. The projector onto a given value of λ is given by (see [\cite=childs07c] or [\cite=serre77])

[formula]

where dλ is the dimension of the irrep Vλ, χλ is the character [formula], and D is the defining representation of Sn that acts by permuting the n subsystems,

[formula]

It is unnecessary to perform the full Schur transform to measure λ; it suffices to use the quantum Fourier transform over the symmetric group Sn, in a procedure known as generalised phase estimation [\cite=harrow05] [\cite=childs07c], which can be seen as a generalisation of the swap test [\cite=barenco97] [\cite=buhrman01]. To perform generalised phase estimation on an n qubit state ρ, one first prepares an ancilla register in the state [formula]. This register is used to control a conditional permutation of the subsystems of ρ, which is followed by an inverse quantum Fourier transform (over Sn) on the ancilla register. Measuring the ancilla gives a value of λ with probability [formula]. This whole procedure can be performed efficiently, i.e. in time polynomial in n [\cite=beals97].

Let |x〉 be the input state and assume that x has Hamming weight k  ≤  ⌊n / 2⌋. Letting σ be an arbitrary permutation of n qubits and U be an arbitrary local unitary, we now compute [formula]. As Pλ commutes with local unitaries and permutations [\cite=childs07c], this is equal to [formula]. Invariance under permutation also implies that the probability of obtaining a given outcome λ depends only on the Hamming weight of x. The following crucial lemma allows us to write down exactly what these probabilities are.

Let Pr [null] denote the probability of getting the measurement outcome corresponding to the partition [formula] when performing weak Schur sampling on an n-bit string with Hamming weight k. Then, if [formula], Pr [null]  =  0. Otherwise,

[formula]

In particular, [formula].

Before we prove this lemma, we show that it implies the results stated in Section [\ref=sec:introduction]. In the case of Theorem [\ref=thm:main], we give an explicit algorithm that achieves the success probability required by the theorem:

Perform weak Schur sampling, obtaining outcome [formula].

Output the guess that [formula].

It is clear that this procedure, which we will term the standard algorithm, will output the correct answer with probability Pr [k|k]  =  1  -  k / (n - k + 1).

One might consider more complicated strategies for inferring k from weak Schur sampling. A general inference strategy can be expressed as a matrix O, where [formula], and [formula] for all [formula]. If one wishes to maximise the worst-case probability of outputting the correct value of k, for example, it is required to find an O that maximises

[formula]

This is a linear programming problem and can be solved exactly for small n, although we do not know a closed form for the solution for general n.

An alternative setting for the inference problem is the Bayesian scenario where one maximises the probability of success assuming an a priori probability distribution on k (see [\cite=mackay03] for a comprehensive introduction to Bayesian inference). Letting {pk} denote this probability distribution, the problem is to maximise

[formula]

This is clearly maximised by taking [formula] for [formula], and [formula] otherwise. In the particularly natural case where we assume that the a priori distribution on k is uniform, this maximisation in fact shows that the standard algorithm is optimal, and gives an average probability of success of

[formula]

For large n, this can be estimated as What about the scenario of Corollary [\ref=thm:threshold], where we only want to compute some function f(k), rather than to output k? It is natural to try to produce an algorithm with high success probability for all 0  ≤  k  ≤  ⌊n / 2⌋. Again, if one attempts to maximise this worst-case probability over all strategies that consist of performing weak Schur sampling and attempting to infer f(k) from the result, one is led to a linear programming problem for which we do not know a closed form solution. A more straightforward approach is to guess k using the standard algorithm (call this guess [formula]), and then to output [formula].

The probability that this gives the right answer can easily be calculated for threshold functions t. Assuming k  ≥  t,

[formula]

This is clearly maximised by k = t, giving a failure probability of at most t / (n - t + 1). On the other hand, if k < t, note that this algorithm succeeds with certainty, as Pr [null] = 0 for [formula]. We thus have a probabilistic algorithm that computes the threshold function t with one-sided error. This can be modified to give an algorithm with small worst-case probability of error, as follows.

Consider any procedure that attempts to compute an arbitrary boolean function f(k) from [formula], where k is picked to minimise the probability that [formula]. Such a procedure can be parametrised by two probabilities q0, q1, where q0 is the probability that the procedure outputs 0, given that [formula], and q1 is the probability of outputting 0, given that [formula]. Let pi  =   Pr [null] for i∈{0,1}, and assume that p0  ≥  p1. Then the probability of success of such a procedure (in the worst case) is at least

[formula]

We pick q1 such that these two values are equal, which gives

[formula]

Our goal is to maximise the corresponding expression for the probability of success,

[formula]

over q0, while still obeying the constraints 0  ≤  q0,q1  ≤  1. This is straightforward and gives the answer

[formula]

which corresponds to a maximum worst-case probability of success of p0 / (p0 + p1) when p0  +  p1  ≥  1, and (1 - p1) / (2 - p0 - p1) when p0  +  p1  ≤  1.

Applying this result to the threshold function t, where p0  =  1 and p1  =  t / (n - t + 1), it can easily be seen that we obtain a two-sided error algorithm that always succeeds with probability at least 1  -  t / (n + 1), as stated in Corollary [\ref=thm:threshold].

In the case of the Parity function, we can calculate the probability that [formula] from It is then immediate that and of course Pr [null]  =  1 -  Pr [null]. Assume that n is even and n / 2 is also even (the cases where n or n / 2 is odd are analogous). This implies that, for k even, we have Pr [null]  ≥  1 / 2, and for k odd, Pr [null]  ≥  1 / 2  +  1 / n. We can use the same technique as before to get an algorithm that succeeds with probability at least 1 / 2  +  1 / (2(n + 1)) in the worst case.

Limits on success probability

To prove Theorem [\ref=thm:optimal], and hence to show that these algorithms are almost optimal, consider the restricted problem of distinguishing a bit-string x with weight k from one with weight k + 1, as is required to compute a symmetric function f where f(k)  ≠  f(k + 1).

We first argue that any procedure for computing f might as well simply consist of weak Schur sampling and post-processing the results. Imagine that an adversary, as in the scenario of Section [\ref=sec:introduction], has performed a random permutation and a random local rotation of each qubit on the initial state |x〉. Then, from Alice's perspective, the resulting state looks like

[formula]

which is equal to [formula] for some coefficients {kλ}. (This follows from the decomposition of eqn. ([\ref=eqn:schur]) and Schur's Lemma, using the fact that ρ commutes with all permutations and local unitaries.) This implies that, without loss of generality, a measurement strategy can be taken as consisting of measuring λ and performing some classical post-processing.

Let [formula] denote the probability distribution over partitions [formula] obtained by performing weak Schur sampling on an input with weight k. We calculate the [formula] distance between the distributions pk, pk + 1 for arbitrary 0  ≤  k  <  ⌊n / 2⌋:

[formula]

Using standard results on distinguishing probability distributions, this distance puts an upper bound on the probability of success of any algorithm attempting to distinguish between weights k and k + 1, and implies that the above algorithms are asymptotically optimal. We finally turn to the proof of Lemma [\ref=lem:probs].

Proof of Lemma [\ref=lem:probs]

Let λ be the partition [formula] and let x be a bit-string with Hamming weight k  ≤  ⌊n / 2⌋, assuming without loss of generality that [formula], where the first k bits of x are 1 and the last n - k are 0. We now calculate [formula] using ([\ref=eqn:plambda]). It is easy to see that [formula] unless π leaves the bit-string x unchanged, in which case [formula]. All such permutations π can be decomposed as a direct product of a permutation of the first k bits, and a permutation of the last n - k bits. This implies that

[formula]

We first calculate the sum over the group Sk  ×  Sn - k. Note that the representation Vλ, while irreducible over Sn, is not necessarily irreducible over Sk  ×  Sn - k, but may split into a direct sum of irreps. The following simple lemma, which can be proven using Schur's Lemma, shows that only the trivial irrep is of interest.

Let Vλ be an irreducible representation of a finite group G. Then

Each occurence of the trivial irrep in the decomposition of the representation Vλ over Sk  ×  Sn - k will thus give a contribution of k!(n - k)! to the sum; all other irreps will contribute nothing. This number of occurrences can be calculated using a special case of the Littlewood-Richardson rule known as Pieri's formula [\cite=fulton91].

Let μ be the diagram corresponding to the trivial irrep of Sk, for some k. Then, for any λ and ν, we define the Littlewood-Richardson number Nλμν as the number of ways that λ can be expanded to ν by adding k boxes to λ, under the constraint that at most one new box is added to each column. See Figure [\ref=fig:expand] for an illustration of this process, and note that Nλμν is always either 0 or 1 (though this does not remain true in the more general setting where μ can be arbitrary; then the rule is more complicated).

Littlewood-Richardson numbers are relevant because of the following theorem [\cite=fulton91].

Let μ be the partition (n - k). The multiplicity of the irrep [formula] in the restriction of the irrep Vν from Sn to Sk  ×  Sn - k is equal to Nλμν.

As we are only interested in expansions of the trivial irrep (k) by another trivial irrep (n - k), this multiplicity is particularly simple to calculate. Let ν be a partition of n, λ be the partition (k), and μ be the partition (n - k). Then, if ν has more than two parts, Nλμν  =  0. (This was expected anyway because each of the n subsystems we are dealing with has dimension 2.) If ν has two parts, express it as [formula]. Then, if [formula], Nλμν  =  0. Otherwise, Nλμν  =  1.

This deals with the sum; to finish the calculation, we need to find the dimension dλ. This can be evaluated using the famous hook-length formula [\cite=fulton91]. Let x be a box in a Young diagram. Then the hook-length h(x) is defined as the total number of boxes in the same row and to the right of x, plus the total number in the same column and below x, plus 1 (for x itself). See Figure [\ref=fig:hooklengths] for an illustration.

The hook-length formula states that

[formula]

As we only need calculate dλ for partitions [formula], this formula is particularly simple, and gives

[formula]

To sum up, we have, for [formula],

[formula]

where the last step is a binomial coefficient identity that can be verified directly. For [formula], by Pieri's formula the sum over Sk  ×  Sn - k is zero. This implies that Pr [null] = 0 in this case, and completes the proof.

Conclusion

We conclude that it is possible to compute symmetric functions of an n qubit state |x〉, even if a malicious adversary has applied an arbitrary local rotation and an arbitrary permutation to the state, even without any prior encoding of x. This is in (perhaps surprising) contrast to the fact that any individual bit of x cannot be retrieved.

Acknowledgements

This work was supported by the EC-FP6-STREP network QICS, and was partly carried out during a visit to the Perimeter Institute for Theoretical Physics. I would like to thank Aram Harrow, Richard Low and Tobias Osborne for helpful discussions on the subject of this work, and an anonymous referee for helpful comments which improved the paper.