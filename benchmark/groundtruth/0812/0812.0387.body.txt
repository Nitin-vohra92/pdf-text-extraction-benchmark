=1

Corollary

Delaunay Triangulations in Linear Time? (Part I)

This was originally part of a manuscript containing further material now in [\cite=b-cdts-09]. For the problem at hand, we found an algorithm avoiding the use of the history of the construnction [\cite=bm-dtotm-09]. This research was supported by the Deutsche Forschungsgemeinschaft within the European graduate program 'Combinatorics, Geometry, and Computation' (No. GRK 588/2) and by the Netherlands' Organisation for Scientific Research (NWO) under BRICKS/FOCUS project no. 642.065.503.

Chan and P atra scu [\cite=cp-pl-0x] [\cite=cp-vd-07] presented o(N log N) randomized algorithms for constructing Voronoi Diagrams of points in the plane (from which the Delaunay triangulation can be computed in linear time and vice-versa) under suitable models of computation. Here we present an O(N) randomized algorithm for the Delaunay triangulation in the plane in a different model. The algorithm is not restricted to two dimensions and it runs in linear expected time as long as the expected complexity of the Delaunay triangulation of a random sample of the input points is linear in the sample size. An example of linear complexity Delaunay triangulation are suitably sampled (d - 1)-dimensional polyhedra in [formula]. Our algorithm locates points by combining the history (i.e., the Delaunay tree [\cite=BT86] [\cite=bt-rcdt-93]) of a randomized incremental construction with a sequence of nearest-neighbor graph computations. For the nearest-neighbor graphs we use a recent result by Chan [\cite=c-wspd-08] that links well-separated pair decompositions to sorting. By the use of radix sort this results in a linear time algorithm for well-separated pair decompositions and as a consequence for nearest-neighbor graphs. We will use the same assumptions as Chan on the model of computation and the point set. The model of computation is a real-RAM with a constant-time restricted floor function that can be applied only if the resulting integer has O( log N) bits. Restricting the floor function avoids issues about creating an unreasonably powerful model of computation. The input point set should have polynomially bounded spread, i.e., the ratio of the largest and smallest point to point distance should be bounded by a polynomial in the size of the point set. But also other combinations of models of computation and sorting algorithms can be used, resulting in a optimal running time asymptotically bounded by the time needed for sorting (see [\cite=c-wspd-08] for details).

General Setup.

We construct the Delaunay triangulation of a finite point set [formula] by a randomized incremental construction using a history. The point location is accelerated by locating points at intermediate levels in the history instead of the top, see Algorithm [\ref=alg:nng]. Given an insertion order we group the points into rounds [formula] in accordance with the order, i.e., the points in Ri are in the insertion order before the points in Ri + 1 for 1  ≤  i  <  m. The rounds double in size, i.e., |R1| is constant, and |Ri + 1|  =  2|Ri| (with possibly the exception of the last round for which |Rm|  ≤  2Rm - 1). Let [formula] denote the points inserted in or before round j. Together with the history graph we store the Delaunay triangulations of the Sj. Note that the rounds are only used for facilitating the point location; the insertion order remains the same.

Point Location in a Round.

The points of the first round are located in the standard way using the history. At the beginning of round k (2  ≤  k  ≤  m) the points of the round Rk are located in the Delaunay triangulation of Sk - 1 using a family of sets [formula] (in every round a different family, thus more formally the family could be written as [formula]): Let Tk - 1: = Rk. We compute the nearest-neighbor graph of [formula]. For connected components of the nearest-neighbor graph without a vertex in Sk - 1 we include the first point (according to the insertion order) of the component in a set Tk - 2. We repeat the same procedure higher up in the history, i.e., we compute the nearest-neighbor graph of [formula], for each connected component without a vertex in Sk - 2 we include the first point in a set Tk - 3, and so on. We stop this process with the construction of T0 (or earlier with Tj if Tj - 1 is empty. For simplicity we describe the algorithm for the case that T0 is not empty). This yields a hierarchy of sets [formula].

Now we locate the points in T0 in [formula] by using the history, i.e., we use the history to find a conflicting simplex and then locally search for the simplex containing T0. For locating T1 we have the following situation: each connected component of the nearest-neighbor graph of [formula] either has a vertex in S1 or has a vertex in T0, thus each component has a vertex already located in [formula]. We traverse each component starting at an already located vertex, e.g., by a depth first search. During the traversal we locate the traversed points in [formula] by walking from an already located neighbor, i.e., we locally traverse the triangulation along the line segment between the two points. After locating the points in T1 in [formula] we locate them in [formula] by using the history, starting not at the top of the history but at the simplices of [formula] containing the points. By the same procedure we locate the points in T2 in [formula] and [formula], and so on, until we have located the points in Tk - 1  =  Rk in [formula]. Finally we insert the points of Rk into the Delaunay triangulation, where a new point is located using the history starting at the simplex of [formula] containing the point.

Analysis.

In the analysis of the algorithm we will assume that the expected complexity of the Delaunay triangulation of a random sample of the given point set is linear in the size of the sample. This is the case for points in the plane, but it is also a realistic assumption for points sampled from a (d - 1)-dimensional surface in [formula]. The analysis can be adapted to the case where this assumption does not hold, yielding additional terms depending on the complexity of the triangulation. In the following theorem we bound the run-time in terms of the cost of computing the nearest-neighbor graph. Note that this bound holds for the standard real-RAM model and with no assumption about the spread of the point set.

Let [formula] be a set of N points in general position such that the expected complexity of the Delaunay triangulation of a random sample R of P of size r is in O(r). Algorithm [\ref=alg:nng] constructs the Delaunay triangulation of P given in a random order in expected time [formula], where c is the (constant) size of the first round, m = ⌈ log 2(N / c  +  1)⌉, and F(k) denotes the time needed to compute the nearest-neighbor graph of a subset of P of size k.

We will analyse the cost of Step 3.3. Step 1 is only a conceptual step and Step 2 takes constant time. Step 3.1 takes constant time per loop (of Step 3). For a given k the nearest-neighbor graphs of [formula], [formula], , [formula] (or possibly fewer) are computed in Step 3.2. The size of these sets are bounded by [formula], where c = |R1| (except for k - 1  =  m - 1, where [formula]). Summing up over the loop of Step 3 this yields a cost of [formula] with m = ⌈ log 2(N / c) + 1⌉.

We now bound the cost of Step 3.3 for a given round (k > 1). The size of Rk is c2k - 1. It suffices to prove that the cost of Step 3.3 is in O(|Rk|). For this we construct sets [formula] such that any point of Rk has the same probability to be included into [formula] (0  ≤  i  ≤  k - 1). Let [formula]. We construct Ti' (k - 1 > i  ≥  0) as follows: First we add each point of Ti + 1' with probability 1 / 2. Second from each connected component in [formula] with a vertex in Si + 1 we add each point of Ti + 1 with probability 1 / 2. Note that the choices do not need to be independent. For all other connected components we add each point of Ti + 1 excluding the first and second (in the insertion order) with probability 1 / 2. Note that for a connected component all points have the same probability of being the first point of the component (in this case it is included in [formula]). Likewise all points have the same probability of being the second point (in this case it is not included), and likewise the same probability that it is one of the remaining points (in this case it is included with probability 1 / 2). Overall we get for all i that any point of Rk is included into [formula] with probability 2i - k + 1 and the expected size of [formula] is |Rk|2i - k + 1.

We first bound the cost of locating a point p∈Tj in [formula]. Since in the previous step we located p in [formula], we can locate p using the history starting at a conflicting simplex of p in [formula]. Since Sj + 1 is a random subset of P and the points of Sj + 1 were inserted in a random order, the expected cost of locating p would be O( log (|Sj + 1| / |Sj|)) = O(1) if p were a random point of Rk [\cite=d-rysa-92]. This is not the case, but for a random point of [formula] it would be the case. The cost of locating all points of Tj in [formula] is bounded by the cost of locating all points of [formula] in [formula] (knowing a conflict in [formula] for each point). The expected cost of this is in [formula].

This gives us the expected cost of locating one conflicting simplex for each point p∈Tj. We actually need to find the simplex in [formula] containing the point p. This can be done by locally searching all conflicting simplices, one of which contains the point. The cost of this is therefore proportional to the number of conflicts a point has with [formula]. The cost for all points in Tj can again be bounded by the total number of conflicts of [formula] with [formula] which is expected to be in 2j - k + 1O(|Rk|).

Second we bound the cost for locating the points of Tj + 1 in [formula]. For locating a point of Tj + 1, we traverse the connected components of [formula]. For each component we start at a point for which we know the location in [formula], i.e., a point from [formula]. Assume we traverse the edge between p and q where p is already located and q needs to be located. The point q is located by walking along the line segment pq, i.e., by traversing the Delaunay triangulation along pq. The cost corresponds to the number of intersected simplices. Any simplex intersected is either in conflict with p or with q, i.e., p or q lie in its circumsphere. If p∈Sj + 1 we additionally have the cost of searching for the d-simplices adjacent to p that is the first simplex on the walk.

Therefore the cost of the walk from p to q is bounded by the number of conflicts of q with simplices of [formula] and - depending on whether p is in Tj + 1 or Sj + 1 - by the number of conflicts of p or the number of faces at p. Any point can occur at most once as end point of a walk. Furthermore since the degree of [formula] is in any fixed dimension bounded by the kissing number [\cite=cs-splg-98], any point occurs only a constant times as starting point of a walk. Thus the total cost of walking is up to a constant factor bounded by the complexity of [formula] and the expected total number of conflicts of Tj + 1 with [formula]. By assumption the expected complexity of [formula] is linear in |Sj + 1| = (2j + 1 - 1)c. The expected number of conflicts of Tj + 1 with [formula] we again bound by the expected number of conflicts of Tj + 1' with [formula], which is O(2j - k + 2|Rk|). Therefore the total expected cost of the round Rk is in [formula]. Summing up over all rounds yields an expected linear cost.

We now use that the nearest-neighbor graph of a point set with bounded spread can be computed in linear time. Note that the condition on the complexity of the Delaunay triangulation always holds in the plane, thus the algorithm computes the Delaunay triangulation of points in the plane with bounded spread in linear expected time.

Let [formula] be a set of N points in general position with bounded spread such that the expected complexity of the Delaunay triangulation of a random sample R  ⊂  P of size r is in O(r). Algorithm [\ref=alg:nng] constructs the Delaunay triangulation of P given in a random order in linear expected time on a real-RAM with a constant-time floor function restricted to log N bits.

We would like to note that the analysis can be extended to the case where the Delaunay hierarchy [\cite=d-dh-02] is used instead of a history (the hierarchy is then built level by level) and also to the case of biased randomized insertion orders [\cite=acr-iccb-03] [\cite=k-ops-07].