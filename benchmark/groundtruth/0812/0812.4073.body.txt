=1

Multi-Level Algorithms for Modularity Clustering

Introduction

A graph clustering partitions the vertex set of a graph into disjoint subsets called clusters. Modularity was introduced by Newman and Girvan as formalization of the common requirement that the connections within graph clusters should be dense, and the connections between different graph clusters should be sparse [\cite=newman2004fae]. It is by far not the only quality measure for graph clusterings [\cite=Gaertler:2005] [\cite=Schaeffer:CSR2007], but one of the most widely used measures, and has been successfully applied for detecting meaningful groups in a wide variety of complex systems.

The problem of finding a clustering with maximum modularity for a given graph is NP-hard [\cite=BrandesEtAl:TKDE2008], and even recent exact algorithms scale only to graphs with a few hundred vertices [\cite=BrandesEtAl:TKDE2008] [\cite=agarwal2008mmg] [\cite=XuEtAl:EPJ2007]. In practice, modularity is almost exclusively optimized with heuristic algorithms. Like modularity itself, many of these heuristics have been proposed in the physics literature.

A particularly simple heuristic is the iterative merging of cluster pairs, starting from singleton clusters, and always choosing the merge that results in the largest modularity increase. This greedy coarsening can be efficiently implemented and produces reasonable clusterings [\cite=newman2004fad] [\cite=clauset2004vln], but was soon observed to be biased towards merging large clusters [\cite=danon2006esh] [\cite=wakita2007msn]. To remove this bias and obtain clusterings with even higher modularity, researchers suggested to replace modularity increase with other prioritizing criteria for potential merges [\cite=danon2006esh] [\cite=wakita2007msn], and to modify the purely greedy merge strategy [\cite=schuetz2008emo]. However, the numerous proposals have not been organized into a coherent design space, and the published evaluation results are largely incomparable due to the use of different (and often small) graph collections. Therefore, Section [\ref=s:coarsening] systematically describes major design alternatives for coarsening algorithms, including two new prioritizing criteria for merges, and Section [\ref=ss:ecoarsening] compares them experimentally.

The clusterings produced by coarsening heuristics can be improved with refinement algorithms, which iteratively move individual vertices between clusters [\cite=schuetz2008emo]. An obvious solution is greedy refinement, which always chooses the vertex move resulting in the largest increase of modularity. However, moving the vertices in arbitrary order (instead of always moving the best vertex) is much faster and not necessarily less effective, and adaptations of the classic Kernighan-Lin refinement [\cite=kernighan1970ehp] are not much slower and have some capability to escape local maxima. All of these algorithms can be applied not only to the original graph, but to any level of the coarsening hierarchy, by considering each cluster of the coarsening level as a single coarse vertex. This multi-level refinement is extremely effective for minimum cut partitioning problems [\cite=hendrickson1995mlp] [\cite=karypis1998fah], but has not previously been adapted to modularity clustering. Section [\ref=s:refinement] details the single-level and multi-level refinement heuristics, and Section [\ref=ss:erefinement] compares them experimentally. Because the effectiveness of (particularly multi-level) refinement may depend on the coarsening algorithm, Section [\ref=ss:ecombi] examines various combinations of coarsening and refinement heuristics.

Section [\ref=s:related] compares public implementations and benchmark results of modularity clustering heuristics, without a restriction to coarsening and refinement algorithms. While this is one of the most extensive comparisons in the literature, it is far from exhaustive, because implementations and sufficient experimental results have not been published for some proposed heuristics. The main purpose is to demonstrate that particular combinations of simple coarsening and multi-level refinement algorithms are (at least) competitive with the best available heuristics, and thus the results of the previous sections are indeed practically significant.

Graph Clusterings and Modularity

Graph Clusterings.

A graph (V,f) consist of a finite set V of vertices and a function [formula] that assigns a nonnegative edge weight to each vertex pair. For simplicity, graphs are assumed to be undirected, i.e., f(u,v)  =  f(v,u) for all u,v∈V. The degree deg (v) of a vertex v is the total weight [formula] of its edges. The degrees and weights are naturally generalized to sets of vertices, e.g., [formula]. Note that deg (V)  =  f(V,V).

A graph clustering [formula] partitions the vertex set V into disjoint non-empty subsets Ci.

Modularity.

Modularity is a quality measure for graph clusterings. It was originally introduced for graphs where the edge weights are either 0 or 1 [\cite=newman2004fae], and was later generalized to arbitrary edge weights [\cite=Newman:2004]. The modularity of a clustering [formula] is defined as

Intuitively, the first term is the actual fraction of intra-cluster edge weight. In itself, it is not a good measure of clustering quality, because it takes the maximum value 1 for the trivial clustering where one cluster contains all vertices. The second term specifies the expected fraction of intra-cluster edge weight in a null model where the end-vertices of [formula] edges are chosen at random, and the probability that an end-vertex of an edge attaches to a particular vertex v is [formula] [\cite=newman2006fcs]. In this null model, the edge weight f(u,v) between each vertex pair (u,v)∈V2 is binomially distributed with the expected value [formula].

It can be easily verified that merging two clusters C and D increases the modularity by

[formula]

and moving a vertex v from its current cluster C to another cluster D increases the modularity by

[formula]

Coarsening Algorithms

Greedy coarsening algorithms iteratively merge either one cluster pair, as detailed in the first subsection, or several disjoint cluster pairs, as detailed in the second subsection, and choose the merged cluster pairs according to certain priority criteria, which are discussed in the third subsection.

Single-Step Greedy.

The Single-Step Greedy algorithm starts with single-vertex clusters, and iteratively merges the cluster pair with the highest priority, until this merge would decrease the modularity.

Implementation and Runtime.

For the calculation of the priorities (see Section [\ref=ss:priority]) it is necessary to quickly retrieve the total edge weights between adjacent clusters. These total weights change locally with each merge and are thus stored in a dynamically coarsened graph where each cluster is represented by a single vertex. In each merge of two vertices u and v, the edge list of the vertex with fewer edges (say u) is merged into the edge list of the other vertex. Using the sorted double-linked edge lists proposed by Wakita and Tsurumi [\cite=wakita2007msn], this requires linear time in the list lengths. However, if some neighbor vertices of u are not neighbors of v, then one end-vertex of the edges to these neighbors changes from u to v, and the position of these edges in the neighbors' edge lists must be corrected to retain the sorting.

Let n be the number of clusters (initially the vertex count), m be the number of adjacent cluster pairs (edge count), and d be the height of the merge tree. Merging the edge lists of two clusters has linear runtime in the list lengths, and each edge participates in at most d such merges. Thus the worst-case runtime is [formula] for the merges and, given that the length of each edge list is at most n, [formula] for the position corrections. (The implementation of Clauset et al. [\cite=clauset2004vln] has better worst-case bounds, but experimental results in Section [\ref=s:experiment] indicate that it is not more efficient in practice.)

In order to quickly find the prioritized cluster pair for the next merge, a priority queue (max-heap) over the clusters and their current best partner is used. It is updated as described in [\cite=wakita2007msn]. In worst case the priority queue is updated with each merged edge, taking [formula] runtime.

Multi-Step Greedy.

To prevent extremely unbalanced cluster growth, Schuetz and Caflisch introduced Multi-Step Greedy coarsening, which iteratively merges the l  disjoint cluster pairs with the highest priority (unless the merge decreases the modularity) [\cite=schuetz2008emo]. Single-Step Greedy coarsening corresponds to the special case of l = 1 (at least conceptually, the implementation differs). To make the parameter l independent of the graph size, we specify it as percentage of the number of modularity-increasing cluster pairs, and call it merge fraction. The impact of the merge fraction on the effectiveness of Multi-Step Greedy coarsening will be examined experimentally in Section [\ref=ss:ecoarsening].

Implementation and Runtime.

The same basic data structures as in Single-Step Greedy are used. To iterate over the l cluster pairs in priority order, the edges are sorted once before entering the inner loop. This requires [formula] time in worst case. Alternative implementations optimized for very small merge fractions could use partial sorting with [formula] (but a larger constant factor). With merge fraction α the inner loop is repeated at least n / α times. However, if only few disjoint cluster pairs exist, as in some power-law graphs, up to n iterations may be necessary.

Merge Prioritizers.

A merge prioritizer assigns to each cluster pair (C,D) a real number called merge priority, and thereby determines the order in which the coarsening algorithms merge cluster pairs. Because the coarsening algorithms use only the order of the priorities, two prioritizers can be considered as equivalent if one can be transformed into the other by adding a constant or multiplying with a positive constant.

The Modularity Increase (MI) ΔQC,D resulting from the merge of the clusters C and D is an obvious and widely used merge prioritizer [\cite=newman2004fad] [\cite=clauset2004vln] [\cite=schuetz2008emo] [\cite=Ye2008aca].

The Weight Density (WD) is defined as [formula], and is equivalent to [formula] Its use as merge prioritizer has not yet been proposed in the literature, although Newman and Girvan originally introduced the modularity measure to formalize the requirement of intra-cluster density and inter-cluster sparsity [\cite=newman2004fae], and Reichardt and Bornholdt showed that clusterings with optimal modularity indeed fulfill this requirement [\cite=reichardt2006smc].

The Significance (Sig), another new merge prioritizer, is defined as [formula], and is thus a natural compromise between Modularity Increase and Weight Density. A further motivation is its relation to the (im)probability of the edge weight f(C,D) in the null model described in Section [\ref=ss:modularity]. Under this null model, both the expected value and the variance (at least for large deg (V)) of the edge weight between C and D are [formula], and the Significance is equivalent to the number of standard deviations that separate the actual edge weight from the expected edge weight.

Danon et al. (DA) observed that the Modularity Increase ΔQC,D tends to prioritize pairs of clusters with large degrees, and proposed the merge prioritizer [formula] to avoid this bias [\cite=danon2006esh]. It equals the Significance if [formula], and is another compromise between Modularity Increase and Weight Density.

Wakita and Tsurumi found that greedy coarsening by Modularity Increase tends to merge clusters of extremely uneven sizes [\cite=wakita2007msn]. In order to suppress unbalanced merges, they proposed the merge prioritizer [formula], where [formula] is either the number of vertices in C (prioritizer HN) or the number of other clusters to which C is connected by an edge of positive weight (prioritizer HE).

Other types of merge prioritizers are clearly possible. For example, vertex distances from random walks or eigenvectors of certain matrices have been successfully applied in several clustering algorithms (e.g., [\cite=pons2006ccl] [\cite=newman2006fcs] [\cite=donetti2004dnc]). However, preliminary experiments suggest that these relatively complicated and computationally expensive prioritizers may not be more effective than the simple prioritizers in this section [\cite=rotta2008mla].

Refinement Algorithms

Refinement algorithms perform a local search by iteratively moving individual vertices to different clusters (including newly created clusters) such that the modularity increases.

The first three subsections describe simple variants of greedy refinement, and the final subsection proposes, for the first time in modularity clustering, to apply refinement on more than one level of the coarsening hierarchy. Excluded from consideration are algorithms with several tunable parameters or explicit randomness, like simulated annealing [\cite=reichardt2006smc] [\cite=medus2005dcs] [\cite=massen2005icel] or extremal optimization [\cite=duch2005cdeo].

Complete Greedy.

Complete Greedy refinement repeatedly performs the best vertex move, until no further modularity-increasing vertex moves are possible. Here the best vertex move is a move with the largest modularity increase ΔQv  →  D over all vertices v and all target clusters D.

Implementation and Runtime.

Vertices are moved in constant time using a vector mapping vertices to their current cluster. To find the best move, the modularity changes ΔQv  →  D for all vertices v and clusters D adjacent to v (and a newly created cluster) need to be determined. For this purpose the algorithm iterates over the vertices. For each vertex v the summed weights f(v,D) are collected in one pass over its edges by using a search tree similar to [\cite=blondel_fast_2008]. Given f(v,D), the modularity change ΔQv  →  D can be computed in constant time (see Section [\ref=ss:modularity]). Therefore, to find the globally best move, all n vertices and m edges are visited once, and the weight of each edge is added in a search tree of at most n entries. Assuming [formula] moves yields a worst-case runtime of [formula].

Fast Greedy.

Fast Greedy refinement repeatedly iterates through all vertices and moves each vertex to its best cluster, until no improvement is found for any vertex. Finding the best move for a particular vertex is considerable cheaper than finding the globally best vertex move, as in Complete Greedy refinement; the question whether this improved efficiency comes at the cost of worse effectiveness will be addressed by an experiment in Section [\ref=ss:erefinement]. Fast Greedy refinement has been previously proposed by Schuetz and Caflisch [\cite=schuetz2008emo] and Ye et al. [\cite=Ye2008aca].

Implementation and Runtime.

The implementation is very similar to the previous algorithm. The worst-case time for one run of the inner loop is [formula], and a few runs usually suffice.

The order in which the inner loop visits the vertices seems to have little impact on the obtained modularity in practice; in our implementation, vertices are sorted by increasing number of edges.

Adapted Kernighan-Lin.

Kernighan-Lin refinement extends Complete Greedy refinement with a basic capability to escape local maxima. The algorithm was originally proposed by Kernighan and Lin for minimum cut partitioning [\cite=kernighan1970ehp], and was adapted to modularity clustering by Newman [\cite=newman2006mac] (though with a limitation to two clusters). In its inner loop, the algorithm iteratively performs the best vertex move, with the restriction that each vertex is moved only once, but without the restriction that each move must increase the modularity. After all vertices have been moved, the inner loop is restarted from the best found clustering. Preliminary experiments indicated that it is much more efficient and rarely less effective to abort the inner loop when the best found clustering has not improved in the last k: = 10 log 2|V| vertex moves [\cite=rotta2008mla].

Implementation and Runtime.

The implementation is largely straightforward; to improve efficiency, the current clustering is not copied unless the modularity begins to decrease. The worst case runtime is the same as for Complete Greedy, assuming that a few outer iterations suffice. In practice, Kernighan-Lin refinement takes somewhat longer, because it also performs modularity-decreasing moves.

Multi-Level Refinement.

The refinement algorithms in the previous subsections easily get stuck in suboptimal clusterings because they only move individual vertices. Even Kernighan-Lin refinement is unlikely to move a medium-sized group of densely interconnected vertices to another cluster, because this would require a series of sharply modularity-decreasing vertex moves. However, the vertex group may well have been merged into a single cluster at some stage of the coarsening, and a refinement algorithm can easily reassign the group if it moves entire clusters of this coarsening level, instead of individual vertices. This is the basic idea of multi-level refinement, which has already proved to be very effective for minimum cut partitioning problems [\cite=hendrickson1995mlp] [\cite=karypis1998fah].

The Multi-Level Clustering algorithm first executes a coarsening algorithm (for example, any algorithm from Section [\ref=s:coarsening]) and then, usually several times, a refinement algorithm (for example, any algorithm from the previous subsections). Intermediate results of the coarsening algorithm are recorded as coarsening levels whenever the number of clusters has decreased by a certain percentage, which is provided as a parameter called reduction factor. Each coarsening level is a graph whose vertices are the clusters at the respective state of coarsening. The refinement algorithm is applied to every coarsening level, from the coarsest level to the original graph. At the coarsest level, each vertex belongs to a separate cluster, and at the finer levels, the initial cluster membership of each vertex is copied from the corresponding vertex of the previous (coarser) level.

The conventional Single-Level refinement, which executes a refinement algorithm only on the original graph, is the special case of Multi-Level refinement with a reduction factor of 100%. While Multi-Level refinement, and more generally every decrease of the reduction factor, potentially produces better clusterings, it may be suspected to significantly increase the required runtime. However, this is not necessarily the case, because the additional coarsening levels are smaller than the original graph, and one cheap vertex move on a coarse graph can save many expensive vertex moves on a finer graph. The impact of the reduction factor on both effectiveness and efficiency is examined experimentally in Section [\ref=ss:erefinement].

Related Work.

Several recent algorithms for modularity clustering are related to Multi-Level refinement, but differ in crucial respects. Djidjev's method is (despite its name) not itself a multi-level algorithm, but a divisive method built on an existing multi-level algorithm for minimum cut partitioning [\cite=djidjev2006csd]. Blondel et al. use local search on multiple levels to coarsen graphs, but do not refine the results of the coarsening [\cite=blondel_fast_2008]. Ye et al.'s algorithm performs refinement on multiple coarsening levels, but only moves vertices of the original graph instead of coarse vertices (clusters) [\cite=Ye2008aca].

Implementation and Runtime.

With reduction factor α at most log 1 / (1 - α)(n) coarsening levels are generated. For each new level a graph homomorphism connecting it to the previous level is constructed and used to transfer weights and clusterings between levels. To decouple the Multi-Level Clustering algorithm from details of the coarsening algorithm, the coarse graph and its homomorphism is constructed from the clustering produced by the coarsening algorithm: The vertices of each cluster are connected to their cluster-vertex in [formula] time. For each edge the corresponding cluster-edge has to be found or added if not yet existing. This search is accelerated by processing all vertices of a cluster successively and using a search tree over the cluster-edges of the current cluster. Thus constructing and connecting all edges costs [formula] time.

Experiments

This section experimentally compares the effectiveness (achieved modularity) and efficiency (runtime) of the various heuristics presented in the previous sections.

Experimental Setup.

The heuristics were implemented in C++ and compiled with GCC 4.2.3. The implementations are available online at .

In order to compare the effectiveness of the heuristics, the arithmetic mean of the modularity over a fixed set of graphs is measured; higher means indicate more effective algorithms. (Thus only the relative values of the means are interpreted, the absolute values are not intended to be meaningful.) Generated graphs are not used because they are structurally very limited (e.g., in their vertex degree distribution), and do not necessarily permit generalizations to graphs from real applications. Instead the graph set contains 58 real-world graphs retrieved from various resources as listed in Appendix [\ref=app:graphs]. The available graphs were roughly classified by their application domain and graphs of diverse size that fairly represent all major domains were selected. In addition the collection includes commonly used benchmark graphs like Zachary's karate club network [\cite=zachary1977ifm]. The graphs range from a few to 75k vertices and 352k edges.

All runtimes were measured on a 3.00GHz Intel Pentium 4 processor with 1GB main memory. The time for reading the graph was excluded to avoid that it interferes with the aspects studied here.

Coarsening Algorithms.

Figure [\ref=fig:selector-mf] compares the effectiveness of the merge prioritizers for Single-Step Greedy coarsening (represented by a merge fraction of 0%) and Multi-Step Greedy coarsening with merge fractions of 2%, 5%, 10%, 20%, 50%, and 100%. No refinement was used. The runtime measured on the graph 'DIC28_main' is shown in Fig. [\ref=fig:selector-mf-runtime] and is typical for larger graphs.

Concerning the merge prioritizers, Wakita's HE and HN are much less effective than the others, and not more (usually even less) efficient. The lower effectiveness is also visible in Fig. [\ref=fig:extalg-mod-ml] for Wakita's original implementation.

Concerning the algorithms, Multi-Step Greedy is generally less effective and less efficient than the simpler Single-Step Greedy. Only for Modularity Increase, Multi-Step Greedy is faster and, for merge fractions of 2% and 5%, also slightly more effective, but still similar to Single-Step Greedy with Danon and Significance. Apparently the other merge prioritizers do not benefit from Multi-Step Greedy's tendency to balance cluster sizes because, unlike Modularity Increase, they have no strong bias towards merging large clusters.

Refinement Algorithms.

Figure [\ref=fig:reduction-meanmod] compares the effectiveness of the refinement algorithms for Single-Level refinement (reduction factor 100%) and Multi-Level refinement with reduction factors of 5%, 10%, 20%, and 50%. As coarsener Single-Step Greedy with the Significance prioritizer was chosen, because it proved to be effective and efficient in the previous subsection. The runtime measurements on 'DIC28_main' are shown in Fig. [\ref=fig:reduction-runtime-dic28] and the dependency of the runtime on the graph size is depicted in Fig. [\ref=fig:reduction-runtime].

Multi-Level refinement with a reduction factor of 50% turns out to be more effective than Single-Level refinement, and similarly efficient. Reduction factors below 50% do not considerably improve the modularity, but significantly increase the runtime for Fast Greedy.

Fast Greedy refinement is about as effective as Complete Greedy, and just slightly less effective than Kernighan-Lin, but much faster. It scales well with the graph size (see Fig. [\ref=fig:reduction-runtime]), while Complete Greedy and Kernighan-Lin become prohibitively expensive.

Combining Coarsening and Refinement.

Concerning Single-Level vs. Multi-Level refinement, Fig. [\ref=fig:selector2] shows that Multi-Level refinement is consistently more effective for all merge prioritizers, and thus confirms the results for the Significance prioritizer in Fig. [\ref=fig:reduction-meanmod].

Concerning Single-Step vs. Multi-Step Greedy coarsening, Fig. [\ref=fig:selector3] shows that for the best merge prioritizers, both are similarly effective with Multi-Level refinement, while Single-Step Greedy is more effective without refinement. Clearly, Multi-Level refinement benefits from the uniform cluster growth enforced by Multi-Step Greedy coarsening. Overall, Single-Step Greedy coarsening is still preferable because of its greater simplicity and efficiency.

Concerning the merge prioritizers, Figs. [\ref=fig:selector2] and [\ref=fig:selector3] show that Modularity Increase is only competitive without refinement (ignoring efficiency), and Weight Density is only competitive with Multi-Level refinement. Here Multi-Level refinement benefits from the bias of Weight Density towards balanced cluster growth, and suffers from the bias of Modularity Increase towards unbalanced cluster growth. Danon and Significance are effective with and without refinement.

Conclusions.

The best algorithm found in these experiments is Single-Step Greedy coarsening with Danon or Significance as merge prioritizer combined with Multi-Level Fast Greedy refinement (or Multi-Level Kernighan-Lin, if efficiency is no concern).

Interestingly, Single-Step Greedy refinement outperformed the recent and more complex Multi-Step Greedy (for the best merge prioritizers), the Danon and Significance merge prioritizers clearly outperformed the much more widely used Modularity Increase (especially with refinement, and considering efficiency) and Wakita's prioritizers, and the newly proposed Multi-Level refinement consistently outperformed the popular Single-Level refinement.

Related Algorithms

An exhaustive review and comparison of the numerous algorithms for modularity clustering is beyond the scope of this paper; the purpose of this section is to provide evidence that our recommended heuristic - Single-Step Greedy coarsening by Significance with Multi-Level Fast Greedy refinement ( SS+ML) - is competitive with the best existing methods.

Basic Approaches.

Algorithms for modularity clustering can be categorized into the following four types: Subdivision heuristics try to divide the network, for example by iteratively removing edges [\cite=newman2004fae] or by recursively splitting the graph using eigenvectors [\cite=newman2006mac]. Coarsening (or agglomeration) heuristics iteratively merge clusters starting from singletons. Cluster pairs can be selected based on random walks [\cite=pons2006ccl] [\cite=pujol2006dcs], increase of modularity [\cite=clauset2004vln] [\cite=schuetz2008emo] [\cite=Ye2008aca], or other criteria [\cite=wakita2007msn] [\cite=danon2006esh] [\cite=donetti2004dnc]. Local search heuristics move vertices between clusters, with Kernighan-Lin-style and greedy search being the most prominent examples. Other approaches include Tabu Search [\cite=arenas2008ascn], Extremal Optimization [\cite=duch2005cdeo], and Simulated Annealing [\cite=reichardt2006smc] [\cite=medus2005dcs] [\cite=massen2005icel]. Finally, mathematical programming approaches model modularity maximization as a linear or quadratic programming problem which can be solved with existing software packages [\cite=agarwal2008mmg] [\cite=BrandesEtAl:TKDE2008] [\cite=XuEtAl:EPJ2007].

Published Modularity Values.

Table [\ref=tab:pub_results] compares modularity values from various publications with the results of our heuristic SS+ML. Mathematical programming approaches consistently find better clusterings than SS+ML, though by a very small margin; however, they are computationally much more expensive and do not scale to large graphs [\cite=agarwal2008mmg] [\cite=XuEtAl:EPJ2007]. Compared to the best algorithms in the three other classes, the results of SS+ML are very competitive, and for large graphs significantly better.

Published Implementations.

In order to directly compare our heuristics with existing algorithms, a range of publicly available implementations was retrieved from authors' websites and through the igraph library of Csárdi and Nepusz [\cite=igraph2006]. Only a subset of the graph collection could be used as some implementations cannot process graphs with weighted edges or self-edges. The employed 23 graphs range from a few to 75k vertices and are marked with UW in Appendix [\ref=app:graphs]. In some of these graphs negligible differences in edge weights and small amounts of self-edges were removed.

The included coarsening heuristics are the fast greedy joining of Clauset et al. [\cite=clauset2004vln], the algorithms of Wakita and Tsurumi [\cite=wakita2007msn], the recent multi-step greedy algorithm of Schuetz and Caflisch [\cite=schuetz2008emo] (with parameter [formula], as recommended by Schuetz and Caflisch in [\cite=schuetz2008mga]), and the algorithm of Pons and Latapy [\cite=pons2006ccl] based on short random walks (here of length 4). The examined local search heuristics are simulated annealing of Reichardt and Bornholdt [\cite=reichardt2006smc] (here with at most 120 clusters) and the recent hierarchical algorithm of Blondel et al. [\cite=blondel_fast_2008].

Concerning the performance of the (approximately) reimplemented heuristics, the mean modularities from the published implementations are roughly reproduced or slightly improved by our implementations (Fig. [\ref=fig:extalg-mod-eqv]) - even for Schuetz and Caflisch, where the computation of the parameter l differs (see Section [\ref=ss:multistep]). Note that refinement is not available in the implementations of Wakita and Tsurumi and of Clauset et al., and is optional in the implementation of Schuetz and Caflisch.

Concerning the performance of our recommended heuristic, Single-Step Greedy coarsening by Significance with Multi-Level Fast Greedy refinement (SS-Sig+ML), only Reichardt and Bornholdt's implementation produces clusterings of similarly high modularity, but it is much slower, and only Blondel et al.'s implementation is faster, but it produces worse clusterings (Figs. [\ref=fig:extalg-mod-ml] and [\ref=fig:extalg-runtime]). Even the still simpler and faster variant with Single-Level refinement (SS-Sig+SL) produces competitive clusterings, notably in comparison with the recent algorithm of Schuetz and Caflisch which is more complex and requires parameter tuning (see Section [\ref=ss:multistep]).

Summary and Conclusion

Various coarsening and refinement heuristics for modularity clustering can be organized into a design space with four dimensions: merge fraction (including Single-Step and Multi-Step Greedy coarsening), merge prioritizer, refinement algorithm, and reduction factor (including Single-Level and Multi-Level refinement). In an experimental comparison of achieved modularities and runtimes, some widely used or rather complex design alternatives - for example, Multi-Step Greedy coarsening, merge prioritization by Modularity Increase, or Single-Level refinement - were outperformed by newly proposed or simpler alternatives - particularly Single-Step Greedy coarsening by Significance with Multi-Level Fast Greedy refinement. In a comparison with published implementations and benchmark results, this heuristic was more efficient than algorithms that achieved similar modularities, and achieved higher modularities than algorithms with similar or better efficiency.

The Benchmark Graph Collection

Table [\ref=tab:graphs] on the next page lists graphs used for the experiments. The graphs postfixed with '_main' just contain the largest connectivity component of the original graph. All graphs from the subset 'UW' were used without edge weights and self-edges for the experiments on published implementations. For each graph the source collection is named in the last column. Web addresses to these collections are listed in Table [\ref=tab:sources]. For information about the original authors please visit the respective websites.