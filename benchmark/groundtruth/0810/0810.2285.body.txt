truein

An elementary derivation of the Deutsch-Jozsa algorithm

Introduction

Some of the most exciting applications of modern quantum mechanics are in the field of quantum computing. As such it would be worthwhile to introduce the topic in undergraduate quantum mechanics classes, even only briefly. Although the basic idea of quantum computing is simple, to harness the power of the superposition principle to speed up calculations, the actual design of quantum algorithms is far from intuitive.

The simplest and among the most well-known is the Deutsch-Jozsa algorithm which we will describe in details below (introduced in Refs.[\cite=D1] and [\cite=D2] and subsequently improved in Ref.[\cite=D3]) . The basic idea of the algorithm is to show how, for a specific type of operator, treating the system quantum-mechanically and making a clever choice for the input quantum state allows one to gain information in fewer operations than would be possible with any classical system. This is of course the essence of the power of quantum computing but the beauty of the Deutsch-Jozsa algorithm is that it exhibits this power in the simple setting of a two dimensional Hilbert space and without requiring any other mathematical concept than basic linear algebra (as opposed to Shor's algorithm, for example, which involves quantum Fourier transforms). As such it is the ideal example of quantum computing for an introductory quantum mechanics class.

It is fairly straightforward to verify that the particular quantum superposition provided by the algorithm does indeed allow to gain information in fewer steps than would be possible classically and checking this, in itself, can be assigned as a homework problem. However, it is not obvious how one could have seen that this input quantum state is the right choice to start with. In other words, it is easy to check that the solution works but it is hard to see how one could have figured it out in the first place. After checking that the algorithm works, students therefore often ask: How did anyone ever come up with this solution? Of course, the discoverers of the algorithm had a lot of experience in quantum mechanics and are very clever, which is why they were able to find the solution. Indeed, even the standard presentation of the solution (presented below) involves several steps which are nontrivial and which usually leave the students feeling that they could never have thought of that by themselves.

From a pedagogical point of view it would be more interesting to have the students figure out the algorithm by themselves as opposed to simply applying it. The goal of this short article is to show how the problem can be posed in such a way that it can be solved by students taking an introductory quantum mechanics class and using none of the clever tricks involved in the standard presentation but only basic linear algebra.

In the first section we review the problem to be solved. In the following section we give the standard presentation of the Deutsch-Jozsa algorithm. In the last section we present a way to state the problem such that the algorithm can be "discovered" by the students using only simple algebra and a basic understanding of quantum mechanics. The solution is then presented.

The problem to be solved

Consider for now a classical bit whose states we will denoted by 0 or 1. In this section we consider only classical systems. Consider a function which acts on a single bit[\cite=foot1]. Let's define a constant function one which always returns the same value no matter what the input is. Clearly, there are two such constant functions: the one which always returns 0, which we will denote CI, and the one which always returns 1, denoted by CII.

In other words, we have that the action of CI on a bit is given by

[formula]

whereas

[formula]

Now we consider the so-called balanced functions, which are balanced in the sense that they may return 0 or 1 depending on their input. There are also two possible balanced functions. We will call the first one BI, with action

[formula]

The second balanced function, BII is simply the identity operator:

[formula]

Clearly, the balanced operators are invertible; given one of the two operator and a certain output one can determine uniquely what the input was. This is obviously not the case for the constant functions.

Another operation that is required before we can proceed is the exclusive OR (XOR) operation [formula] which is simply the addition of two bits (in base 2):

[formula]

Another way to think of XOR is as a parity operation. Indeed, if one assigns a positive parity to 0 and a negative parity to 1, the operation [formula] essentially computes the parity of the product ab.

Consider now an operator that takes two bits x and y as an input. The first bit, x, is used as a control bit and is therefore left unchanged. The second bit is replaced by

[formula]

where the function f is one of the four functions described above. We will represent such an operator by the symbol Ff where f is either BI, BII, CI or CII. We can therefore represent the operation of Ff on two bits by

[formula]

Note that the operators Ff are invertible; they are actually their own inverse. Indeed, if we apply any which one twice in a row we get

[formula]

where we have used that for any bit x we have [formula] and therefore [formula].

To consider a specific example, pick an operator with the function f being the first balanced function BI. If we feed to this operator the two classical bits x = 1,y = 1, the output will then be

[formula]

Now the problem to be solved can finally be stated. Imagine being provided one of the operators Ff but not being told which of the four functions it uses to calculate the output. Such an operator with f being unspecified will be called an oracle and will be represented by Of with the understanding that f is unknown. You may only feed it pairs of bits and examine the result coming out. The question to answer is the following: what is the minimum number of times the oracle must be run in order to determine with certainty if the function it uses is balanced or constant?

Of course, another obvious question would be to ask how many trials would be required in order to tell which of the four functions is being used, and we will get back to this point below, but this is not the question addressed by the Deutsch-Jozsa algorithm.

It is not hard to convince oneself that two trials are required in order to being able to tell if the function is constant or balanced. This will be obvious if we get back to our above explicit example where the input was (1,1) and the output was also (1,1). In our example we computed the output using f = BI but let's pretend that we are only given the input and the output and that we don't know what the function f is. What can we tell about f from this single run? The first bit is always left unchanged so we can't learn anything from it. The only information we have is from the second bit. We know that the function used by the oracle satisfies

[formula]

which implies

[formula]

This is the only information provided by the above test run. But there are two functions having this property: BI and CI. Therefore, given only that the input was (1,1) and the output (1,1), we can only say that the function is either BI or CI. To determine which is actually used, we would have to run a second trial. For example, feeding the state (0,1) will produce the output [\cite=foot2] (0,0) if the function is BI as in our above example but would have produced the output (0,1) if the function had been CI.

It is clear that running the oracle only once for some input (x,y) gives either the information f(x) = 1 or f(x) = 0. In either case, there are always two possible functions to choose from, one balanced and one constant. The oracle must be run a second time to pick which one.

The above conclusion is inescapable if the bits are classical. The magic of quantum computing is that if we allow the oracle to act on quantum bits (linear superposition of classical bits) it is possible to determine if the function is balanced or constant with a single run of the oracle (but one can't determine which of the two balanced or constant functions is being used). This can be done if one is clever about the choice of the two qubits being fed to the oracle. The determination of this clever choice of the input quantum state is what the Deutsch-Jozsa algorithm accomplishes. In the following section we review the standard presentation of the algorithm.

The Deutsch-Jozsa algorithm: standard presentation

Te Deutsch-Jozsa algorithm provides a clever choice of the two qubits to input in the oracle in order to determine if the function is constant or balanced with a single run. Instead of simply stating the answer we will try to provide the motivation for this choice.

This time the oracle takes as input a tensor product of two qubits and outputs another tensor product of two qubits. The effect of the oracle on a tensor product of the basis states is the following:

[formula]

A general input state may be written in the form [formula] with

[formula]

Since the oracle is a linear operator, we immediately obtain the result for the application to an arbitrary state to be (using Eq.([\ref=qub]) for the two kets)

[formula]

Note that in general this is not a tensor product of the control qubit |a〉 times some other ket, i.e. it cannot be written in the form [formula] for some ket |c〉. We therefore see that in general the control qubit |a〉 gets entangled with the second input qubit.

The first trick is to observe that one way to distinguish balanced and constant functions is to compute [formula]. Indeed, the result is

[formula]

if the function is constant and

[formula]

if the function is balanced, as can easily be verified.

At first, it seems as if using this will require running the oracle twice since the function apparently has to be applied twice (once on 0 and once on 1). But this is not necessary if one works with quantum bits at the condition that the function appears through a phase, as we will now show.

Schematically, we are trying to have a situation where a relative phase of the desired form will be generated between the two input bits |0〉 and |1〉. In other words we would like to find a qubit |b〉 which has the properties

[formula]

and

[formula]

As we will see below, it is not difficult to find a ket |b〉 that has those properties. But before presenting the (almost obvious) answer, let us first discuss why having such a state allows one to distinguish constant from balanced functions in only one step.

Assuming that we have a state |b〉 satisfying the above properties, applying the oracle to the product [formula] where |a〉 is an arbitrary qubit will give

[formula]

where have used ( - 1)- f(0)  =  ( - 1)f(0). As usual, the overall phase is unimportant.

Therefore, using that [formula] if the function is balanced (see Eq.([\ref=balanced])), the final result is simply (after discarding the overall phase)

[formula]

and if the function is constant, using f(0)  +  f(1) = 0, we simply get

[formula]

If we impose that the two possible outcomes are orthogonal so that they can be distinguished, we find that we must have |a1|2  -  |a2|2  =  0 which implies that a1 and a2 may only differ by a phase:

[formula]

Therefore, the normalized control qubit must be

[formula]

and the input state that must be fed to the oracle is

[formula]

with the ket |b〉 having the properties ([\ref=propa]) and ([\ref=propb]).

We have accomplished the goal we had set for ourselves: we have found an input state such that running the oracle only once will determine if the function is constant or balanced. Indeed, if the we use the above state as input, we simply have to project the output on the bra [formula]. If the result is one, the function used by the oracle is constant. If the result is zero, the function is balanced.

All this relies of course on finding a state |b〉 satisfying the properties ([\ref=propa]) and ([\ref=propb]). It is not difficult to guess what the answer is:

[formula]

Consider the case f(0) = 1 (so the function is either BI or CII ). Then we have

[formula]

which we may write as [formula].

It is easy to verify that if f(0) = 0 (so the function is either CI or BII), the state [formula] is left unchanged by applying Of so that we may still write the result as [formula]. The conclusion is therefore that for any of our four operators, we obtain

[formula]

with |b〉 chosen as in Eq. ([\ref=yy]).

It is easy to check also that for any operator, one finds

[formula]

So the state ([\ref=yy]) satisfies the relations ([\ref=propa]) and ([\ref=propb]).

Our final result is therefore that the input we must feed to the oracle is

[formula]

With this choice of input, the outputs corresponding to an oracle using a balanced function will be orthogonal to the output corresponding to an oracle using a constant function. As explained above, one can determine if the function is constant or balanced by projecting on the bra [formula].

An elementary derivation

The presentation given in the previous section emphasizes the key ideas on which the algorithm is based but students (and non-students alike!) may feel that it relies on too many clever guesses. We will present now the problem in such a way that it can be solved "mechanically" using only basic linear algebra and none of the clever tricks needed in the previous derivation. It is of course more algebra intensive and may be considered less satisfying from a conceptual point of view by some. But it has the pedagogical advantage that it can be solved by students with only a basic knowledge of quantum mechanics who will therefore have the satisfaction of having "rediscovered" the algorithm by themselves.

We will represent the tensor products of two qubits as four component column vectors using the convention

[formula]

The first step is to represent the four possible operators Ff as four by four matrices. It is now easy to construct explicit representations of those operators since we know how they act on each of the four basis states. For example,

[formula]

and so on. One finds

[formula]

Now we are ready to state the problem in such a way that students in an introductory quantum mechanics class could solve without any subtle trick, only simple algebra, and therefore recover the solution provided by the Deutsch-Jozsa algorithm.

Let's consider an arbitrary input state

[formula]

with

[formula]

The goal is to choose the coefficients in such a way that, given an oracle, we will be able to tell with only one application whether the function used by the operator is balanced or constant. The way to obtain this is clear: we must choose the coefficients of our input state such that if we run it through each of the four operators, the output of each balanced operator must be orthogonal to the output of both constant operators. This gives four conditions which we can schematically write as

[formula]

This is all there is to it. If one can find coefficients satisfying these four conditions (and of course we know that there is at least one solution), the problem has been solved.

Equation ([\ref=first]) yields the following condition:

[formula]

whereas equation ([\ref=second]) gives

[formula]

The third and fourth equations, ([\ref=third]) and ([\ref=fourth]), end up being exactly the same as the two above. So we need to solve those two equations with the constraint that the state be normalized, equation([\ref=normal]). To simplify the problem, one may at first try to see if there exists a solution with all coefficients real. Our set of equations is therefore

[formula]

If we isolate c23  +  c24 from equation([\ref=one]) and use this in equation ([\ref=three]), we obtain

[formula]

which gives

[formula]

Similarly, if we isolate c21  +  c22 from ([\ref=two]) and put this in equation ([\ref=three]), we get

[formula]

First case: c1  =  c2 + 1 and c3  =  c4 + 1

Let's first pick the cases

[formula]

If we plug those values in the normalization condition ([\ref=three]), we get a quadratic formula for c2 in terms of c4:

[formula]

If we impose that c2 be real, the discriminant must be larger of equal to zero:

[formula]

but it's trivial to show that the only solution is for a strict equality (in other words, this describes a parabola with its apex on the horizontal axis) which is solved by

[formula]

Putting this back in equations ([\ref=cthree]), ([\ref=yaya]), ([\ref=yoyo]) and ([\ref=quad]), we final get

[formula]

as our first solution. Written as a tensor product of two kets, this corresponds to

[formula]

which is indeed a special case of equation([\ref=finalresult]) with θ  =  0.

Second case: c1  =  c2 + 1 and c3  =  c4 - 1

In that case, one finds obviously the same quadratic equation as before except that with the opposite sign for the term linear in c4:

[formula]

Again, imposing c2 to be real leads to solving

[formula]

which, again, turns out to have a unique solution, corresponding to a strict equality. The result this time is [formula] which yields

[formula]

giving the state

[formula]

which is indeed the other solution of equation([\ref=finalresult]) with real coefficients, ı.e. θ  =  π.

The other two cases

We still have to consider the cases c1  =  c2 - 1 and c3  =  c4  ±  1. As one would expect, these two cases give the same two results we obtained above excepted for an overall irrelevant factor of - 1.

A Bonus

One obvious question that comes to mind when learning about the Deutsch-Jozsa algorithm is whether it would be possible to not only determine if the oracle uses a constant or balanced function in only one step but in addition to determine uniquely which of the four functions is used. Since the standard presentation relies on several clever guesses, one might wonder if more clever tricks could be used to identify uniquely the function. The answer is easy to find using our "mechanical" approach. The question becomes whether it is possible in addition to the conditions ([\ref=first]) - ([\ref=fourth]) to fulfill the extra constraints

[formula]

which both give (going back to complex coefficients for now in order to be more general):

[formula]

which may be written as

[formula]

But this condition is clearly inconsistent with equations ([\ref=fcond]) and ([\ref=scond]) which combined imply

[formula]

Therefore we see that it would be impossible to determine uniquely the function used by the oracle in a single step.

Conclusion

We have shown how it is possible to formulate the problem solved by the Deutsch-Jozsa algorithm in such a way that the solution can be found using only basic concepts of quantum mechanics and simple linear algebra. This brings the rediscovery of the algorithm within the reach of students taking an introductory class in quantum mechanics as part of an assignment set, for example.