Propositional Theories are Strongly Equivalent to Logic Programs

Note: This article has been accepted for publication in Theory and Practice of Logic Programming, © Cambridge University Press.

Introduction

One of the most interesting consequences from research in declarative semantics for Logic Programming (LP) has probably been the progressive increase in expressiveness that the field has experienced over the years. A clear example of this trend is the case of the stable models (or answer sets) semantics [\cite=Gel88], which meant the first satisfactory treatment of default negation, and whose simplicity directly allowed new extensions like the use of disjunction [\cite=Gel91] and negation [\cite=Lif92] [\cite=Ino98] in the rule heads. In one of the most general formalizations [\cite=Lif99d] of answer sets, logic programs consist of rules whose head and body are nested expressions, that is, propositional formulas without the connectives for implication and equivalence. The intuitive behavior of these nested expressions is well understood: in fact, it is quite analogous to the way in which we nest operators in Prolog. To put an example of their utility, a set of rules like:

[formula]

can be "packed" into the single rule with nested expressions:

[formula]

In [\cite=Lif99d], it was also shown that these rules with nested expressions can always be unfolded back into usual program rules (that allow disjunction and negation in the head) and, moreover, that this replacement can be done locally, regardless of the context (this last property of the transformation has the name of strong equivalence).

In view of a commonly used abbreviation (see section 2.2), nested logic programs allow a free use of all the usual connectives for logic programs, excepting for implication, the only one that cannot be nested. This last syntactic restriction has been eventually removed thanks to the result established in [\cite=Lif01]. In that work, it was shown that the answer sets semantics is further generalized by Equilibrium Logic [\cite=Pea97], which just deals with arbitrary propositional theories, imposing a selection criterion on their models under the intermediate logic of here-and-there [\cite=Hey30]. As a result, theories containing, for instance, a rule in the scope of a disjunction:

[formula]

or a rule as body of other rule:

[formula]

have now an interpretation in terms of answer sets. Although from a purely logical point of view, ruling out syntactic restrictions is a clear advantage, from the LP viewpoint one may wonder, however, what the practical interest of dealing with arbitrary formulas is. A recent example of their utility has been provided in [\cite=Fer05b], where nonmonotone aggregates are expressed using rules as part of a body rule. To give an example, according to [\cite=Fer05b], the following rule with an aggregate in the body:

[formula]

is translated as ([\ref=nest-impl]).

Despite of their interest, the intuition on how arbitrary theories may behave as "programs" was still far from obvious. Until now, we missed a formal connection with the usual rule format of pairs of head and body. Furthermore, we did not even know whether they provide a real increase in expressiveness, or perhaps they can always be translated instead into a strongly equivalent program (as in the case of nested expressions). In this paper we show that, in fact, the latter happens to be the case. In other words, the main result states that:

every propositional theory is strongly equivalent to a logic program.

From an LP reading, this result is pointing out that any generic propositional theory can be seen as "shorthand" for a logic program. Furthermore, the transformation from a propositional theory to a logic program is modular, i.e., it can be done formula by formula. For instance, formula ([\ref=nest-impl]) inside any theory can be simply replaced by the rules:

[formula]

and similarly ([\ref=or-rule]) can be replaced by:

[formula]

Another possible reading of the main result is that the form of logic programs is a kind of normal form for arbitrary formulas from the point of view of Equilibrium Logic.

The main result is independently proven in two ways: (1) with a syntactic recursive transformation, and (2) with a method that builds a strongly equivalent program starting from the countermodels (in the logic of here-and-there) of the propositional theory. Presenting the two proofs is interesting for several reasons. First, we get in this way an interesting analogy with the two ways of transforming a formula into CNF in classical logic: using a syntatic transformation or building the formula from its countermodels. Second, both proofs may provide technical tools for achieving other interesting results, as we explain later in the conclusions.

The rest of the paper is organized as follows. Section [\ref=sec:prelim] contains the preliminaries, with brief reviews of the logic of here-and-there and of answer sets semantics. In Section [\ref=sec:recurs] we present the first proof of the main result, based on the recursive syntactic transformation, whereas Section [\ref=sec:nonnested] contains the second proof, which builds a program from the here-and-there countermodels of the original theory. In Section [\ref=sec:nf] we further explore the analogies to classical logic, and obtain a disjunctive normal form based on the here-and-there models.

Preliminaries

Before introducing the logic of here-and-there, a small remark about notation. We assume that we handle a set of atoms Σ called the propositional signature. We will use letters [formula] to denote propositional interpretations in classical logic, represented here as sets of atoms, that is, subsets of Σ. For any propositional formula F, we adopt the usual notation [formula] to stand for X satisfies F under classical logic.

Logic of here-and-there

The logic of here-and-there was originally defined in [\cite=Hey30]. A propositional formula is any combination of atoms in Σ with connectives [formula] (false), [formula], [formula], and →  . We also define the abbreviations:

[formula]

As usual, a propositional theory is a (possibly infinite) set of propositional formulas.

The semantics of the logic of here-and-there is defined as follows. An interpretation is a pair (X,Y) of sets of atoms (respectively called "here" and "there") such that X  ⊆  Y. Intuitively, atoms in X are considered to be true, atoms not in Y are considered to be false, and the rest (Y - X) are thought to be undefined. We say that an interpretation (X,Y) is total when X = Y (no undefined atoms).

Although we use the same symbol '[formula]' for satisfaction in classical logic and the logic of here-and-there, ambiguity is avoided in view of the difference in the form of the interpretation on the left. In this way, the last line of Definition [\ref=def:satisf] is referring to classical satisfaction for [formula]. As usual, an interpretation is a model of a theory T if it satisfies all the formulas in T. Two formulas (theories) are equivalent if they have the same models.

As a first immediate observation about Definition [\ref=def:satisf], note that when the interpretation is total (X=Y), [formula] simply collapses into classical satisfaction [formula]. Another interesting property we will use later is that truth in the "here" component implies truth in the "there" component:

When dealing with countermodels, this property can be rephrased as: if (Y,Y) is a total countermodel of T, then any (X,Y) is also a countermodel of T. Besides, using the definition of [formula] as [formula], it also allows us to obtain the following characterization of satisfaction for negated formulas:

Axiomatically, the logic of here-and-there is intermediate between intuitionistic and classical logic. Recall that a natural deduction system for intuitionistic logic can be obtained from the corresponding classical system [\cite=bib93] by dropping the law of the excluded middle

[formula]

from the list of postulates. The logic of here-and-there, on the other hand, is the result of replacing the excluded middle in the classical system with the weaker axiom schema [\cite=DeJ03]:

[formula]

In addition to all intuitionistically provable formulas, the set of theorems of the logic of here-and-there includes, for instance, the weak law of the excluded middle

[formula]

and De Morgan's law

[formula]

(the dual law can be proved even intuitionistically).

The logic of here-and-there differs from intuitionistic logic also as far as minimal adequate sets of connectives are concerned. In fact, a disjunction

[formula]

is equivalent [\cite=Luk38], in the logic of here-and-there, to

[formula]

Logic programs

The set of logic programs can be defined as a subset of propositional formulas as follows. A nested expression is any propositional formula not containing implications of the form F  →  G with [formula] (i.e., negations and [formula] are allowed). A rule r is a formula of the form F  →  G where F and G are nested expressions. The head and the body of r are respectively defined as head(r) = G and body(r) = F. When convenient, we will implicitly consider any nested expression G as the rule [formula].

As usual, a literal is any atom a or its negation [formula]. A rule is said to be nonnested when it has the form:

[formula]

(0  ≤  m  ≤  n) where [formula] are literals. An empty conjunction (m = 0) is understood as the formula [formula] and analogously, an empty disjunction (n = m) is represented as [formula].

A (logic) program is a propositional theory consisting of rules; a program is nonnested when all its rules are nonnested.

The usual definition of the answer sets ( stable models) of a logic program Π is given in terms of the minimal models of a reduct program ΠX constructed from Π and a given interpretation X. The original answer sets semantics was defined in [\cite=Gel88] and [\cite=Gel91] for special cases of nonnested programs, and extended in [\cite=Lif99d] for programs with nested expressions. However, these definitions were later subsumed by a general logical encoding called Equilibrium Logic [\cite=Pea97], which allows considering answer sets (or equilibrium models) for arbitrary propositional theories as a particular type of selected models in the logic of here-and-there:

An alternative, reduct-based description of equilibrium models of arbitrary propositional theory was recently obtained in [\cite=Fer05b].

Apart from constituting a monotonic framework in which answer sets can be defined, the logic of here-and-there further satisfies an interesting property: it allows capturing the concept of strong equivalence of theories. Two theories T1 and T2 are strongly equivalent if, for any theory T, [formula] and [formula] have the same answer sets. The main result in [\cite=Lif01] asserts that this condition holds iff T1 and T2 are equivalent in the logic of here-and-there.

Our main result can be enunciated now as the following theorem:

Every propositional theory (of Equilibrium Logic) is strongly equivalent to a logic program. [formula]

Proving Theorem [\ref=th:gen] by syntactic transformation

In this proof of Theorem [\ref=th:gen], we identify every finite program with the conjunction of its rules. We also need a few lemmas.

For any formulas F,G and K,

[formula]

is equivalent to

[formula]

in the logic of here-and-there.

In the proof of the implication from ([\ref=f2]) to ([\ref=f1]), we assume F  →  G, and we want to prove K. We consider the three cases K, F and [formula] from the last formula of ([\ref=f2]). The first case is trivial. If F then G, and if [formula] then [formula] from the hypothesis F  →  G. In both cases, the antecedent of the implication in ([\ref=f2]) is true, so we can conclude K as well.

Now we assume ([\ref=f1]) and we want to derive each formula of ([\ref=f2]). For the first one, we also assume [formula], and we want to derive K. It is sufficient to notice that both G and [formula] make the antecedent of ([\ref=f1]) -- and consequently K -- true. To prove the second formula of ([\ref=f2]), we consider the axiom ([\ref=weakmiddle]). The claim is clearly proven in the cases F and [formula]. In the remaining case, we obtain K by modus ponens on F  →  G and ([\ref=f1]).

The implication of two finite programs is equivalent to a finite program.

We shall prove that the implication of two programs Π1  →  Π2 is equivalent to a program, by strong induction on the number of rules of Π1. If Π1 is empty (i.e., it is [formula]) then Π1  →  Π2 is clearly equivalent to Π2. If Π1 consists of a single rule F  →  G then It remains to notice that each conjunctive term (F  →  G)  →  (H  →  K) is equivalent to the conjunction of two rules. Indeed, by Lemma [\ref=specialeq],

It remains to consider the case when Π1 contains more than one rule. In this case, Π1 can be broken into two programs Π'1 and Π'2 with |Π'1|  ≤  |Π''1| < |Π1|. Then, since

[formula]

the assertion follows by applying the induction hypothesis twice.

It is sufficient to prove that any theory consisting of a single formula is equivalent to a finite program, by structural induction. We also assume that such a formula contains atoms

and connectives [formula], →   and [formula] only (all the other connectives can be eliminated). Clearly, every atom and the connective [formula] are programs. For formulas of the form [formula] and F  →  G, we assume, as induction hypothesis, that there are two finite programs equivalent to F and G respectively. Clearly, [formula] is equivalent to the union of such two programs. The existence of a finite program equivalent to F  →  G follows from the induction hypothesis and Lemma [\ref=lemma:gen].

To understand how an arbitrary propositional theory is converted into a logic program, consider formula ([\ref=or-rule]) as a logic program. First of all, we need to remove the disjunction, so we write it as

[formula]

Then we convert each subformula that is not a logic program into a logic program bottom-up. Lemma [\ref=lemma:gen] shows how each subformula can be converted, but simplifications or other transformations can also be applied. For instance, by Lemma [\ref=specialeq], the subformula r  →  (q  →  p) is converted into

[formula]

which can be equivalently rewritten as

[formula]

Consequently, the first conjunctive term of ([\ref=ex1]) becomes

[formula]

this formula, by Lemma [\ref=lemma:gen] again, can be rewritten as

[formula]

which can be simplified into

[formula]

With similar steps, we can rewrite the second conjunctive term of ([\ref=ex1]) as a logic program. As ([\ref=ex1]) becomes the conjunction of two programs, it becames a program itself.

Proving Theorem [\ref=th:gen] by using countermodels

The main idea of this technique is to start from the countermodels (under the logic of here-and-there) of some propositional theory T with a finite signature and construct a logic program, call it Π(T), which has exactly the same set of countermodels. We can think about the construction of Π(T) as a process where we start with an empty program, which would have as models all the possible interpretations, and go adding a rule per each model we want to remove. Note that, since there can only be a finite number of models and countermodels for a finite signature, Π(T) is finite even if T is infinite. In the case of an infinite signature for T, we can define Π(T) as the union of Π({F}) (computed on the finite set of atoms that occur in F) for each F∈T. The form of each rule in Π(T) is defined as follows.

For instance, if Σ  =  {p,q,r} then r{q},{p,q} is

[formula]

When the interpretation is total, the head (Y,Y) of rY,Y is empty, leading to the constraint:

[formula]

For instance, with Σ  =  {p,q,r}, r{q},{q} is

[formula]

From the definition of satisfaction in the logic of here-and-there, it is not difficult to see that (X,Y) is always a countermodel of rX,Y. Moreover, when X  ⊂  Y, this is indeed the only countermodel. When X = Y, however, Property [\ref=prop1] may lead to additional countermodels, as reflected by the following proposition:

Given any interpretation (X,Y), an interpretation (X',Y') is a countermodel of rX,Y iff

Y' = Y,             if X = Y, and

X' = X, Y' = Y   otherwise.

To prove this result, the following lemma will be particularly useful:

Let (X,Y) and (X',Y') be a pair of interpretations. Then,

[formula]

Note first that X'  ⊆  Y' trivially follows from the form of interpretations. We have that [formula] iff

[formula]

By Property [\ref=prop2], we can rewrite this condition as

[formula]

and then as

[formula]

This is clearly equivalent to X  ⊆  X' and Y'  ⊆  Y.

If X = Y then [formula] so that rX,Y can be rewritten as [formula]. Consequently, by Property [\ref=prop2], the countermodels of rX,Y are the interpretations (X',Y') such that Y' satisfies body(rX,Y) in classical logic. It remains to notice that, in this case, body(rX,Y) is the conjunction of all literals classically satisfied by Y, and so, this guarantees Y' = Y.

If X  ≠  Y, we must have X  ⊂  Y, by the form of interpretations. We show first that (X,Y) is not model of rX,Y. To this aim, it suffices to show that [formula] but [formula]. The satisfaction of the body trivially follows from Lemma [\ref=lem:bodyrI] (take X' = X and Y' = Y). For the head, take the disjunction [formula] in head(rX,Y) for each a∈Y - X. Since [formula] we get [formula] whereas since a∈Y, [formula] and, by Property [\ref=prop2], [formula].

Now, it remains to prove that any interpretation (X',Y') different from (X,Y) is a model of rX,Y. Note first that as Y - X is not empty, rX,Y is a tautology in classical logic, since its head contains at least a disjunction like [formula]. Therefore, [formula] and we just have to show that [formula] whenever [formula]. If we assume the latter, from Lemma [\ref=lem:bodyrI] we conclude X  ⊆  X'  ⊆  Y'  ⊆  Y, but as (X',Y') is different from (X,Y) then either X  ⊂  X' or Y'  ⊂  Y. Assume first that there exists some atom d∈X' - X. Since X'  ⊆  Y, we get d∈Y - X, and so d is one of the atoms a in the head of rX,Y. As d∈X', we have [formula] and so [formula]. On the other hand, if we assume that there exists some d∈Y - Y', as X  ⊆  Y', we conclude d∈Y - X and so, d is again one of the atoms in head(rX,Y). Now, as [formula], by Property [\ref=prop2], [formula] and [formula].

A set S of interpretations is total-closed if given any total (Y,Y)∈S then also (X,Y)∈S for any X  ⊆  Y. Clearly, a theory has a total-closed set of countermodels by Property [\ref=prop1]. Then the main theorem immediately follows from the following theorem.

Each total-closed set S of interpretations is the set of countermodels of a nonnested logic program:

[formula]

Any interpretation (X,Y) is a countermodel of rX,Y by Proposition [\ref=prop:cm], so every element of S is a countermodel of Π(S). Now take any countermodel (X,Y) of Π(S). By construction of Π(S) and Proposition [\ref=prop:cm] this means that either rX,Y or rY,Y belongs to Π(S). Consequently, either (X,Y) or (Y,Y) is element of S. Since S is total-closed, we conclude that (X,Y)∈S.

For instance, consider formula ([\ref=or-rule]). As its 6 countermodels are

[formula]

it is strongly equivalent to the 6 rules

[formula]

The one-to-one correspondence between total-closed sets of intepretations and the "classes" of strongly equivalent programs shown by Theorem [\ref=th:cm] can be used to count the number of such classes.

The number of different logic programs (modulo strong equivalence) that can be built for a finite signature of n atoms is:

[formula]

We need to count the number of total-closed sets S of interpretations. For any S, let SY be the subset of S consisting of the elements of the form (X,Y). Clearly each SY is independent from SY' if [formula], so the number of values of S is the product of the number of values of SY for each Y  ⊆  Σ. If [formula] then SY can independently contain or not each term of the form (X,Y) where X is a proper subset of Y. There are 2|Y| - 1 of such subsets giving 22|Y| - 1 total combinations. On the other hand, when (Y,Y)∈S, SY is completely determined as {(X,Y) | X  ⊆  Y}, since S is total-closed. Consequently the total number of values for S is

[formula]

The final result is obtained by grouping all sets Y with the same cardinality, and by noticing that the sets Y of size i are [formula].

Normal Forms

The reader may have noticed that Theorem [\ref=th:cm] seems, in principle, stronger than the original claim: we know now that any theory is strongly equivalent to a nonnested logic program. Nevertheless, this was also implicitly asserted by Theorem [\ref=th:gen], since as we had seen, a nested program can always be transformed into a nonnested one under strong equivalence [\cite=Lif99d]. Thus, both proofs actually point out that nonnested logic programs act as a kind of normal form for the logic of here-and-there. Furthermore, they show a strong analogy to CNF in classical logic: we can understand the program as a conjunction of nonnested rules which, in their turn, are seen as clauses. The method in Section [\ref=sec:nonnested] is then completely analogous to the construction of the classical CNF of a formula starting from its countermodels. In both cases, we build a rule/clause per each countermodel, and this clause refers to all the atoms of the signature.

In classical logic, however, we know that the construction of CNF from the theory countermodels is completely dual to the construction of DNF from its models. So, the following question arises immediately: is there some kind of disjunctive normal form for the logic of here-and-there that can be built starting from the theory models? The answer is affirmative, as we show next.

For instance, if Σ  =  {p,q,r} then c{q},{p,q} is

[formula]

The interesting properties of cX,Y are stated in the next Peoposition and Theorem.

The only interpretations that satisfy cX,Y are (X,Y) and (Y,Y).

Consider the following formulas c'X,Y and c''X,Y:

[formula]

Clearly, [formula]. We are going to see for which conditions the three terms body(rX,Y), c'X,Y and c''X,Y are satisfied by an interpretation (X',Y'). Each formula [formula] in c'X,Y is satisfied by (X',Y') iff [formula] by Property [\ref=prop2]. That means that [formula] iff Y - X  ⊆  Y', or, equivalently, iff [formula]. On the other hand, by Lemma [\ref=lem:bodyrI], [formula] iff X  ⊆  X'  ⊆  Y'  ⊆  Y. Notice that if X  ⊆  Y' then [formula]. Consequently, [formula] iff

[formula]

That means that the only models for cX,Y are the ones of the form (X',Y) with X  ⊆  X'  ⊆  Y, that satisfy c''X,Y. Since Y contains all the consequents of the implications of c''X,Y, then [formula]. If we consider that X doesn't contain any of the antecedents, then [formula], and also [formula] by Property [\ref=prop1]. It remains to show that if X  ⊂  X'  ⊂  Y then [formula]. This is immediate, since c''X,Y contains an implication d  →  e with d∈X' and [formula].

Let T be a theory over a finite signature and let F(T) denote the formula constructed from the models of T:

[formula]

Then T is equivalent to F(T) under the logic of here-and-there.

Take any model (X,Y) of T. Then, cX,Y is a disjunctive term in F(T). Since [formula] by Proposition [\ref=lemmac], we can conclude that [formula]. Now take any model (X,Y) of F(T). That means that, by Proposition [\ref=lemmac], (X,Y) satisfies some disjunctive term cX',Y of F(T), where

X = X', if X  ⊂  Y, and

X'  ⊆  Y, if X = Y.

We know that [formula] by construction of F(T). Consequently, if X  ⊂  Y then (X,Y) is a model of T because (X',Y) = (X,Y). For the case X = Y, it is sufficient to notice that (X,Y) = (Y,Y), and that [formula] implies [formula] by Property [\ref=prop1].

For instance, consider formula ([\ref=or-rule]). As its 21 models are

[formula]

it is strongly equivalent to the disjunction of

[formula]

As a final remark, note that F(T) is a disjunction of clauses cX,Y which are in their turn conjunctions of expressions of a very restricted type: each one may involve negation, implications, and (at most two) atoms, but no conjunction or disjunction. It must be said, however, that we still ignore whether F(T) may have any practical interest at all for computing answer sets.

Conclusions

We have shown that when we consider answer sets for arbitrary propositional theories (that is, Equilibrium Logic) we actually obtain the same expressiveness than when we just deal with disjunctive programs that allow negation in the head. To this aim, we proved that for any propositional theory, there always exists a strongly equivalent logic program, i.e., a program that may safely replace the original theory in terms of answer sets, even in the context of additional information. In fact, to be precise, our result shows that disjunctive logic programs (with negation in the head) constitute a conjunctive normal form for the monotonic basis of Equilibrium Logic, the intermediate logic of here-and-there.

We actually provided two different proofs for this result: one consisting in a recursive syntactic transformation, and a second one that deals with countermodels of the propositional theory in the logic of here-and-there. The reason for presenting the two proofs is that, in both cases, they provide technical tools for obtaining additional results. For instance, the proof based on the recursive transformation can be adapted to generalize the Completion Lemma for logic programs from [\cite=Fer05c] to the case of propositional theories: the new statement of the lemma is almost as general as the statement from [\cite=Fer05b]. On the other hand, the technique based on countermodels has helped us to establish for the first time, as far as we know, the number of different programs (modulo strong-equivalence) that can be built with a given number of atoms. Furthermore, this technique has also opened research work under development [\cite=Cab06] that studies the generation of a minimal program from a set of countermodels, analogously to the methods [\cite=Qui52] [\cite=McC56] for minimizing boolean functions in classical logic, well-known in digital circuit design.

The main focus in this technical note was just to prove the existence of a strongly equivalent program for any propositional theory, leaving more detailed related topics to be treated in subsequent work. Consequently, the methods we present to obtain the resulting program are mostly thought to achieve simple proofs of the main result, rather than to obtain an efficient computation or a more compact representation of the final program itself. As an example of work directly derived from the current result, but perhaps more interesting from a computational viewpoint, [\cite=Cab05] presented a pair of alternative syntactic transformations to reduce a propositional theory into a strongly equivalent logic program. One of the transformations preserves the vocabulary of the original theory, but is exponential in the obtained program size, whereas the other is polynomial, but with the cost of adding auxiliary atoms. [\cite=Cab05] further confirms this complexity result for nonnested programs, actually proving that no polynomial time transformation to nonnested programs can be obtained if we preserve the original vocabulary. The existence of polynomial space/time strongly equivalent translations to programs with nested expressions is an open question.

Acknowledgements

Special thanks to Vladimir Lifschitz and David Pearce for their invaluable help to improve the paper; in fact, the motivation for the current research was originated by their joint discussions. The first author is partially supported by the Spanish MEC project TIN-2006-15455-C03-02, and the second by the National Science Foundation under Grant IIS-0412907.