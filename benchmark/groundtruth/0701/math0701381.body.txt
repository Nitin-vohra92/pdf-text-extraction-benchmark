Corollary Claim Lemma Lemma-Definition Proposition Example

Definition Algorithm

Remark Notation

Concrete and abstract structure of the sandpile group for thick trees with loops

Introduction

The abelian sandpile model (ASM) was defined in [\cite=Dhar90] for any graph, generalizing the case of a grid from [\cite=BTW]. This model is a prime example of self-organized criticality [\cite=BTW] which has transformed the understanding of how complexity arises in nature (see [\cite=Turcotte] for a summary of applications to modelling earthquakes, forest fires, landslides, etc.) The ASM is related to the chip-firing game, introduced by Spencer [\cite=Spencer], and later modified by Björner, Lovász, and Shor [\cite=BLS]. For general references on the abelian sandpile model, see e.g. [\cite=BT] [\cite=Dhar99].

We will only consider undirected graphs. An (undirected) abelian sandpile model begins with any connected undirected graph (with arbitrary edge multiplicities) with vertex set V and edge set E, together with a distinguished vertex s∈V called the sink. Then, a configuration of the abelian sandpile model is an element of [formula], which assigns a nonnegative integer to each vertex except the sink, considered the number of grains of sand at that vertex. A configuration is stable if the number of grains of sand on each vertex is less than the degree of the vertex (otherwise it is unstable). Then, one obtains a dynamical system on the space of configurations, where at each time step, each unstable vertex sends one grain of sand along each incident edge. Sending grains of sand to the sink merely reduces the total number of grains. Because every vertex has a path to the sink, it turns out that this yields a well-defined stabilization of any configuration in finite time. The system can remain in motion by continually adding grains (e.g., at random vertices).

One basic question about any dynamical system is to find "recurrent configurations." For sandpiles, Dhar [\cite=Dhar90] defined these to be stable configurations that can be obtained from any configuration by adding grains and stabilizing. Dhar showed that they form an abelian group (under adding and stabilizing), called "the sandpile group," whose abstract group structure is [formula], where Δ is the matrix obtained from the Laplacian of the graph by deleting the row and column corresponding to the sink.

However, the concrete structure (in terms of configuration on the graph) of these recurrent configurations turns out to be quite complicated and interesting. For example, Creutz's paper [\cite=Cre] displays intricate fractal patterns of the identity element of this group in the case of a square grid, which was further studied in [\cite=DM] [\cite=LR].

László Babai suggested that the authors study the sandpile group for "thick" graphs: graphs which may have large edge multiplicities, but whose combinatorial structure is simple. In this note, we consider thick trees with loops: graphs which become trees when all positive edge multiplicities are dropped to one, and all loops are discarded. We concretely describe the group elements and operations in these cases, compute the abstract group structure, and relate the two using recursive formulas. To our knowledge, this is the first result giving the complete, explicit structure of the sandpile group in any class of undirected graphs. In [\cite=DRSV] (the grid) and [\cite=Bai] [\cite=JNR] [\cite=T] (other graphs), information about the abstract group structure for more complicated graphs was given.

The note is organized as follows: in Section [\ref=asm] we recall the necessary background. In Section [\ref=thtree] we state our main theorem and its corollaries. In Section [\ref=pfs] we prove the theorem.

The abelian sandpile model

We review the theory of the (undirected) abelian sandpile model (ASM), following [\cite=BT].

Let A be a finite connected undirected graph with arbitrary edge multiplicities, allowing loops. Precisely, A  =  (V,E,g), where V is the set of vertices, E is the set of edges, and g:E  →  V(2) is the incidence map. Here V(2) is the set of one- and two-element subsets of V (i.e., unordered pairs of vertices). We have g(e) = {i,j} where i,j are the endpoints of e. We require that A be connected, i.e., there is a path of edges connecting any two vertices.

An (undirected) is a collection (A,s) where A is an undirected, connected graph with vertex set V and edge set E (allowing multiple edges and loops), and s∈V is a distinguished vertex, called the sink. All other vertices are called ordinary. Let [formula] be the set of ordinary vertices.

A configuration of the ASM associated to (A,s) is a vector [formula], i.e., an assignment of a nonnegative integer ui to each ordinary vertex i (called its height).

For any i,j∈V, define the edge multiplicity to be ei,j: =   #  {a∈E:g(a)  =  {i,j}}.

We may now define the notion of stability of a configuration:

Given a configuration u, a vertex i∈V0 is called stable if ui  <   deg (i). Otherwise i is called unstable. A configuration is called stable if all vertices are stable.

If i∈V0 is unstable for u, then define the state τi(u)i by τi(u)i: = ui  -   deg (i)  +  ei,i and τi(u)j: = uj  +  ei,j for j  ≠  i. Passing from u to τi(u) is called "toppling the vertex i."

Given any unstable configuration, one may continually perform such topplings τi until a stable configuration results, which we call the stabilization.

[\cite=Dhar90] [\cite=BLS] (cf. also [\cite=Biggs99]) Given any ambient space (A,s) and any configuration u of its ASM, then there exists a unique stable configuration σ(u), which satisfies [formula] for some sequence of topplings [formula].

(The theorem rests on an application of the Diamond Lemma, since if two vertices are unstable at once, one may topple them in either order with the same result.)

For each configuration u, we denote by σ(u) its unique stabilization.

With this in mind, one may conclude that the set of stable configurations form a monoid under vertexwise addition:

[\cite=Dhar90] Let M be the set of stable configurations. Define the operation [formula] on M by [formula], where +   is vector addition.

[\cite=Dhar90] The operation [formula] is commutative and associative, making [formula] a commutative monoid, called the sandpile monoid.

Even the abstract structure of the sandpile monoid (without discussing concrete configurations) can be quite complicated. However, Dhar [\cite=Dhar90] noticed that the subset of "recurrent" configurations has a much simpler abstract structure:

A configuration u is called recurrent if, for all configurations v, there exists a configuration w such that [formula].

(Actually, as noticed in [\cite=BT], the above is true for any finite commutative monoid, if one replaces G by the unique minimal ideal.) In [\cite=Dhar90] (elaborated in [\cite=DRSV]) there is a surprisingly simple formula for the abstract structure of this group:

The toppling matrix Δ = (Δij)i,j∈V0 is given by

[formula]

Note that any two configurations which have the same stabilization are related by an element in the row span of Δ; also, adding a large enough multiple of the sum of the rows Δi must give a unique stabilization. Using this, one has the

Let Λ: = 〈Δi〉i∈V0 be the lattice spanned by the rows Δi of the toppling matrix.

[\cite=Dhar90] [\cite=BT] The natural map [formula], c  ↦  σ(c  +  eA) descends to an isomorphism [formula]. In particular, #  (G)  =   det (Δ).

(Note: [formula] and #  (G)  =   det (Δ) are due to [\cite=Dhar90]; the map c  ↦  σ(c  +  eA) was pointed out in [\cite=BT].)

Dhar found an algorithm to test for recurrence, of linear time in the combinatorial size of A (the number of edges counted without multiplicity plus the number of vertices):

Let [formula] be given by [formula]. That is, βi  =  ei,s.

We consider adding β to be "toppling of the sink". One has the The term "burning algorithm" (with which each vertex that topples in the process is considered "burned") was introduced in [\cite=MD]. The algorithm above was discovered by [\cite=Dhar90], and the proof follows from [\cite=Dhar90] and [\cite=MD92].

The sandpile group for thick trees

Following L. Babai, we call an undirected graph T a thick tree if the underlying simple graph T' obtained by reducing all nonzero edge multiplicities to 1 is a tree (i.e., a connected graph without cycles). A vertex i is called a leaf if deg T'i = 1 and i  ≠  s.

An undirected graph T is called a thick tree with loops if, after removing all loops (dropping ei,i to zero for all i∈V), the obtained graph is a thick tree.

Recall that a graph is a tree iff, for any two vertices, there exists a unique path from one to the other. Let i,j∈V. We define a partial ordering [formula] on V, where [formula] if j is on the unique path of T' from i to the sink. By definition, this means that [formula] for all j∈V. Also, [formula] if the condition i  ≠  j is added. Vertex p(j) is the parent of j if [formula] and p(j) is adjacent to j.

For a thick tree with loops, T, we define [formula] using the underlying tree T'.

We have the following main result, whose proof is the content of the next section.

The sandpile group [formula] for a thick tree T with loops can be characterized as follows (recall Notation [\ref=evntn]):

[formula].

The map [formula] [formula] is a group isomorphism. In particular, the abstract group structure does not depend on which vertex is chosen to be the sink.

The map φ- 1 may be expressed recursively as follows: For any j∈V0,

[formula]

where for any [formula], we let [formula] be its preferred representative, and for any j∈V0, [formula] is given (uniquely) by [formula].

Let u be any configuration. Then the associated recurrent configuration σ(u  +  eT) is given recursively by

[formula]

where [formula]. If σ(u) is already recurrent, we can delete the eT's.

Simply apply the map φ and then the map φ- 1; we then expand fj.

The identity configuration eT is given by

[formula]

where [formula]

Specialize Corollary [\ref=asreccor] to the case of u  =  0. (Alternatively, specialize [\eqref=pif] to the case of v  =  0 and expand fj.)

Proof of Theorem [\ref=mt]

We divide Theorem [\ref=mt] into Propositions [\ref=mt1], [\ref=mt2], and [\ref=mt3], corresponding to (refinements of) parts (i), (ii), and (iii), respectively.

Take any stable configuration u. We apply Algorithm [\ref=ba2]. This means that we try to stabilize u  +  β, and test whether or not every vertex topples. Since β adds sand only to the vertices adjacent to the sink, one easily sees that no vertex can topple before its parent. We can view adding β as having "the sink topple," and thus inductively, a configuration is recurrent iff every vertex can topple once its parent topples. We conclude that every vertex fires iff, for every vertex j, the amount of chips needed to topple (deg (j)  -  uj) is less than or equal to the amount of chips it inductively receives from its parent (ei,p(i)).

The lattice Λ can be characterized as

[formula]

First, we show the inclusion ⊆  . It suffices to show that, if v  =  Δk for any k∈V0, then [formula] for any j∈V0.

For k  =  p(j), one has

[formula]

For k  =  j, one has

[formula]

For all [formula], one has

[formula]

The result is proved.

Next, we show the inclusion ⊇  . For any j∈V0, consider the sum

[formula]

A simple inductive argument on V0 shows that these elements span the desired space [formula]. To do this, note that if j is a leaf, Δjj  =  ej,p(j), and one may express all elements of W as a sum of such Δj's and vectors which are zero in the leaf components.

As a consequence, we deduce the

It remains to combine the two propositions to give an explicit inverse of the isomorphism [formula] (to express the sandpile group [formula] in terms of configurations), which is part (iii) of Theorem [\ref=mt].

Since [formula] is an isomorphism and hence a bijection, we need only check that (i) the formula [\eqref=pif] indeed gives a recurrent element (i.e., an element of G) for every [formula], and (ii) the composition [formula] is the identity.

The first part (i) is obviously true by definition, using Proposition [\ref=mt1] (we defined fj to satisfy this). Let us check (ii). To avoid confusion, let us denote the map recursively defined in [\eqref=pif] by (φ- 1)' for now (so replace every instance of φ- 1 with (φ- 1)'. We then compute

[formula]

Acknowledgements

The authors would like to thank László Babai for introducing them to the sandpile model through lectures at the 2005 University of Chicago REU, supported by the University's VIGRE grant; in particular for explaining all of the material in Section 2, based on [\cite=BT]. They are also grateful to Babai for proposing the problem, for providing many references, and for extensive comments on earlier versions of this note. The authors are grateful to the participants and organizers of the aforementioned REU, without whom this research would not have occurred. The work of the second author was partially supported by an NSF GRF.