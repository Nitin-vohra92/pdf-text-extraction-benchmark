=1

AN ALGORITHM FOR SINGULAR VALUE DECOMPOSITION OF MATRICES IN BLOCKS

Introduction

Singular Value Decomposition has proved to be useful in a wide range of applications, where a linear relation is a suitable model for a big number of variables. Its main strength is in its ability to abstract most of the meaningfull relation in a much smaller subspace [\cite=StructuresLSA],[\cite=SVDProjections],[\cite=LSA],[\cite=Latent].

Even though the calculations are very simple in essence, the method is at its best when dealing with big dimension matrices of data, and the computational resources to perform the calculations are often insufficient.

In this document I propose an algorithm that allows to deal with the matrix by pieces, so it does not need to define big matrices or operate with them, but only smaller blocks.

The usual algorithm

the usual algorithm to perform the decomposition is made in two steps: First, a transformation is found that takes the matrix to bidiagonal form, and then, the bidiagonal matrix is decomposed with a different procedure.

Householder transformations and bidiagonal matrices

The first step is carried by means as a certain class of symmetrical orthogonal (or unitary) matrices called Householder transformations [\cite=Householder]. A Householder transformation is defined by a unitary vector this way:

[formula]

where R̂ is an unitary vector of dimension (number of components) n, and 1n  ×  n is the identity with n rows and columns. It is easy to see that the matrix that corresponds to this transformation is symmetric, which means that it is not changed by transposition (changing rows by columns, and vice versa). That impplies that it is its own inverse, e.i., that its square is the identity matrix.

A householder operation can be found that, when multiplied by the left, turns the all but one of the entries of the first column of a matrix into zero, but preserving the sum of the squares of the entries of that column.

[formula]

The unitary vector that defines the Householder transformation can be computed as having one part proportional to the part that is to turn into zero. Being an unitary vector, the proportionality factor can be best represented by some unknown factor X divided by the norm of that part of the vector, the square root of the sum of the squares. In our example:

[formula]

Imposing the condition that it makes the required entries of the vector 0, the unknown factor turns out to be:

[formula]

We can express any matrix in block form, separating the first row and column, in the same way as the Householder matrix. This latter has a very simple form:

[formula]

where M0 is the first diagonal entry of the matrix, and the remaining of the first row and first column are expressed by a norm and an unit vector, MrowV̂row and Mcol(V̂col)t. N would be the norm of the first column, that is [formula]

Multiplying the matrix M by the Householder matrix by left, we get the following result:

[formula]

A Householder transformation applied on the right, can have the same effect of annihilating all but one of the entries of the first row. But, if we try to get a diagonal block matrix using two consecutive Householder transformation, one on the left and one on the right, the second is going to turn the zero entries produced by the first into other number, thus failing to produce a block diagonal matrix.

We can, however, leave one nonzero element in the first column, and two nonzero elements in the first row, using on the left a Householder transformation that mixes the contents of the rows only from the second element on:

Next we can focus on the right-bottom block of the matrix where the zero elements have not yet been produced. The right and left Householder transformation for that block can be computed, so it will be left with only two nonzero elements in the first row and column. Then, the same is done for the remaining block, and so on.

The number of steps necessary to bring the matrix to a bidiagonal form has been 2n - 1, where n is the lower dimension of the matrix. It is a very fast step.

Iterative diagonalisation

To take the bidiagonal matrix to a diagonal form is not so easy, and cannot be done in a fixed number of steps, but has to be an iterative process. The most efficient method for this is the QR factorisation [\cite=QRdecomposition].

Starting from our upper bidiagonal matrix, the steps to be performed are:

Construct the orthogonal transformation to bring the matrix to lower triangular form, with Householder transformations like the ones we used in the last part, but only applied by right.

Apply the transformation by left as well. The result will be a matrix that is not either upper or lower triangular, but has the values more concentrated on the diagonal.

Repeat the procedure.

All the steps are done with orthogonal transformation, and that ensures that the singular values are preserved. In each step, besides, the square of every diagonal element are increased with the squares of the other elements in the row. That, together with the preservation of singular values, ensures convergence.

getting the economy decomposition

The last procedure yields the two square unitary matrices, and the singular values diagonal must be nonsquare. That means that a lot of memory is needed for the unitaries, wich are huge matrices with double precision. A lighter alternative is to compute the economy decomposition [\cite=EconomySVD], wich give us just slices of unitary matrices. The left one has as much rows as our matrix, but only as much columns as the rank (number of nonzero singular values) of the matrix. And the right one has as much columns as our matrix, but only as much rows as the rank of the matrix.

[formula]

To compute the economy decomposition, a lesser computational effort is needed. Suppose that we have in our matrix more rows than columns, or that we took it to that form by transposing it. Then, the symmetric matrix AtA will be smaller in dimensions than A. We can use one of the usual algorithms to diagonalise it, and get

[formula]

It is very easy to compute the inverse of square root of this matrix, all that is necessary is to take inverses of square roots of the diagonal elements of D. Then, we can express our matrix like this:

[formula]

It can be easily shown that U = AVD- 1 / 2 is a slice of a unitary matrix:

[formula]

If the square matrix AtA hapens to be singular, then V is also a slice of a square unitary, and D is smaller, but allways invertible.

Frobenius norm and a better starting point

Latent Semantic Analysis, and other techniques, are based on the fact that some big matrices can be accurately represented only by the bigger terms of their spectral decomposition, that is, only the bigger singular values. The usual convention to represent the diagonal matrix of singular values is in an ordered form, from the biggest, in the first element, to the smallest.

The matrices are usually rather sparse, and with only some column and row swaps, we can take the bigger elements up and to the left, so the matrix is going to be closer to the desired form.

The singular value problem, as the eigenvalue problem, can be seen as a maximisation of a certain value. The solution of the following problem gives the left and right eigenvectors corresponding to the highest singular value:

[formula]

All along this work, the maximisation of the values in the upper left corner of the matrix is going to be used to arrive near to the diagonal form. The first thing that can be done, is just arranging the rows and columns to take the higher values to the upper left corner of the matrix.

There is a well known result, that tells us that the Frobenius norm of a matrix [\cite=Frobenius], that is, the trace of its square [formula], is the sum of the squares of the singular values, and is as well the sum of the squares of all the elements of the matrix.

[formula]

If we consider the other square matrix AAt the result is the same, because in that case we just swap indexes i and j. With the SVD decomposition of the matrix, we only need to remember that a unitary matrix does not affect the trace:

[formula]

where Dmn is a square m  ×  n diagonal matrix with the singular values.

A vector can be computed with the norms of each row, and the Cartesian norm of this vector will be the frobenius norm of the matrix. The same can be done with the columns. This two vectors can be used to sort the rows and columns of the matrix to get the higher values in the upper left corner.

Afther that sorting, a definition of the blocks can be done, with some criterion based on those row and column norms. The blocks can be defined, for example, as to put a certain percentage of the whole frobenius norm in the first column-block, and a certain percentage on the first row-block.

If only the higher singular values are needed, it is not necessary to decompose the whole matrix, but instead two steps can be taken:

Separate the subspace of the highest singular values from that of the lower singular values

Decompose only the block corresponding to the highest singular values

Partial SVD

In the proposed algorithm, the matrix is prepared so as to have more rows than columns (transposed if necessary) and the columns are cut in such a way that a fraction of the total square Frobenius norm is enclosed in the first column block. The rows are separated in such a way to have square upper left block.

Then, each block can be considered separately, and that can require considerably less computer resources.

A generalisation of Householder matrices for blocks

The first thing that can be done, is to generalise the concept of a Householder transformations to any partition of the rows and columns of the matrix in four blocks. The general form of such a transformation is the following:

[formula]

where U is a slice of a unitary matrix with n rows and m columns, and V is a slice of unitary matrix with N - n rows and m columns. This transformation would be a N  ×  N unitary matrix, to be multiplied by left to a matrix with N rows divided in two blocks with n and N - n rows, or by right to a matrix with N columns split in blocks with n and N - n columns. α and β are diagonal matrices of rank m with the property α2  +  β2  =  1m  ×  m

This matrix y symmetric and it is its own inverse, two of the properties of a Householder transformation. A householder transformation shifts the sign of only one vector, but this transformation can be shown to change the sign of any vector that lies within a subspace. This subspace is defined by a set of mutually orthogonal vectors, which can be arranged in a column or row block. The matrix can be written also like this:

[formula]

A transformation like this can be used, for example, to annihilate a block of a matrix, just as in the usual SVD method. Here are the steps to annihilate a nondiagonal block by multiplication by left:

The two relevant blocks, the ones that are going to be transformed to annihilate one of them, are decomposed. Full SVD is not necessary, a simple decomposition Unitary-Symmetric will do.

[formula]

The unitary factors of the two blocks are taken as the U and V matrices of the Householder matrix

If we take the first column of a 2x2 blocks matrix as the relevant blocks, the action of the Householder matrix will give in the nondiagonal block:

[formula]

For this block to be zero, the parameters of the matrix must be:

[formula]

There is another way of doing it as well, wich will probably take more time, but is based on a well known technique: the GSVD: Generalised Single Value Decomposition. This is the simultaneous decomposition of two matrices:

[formula]

where, in the economy representation, U and V are slices of unitary matrices with the same dimensions than those of the other method. X is a square matrix. The matrices S and C are square and diagonal, and fulfil C2 + S2 = 1. They can be used indeed as α and β respectively (C = α,S = β) in the Householder matrix.

With this kind of Householder transformations, we can perform a complete (not economy) blockwise decomposition of a matrix, iterating the annihilation of the two nondiagonal blocks as shown in the figure:

Blocks and the trace trick

To be able to perform the decomposition directly in the economy representation, a version of the eigenvalue (spectral) decomposition is needed. The formula shown for annihilating blocks only works multiplied by one side, but it does not work to annihilate nondiagonal blocks acting on both sides, as an equivalence transformation.

For a 2x2 number symmetric matrix, the problem of diagonalising it amounts to finding a certain number x that fullfills:

[formula]

The condition is better derived from the null elements of the matrix, and is:

[formula]

Defining α  =  (1 - 2x2) the condition becomes very simple, because [formula]

[formula]

The solution is easily found to be:

[formula]

On the other hand, if the entries of the matrix are suitably sized blocks, the condition is a lot more complicated. We can represent the unitary matrix as being constructed with blocks x, y and z having the form shown above for Householder matrices.

[formula]

The noncommutativity of the matrices does not allow for an easy solution as that with numbers. Furthermore, to solve the condition for the nondiagonal elements should not be possible, except in the 2x2 or 2x3 blocks case, because that could be translated to solve analytically a general equation of order higher than five. That, according to Abel's theorem, is not possible.

But there is something we can do, and it is working with traces. We can either maximise the trace of the first diagonal block, or minimise the trace of the square of the nondiagonal block.

On the other hand, using slices of the unitary matrices, and their complement (the slice that is lacking for the total unitary) we can build an unitary matrix S that allow us to isolate just a subspace to work on it, thus reducing substantially the dimensionality of the problem.

[formula]

Note that if block (AtA)12 is full rank, then U1 would be square and there would not be a Ū1.

Applying this unitary transformation to the matrix we get:

[formula]

The trace of the first diagonal block can be recovered from this matrix as the sum of the first and third diagonal blocks.

If U1 and U2 are chosen as the unitaries that take the nondiagonal block (AtA)12 to diagonal form DN, things are very simplified in the above expression

[formula]

[formula]

Now, a transformation should be chosen that maximises the trace of the two first blocks. This is accomplished by a transformation that diagonalises the reduced matrix [formula]. The computation of such transformation does not represent a big computational cost, because of the relatively small size of this matrix.

[formula]

where 11 = (U1)tM11U1 and 22 = (U2)tM22U2.

The final form of the matrix will be:

[formula]

Where:

[formula]

and

[formula]

The trace of the two first blocks will now be bigger, because the highest eigenvalues of the reduced matrix are concentrated in D1.

This procedure can be iterated, and each time the trace of the first blocks will be bigger.

[formula]

An algorithm for block-SVD

Then, an algorithm can is proposed for block-SVD of a big matrix:

Make sure that there are more (or the same) rows as columns, or transpose otherwise. This first steps are performed with the sparse csv triplet representation.

Compute the rows and columns euclidean norm

Order rows and columns in descending norm order

Choose a cutting point for the rows and columns. This can be made in several ways. The one tried here is taking the point where at least 2/3 of the frobenius norm is in the first column block, and cut the row blocks as to yield a square first diagonal block.

Create the blocks the appropriate size

Create the Householder unitary matrix that annihilates block 12

From that starting point, iterate the maximisation of the trace of block 11 of the square matrix AtA until a certain tolerance

Perform SVD of the first block

This gives an approximation of the eigenvalue decomposition of AtA. Multiplying the initial matrix (by blocks) times the inverse of the square root (also by blocks) the two-block relevant vertical slice of the economy unitary left (U in UDVtmatrix are obtained. The relevant slice of the other unitary is the first vertical 2-block slice of the unitary obtained by iteration (V)

Some results

A matrix of the occurrences of 3204 words in 17780 documents was used. The procedure of cutting the blocks gave blocks with the following characteristics:

It must be noted that the matrix was cut as to leave blocks 11 and 21 with a little more than 2/3 of the square frobenius norm.

The blocks of the matrix AtA had the following characteristics:

(*)The "trace" of the nondiagonal block is not actually a trace, but the sum of its singular values. The traces of the diagonal blocks must of course sum up to the total trace, so their percentages sum up to 100%. The percentage for the nondiagonal block is only computed to measure how non-block-diagonal the matrix is.

The sum of the singular values of the nondiagonal block is going to be called nondiagonality from now on.

To enhance convergence, in every iteration whose number is the square of an integer, a transformation is included that tries to annihilate the block 12, but is damped by [formula], being n the number of the iteration. This is accomplished by computing matrix α and β as if the whole nondiagonal block was divided by n.

The values of the traces for the first five iterations are shown in the following table:

The criterion used for convergence was that the ratio [formula] became 1/10000 of its initial value (about 1.16). It can be seen that the trace of the first block is allways increased, as expected, but the sum of eigenvalues of the nondiagonal block oscillates after some iterations.

The availability of memory for MATLAB 6.5 does not allow to perform the complete SVD decomposition of the matrix, but it is possible to compute the singular values. The singular values contained in the first [formula] block then account for 75% of the square block of the matrix.

The first 215 obtained singular values had differences under 1e-10 with those calculated by the usual algorithm, except for the lowest four.

Aknowledgements

This work was sponsored by the European Comission under the contract FP6-027026 K-Space and Foundation for the Future of Colombia COLFUTURO. I would also like to aknowledge the valuable guidance of professor C. J. van Rijsbergen and useful advise from Mark Girolami in the developement of this work.