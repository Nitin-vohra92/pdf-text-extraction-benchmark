Lemma Corollary Proposition

Definition Algorithm Example Exercise

Remark

Random Search Algorithms for the Sparse Null Vector Problem

Introduction

Let A be a real M  ×  N matrix with rank m  <  N. In this paper, the following problem is studied:

Find a minimal set of linearly dependent columns of A,

that is, a set of linearly dependent columns of A such that each proper subset consists of linearly independent columns. An essentially equivalent problem is:

Find a null vector x of A whose support {i  |  xi  ≠  0} is minimal.

This problem is commonly called the sparse null vector problem, and an extension of the problem, known as the sparse null space problem, is:

Find a basis of the null space of A whose vectors all have minimal support.

The sparse null space problem occurs in optimization and in finite element analysis, where it is often of interest to express all solutions of an underdetermined system of equations Ax  =  b (a system of constraint equations or a discrete balance law) in the form x  =  x0  +  Cu, with a matrix C whose columns span the null space of A. Sparsity of C leads to well-known computational advantages. The sparse null space problem is discussed in detail in [\cite=coleman_pothen1] and [\cite=coleman_pothen2], and approximative algorithms for its solution are presented. Further work may be found in [\cite=brualdi], [\cite=gilbert_heath], [\cite=pinar], [\cite=stern]. The sparse null space problem can be solved with a canonical greedy algorithm that looks for a sequence of sparsest linearly independent null vectors. On the other hand, it is known that the sparse null vector problem is NP-complete in its full generality. Exceptions are also known. For example, a polynomial algorithm is known if A is the vertex-edge incidence matrix of a graph, see [\cite=itai].

The problem of identifying minimal sets of linearly dependent columns of a matrix occurs also in electrical engineering. Here, the goal is to identify the behavior of the components of a circuit from measurements at a set of test points (input frequencies for an analog circuit, test words for a digital-to-analog converter, physical test nodes). Then it may happen that faults in a group of components are indistinguishable from one another. A simple example is a string of electric light bulbs: If one of the bulbs is defective, the entire string is dark, and it is not immediate which light has to be replaced. The connection with linear algebra comes up as follows. Small deviations from the nominal circuit behavior can be described by a matrix equation Ax = b for the linearized response of a circuit near a desired behavior. The vector b encodes deviations from nominal measurements at various test points, and the unknown x corresponds to deviations of parameters for circuit components from their desired status. If a subset of columns of A is linearly dependent, then the corresponding components of x are not unique, but satisfy some affine relation. Thus the deviations in the behavior of components in this group cannot be determined uniquely, and faults cannot be located unambiguously. Such groups of components are called ambiguity groups in the engineering literature, and minimal groups are called canonical ambiguity groups. Their identification is useful to guide design modifications to improve the testability of a circuit. A discussion of this problem and of the numerical issues associated with it may be found in [\cite=stenbak]. This paper also gives an algorithm (essentially a complete search) that can lead to the identification of all canonical ambiguity groups of moderate size. Further algorithmic approaches were presented in [\cite=fedi], [\cite=manetti], and [\cite=starzyk].

A common framework for this problem is provided by matroid theory; see e.g. [\cite=oxley] for an introduction. Here, subsets of elements of an abstract base set may be independent or dependent, and it is of interest to determine minimal dependent sets. Concrete examples for dependent sets are linearly dependent sets of vectors or vertices on a closed path in a graph. Minimal dependent sets are called circuits in this theory and correspond to closed paths with no repeated vertices in the graph theory context. The problem of enumerating all circuits up to a given size in a matroid is discussed in [\cite=boros]. The structure of the set of all circuits up to a given size can be very complex.

In recent work on compressed sensing or compressive sampling, it has been discovered that the sparsest solution x (in the sense of having the fewest number of non-zero components) of an underdetermined system of equations A0x  =  b may often be recovered exactly or approximately by looking for a solution with minimal l1-norm; see e.g. [\cite=candes] and [\cite=donoho]. An otherwise intractable problem can therefore be attacked with linear programming methods. It appears therefore to be promising to find minimal sets of linearly dependent columns of A by removing a single column (call this column b and call the remaining matrix A0) and looking for a sparse solution of the system A0x  =  b, using l1-minimization. A sparse solution of this problem immediately results in a sparse null vector. Repeating this for all columns of A would give all sparse null vectors. However, a typical assumption in these results, known as restricted isometry property, is that the condition numbers of all M  ×  K submatrices of A0 have to be uniformly bounded, for some sufficiently large K. It is easy to see that in this case A cannot have many disjoint linearly dependent subsets of size ≤  K. Indeed, for coefficient matrices with many disjoint subsets of linearly dependent columns, l1-minimization may fail to detect the sparsest solution of a system of linear equations. We illustrate this with the following example.

Let B,C be M  ×  L matrices with rank L such that the column spaces have trivial intersection (hence 2L  ≤  M). For β,  γ  ≠  0, consider the matrix

[formula]

This matrix has many sets of minimal linearly dependent columns of size 3. Specifically, denoting by [formula] the i-th column of A, all sets of the form [formula] have this property. Let [formula] be arbitrary, and set b  =  By. The sparsest solution of the equation Ax  =  b is x  =  (yT,  0,  0)T. However, if [formula], then the l1-minimal solution of this problem is [formula] which has twice as many non-vanishing entries as x if γ  ≠   - 1. That is, if - 1  <  γ  <  0 and |β|  >  1 or if - 2  <  γ  <   - 1 and [formula], the l1-minimal solution is not the sparsest solution.

In a sense, this paper is concerned with methods for examining the residual class of matrices for which l1-minimal solutions of overdetermined linear systems are not necessarily sparsest.

We finally mention some problems in statistics that are related to the topic of this paper. Consider a linear regression problem Ax  ≈  b, where the columns of A (the predictors) are now assumed to be linearly independent. The least squares solution is [formula]. If A has small singular values, then the estimate x̂ will depend sensitively on small changes in the data b and may in fact be nonsensical. Often this instability occurs because a group of columns of A is nearly linearly dependent, a phenomenon known as multicollinearity (see e.g. [\cite=kutner]). This happens e.g. when similar measures of the same phenomenon are included in the set of predictors. While multicollinearity may be addressed by judicious choices of the variables that are included in a regression model, the detection of a subset of closely related variables in a data set is often interesting in its own right. A similar problem is the selection of a small set of variables in a regression model that may be used to predict a response. To place this in the present setup, consider the augmented matrix Ã  =  (A  b). One would like to find a minimal set of nearly linearly dependent columns of Ã that contains b. This specific model selection problem is attacked with machine learning techniques in [\cite=neylon]. More broadly, the problem of detecting sets of components that are nearly linearly related in a high-dimensional data set belongs in the area known as association mining, see e.g. [\cite=ceglar].

In this paper, two algorithms are discussed that may be used to detect or rule out the existence of small minimal subsets of columns of an M  ×  N matrix A of rank m that are exactly or nearly linearly dependent. Suppose a single such subset of size n is present. The first method given here, a random search, is expected to detect it with probability 1  -  ε by examining about | log ε  ·  ρ- n| submatrices, where [formula]. The submatrices are expected to have about m(1  -  ρ) rows and columns each. The second method, a systematic search, is capable of ruling out the presence of such a subset by examining about [formula] submatrices of similar size, although recursive calls of the search routine may increase the computational effort. In either case, matrices with small relative rank defects, i.e. ρ close to 1, offer the best chances to detect or rule out the presence of small sets of minimal linearly dependent columns. We also give a modification of the random search method for the problem of finding minimal subsets of columns that are nearly linearly dependent.

The paper is organized as follows. Section 2 contains definitions and basic facts. In section 3, two versions of the random search method for exactly dependent subsets are introduced. The systematic search is presented in section 4. Section 5 contains the modification of the random search method for the case of nearly dependent sets of columns. In section 6, results from numerical experiments are presented. In section 7, we briefly discuss some related problems.

The author would like to thank G. Stenbakken and T. Souders for introducing him to the problem and for many stimulating discussion.

Notation and Auxiliary Results

Given two nonnegative integers a  ≤  b, we denote the set [formula] by [formula] and identify it with the vector [formula]. Given N  ≥  1, let [formula] with [formula]. We identify I with the vector [formula] and write [formula].

Let A be a real M  ×  N matrix. Using Matlab notation, for a non-empty set [formula], we write A(:,I) for the M  ×  |I| matrix obtained by extracting all columns with indices in I, with the ordering of the rows remaining the same. Similarly, for a set [formula], A(J,:) is the |J|  ×  N matrix obtained by extracting all rows whose indices are in J. Then A(J,I) is the submatrix obtained from A by extracting the rows with indices in J and columns with indices in I. If y is a row or column vector, y(I) is the row or column vector with the components indexed by I extracted from those of y. The support of the vector y is defined as supp(y)  =  {i  |  yi  ≠  0}. We denote the m  ×  m identity matrix by [formula].

Assume now that A has exact rank m  ≤   min (M,N). One can then write A  =  LQ ([\cite=golub]), where L is M  ×  m lower triangular and Q is m  ×  N with orthonormal rows. In particular, L has a left inverse (LTL)- 1LT, and Q has full rank. Moreover, the null space of A is spanned by the columns of an N  ×  (N - m) matrix U with orthonormal columns.

We are interested in minimal linearly dependent sets of columns of A, that is, subsets [formula] such that A(:,J) does not have full rank, but any matrix A(:,J') with J'  ⊂  J,  J'  ≠  J has full rank. Borrowing the corresponding term from matroid theory, such a set J or the set of columns indexed by it will be called a circuit in this paper. Recall that in the engineering literature on testability, a circuit is called a canonical ambiguity group; cf [\cite=manetti] [\cite=stenbak]. If J is a circuit, there exists a N  ×  1 null vector z of A (or equivalently of Q) such that supp(z)  =  J. Reversely, there exists a circuit J  ⊂  supp(z) for any null vector z. Thus z is a sparse null vector for A if supp(z) is a circuit, and z is also a sparse column vector for U in this case. Circuits containing only one column clearly must be columns of zeroes in A.

A matrix with linearly independent columns does not have any circuits. More generally, a column A(:,j) does not belong to any circuit of A, if this column does not belong to the space spanned by the columns A(:,i),  i  ≠  j or equivalently if the rank of the matrix drops if column j is removed. An explicit way of identifying columns that do not belong to circuits is given below in Lemma [\ref=lmm_nocircuit]. We now characterize circuits of A.

Let A  =  LQ where Q has orthonormal rows, and let U have orthonormal columns such that QU = 0 and the columns of U span the null space of A. Let [formula], and let Jc be the complement of J in [formula].

(i) Then A(:,J) has a non-trivial null vector if and only if U(Jc,:) has a non-trivial null vector.

(ii) The following properties are equivalent:

a) J is a circuit for A.

b) Q(:,J) has a one-dimensional null space spanned by a |J| - vector w that does not vanish anywhere.

c) U(Jc,:) has a non-zero null vector, and for all k∈J and [formula], the matrix U(K,:) has full rank.

d) There are [formula] with J  ⊂  K and an N-vector y with supp(y)  =  J such that Q(:,K) has a one-dimensional null space generated by y(K).

e) There is [formula] with [formula] such that U(I,:) has a one-dimensional null space generated by a vector d, and supp(Ud) = J.

To prove (i), observe that any null vector v of A is of the form v  =  Ud, and the map v  ↦  d is an isomorphism between the null space of A and [formula]. If supp(v)  ⊂  J and v  ≠  0, then d  ≠  0 and v(Jc)  =  U(Jc,:)d  =  0. Reversely, if U(Jc,:)w  =  0 for some w  ≠  0, then supp(Uw)  ⊂  J and Uw is a non-trivial null vector of A.

We now turn to (ii). First note that A(:,K) and Q(:,K) have the same null space for any [formula]. Let us prove that a) implies b). If a) holds, the null space of Q(:,J) is non-trivial. All non-zero null vectors of Q(:J) must have support equal to J, since otherwise J would not be minimal. If the null space of Q(:,J) had dimension larger than 1, a linear combination of two null vectors could be found that vanishes at an index in J but not everywhere. Thus the null space a) of Q(:,J) must be one-dimensional, and b) follows. Reversely, if b) holds, then there exists a nontrivial null vector v of A(:,J). A non-trivial null vector of A(:,J) with strictly smaller support would be linearly independent of v, which is not allowed if b) holds. Hence J is a circuit of A.

To prove the equivalence of a) and c), let J be a circuit of A. Then U(Jc,:) has a non-trivial null vector by part (i). Now assume that for K as in the assumption, U(K,:) does not have full rank. By (i), A(:,Kc does not have full rank and Kc  ⊂  J,  Kc  ≠  J, contradicting the minimality of J. Reversely, assume c). By (i), J contains a circuit of A. If J were not minimal, we could find J'  =  J  -  {k} such that A(:,J') does not have full rank. But then with [formula], U(K,:) will not have full rank by (i), contradicting c).

Clearly b) implies d) - just take K  =  J. For the reverse conclusion, just take w  =  y(J). Then w does not vanish anywhere and spans the null space of Q(:,J).

To prove that a) - d) together imply e), choose I  =  Jc. By (i), there is a null vector d of U(Jc,:). Then clearly supp(Ud)  ⊂  J for all such null vectors. If the inclusion were strict, e.g. (Ud)k  =  0 with k∈J, then [formula] would not have full rank, contradicting c). Also, if U(Jc,:) had two linearly independent null vectors d and d', then the support of a suitable linear combination of Ud and Ud' would be strictly contained in J, again contradicting c). Reversely, if e) holds, then U(Jc,:)d  =  0 and hence J contains a circuit of A by (i). If J were not a circuit of A, e.g. if we could find a circuit J'  ⊂  J,  J'  ≠  J of A, we could find a null vector w  =  Ud' of A with supp(w)  =  J' and U(J'c,:)d'  =  0, hence also U(I,:)d' = 0. Now w  =  Ud' and x  =  Ud are linearly independent, since they do not have the same support. Hence also d and d' are linearly independent, contradicting the assumption that U(I,:) has a one-dimensional null space. Therefore J is a circuit of A. So e) implies a). This completes the proof.

With these preparations, a prototype algorithm for detecting circuits can be described. It operates on the matrix Q.

The algorithm stops with a circuit due to Lemma 2.1 d). The questions then arise how to choose K, what the size of this subset should be, whether one can do better if Y has more than one column, how to conclude that there (probably) is no circuit of a given size, and so on.

There is also a version of this prototype algorithm that operates on the matrix U. It was proposed in [\cite=manetti]. This algorithm stops after finding a circuit, due to Lemma 2.1 e). The same questions about the choice of I and alternate stopping criteria arise.

Let us now assume that the last m columns of Q form an invertible matrix. This is always possible after permuting columns. Thus [formula], where Q*  =  Q- 12Q1 is m  ×  (N - m), and therefore

[formula]

with   =  LQ2. This decomposition was exploited in [\cite=starzyk] to find circuits. Partitioning [formula], where U1 is (N - m)  ×  (N - m) and U2 is m  ×  (N - m), we see that [formula]. Then U1 must be invertible, since otherwise U could not have full rank. Write

[formula]

then it follows that

[formula]

The matrix C (or rather the set of its columns) is commonly called a fundamental null basis, see e.g. [\cite=coleman_pothen1]. It is now easy to give a version of Lemma 2.1 that uses only properties of Q* (or U*), i.e. that refers only to the fundamental null basis C. For any [formula], set [formula], and [formula].

Let [formula], and assume that the factorization ([\ref=eq_decomp]) holds. The following properties are equivalent:

a) J is a circuit for A.

b) Q*(J2,c,J1) has a one-dimensional null space spanned by a vector w that does not vanish anywhere, and Q*(J2,J1)w does not vanish anywhere.

c) There is an index set K with [formula] such that Q*(K2,c,K1) has a one-dimensional null space generated by a vector w, with

[formula]

Let [formula]. Let y be an N-vector, then Q(:,J)y(J)  =  0 if and only if Q*(J2,c,J1)y(J1) = 0 and Q*(J2,J1)y(J1)  =    -  y(J2). By Lemma 2.1, statements a) and b) are therefore equivalent.

To show that a) and c) are equivalent, one shows similarly that property d) in Lemma 2.1 reduces to property c) in the present situation.

Columns of A that do not belong to any circuit can be easily identified if the factorization ([\ref=eq_decomp]) or equivalently a fundamental null basis [formula] are given.

Let A be given such that the factorization ([\ref=eq_decomp]) holds with a full rank left factor [formula]. Column j of A belongs to a circuit of A if and only if either 1  ≤  j  ≤  N - m or if N - m + 1  ≤  j  ≤  N and row j - N + m of Q* does not vanish identically.

Note that row j - N + m of the right factor [formula] contains a 1 in column j. Let ek denote the k-th standard unit vector. If 1  ≤  j  ≤  N - m, then column j of - 1A satisfies

[formula]

Thus this column is a unique linear combination with non-vanishing coefficients of some of the last m columns and therefore is in a circuit. If N - m + 1  ≤  j  ≤  N and Q*(j - N + m,k)  ≠  0 for some k, then again

[formula]

The term corresponding to ν  =  j - N + m cannot be dropped, hence column j belongs to a circuit of A.

Reversely, if N - m + 1  ≤  j  ≤  N and if Q*(j - N + m,:)  =  0, then clearly the rank of [formula] drops if column j is removed, since the remaining matrix will now have a row of zeroes. Hence column j does not belong to a circuit of A.

Random Search for Circuits

In this section, we give an Monte Carlo algorithm for finding circuits up to a certain size, say n. If there is no such circuit, the algorithm always states this correctly. If there is such a circuit, it is found with probability 1 - ε in K steps, where [formula] and in each step typically a null vector of a submatrix of Q or U must be found.

Since the matrix Q(:,K) is m  ×  (m + 1), step 2 always finds a non-trivial matrix Z in the first attempt. Should rank(Z)  =  l be larger than 1, and step 3.c be carried out with a smaller K, then the new matrix Q(:,K) still has a non-trivial null space, but strictly smaller dimensions. Therefore, the method eventually ends up in step 3.a, i.e. it finds a subset K of size r such that Q(:,K) has a one-dimensional null space. It then inspects this subset to determine if it contains a circuit of the desired size. A single pass of the algorithm that ends in step 3.a) will be called at trial. It may involve several computations of null space bases Z.

A given circuit J of size n will be detected in step 3.a if J  ⊂  K. This happens with probability [formula] and fails to happen with probability [formula], where r  =  |K|. At any stage of the algorithm, the value p therefore is the probability that a fixed circuit J of size n would not have been detected up to this stage. If this probability is very small (less than ε), then we may be confident (with a confidence level of 1  -  ε) that no such circuit exists; hence the termination criterion.

Let [formula] and [formula]. If step 3.a is reached immediately (the generic case), then |K|  =  m + 1, and the probability that a given circuit J of size n is detected equals

[formula]

For small δ, this is approximately equal to ρn. Therefore, the probability of not detecting a fixed circuit of size n with K independent choices of K is approximately bounded by (1 - ρn)K. This is certainly smaller than a given ε if [formula]. If there is indeed a circuit J of size n, the expected number of trials until it is found is approximately ρ- n. Consider in particular instances of the problem where [formula], where ρ0  >  0 is given, and n is fixed. As N,  m  →    ∞  , the probability that a given circuit of size n is detected in a single trial is bounded below asymptotically by ρ- n0. Therefore, the expected number of steps to find a circuit of size n is exponential in n, but does not depend directly on the problem size Nm. One can expect that circuits of moderate size n are found rapidly if the rank defect N - m is small relative to N.

If there is more than one circuit of size ≤  n, it will take fewer trials to find one of them. Suppose there are k circuits of size cj, [formula], and assume that the circuits are all disjoint and their sizes are small compared to N. The probability of selecting a set K of size m + 1 that contains a specific circuit of size cj then is pj  ≈  ρcj. The probability of selecting a K that contains one of these circuits is approximately

[formula]

The reciprocal of this number is (close to) the expected number of trials until a circuit is found.

We now give a version of this algorithm that operates on the matrix Q*, where [formula], or equivalently on the fundamental null matrix C. As was noted in the previous section, this may require permuting the columns of A.

After choosing K in step 1, the matrix Q*(K2,c,K1) is k  ×  (k + 1), where k  =  |K2,c|  ≤   min (m,N - m), and therefore step 2 always finds a non-trivial matrix Z in the first attempt. Should rank(Z)  =  l be larger than 1, and step 3.b be carried out, then the new matrix Q*(K2,c,K1) is obtained from the previous one by deleting s columns and adding l - 1 - s rows, where 0  ≤  r  ≤  l - 1. As a result, this matrix still has a non-trivial null space, but strictly smaller dimensions. Therefore, the method eventually ends up in step 3.a, i.e. it finds a subset K of size r such that Q*(K2,c,K1) has a one-dimensional null space. It then inspects this subset to determine if it contains a circuit of the desired size.

If K is selected randomly such that |K|  =  m + 1, then Q*(K2,c,K1) is k  ×  (k + 1) with k  ≤  m,  k  ≤  N - m, and k has a hypergeometric distribution with expected value [formula]. The expected computational effort to find a basis of the null space of such a matrix is proportional to N3ρ3(1 - ρ)3, to leading order ([\cite=golub]). This implies that considerable savings are achieved by precomputing [formula] if the rank m or the rank defect N - m are small relative to N, since then ρ  ≪  1 or [formula].

Excluding Circuits of a Certain Size

In this section, a deterministic algorithm will be given that allows one to conclude with certainty that a matrix A does not have a circuit of size n. This is a derandomized version of the Monte Carlo algorithm of the previous section. It is based on the following observation.

Let A be an M  ×  N matrix of rank m. Let [formula] be disjoint and non-empty such that [formula]. For [formula], set [formula]. Assume that A has a circuit of size n. Then there exists C with |C|  =  n such that A(:,J(C)) has a circuit of size n.

If A has a circuit I of size n, we can set [formula]. This set has at most n elements, and I  ⊂  J(). Enlarging [formula] if necessary, we obtain a set [formula] with n elements such that I  ⊂  J(C). A vector from the null space of A that is supported on I may be restricted to J(C), resulting in a vector in the null space of A(:,J(C)) with the same support. Hence also A(:,J(C)) has a circuit of size n.

This observation is the basis of a recursive algorithm to determine if a given matrix A has a circuit of size n or smaller. The algorithm returns the value true if there is a circuit of size at most n and false otherwise.

Since m + 1  ≤  N, the integer r computed in step 0 is never smaller than n. In fact n  =  r is only possible if N = m + 1. In this case, the only possible circuit of A is the common support of the vectors in the one-dimensional null space of A. Therefore, one obtains r  >  n except in this trivial case. Then there are [formula] possible matrices Q(:,J(C)) which may be examined in lexicographic order, starting with [formula] and ending with [formula]. If A has a circuit of size n or smaller, one of these matrices must also have such a circuit, by Lemma [\ref=lmm_subsets]. All these matrices have m rows and at most m + 1 columns, thus the dimension d of their null spaces may range from d = 0 to d  =  m. If d = 0, the matrix Q(:,J(C)) does not have a circuit, and the algorithm examines the next subset J(C). If d = 1, the single possible circuit of this matrix consists of the common support of the vectors in this null space, by Lemma [\ref=lmm_char]. The algorithm examines this circuit and stops with a value α  =  true if the circuit has size at most n. Finally, if d > 1, there may still be a circuit of size n or smaller in Q(:,J(C)), and it can be found by applying the same algorithm. This matrix has strictly fewer columns than Q, and its rank is also strictly smaller than the rank of Q. Hence the recursion will terminate after finitely many calls.

Using as before the notation [formula], we see that r  ≈  nρ- 1. For the class of instances where [formula] remains bounded away from 0, the number of matrices that has to be examined to exclude the presence of circuits up to size n is exponential in n, but it is independent of the problem size Nm, assuming of course that the algorithm does not call itself. Specifically, consider instances where [formula] and [formula] for some integer s and some ρ0. Then [formula], and we may take r = n + s  ≤  (1 - ρ0)- 1s. In this case, the number of matrices that has to be examined is approximately bounded by

[formula]

by Stirling's formula. Recall that for this class of instances, the expected number of matrix examinations to find a circuit of length n with the randomized algorithm of the previous section is also bounded independently of Nm and exponential in n.

As before, it is possible to compute the factorization [formula] and achieve additional computational savings. We leave the details to the reader.

Inexact Circuits

We now discuss situations in which the M  ×  N matrix A has full rank and we wish to find a small subset of columns for which a linear combination vanishes approximately. Let ε  >  0 and x be an N-vector with [formula], then we say that [formula] is an ε-near circuit with witness vector x if [formula], and all singular values of A(:,I1) are larger than ε whenever I1  ⊂  I,  I1  ≠  I. We are interested in circuits with "few" elements (relative to the number of columns N). Thus if a candidate for an ε-near circuit with corresponding witness vector has been proposed, it is an easy matter to verify this. In particular, finding all singular values of A(:,I) is a matter of O(M|I|2) operations, and it is possible to find all singular values of all matrices A(:,I1) with I1  =  I  -  {k} for some k in O(M|I|3) operations or faster, if suitable downdating methods are used.

Let ε  >  0 and let A be an M  ×  N matrix with singular values [formula] and singular value decomposition A  =  USVT. Let V  =  (v,V2), where v is the first column of V, corresponding to σ1. Let [formula].

a) If I is an ε-near circuit of A with witness vector x and ε  <  σ2, then

[formula]

b)If

[formula]

then I is an ε'-near circuit with

[formula]

To prove part a),set x1  =  vvTx and x2  =  x - x1. Then clearly VT2x1  =  0 and [formula]. Also,

[formula]

Consequently

[formula]

Therefore [formula] has the desired properties.

To prove part b), let zj  =  vj if j∈I and zj  =  0 otherwise, and set [formula]. The cosine of the angle enclosed by v and z is [formula], and hence [formula] where [formula] and (Ay)TAv  =  0; therefore [formula]. Hence

[formula]

This observation suggests that one should look for ε-near circuits by selecting subsets [formula] such that A(:,K) has only one singular value σ1  <  ε. A near circuit with a witness vector may then be discovered by setting all small components of the corresponding singular vector v equal to zero.This is the idea of the following algorithm. It either produces a candidate set I for an ε-near circuit, or it returns the answer that no such near circuit exists.

Since the matrix A(:,K) has m + 1 columns, at least one of its singular values is less or equal than ε, by well-known interlacing properties of singular values ([\cite=golub]). Hence either case 3.a) or case 3.b) always occurs. Should there be more than one singular value that is less or equal than ε, then K is replaced with a smaller K, and the smaller matrix A(:,K) still has at least one singular value less or equal than ε. Therefore, the method eventually ends up in step 3.a. By Lemma [\ref=lmm_near], the singular vector corresponding to this singular value should suggest a near circuit. The method therefore inspects this singular vector to determine a candidate for a circuit of the desired size.

As before, if no near circuit of size up to n is found before p  <  δ, we may be confident with confidence 1  -  δ that no near circuit of the desired size exists, that is, the search has been performed sufficiently often such that a near circuit with the desired properties would have been found with probability at least 1  -  δ, if it existed. The number of trials until a near circuit is found has the same distribution as the corresponding quantity in algorithm [\ref=rand_alg]. If a candidate I has been found, it should still be tested; that is, the smallest singular value σ(I) of A(:,I) should be found as well as the minimal eigenvalues σ(I') of all matrices A(:,I') with I' = I  -  {k}. If σ(I)  ≤  ε  <  σ(I') for all i, an ε-near circuit has been found.

Practical Considerations and Numerical Examples

When looking for circuits, one should first identify and remove those columns that cannot belong to any circuits. This is easily done using Lemma [\ref=lmm_nocircuit] and reduces N and m = rank(A) by the same fixed amount. Next, one should use a version of the random search algorithm [\ref=rand_alg], starting with small circuit sizes. A repeated random search will reveal whether there is more than one circuit present. Starting with algorithm [\ref=syst_alg] to find circuits is also possible but not recommended, since it may lead to very long run times for reasons that will be explained below.

The main computational step in algorithm [\ref=rand_alg] is the determination of Z, a matrix whose columns span the null space of A, in step 2. This has to be done repeatedly until rank(Z)  =  1. One would expects that rank(Z)  =  1 already when the first random subset K of size m + 1 is selected in step 1 of that algorithm. However, if the rank m of A is small relative to the number of columns N (e.g. [formula] or smaller), the null space dimension rank(Z) is typically larger than 1 for the first selection of K, and Z must be computed again for smaller subsets of columns. This is just the computation of a null space of a downdated submatrix, and can be thus be done rapidly, see [\cite=golub].

A numerical experiment was carried out to test if the probability of detecting a circuit in a single trial depends only on the ratio of the matrix rank m to the number of columns N and the size of the circuits that are present. Random matrices with N = 100 columns and m  =  ρN rows, with [formula] were generated that had circuits with sizes given by vectors of integers [formula]. This was done by first generating an m  ×  (N - k) matrix A' with independent entries drawn from a standard normal distribution, choosing k random sets of columns of size [formula] of A' and forming k random linear combinations from them, and appending these k vectors to the matrix A' to form A. The probability of detecting a circuit in a single trial was estimated from 1000 trials applied to the same fixed matrix A. The results are given in the table below. The last column of the table contains the approximate probability computed from ([\ref=eq_prob_2]).

The table shows nearly constant detection probabilities, independent of the number of columns N, close to the approximate values in the last column. While the actual detection probability for a single trial of course does depend on the matrix, the experiment confirms the results of the discussion in section 3: The detection probability for a single trial depends essentially only on [formula] and on the number and sizes of circuits that are present.

The systematic algorithm [\ref=syst_alg] examines a fixed set of [formula] submatrices of A for the presence of circuits. Unless something is known about the likely location of a circuit, the subsets [formula] in step 0 should be generated randomly. The number of submatrices to be examined is easy to determine at the start, but it may increase during the execution, since the algorithm is recursive. Thus the computational effort may increase substantially beyond the initial estimate. The algorithm can also be used to search for a circuit.

In an experiment, a m  ×  N random matrix with N = 100 columns and m  =  ρN orthonormal rows was prepared that contained a single circuit of size c = 5. Algorithms [\ref=rand_alg] and [\ref=syst_alg] were used to find this circuit. The ordering of the columns was permuted randomly between attempts. The mean number of times that a nullspace had to be computed until the circuit was detected was estimated from 100 attempts for both algorithms. Also recorded is the expected number of trials from formula [\ref=eq_prob_1]. The results are given in the table below.

The table shows that the observed average number of nullspace evaluations tracks the expected number of trials closely if random search is used (algorithm [\ref=rand_alg]) and also for the case of systematic search (algorithm [\ref=syst_alg]) for ρ close to 1. For smaller ρ, the systematic search algorithm tends to require substantially more nullspace evaluations than the random method, no doubt because of the recursion.

The systematic search algorithm [\ref=syst_alg] could also be used to find all circuits of a given size. It turns out that any given circuit will typically be detected many times, if this is attempted, leading to very long execution times. This occurs independently of self-calls of this algorithm. Hence one should only turn to algorithm [\ref=syst_alg] if the absence of such circuits is suspected with high confidence, after repeated random searches have turned up nothing.

Unlike circuits of a given size, near circuits as defined in section 5 are not unique. Hence algorithm [\ref=near_rand_alg] does not behave as predictably as algorithm [\ref=rand_alg]. In particular, if ε is chosen too large in this algorithm, then there may be many ε-near circuits which can be detected, while there are none if ε is too small. Using a bisection approach, it is possible to find ε-near circuits with near minimal ε fairly reliably.

Given a matrix A (generated at random), it is observed that the smallest singular values of randomly selected submatrices with a fixed number of columns are very nearly normally distributed ~  N(μ,σ) with μ and σ depending on the matrix. Hence randomly selected submatrices will very rarely have smallest singular value less than μ  -  4σ or so. In this situation, Algorithm [\ref=near_rand_alg] is capable of detecting submatrices for which the smallest singular value is less than μ  -  8σ, with high reliability.

Other Problems

There are a number of other problems which can be addressed with modifications of the methods in this note. We only discuss problems that may be posed for general matrices; that is, problems related to circuits in specific matrices coming from graph theory, electrical engineering, or statistical applications will not be discussed.

A simple variation on the task of finding one circuit of a given size is to find all circuits up to a given size. Clearly this may be attacked by repeated application of algorithm [\ref=rand_alg]. Since circuits with fewer columns are more likely to be detected with this method, it may be necessary to delete a column in a circuit that has already been found from the matrix in order to find specifically longer circuits that do not contain this column.

A common problem is to find circuits or near circuits that have prescribed intersection properties with a given collection of sets of columns. This occurs e.g. in statistics, where a portion of the variables may be thought of as predictors and another one as responses. Circuits that contain one response and a small number predictors are of special interest in problems of model selection. Algorithms [\ref=rand_alg] and [\ref=syst_alg] are easily modified to handle such situations.

One may be interested in sampling randomly from the set of all ε-near circuits up to a given size, for a given ε. Algorithm [\ref=syst_alg] effectively provides such a random sampling scheme. However, it is unclear what the sampling distribution is in this case, and it appears to be difficult and laborious to estimate its properties.

We finally mention the following update problem: Suppose [formula] and a set of circuits of A1 has been identified. Is it possible to exploit this information to speed up the detection of circuits of the full matrix A? An extreme version of this task, related to subspace tracking, occurs if rows are added to A one at a time and a set of circuits has to be maintained or modified. Progress on such incremental algorithms has been made in [\cite=neylon].