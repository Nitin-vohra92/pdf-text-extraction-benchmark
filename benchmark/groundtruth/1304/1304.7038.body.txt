=

Staged Self-Assembly andPolyomino Context-Free Grammars

Introduction

In the mid-1990s, the Ph.D. thesis of Erik Winfree [\cite=Winfree-1998] introduced a theoretical model of self-assembling nanoparticles. In this model, which he called the abstract tile assembly model (aTAM), square particles called tiles attach edgewise to each other if their edges share a common glue and the bond strength is sufficient to overcome the kinetic energy or temperature of the system. The products of these systems are assemblies: aggregates of tiles forming via crystal-like growth starting at a seed tile. Surprisingly, these tile systems have been shown to be computationally universal [\cite=Winfree-1998] [\cite=Cook-2011], self-simulating [\cite=Doty-2010] [\cite=Doty-2012a], and capable of optimally encoding arbitrary shapes [\cite=Rothemund-2000] [\cite=Adleman-2001] [\cite=Soloveichik-2005].

In parallel with work on the aTAM, a number of variations on the model have been proposed and investigated. These variations change a number of features of the original aTAM, for instance allowing glues to repulse [\cite=Doty-2011] [\cite=Patitz-2011] [\cite=Schweller-2012], or adding labels to each tile to produce patterned assemblies [\cite=Goos-2011] [\cite=Czeizler-2012] [\cite=Seki-2013]. For a more thorough treament of the aTAM and its variants, see the recent surveys of Patitz [\cite=Patitz-2012] and Doty [\cite=Doty-2012b].

In parallel with work on the aTAM, a number of variations on the model have been proposed and investigated. One well-studied variant called the hierarchical [\cite=Chen-2012] or two-handed assembly model (2HAM) [\cite=Demaine-2008] eliminates the seed tile and allows tiles and assemblies to attach in arbitrary order. This model was shown to be capable of (theoretically) faster assembly of squares [\cite=Chen-2012] and simulation of aTAM systems [\cite=Cannon-2013], including capturing the seed-originated growth dynamics. A generalization of the 2HAM model proposed by Demaine et al. [\cite=Demaine-2008] is the staged assembly model, which allows the assemblies produced by one system to be used as reagents (in place of tiles) for another system, yielding systems divided into sequential assembly stages. They showed that such sequential assembly systems can replace the role of glues in encoding complex assemblies, allowing the construction of arbitrary shapes efficiently while only using a constant number of glue types, a result impossible in the aTAM or 2HAM.

To understand the power of the staged assembly model, Demaine et al. [\cite=Demaine-2012a] studied the problem of finding the smallest system producing a one-dimensional assembly with a given sequence of labels on its tiles, called a label string. They proved that for systems with a constant number of glue types, this problem is equivalent to the well-studied problem of finding the smallest context-free grammar whose language is the given label string, also called the smallest grammar problem (see [\cite=Lehman-2002] [\cite=Charikar-2005]). For systems with unlimited glue types, they proved that the ratio of the smallest context-free grammar over the smallest system producing an assembly with a given label string of length n (which they call separation) is [formula] and O((n /  log n)2 / 3) in the worst case.

In this paper we consider the two-dimensional version of this problem: finding the smallest staged assembly system producing an assembly with a given label polyomino. For systems with constant glue types and no cooperative bonding, we achieve separation of grammars over these systems of Ω(n / ( log  log n)2) for polyominoes with n cells (Sect. [\ref=sec:sas-much-better-pcfgs-gen]), and Ω(n /  log 3n) when restricted to rectangular (Sect. [\ref=sec:sas-much-better-pcfgs-rectangle]) or square (Sect. [\ref=sec:sas-much-better-pcfgs-square]) polyominoes with a constant number of labels. Adding the restriction that each step of the assembly process produces a single product, we achieve Ω(n /  log 3n) separation for general polyominoes with a single label (Sect. [\ref=sec:sas-much-better-pcfgs-gen]). For the separation of staged assembly systems over grammars, we achieve bounds of Ω( log n  /   log  log n) (Sect. [\ref=sec:pcfgs-slightly-better-sas-ssas]) and, constructively, O( log n) (Sect. [\ref=sec:pcfgs-never-much-better-sas]). For all of these results, we use a simple definition of context-free grammars on polyominoes that generalizes the deterministic context-free grammars (called RCFGs) of [\cite=Demaine-2012a].

When taken together, these results give a nearly complete picture of how smallest context-free grammars and staged assembly systems compare. For some polyominoes, staged assembly systems are exponentially smaller than context-free grammars (O( log n) vs. Ω(n /  log 3n)). On the other hand, given a polyomino and grammar deriving it, one can construct a staged assembly system that is a (nearly optimal) O( log n)-factor larger and produces an assembly with a label polyomino replicating the polyomino.

Staged Self-Assembly

An instance of the staged tile assembly model is called a staged assembly system or system, abbreviated SAS. A SAS S  =  (T,G,τ,M,B) is specified by five parts: a tile set T of square tiles, a glue function [formula], a temperature [formula], a directed acyclic mix graph M  =  (V,E), and a start bin function B:VL  →  T from the leaf vertices VL  ⊆  V of M with no incoming edges.

Each tile t∈T is specified by a 5-tuple (l,gn,ge,gs,gw) consisting of a label l taken from an alphabet Σ(T) (denoted l(t)) and a set of four non-negative integers in [formula] specifying the glues on the sides of t with normal vectors 〈0,1〉 (north), 〈1,0〉 (east), 〈0, - 1,〉 (south), and 〈 - 1,0〉 (west), respectively, denoted [formula]. In this work we only consider glue functions with the constraints that if G(gi,gj)  >  0 then gi  =  gj, and G(0,0)  =  0.

A configuration is a partial function [formula] mapping locations on the integer lattice to tiles. Any two locations p1  =  (x1,y1), p2  =  (x2,y2) in the domain of C (denoted dom(C)) are adjacent if ||p2  -  p1||  =  1 and the bond strength between any pair of tiles C(p1) and C(p2) at adjacent locations is G(gp2  -  p1(C(p1)),gp1  -  p2(C(p2)). A configuration is a τ-stable assembly or an assembly at temperature τ if dom(C) is connected on the lattice and, for any partition of dom(C) into two subconfigurations C1, C2, the sum of the bond strengths between tiles at pairs of locations p1∈dom(C1), p2∈dom(C2) is at least τ. Any pair of configurations C1, C2 are equivalent if there exists a vector [formula] such that [formula] and [formula] for all p∈dom(C1). Two τ-stable assemblies A1, A2 are said to assemble into a superassembly A3 if there exists a translation vector [formula] such that [formula] and A3 defined by the partial functions A1 and A2' with [formula] is a τ-stable assembly.

Each vertex of the mix graph M describes a two-handed assembly process. This process starts with a set of τ-stable input assemblies I. The set of assembled assemblies Q is defined recursively as I  ⊆  Q, and for any pair of assemblies A1,A2∈Q with superassembly A3, A3∈Q. Finally, the set of products P  ⊆  Q is the set of assemblies A such that for any assembly A', no superassembly of A and A' is in Q.

The mix graph M  =  (V,E) of S defines a set of two-handed assembly processes (called mixings) for the non-leaf vertices of M (called bins). The input assemblies of the mixing at vertex v is the union of all products of mixings at vertices v' with (v',v)∈E. The start bin function B defines the lone single-tile product of each mixings at a leaf bin. The system S is said to produce an assembly A if some mixing of S has a single product, A. We define the size of S, denoted S, to be |E|, the number of edges in M. If every mixing in a S has a single product, then S is a singular self-assembly system (SSAS).

The results of Section [\ref=sec:constant-glues] use the notion of a self-assembly system S' simulating a system S by carrying out the same sequence of mixings and producing a set of scaled assemblies. Formally, we say a system S'  =  (T',G',τ,M',B') simulates a system S  =  (T,G,τ,M,B) at scale b if there exist two functions f, g with the following properties:

The function [formula] maps the labels of b  ×  b regions of tiles (called blocks) to a label of a tile in T. The empty label [formula] denotes no tile.

The function g:S'  →  V maps a subset S' of the vertices of the mix graph M' to vertices of the mix graph M such that g is an isomorphism between the subgraph induced by S' in M' and the graph M.

Let P(v) be the set of products of the bin corresponding to vertex v in a mix graph. Then for each vertex v∈M with v'  =  g- 1(v), P(v)  =  {f(p)|p∈P(v')}.

Intuitively, f defines a correspondence between the b-scaled macrotiles in S' simulating tiles in S, and g defines a correspondence between bins in the systems. Property (3) requires that f and g do, in fact, define correspondence between what the systems produce.

The self-assembly systems constructed in Sections [\ref=sec:pcfgs-never-much-better-sas] and [\ref=sec:sass-much-better-than-pcfgs] produce only mismatch-free assemblies: assemblies in which every pair of incident sides of two tiles in the assembly have the same glue. A system is defined to be mismatch-free if every product of the system is mismatch-free.

Polyomino Context-Free Grammars

Here we describe polyominoes, a generalization of strings, and polyomino context-free grammars, a generalization of deterministic context-free grammars. These objects replace the strings and restricted context-free grammars (RCFGs) of Demaine et al. [\cite=Demaine-2012a].

A labeled polyomino or polyomino P  =  (S,L) is defined by a connected set of points S on the square lattice (called cells) containing (0,0) and a label function L:S  →  Σ(P) mapping each cell of P to a label contained in an alphabet Σ(P). The size of P is the number of cells P contains and is denoted |P|. The label of the cell at lattice point (x,y) is denoted L((x,y)) and we define P(x,y)  =  L((x,y)) for notational convenience. We refer to the label or color of a cell interchangeably.

Define a polyomino context-free grammar (PCFG) to be a quadruple G  =  (Σ,Γ,S,Δ). The set Σ is a set of terminal symbols and the set Γ is a set of non-terminal symbols. The symbol S∈Γ is a special start symbol. Finally, the set Δ consists of production rules, each of the form [formula] where N∈Γ and is the left-hand side symbol of only this rule, [formula], and each (xi,yi) is a pair of integers. The size of G is defined to be the total number of symbols on the right-hand sides of the rules of Δ.

A polyomino P can be derived by starting with S, the start symbol of G, and repeatedly replacing a non-terminal symbol with a set of non-terminal and terminal symbols. The set of valid replacements is Δ, the production rules of G, where a non-terminal symbol N with lower-leftmost cell at (x,y) can be replaced with a set of symbols R1 at (x  +  x1,y  +  y1), R2 at (x  +  x2,y  +  y2), [formula], Rj at (x  +  xj,y  +  yj) if there exists a rule [formula]. Additionally, the set of terminal symbol cells derivable starting with S must be connected and pairwise disjoint.

The polyomino P derived by the start symbol of a grammar G is called the language of G, denoted L(G), and G is said to derive P. In the remainder of the paper we assume that each production rule has at most two right-hand side symbols (equivalent to binary normal form for 1D CFGs), as any PCFG can be converted to this form with only a factor-2 increase in size. Such a conversion is done by iteratively replacing two right-hand side symbols Ri, Ri' with a new non-terminal symbol Q, and adding a new rule replacing Q with Ri and Ri'.

Intuitively, a polyomino context-free grammar is a recursive decomposition of a polyomino into smaller polyominoes. Because each non-terminal symbol is the left-hand side symbol of at most one rule, each non-terminal corresponds to a subpolyomino of the derived polyomino. Then each production rule is a decomposition of a subpolyomino into smaller subpolyominoes (see Figure [\ref=fig:pcfg-prod-rule-explanation]).

In this interpretation, the smallest grammar deriving a given polyomino is equivalent to a decomposition using the fewest distinct subpolyominoes in the decomposition. As for the smallest CFG for a given string, the smallest PCFG for a given polyomino is deterministic and finding such a grammar is NP-hard. Moreover, even approximating the smallest grammar is NP-hard [\cite=Charikar-2005], and achieving optimal approximation algorithms remains open [\cite=Jez-2013].

In Section [\ref=sec:pcfgs-never-much-better-sas] we construct self-assembly systems that produce assemblies whose label polyominoes are scaled versions of other polyominoes, with some amount of "fuzz" in each scaled cell. A polyomino P'  =  (S',L') is said to be a (c,d)-fuzzy replica of a polyomino P  =  (S,L) if there exists a vector 〈xt,yt〉 with the following properties:

For each block of cells S'(i,j)  =  {(x,y)|xt  +  di  ≤  x  <  xt  +  d(i + 1),yt  +  dj  ≤  y  <  yt  +  d(j + 1)} (called a supercell), [formula] if and only if (i,j)  ⊆  S.

For each supercell S'(i,j) containing a cell of P', the subset of label cells {(x,y)|xt  +  di  +  (d - c) / 2  ≤  x  <  xt  +  d(i + 1)  +  (d - c) / 2,yt  +  dj  +  (d - c) / 2  ≤  y  <  yt  +  d(j + 1)  +  (d - c) / 2} consists of c2 cells of P', with all cells having identical label, called the label of the supercell and denoted L(i,j).

For each supercell S'(i,j), any cell that is not a label cell of S'(i,j) has a common fuzz label in L'.

For each supercell S'(i,j), the label of the supercell L'(i,j)  =  P(i,j).

Properties (1) and (2) define how sets of cells in P' replicate individual cells in P, and the labels of these sets of cells and individual cells. Property (3) restricts the region of each supercell not in the label region to contain only cells with a common fuzz label. Property (4) requires that each supercell's label matches the label of the corresponding cell in P.

SAS over PCFG Separation Lower Bound

This result uses a set of shapes we call n-stagglers, an example is seen in Figure [\ref=fig:staggler]. The shapes consist of log n bars of dimensions n /  log n  ×  1 stacked vertically atop each other, with each bar horizontally offset from the bar below it by some amount in the range [formula]. We use the shorthand that log n  =  ⌊ log n⌋ for conciseness. Every sequence of log n - 1 integers, each in the range

[formula]

SAS over PCFG Separation Upper Bound

SAS over PCFG Separation Upper Bound Details

Next we show that the separation lower bound of the last section is nearly large as possible by giving an algorithm for converting any PCFG G into a SSAS S with system size O(|G| log n) such that S produces an assembly that is a fuzzy replica of the polyomino derived by G. Before describing the full construction, we present approaches for efficiently constructing general binary counters and for simulating glues using geometry.

The binary counter row assemblies used here are a generalization of those by Demaine et al. [\cite=Demaine-2008] consisting of constant-sized bit assemblies, and an example is seen in Figure [\ref=fig:binary-counter-row-ex]. Our construction achieves O( log n) construction of arbitrary ranges of rows and increment values, in contrast to the contruction of [\cite=Demaine-2008] that only produces row sets of the form [formula] that increment by 1. To do so, we show how to construct two special cases from which the generalization follows easily.

Let i,j,n be integers such that 0  ≤  i  ≤  j  <  n. There exists a SSAS of size O( log n) with a set of bins that, when mixed, assemble a set of j - i + 1 binary counter rows with values [formula] incremented by 1.

Representing integers as binary strings, consider the prefix tree induced by the binary string representations of the integers i through j, which we denote T(i,j). The prefix tree T(0,2m - 1) is a complete tree of height m, and the prefix tree T(i,j) with 0  ≤  i  ≤  j  ≤  2m - 1 is a subtree of T(0,2m - 1) with j - i + 1 leaf nodes See Figure [\ref=fig:conversion-algo-incrementors] for an example with m  =  4.

Now let n  =  2m - 1. If T(0,n) is drawn with leaves in left-to-right order by increasing integer values, then the leaves of the subtree T(i,j) appear contiguously. So the subtree T(i,j) has at most 2 log n internal nodes with one child forming the leftmost and rightmost paths in T(i,j). Furthermore, if one removes these two paths from T(i,j), the remainder of T(i,j) is a forest of complete trees with at most two trees of each height and 2 log n trees total.

Note that a complete subtree of the prefix tree corresponds to a set of all possible 2h suffixes of length h, where h is the height of the subtree. The leaves of such a subtree then correspond to the set of strings of length l with a specific prefix of length l  -  h and any suffix of length h. For the assemblies we use the same geometry-based encoding of each bit as [\cite=Demaine-2008], and a distinct set of glues used for each bit of the assembly encoding both the bit index and carry bit value from the previous bit.

Left and right bins. We build a mix graph (seen in Figure [\ref=fig:efficient-counter-range]) consisting of two disjoint paths of bins (called left bins and right bins) that are used to iteratively assemble partial counter rows i and j by the addition of distinct constant-sized assemblies for each bit. The partial rows are used to produce the assemblies in the subtree and missing bit bins (described next). In the suffix trees, the bit strings of these assemblies are progressively longer subpaths of the leftmost and rightmost paths in the subtree of binary strings of the integers i to j.

Subtree bins. Assemblies in subtree bins correspond to assemblies encoding prefixes of binary counter row values. However, unlike left and right bins that encode prefixes of only a single value, subtree bins encode prefixes of many binary counter values between i the j - namely a set of values forming a maximal complete subtree of the subtree of binary strings of integers from i to j, hence the name subtree bins. For example, if i = 12 and j = 16, then the set of binary strings for values 12 (01100b) to 15 (01111b) have a common prefix 011b. In this case a subtree bin containing an assembly encoding the three bits 011 would be created. Since there are at most 2 log n such complete subtrees, the number of subtree bins is at most this many. Creating each bin only requires a single mixing step of combining an assembly from a left or right bin with a single bit assembly, for example adding a 1-bit assembly to the left bin assembly encoding the prefix 01b.

Missing bit bins. To add the bits not encoded by the assemblies in the subtree bins, we create sets of four constant-sized assemblies in individual missing bit bins. Since the assemblies in subtree bins encode bit string prefixes of sets of values forming complete subtrees, completing these prefixes with any suffix forms a bit string whose value is between i and j. This allows complete non-determinism in the bit assemblies that attach to complete the counter row, provided they properly handle carry bits. For every bit index missing in some subtree bin assembly, the four assemblies encoding the four possibilities for the input and carry values are assembled and placed into separate bins. When all bins are mixed, subtree assemblies mix non-deterministically with all possible assemblies from missing bit bins, producing all counter rows whose binary strings are found in the subtree. In total, up to 4 log n missing bit bins are created, and each contains a constant-sized assembly and so requires constant work to produce.

The total number of total bins is clearly O( log n). Consider mixing the left and right bins containing completed counter rows for i and j, all subtree bins, and all missing bit bins. Any assembly produced by the system must be a complete binary counter row, as all assemblies are either already complete rows (left and right bins) or are partial assemblies (subtree bins and missing bit bins) that can be extended towards the end of the bit string by missing bit bin assemblies, or towards the start of the bit string by missing bit and then subtree bin assemblies.

The second counter generalization is incrementing by non-unitary values:

Let k,n be integers such that 0  ≤  k  ≤  n and n  =  2m. There exists a SSAS of size O( log n) with a set of bins that, when mixed, assemble a set of 2m binary counter rows with values [formula] incremented by k.

For each row, the incremented value of the bth bit of the row depends on three values: the previous value of the bth bit, the carry bit from the (b - 1)st addition, and the bth bit of k. The resulting output is a pair of bits: the resulting value of the bth bit and the bth carry bit (seen in Table [\ref=table:incrementor_bit_values]).

Create a set of four O(1)-tile subassemblies for each bit of the counter, selecting from the first or second half of the combinations in Table [\ref=table:incrementor_bit_values], resulting in 4 log n assemblies total. Each subassembly handles a distinct combination of the bth bit value of the previous row, (b - 1)st carry bit, and bth bit value of k by encoding each possibility as a distinct glue. When mixed in a single bin, these subassemblies combine in all possible combinations and producing all counter rows from 0 to 2m - 1.

Let i,j,k,n be integers such that 0  ≤  i  ≤  j  <  n and 0  ≤  k  ≤  n. There exists a SSAS of size O( log n) with a set of bins that, when mixed, assemble a set of j - i + 1 binary counter rows with values [formula] incremented by k.

Combine the constructions used in the proofs of Lemmas [\ref=lem:efficient-incrementors-range-sas] and [\ref=lem:efficient-incrementors-value-sas] by using mixing sequences as in the proof of Lemma [\ref=lem:efficient-incrementors-range-sas] and sets of four subassemblies encoding input, carry, and increment bit values as in the proof of Lemma [\ref=lem:efficient-incrementors-value-sas].

Theorem 8 of Demaine et al. [\cite=Demaine-2008] describes how to reduce the number of glues used in a system by replacing each tile with a large macrotile assembly, and encoding the tile's glues via unique geometry on the macrotile's sides. We prove a similar result for labeled tiles, used for proving Theorems [\ref=thm:sas-over-pcfg-upper-bound], [\ref=thm:sas-over-pcfg-upper-bound-constant-glues], and [\ref=thm:constant-glues].

Any mismatch-free τ  =  1 SAS (or SSAS) S  =  (T,G,τ,M) can be simulated by a SAS (or SSAS) S' at τ = 1 with O(1) glues, system size O(Σ(T)|T|  +  |S|), and O( log |G|) scale.

The proof is constructive. Produce a set of north macroglue assemblies for the glue set: O( log |G|)  ×  O(1) assemblies, each encoding the integer label of a glue i via a sequence of bumps and dents along the north side of the assembly representing the binary sequence of bits for i, as seen in Figure [\ref=fig:glue-bit-encoding]. All north macroglue assemblies share a pair of common glues: an inner glue on the west end of the south side of the assembly (green in Figure [\ref=fig:glue-bit-encoding]) and an outer glue on the west end of the north side of the assembly (blue in Figure [\ref=fig:glue-bit-encoding]). The null glue also has the sequence of bumps and dents (encoding 0), but lacking the outer glue. Repeating this process three more times yields sets of east, west, and south macroglue assemblies.

For each label l∈Σ(T), repeat the process of producing the macroglue assemblies once using a tile set exclusively labeled l. Also produce a square Θ( log |G|)  ×  Θ( log |G|) core assembly, with a single copy of the inner glue on the counterclockwise end of each face. Use the macroglue and core assemblies to produce a set of macrotiles, one for each t∈T, consisting of a core assembly whose tiles have the label of t, and four glue assemblies encode the four glues of t and whose tiles have the label of t. Extend the mix graph M' of S' by carrying out the mixings of M but starting with the equivalent macrotiles. Define the simulation function f to map each macrotile to the label found on the macrotile, and the function g to take the portion of M' and g to be the portion of the mix graph carrying out the mixings of S.

The work done to produce the glue assemblies is O(Σ(T)|G|), to produce the core assemblies is O(Σ(T) log  log |G|), and to produce the macrotiles is O(|T|). Carrying out the mixings of S requires O(|S|) work. Since each macrotile is used in at least one mixing simulating a mixing in S, |T|  ≤  |S|. Additionally, |G|  ≤  4|T|. So the total system size is O(Σ(T)|G|  +  Σ(T) log  log |G|  +  |T|  +  |S|)  =  O(Σ(T)|T|  +  |S|).

Armed with these tools, we are ready to convert PCFGs into SSASs. Recall that in Section [\ref=sec:pcfgs-slightly-better-sas-ssas] we showed that in the worst case, converting a PCFG into a SSAS (or SAS) must incur an Ω( log n  /   log  log n)-factor increase in system size. Here we achieve a O( log n)-factor increase.

For any polyomino P with |P|  =  n derived by a PCFG G, there exists a SSAS S with |S|  =  O(|G| log n) producing an assembly with label polyomino P', where P' is a (O( log n),O(n))-fuzzy replica of P.

We combine the macrotile construction of Lemma [\ref=lem:constant-glues], the generalized counters of Lemma [\ref=lem:efficient-incrementors-sas], and a macrotile assembly invariant that together enable efficient simulation of each production rule in a PCFG by a set of O( log n) mixing steps.

Macrotiles. The macrotiles used are extended versions of the macrotiles in Lemma [\ref=lem:constant-glues] with two modifications: a secondary, resevoir macroglue assembly on each side of the tile in addition to a primary bonding macroglue, and a thin cage of dimensions Θ(n)  ×  Θ( log n) surrounding each resevoir macroglue (see Figure [\ref=fig:conversion-macrotile]).

Mixing a macrotile with a set of bins containing counter row assemblies constructed by Lemma [\ref=lem:efficient-incrementors-sas] causes completed (and incomplete) counter rows to attach to the macrotile's macroglues. Because each macroglue's geometry matches the geometry of exactly one counter row, a partially completed counter row that attaches can only be completed with bit assemblies that match the macroglue's value. As a result, mixing the bin sets of Lemma [\ref=lem:efficient-incrementors-sas] with an assembly consisting of macrotiles produces the same set of products as mixing a completed set of binary counter rows with the assembly.

An attached counter row effectively causes the macroglue's value to change, as it presents geometry encoding a new value and covers the macroglue's previous value. The cage is constructed to have height sufficient to accomodate up to n counter rows attached to the reservoir macroglue, but no more.

Because of the cage, no two macrotiles can attach by their bonding macroglues unless the macroglue has more than n counter rows attached. Alternatively, one can produce a thickened counter row with thickness sufficient to extend beyond the cage. We call such an assembly a macroglue activator, as it "activates" a bonding macroglue to being able to attach to another promoted macroglue on another macrotile. Notice that a macroglue activator will never attach to a bonding macroglue's resevoir twin, as the cage is too small to contain the activator.

An invariant. Counter rows and activators allow precise control of two properties of a macrotile: the identities of the macroglues on each side, and whether these glues are activated. In a large assembly containing many macroglues, the ability to change and activate glues allows precise encoding of how an assembly can attach to others. In the remainder of the construction we maintain the invariant that every macrotile has the same glue identity on all four sides, and any macrotile assembly consists of macrotiles with glue identities forming a contiguous interval, e.g. 4, 5, 6, 7. Intervals are denoted

[formula]

.

By Lemma [\ref=lem:efficient-incrementors-sas], a set of row counters incrementing the glue identities of all glues on a macrotile can be produced using O( log n) work. Activators, by virtue of being nearly rectangular with O( log n) cells of bit geometry can also be produced using O( log n) work.

Production rule simulation. Consider a PCFG with non-terminal N and production rule N  →  (R1,(x1,y1))(R2,(x2,y2)) and a SSAS with two bins containing assemblies A1, A2 with the label polyominoes of A1 and A2 being fuzzy replicas of the polyominoes derived by R1 and R2. Also assume A1 and A2 are assembled from the macrotiles just described, including the invariant that the identities of the glues on A1 and A2 are identical on all sides of a macrotile and contiguous across the assembly, i.e. the identities of the glues are

[formula]

on assemblies A1 and A2, respectively.

Select two cells cR1, cR2, in the polyominoes derived by R1 and R2 adjacent in polyomino derived by N. Define the glue identities of the two macrotiles forming the supercells mapped to cR1 and cR2 to be g1 and g2. Then the glue sets on A1 and A2 can be decomposed into three subsets

[formula]

,

[formula]

,

[formula]

, respectively. We change these glue values in three steps:

Construct two sets of row counters that increment i1 through g1 by j1  -  i1  +  1 and i2 through g2 by g2  -  i2  +  1, and mix them in separate bins with A1 and A2 to produce two new assemblies A1' and A2'. Assemblies A1' and A2' have glues

[formula]

, respectively, and the macroglues with values g1 and g2 now have values g1'  =  g1  +  (g1  -  i1)  +  j1  +  1 and g2'  =  g2, i.e. the glues of A1' and A2' are

[formula]

.

Construct a set of row counters that increment the values of all glues on A2' by g2'  -  g1'  +  1 if this value is positive, and mix the counters with A2' to produce A2''. Then the macroglue with value g2' now has value g2''  =  g1'  +  1 and the glue values of A1' and A2'' are

[formula]

.

Construct a pair of macroglue activators with values g1' and g2'' that attach to the pair of macroglue sides matching the two adjacent sides of cells cR1 and cR2. Mix each activator with the corresponding assembly A1' or A2''.

Mixing A1' and A2'' with the pair of activated macroglues causes them to bond in exactly one way to form a superassembly A3 whose label polyomino is a fuzzy replica of the polyomino derived by N. Moreover, the glue values of the macrotiles in A3 are

[formula]

Applying Lemma [\ref=lem:constant-glues] to the construction (creating macrotiles of macrotiles) gives a constant-glue version of Theorem [\ref=thm:sas-over-pcfg-upper-bound]:

For any polyomino P with |P|  =  n derived by a PCFG G, there exists a SSAS [formula] using O(1) glues with ||  =  O(|G| log n) producing an assembly with label polyomino P', where P' is a (O( log n log  log n),O(n log  log n))-fuzzy replica of P.

The construction of Theorem [\ref=thm:sas-over-pcfg-upper-bound] uses O( log n) glues, namely for the counter row subconstruction of Lemma [\ref=lem:efficient-incrementors-sas]. With the exception of the core assemblies, all tiles of S have a common fuzz (gray) label, so creating macrotile versions of these tiles and carrying out all mixings involving these macrotiles and completed core assemblies is possible with O(1  ·  |T|  +  |S|)  =  O(|S|) mixings and scale O( log  log n). Scaled core assemblies of size Θ(n log  log n)  ×  Θ(n log  log n) can be constructed using constant glues and O( log (n log  log n))  =  O( log n) mixings, the same number of mixings as the unscaled Θ(n)  ×  Θ(n) core assemblies of Theorem [\ref=thm:sas-over-pcfg-upper-bound]. So in total, this modified construction has system size O(|S|)  =  O(|G| log n) and scale O( log  log n). Thus it produces an assembly with label polyomino that is a (O( log n log  log n),O(n log  log n))-fuzzy replica of P.

The results in this section and Section [\ref=sec:pcfgs-slightly-better-sas-ssas] achieve a "one-sided" correspondence between the smallest PCFG and SSAS encoding a polyomino, i.e. the smallest PCFG is approximately an upper bound for the smallest SSAS (or SAS). Since the separation upper bound proof (Theorem [\ref=thm:sas-over-pcfg-upper-bound]) is constructive, the bound also yields an algorithm for converting a a PCFG into a SSAS.

PCFG over SAS and SSAS Separation Lower Bound

PCFG over SAS and SSAS Separation Lower Bound Details

Here we develop a sequence of PCFGs over SAS and SSAS separation results, all within a polylogarithmic factor of optimal. The results also hold for polynomially scaled versions of the polyominoes, which is used to prove Theorem [\ref=thm:constant-glues] at the end of the section. This scale invariance also surpasses the scaling of the fuzzy replicas in Theorems [\ref=thm:sas-over-pcfg-upper-bound] and [\ref=thm:sas-over-pcfg-upper-bound-constant-glues], implying that this relaxation of the problem statement in these theorems was not unfair.

General shapes

General shapes

We show that the separation of PCFGs over SASs and SSASs is Ω(n /  log n) using a weak binary counter, seen in Figure [\ref=fig:taste]. These shapes are macrotile versions of the doubly-exponential counters found in [\cite=Demaine-2008] with three modifications:

Each row is a single path of tiles, and any path through an entire row uniquely identifies the row.

Adjacent rows do not have adjacent pairs of tiles, i.e. they do not touch.

Consecutive rows attach at alternating (east, west, east, etc.) ends.

In this section we describe an efficient system for assembling a set of shapes we call weak counters. An example of a rows in the original counter and macrotile weak counter are shown in Figure [\ref=fig:weak-counter-ex]. These shapes are macrotile versions of the doubly-exponential counters found in [\cite=Demaine-2008] with three modifications:

Each row is a single path of tiles, and any path through an entire row uniquely identifies the row.

Adjacent rows do not have adjacent pairs of tiles, i.e. they do not touch.

Consecutive rows attach at alternating (east, west, east, etc.) ends.

Figure [\ref=fig:weak-counter-mate] shows three consecutive counter rows attached in the final assembly. Each row of the doubly-exponential counter consists of small, constant-sized assemblies corresponding to 0 or 1 values, along with a 0 or 1 carry bit. We implement each assembly as a unique path of tiles and assemble the counter as in [\cite=Demaine-2008], but using these path-based assemblies in place of the original assemblies. We also modify the glue attachments to alternate on east and west ends of each row. Because the rows alternate between incrementing a bit string, and simply encoding it, alternating the attachment end is trivial. Finally, note that adjacent rows only touch at their attachment, but the geometry encoded into the row's path prevents non-consecutive rows from attaching.

There exists a τ  =  1 SAS of size O(b) that produces a 2b-bit weak counter.

The counter is an O(1)-scaled version of the counter of Demaine et al [\cite=Demaine-2008]. They show that such an assembly is producible by a system of size O(b).

For any PCFG G deriving a 2b-bit weak counter, |G|  =  Ω(22b).

Define a minimal row spanner of row Ri to be a non-terminal symbol N of G with production rule N  →  (B,(x1,y1))(C,(x2,y2)) such that the polyomino derived by N contains a path between a pair of easternmost and westernmost tiles of the row and the polyominoes derived by B and C do not. We claim that each row (trivially) has at least one minimal row spanner and each non-terminal of G is a minimal row spanner of at most one unique row.

First, suppose by contradiction that a non-terminal N is a minimal row spanner for two distinct rows. Because N is connected and two non-adjacent rows are only connected to each other via an intermediate row, N must be a minimal row spanner for two adjacent rows Ri and Ri + 1. Then the polyominoes of B and C each contain tiles in both Ri and Ri + 1, as otherwise either C or B is a minimal row spanner for Ri or Ri + 1.

Without loss of generality, assume B contains a tile at the end of Ri not adjacent to Ri + 1. But B also contains a tile in Ri + 1 and (by definition) is connected. So B contains a path between the east and west ends of row Ri, and thus N is a not a minimal row spanner for ri. So N is a minimal row spanner for at most one row.

Next, note that the necessarily-serpentine path between a pair of easternmost and westernmost tiles of a row in a minimal row spanner uniquely encodes the row it spans. So the row spanned by a minimal row spanner is unique.

Because each non-terminal of G is a minimal row spanner for at most one unique row, G must have at least 22b non-terminal symbols and total size Ω(22b).

The separation of PCFGs over τ  =  1 SASs for single-label polyomines is Ω(n / ( log  log n)2).

By the previous two lemmas, there exists a SAS of size O(b) producing a b-bit weak counter, and any PCFG deriving this shape has size Ω(22b). The assembly itself has size n  =  Θ(22bb), as it consists of 22b rows, each with b subassemblies of constant size. So the separation is Ω((n / b) / b)  =  Ω(n / ( log  log n)2).

In [\cite=Demaine-2008], the O( log  log n)-sized SAS constructing a log n-bit binary counter repeatedly doubles the length of each row (i.e. number of bits in the counter) using O(1) mixings per doubling. Achieving such a technique in a SSAS seems impossible, but a simpler construction producing a b-bit counter with O(b) work can be done by using a unique set of O(1) glues for each bit of the counter. In this case, mixing these reusable elements along with a previously-constructed pair of first and last counter rows creates a single mixing assembling the entire counter at once. Modifying the proof of Theorem [\ref=thm:pcfgs-over-sas-single-label-gen] to use this construction gives a similar separation for SSASs:

The separation of PCFGs over τ  =  1 SSASs for single-label polyominoes is Ω(n /  log 2n).

Rectangles

Rectangles

For the weak counter construction, the lower bound in Lemma [\ref=lem:pcfg-weak-counter-lower-bound] depended on the poor connectivity of the weak counter polyomino. This dependancy suggests that such strong separation ratios may only be achievable for special classes of "weakly connected" or "serpentine" shapes. Restricting the set of shapes to rectangles or squares while keeping an alphabet size of 1 gives separation of at most O( log n), as any rectangle of area n can be derived by a PCFG of size O( log n).

But what about rectangles with a constant-sized alphabet? In this section we achieve surprisingly strong separation of PCFGs over SASs and SSASs for rectangular constant-label polyominoes, nearly matching the separation achieved for single-label general polyominoes. A separation of Ω(n /  log n) is achieved using an end-to-end binary counter polyomino, seen in Figure [\ref=fig:taste].

The construction

The polyominoes constructed resemble binary counters whose rows have been arranged in sequence horizontally, and we call them b-bit end-to-end counters. Each row of the counter is assembled from tall, thin macrotiles (called bars), each containing a color strip of orange, purple, or green. The color strip is coated on its east and west faces with gray geometry tiles that encode the bar's location within the counter.

Each row of the counter has a sequence of green and purple display bars encoding a binary representation of the row's value and flanked by orange reset bars (see Figure [\ref=fig:rect-structure]). An example for b  =  2 bits can be seen in Figure [\ref=fig:rect-pattern].

Each bar has dimensions O(1)  ×  3( log 2b  +  b  +  2), sufficient for encoding two pieces of information specifying the location of the bar within the assembly. The row bits specify which row the bar lies in (e.g. the 7th row). The subrow bits specify where within the row the bar lies (e.g. the 4th bit). The subrow value starts at 0 on the east side of a reset bar, and increments through the display bars until reaching b + 1 on the west end of the next reset bar. Bars of all three types with row bits ranging from 0 to 2b - 1 are produced.

Efficient assembly

The counter is constructed using a SAS of size O(b) in two phases. First, sequences of O(b) mixings are used to construct five families of bars: 1. reset bars, 2. 0-bit display bars resulting from a carry, 3. 0-bit display bars without a carry, 4. 1-bit display bars resulting from a carry, 5. 1-bit display bars without a carry, The mixings product five bins, each containing all of the bars in the family. These five bins are then combined into a final bin where the bars attach to form the Θ(2b)  ×  Θ(b) rectangular assembly. The five families are seen in Figure [\ref=fig:rect-schema].

Efficient O(b) assembly is achieved by careful use of the known approach of non-deterministic assembly of single-bit assemblies as done in [\cite=Demaine-2008]. Assemblies encoding possible input bit and carry bit value combinations for each row bit and subrow bit are constructed and mixed together, and the resulting products are every valid set of input and output bit strings, i.e. every row of a binary counter assembly.

As a warmup, consider the assembly of all reset bars. For these bars, the west subrow bits encode b and the east subrow bits encode 0. The row bits encode a value i on the west side, and i + 1 on the east side, for all i between 0 and 2b - 1. Constructing all such bars using O(b) work is straightforward. For each of the log 2b  +  1 subrow bits, create an assembly where the west and east bits are 1 and 0 respectively, except for the most significant bit (bit log 2b + 1), where the west and east bits are both 0.

For the row bits we use the same technique as in [\cite=Demaine-2008] and extended in Lemma [\ref=lem:efficient-incrementors-value-sas]: create a constant-sized set of assemblies for each bit that encode input and output value and carry bits. For bits 1 through b - 1 (zero-indexed) create four assemblies corresponding to the four combinations of value and carry bits, for bit 0 create two assemblies corresponding to value bits (the carry bit is always 1), for bit b create three assemblies corresponding to all combinations except both value and carry bits valued 1, and for bit b + 1 create a single assembly with both bits valued 0. Give each bit assembly a unique south and north glue encoding its location within the bar and carry bit value, and give all bit assemblies a common orange color strip. Mixing these assemblies produces all reset bars, with subrow west and east values of b and 0, and row values i and i + 1 for all i from 0 to 2b - 1.

In contrast to producing reset bars, producing display bars is more difficult. The challenge is achieving the correct color strip relative to the subrow and row values. Recall that the row value i locates the bar's row and the subrow value j locates the bar within this row. So the correct color strip for a bar is green if the jth bit of i is 0, and purple if the jth bit of i is 1.

We produce four families of display bars, two for each value of the jth bit of of i. Each subfamily is produced by mixing a subrow assembly encoding j on both east and west ends with three component assemblies of the row value: the least significant bits (LSB) assembly encoding bits 1 through j - 1 of i, the most significant bits (MSB) assembly encoding bits j + 1 through b of i, and the constant-sized jth bit assembly. This decomposition is seen in the bottom half of Figure [\ref=fig:rect-schema].

The four families correspond to the four input and carry bit values of the jth bit. These values determine what collections of subassemblies should appear in the other two components of the row value. For instance, if the input and carry bit values are both 1, then the LSB assembly must have all 1's on its west side (to set the jth carry bit to 1) and all 0's on its east side. Similarly, the MSB assembly must have some value p encoded on its west side and the value p + 1 encoded on its east side, since the jth bit and and jth carry bit were both 1, so the (j + 1)st carry bit is also 1.

Notice that each of the four families has b subfamilies, one for each value of j. Producing all subfamilies of each family is possible in O(b) work by first recursively producing a set of b bins containing successively larger sets of MSB and LSB assemblies for the family. Then each subfamily can be produced using O(1) amortized work, mixing one of b sets of LSB assembly subfamilies, one of b sets of MSB assemblies, and the jth bit assembly together. For instance, one can produce the set of b sets of MSB assemblies encoding pairs of values p and p + 1 on bits b - 1 through b, b - 2 through b, etc. by producing the set on bits k through b, then adding four assemblies to this bin (those encoding possible pairs of inputs to the (k - 1)st bit) to produce a similar set on bits k - 1 through b.

There exists a τ  =  1 SAS of size O(b) that produces a b-bit end-to-end counter.

This follows from the description of the system. The five families of bars can each be produced with O(b) work and the bars can be combined together in a single mixing to produce the counter. So the system has total size O(b).

For any PCFG G deriving a b-bit end-to-end counter, |G|  =  Ω(2b).

Let G be a PCFG deriving a b-bit end-to-end counter. Define a minimal row spanner to be a non-terminal symbol N with production rule N  →  (B,(x1,y1))(C,(x2,y2)) such that the polyomino derived by N (denoted pN) horizontally spans the color strips of all bars in row Ri including the reset bar at the end of the row, while the polyominoes derived by B and C (denoted pB and pC) do not. Consider the bounding box D of these color strips (see Figure [\ref=fig:rect-proof]).

Without loss of generality, pB intersects the west boundary of D but does not reach the east boundary, while pC intersects the east boundary but does not reach the west boundary, so any location at which pB and pC touch must lie in D. Then any row spanned by pN and not spanned by pB or pC must lie in D, since spanning it requires cells from both pB and pC. So pN is a minimal row spanner for at most one row: row Ri.

Because the sequence of green and purple display bars found in D is distinct and separated by display bars in other rows by orange reset bars, each minimal row spanner spans a unique row Ri. Then since each non-terminal is a spanner for at most one unique row, G must have 2b non-terminal symbols and |G|  =  Ω(2b).

The separation of PCFGs over τ  =  1 SASs for constant-label rectangles is Ω(n /  log 3n).

By construction, a b-bit end-to-end counter has dimensions Θ(2bb)  ×  Θ(b). So n  =  Θ(2bb2) and b  =  Θ( log n). Then by the previous two lemmas, the separation is Ω((n / b2) / b)  =  Ω(n /  log 3n).

We also note that a simple replacement of orange, green, and purple color strips with distinct horizontal sequences of black/white color substrips yields the same result but using fewer distinct labels.

Squares

Squares

The rectangular polyomino of the last section has exponential aspect ratio, suggesting that this shape requires a large PCFG because it approximates a patterned one-dimensional assemblies reminiscent of those in [\cite=Demaine-2012a]. Creating a polyomino with better aspect ratio but significant separation is possible by extending the polyomino's labels vertically. For a square this approach gives a separation of PCFGs over SASs of [formula], non-trivial but far worse than the rectangle.

Our final result achieves Ω(n /  log n) separation of PCFGs over SASs for squares using a block binary counter (seen in Figure [\ref=fig:taste]). Each "row" of the counter is actually a set of concentric square rings called a block.

The construction

In this section we describe a polyomino that is square but contains an exponential number of distinct subpolyominoes such that each subpolyomino has a distinct "minimal spanner", using the language of the proof of Lemma [\ref=lem:pcfg-end-to-end-counter-lower-bound]. These subpolyominoes use circular versions of the vertical bars of the construction in Section [\ref=sec:sas-much-better-pcfgs-rectangle] arranged concentrically rather than adjacently. We call the polyomino a b-bit block counter, and an example for b = 2 is seen in Figure [\ref=fig:square-pattern].

Each block of the counter is a Θ(b2)  ×  Θ(b2) square subpolyomino encoding a sequence of b bits via a sequence of concentric rectangular rings of increasing size. Each ring has a color loop encoding the value of a bit, or the start or end of the bit sequence (the interior or exterior of the block, respectively). The color loop actually has three subloops, with the center loop's color (green, purple, light blue, or dark blue in Fig. [\ref=fig:square-pattern]) indicating the bit value or sequence information, and two surrounding loops (light or dark orange in Fig. [\ref=fig:square-pattern]) indicating the interior and exterior sides of the loop.

Efficient assembly of blocks

Though each counter block is square, they are constructed similarly to the end-to-end counter rows of Section [\ref=sec:sas-much-better-pcfgs-rectangle] by assembling the vertical bars of each ring together into horizontal stacks of assemblies. Horizontal slabs are added to "fill in" the remaining portions of each block.

The bars are identical to those found in Section [\ref=sec:sas-much-better-pcfgs-rectangle] with three modifications (seen in Figure [\ref=fig:square-structure]). First, each bar has additional height according to the value of the subrow bits (8 tiles for every increment of the bits). Second, each bar has four additional layers of tiles on the side (east or west) facing the interior of the block, with color bits at the north and south ends of the side encoding three values: 11b (if the center color subloop is purple, a 1-bit), 00b (if the center color subloop is green, a 0-bit), or 01b (if the center color subloop is dark blue, the end of the bit sequence). The additional layers are used to fill in gaps between adjacent rings left by protruding geometry, and the bit values are used to control the attachment of the horizontal slabs of each ring.

Third, the reset bars used in Section [\ref=sec:sas-much-better-pcfgs-rectangle] are replaced with two kinds of bars: start bars and end bars, seein in Figure [\ref=fig:square-schema-starts-ends]. End bars form the outermost rings of each block, and the start bars form the square cores of each block. Both start and end bars "reset" the subrow counters, and the east end bars increment the row value.

Recall that the vertical bars of the end-to-end counter in Section [\ref=sec:sas-much-better-pcfgs-rectangle] were constructed using O(b) total work by amortizing the constructing subfamilies of MSB and LSB assemblies for each subrow value j. We use the same trick here for these assemblies as well as the new assemblies on the north and south ends of each bar containing the color bits. In total there are twelve families of vertical bar assemblies (four families of west display bars, four families of east display bars, and two families each of start and end bars), and each is assembled using O(b) work.

Finally, the horizontal slabs of each ring are constructed as six families, each using O(b) work, as seen in Figure [\ref=fig:square-schema-horizontals].

Efficient assembly of the counter

Once the families of vertical bars and horizontal slabs are assembled into blocks, we are ready to arrange them into a completed counter. Each row of the counter has [formula] blocks. So assuming b is even, the b / 2 least significant bits of the westmost block of each row are 0's, and of the eastmost block are 1's. Before mixing the vertical bar families together, we "cap" the east end bar of each block at the east end of a row by constructing a set of thin assemblies (right part of Figure [\ref=fig:square-schema-caps]) and mixing them with the family of east end bars.

After this modification to the east end bar family, mixing all vertical bar families results in 2b / 2 assemblies, each forming most of a row of the block counter. Mixing these assemblies with the families of horizontal slabs results in a completed set of block counter rows, each containing 2b / 2 square assemblies with dimensions Θ(b2)  ×  Θ(b2), forming 2b / 2 rectangles with dimensions Θ(2b / 2b2)  ×  Θ(b2).

To arrange the rows vertically into a complete block counter, a vertically-oriented version of the end-to-end counter of Section [\ref=sec:sas-much-better-pcfgs-rectangle] with geometry instead of color strips (left part of Fig. [\ref=fig:square-schema-caps]) is assembled and used as a "backbone" for the rows to attach into a combined assembly. This modified end-to-end counter (see Figure [\ref=fig:square-schema-vert-counter]) has subrow values from 0 to b / 2, for the b / 2 most signficant bits of the row value of each block, and row values from 0 to 2b / 2. Modified versions of reset bars with height (width in the horizontal end-to-end counter) Θ(b2) are used to bridge across the geometry-less portions of the west sides of the blocks, as well as the always-zero b / 2 least significant bits of the block's row value and subrow log 2b bits.

This modified end-to-end counter can be assembled using O(b) work as done for the original end-to-end counter, since the longer reset bars only add O( log (b2))  =  O( log b) work to the assembly process. After the vertical end-to-end counter has been combined with the blocks to form a complete block counter, a horizontal end-to-end counter is attached to the top of the assembly to produce a square assembly.

For even b, there exists a τ = 1 SAS of size O(b) that produces a b-bit block counter.

The construction described builds families of vertical bars and horizontal slabs that are used to assemble each the rings forming all blocks in the counter. There are a constant number of families, and each family can be assembled using O(b) work. The vertical and horizontal end-to-end counters can also be assembled using O(b) work each by Lemma [\ref=lem:sas-rect-ub]. Then the b-bit block counter can be assembled by a SAS os size O(b).

We now consider a lower bound for any PCFG G deriving the counter, using a similar approach as Lemma [\ref=lem:pcfg-end-to-end-counter-lower-bound].

For any PCFG G deriving a b-bit block counter, |G|  =  Ω(2b).

Define a minimal block spanner as to be a non-terminal symbol N in G with production rule N  →  (B,(x1,y1))(C,(x2,y2)) such that the polyomino derived by N (denoted pN) contains a path from a gray cell outside the color loop of the end ring of the counter to a gray cell inside the start color loop of the counter, and the polyominoes derived by B and C (denoted pB and pC) do not.

First we show that any minimal block spanner is a spanner for at most one block. Assume by contradiction and that N is a minimal block spanner for two blocks Bi and Bj and that pB contains a gray cell inside the start color loop of Bi. Then B must be entirely contained in the color loop of the end ring of Bi, as otherwise N is not a minimal block spanner for Bi. Similarly, C must then be entirely contained in the color loop of the end ring of Bj. Since no pair of color loops from distinct blocks have adjacent cells, pN is not a connected polyomino and so G is not a valid PCFG.

Next we show that the block spanned by N is unique, i.e. N cannot be reused as a minimal spanner for multiple blocks. See Figure [\ref=fig:square-proof1]. Let N be a minimal spanner for a block Bi and p be a path of cells in pN starting at a gray cell contained in the start ring of Bi and ending at a gray cell outside the end ring of Bi. Consider a traversal of p, maintaining a stack containing the color loops crossed during the traversal. Crossing a color loop from interior to exterior (a sequence of dark orange, then green, purple, or blue, then light orange cells) adds the center subloop's color to the stack, and traversing from exterior to interior removes the topmost element of the stack.

We claim that the sequence of subloop colors found in the stack after traversing an end ring from interior to exterior encodes a unique sequence of display rings and thus a unique block. To see why, first consider that the color loop of every ring forms a simple closed curve. Then the Jordan curve theorem implies that entering or leaving each region of gray cells between adjacent color loops requires traversing the color loop. Then by induction on the steps of p, the stack contains the set of rings not containing the current location on p in innermost to outermost order. So the stack state after exiting the exterior of the end ring uniquely identifies the block containing p and N is a minimal spanner for this unique block.

Since there are 2b distinct blocks in a b-bit block counter, any PCFG that generates a counter has at least 2b non-terminal symbols and size Ω(2b).

The separation of PCFGs over τ = 1 SASs for constant-label squares is Ω(n /  log 3n).

By construction, a b-bit block counter has size Θ(2bb2)  =  n and so b  =  Θ( log n). By the previous two lemmas, the separation is Ω((n / b2) / b)  =  Ω(n /  log 3n).

Unlike the previous rectangle construction, it does not immediately follow that a similar separation holds for 2-label squares. Finding a construction that achieves nearly-linear separation but only uses two labels remains an open problem.

Constant-glue constructions

Lemma [\ref=lem:constant-glues] proved that any system S can be converted to a slightly larger system (both in system size and scale) that simulates S. Applying this lemma to the constructions of Section [\ref=sec:sass-much-better-than-pcfgs] yields identical results for constant-glue systems:

All results in Section [\ref=sec:sass-much-better-than-pcfgs] hold for systems with O(1) glues.

Lemma [\ref=lem:constant-glues] describes how to convert any SAS or SSAS S  =  (T,G,τ,M) into a macrotile version of the system S' that uses a constant number of glues, has system size O(Σ(T)|T|  +  |S|), and scale factor O( log |G|). Additionally, the construction achieves matching labels on all tiles of each macrotile, including the glue assemblies. Because the labels are preserved, the polyominoes produced by each macrotile system S' simulating an assembly system S in Section [\ref=sec:sass-much-better-than-pcfgs] preserves the lower bounds for PCFGs (Lemmas [\ref=lem:pcfg-weak-counter-lower-bound], [\ref=lem:pcfg-end-to-end-counter-lower-bound], and [\ref=lem:pcfg-block-counter-lower-bound]) of each construction. Moreover, the number of labels in the polyomino is constant and so |S'|  =  O(|T|  +  |S|)  =  O(|S|) and the system size of each construction remains the same. Finally, the scale of the macrotiles is O( log |G|)  =  O( log |S|  =  O( log b), so n is increased by a O( log 2b)-factor, but since n was already exponential in b, it is still the case that b  =  Θ( log n) and so the separation factors remain unchanged.

Conclusion

As the results of this work show, efficient staged assembly systems may use a number of techniques including, but not limited to, those described by local combination of subassemblies as captured by PCFGs. It remains an open problem to understand how the efficient assembly techniques of Section [\ref=sec:pcfgs-never-much-better-sas] and Section [\ref=sec:sass-much-better-than-pcfgs] relate to the general problem of optimally assembling arbitrary shapes.

Acknowledgements

We thank Benjamin Hescott and anonymous reviewers for helpful comments and feedback that greatly improved the presentation of the paper.