Recursive Secret Sharing for Distributed Storage and Information Hiding

Introduction

An information theoretically secure k-out-of-n secret sharing technique used to share a secret of size b requires a total storage space of size b  ·  n. Since, k - 1 shares do not reveal any information about the secret, such techniques use k - 1 random elements of size b in order to create the shares. In this paper, we propose that these random elements be replaced with certain hidden information that may serve as a steganographic channel. Note that if a secret sharing scheme uses k - 1 random elements then k - 1 is the upper limit on the number of secrets that can be hidden. We hide k - 2 secrets which is near optimal.

If user A transmits a secret message to user B over a public channel, he may divide the message into several pieces (possibly redundant) and send the pieces on parallel channels, such that an eavesdropper may need to compromise at least k out of n channels to retrieve the message. B upon receiving the pieces may reconstruct the message and authenticate it using the signed hash of the message that A sends to B. Transmission of this signature is an additional burden on the network. In the proposed scheme, A may hide the signature within the pieces of the message that is transmitted.

Information dispersal schemes for distributed storage networks primarily use computational secret [\cite=ref22] [\cite=ref9] sharing schemes. In general, in a computational secret sharing scheme an encryption key is used to encrypt the secret that is to be securely stored/transmitted. The encrypted message is then divided into several (possibly redundant) pieces. The key is divided into shares using conventional secret sharing techniques and these shares are stored along with the pieces of the encrypted message, as an overhead [\cite=ref7] [\cite=ref8] [\cite=ref9].

In a multiparty scenario, such as in secret sharing, the hidden information may be used as a means of authentication of the share (and of reconstructed secret), thus provide cheating detection. For example, the dealer may hide a "specially" chosen message in the shares of the secret and distribute the hash of this message to all the players along with the shares. The players may later reconstruct the secret and the hidden message, find the hash of the hidden message and verify it against the hash they have.

The presented scheme may be used as a multi-secret sharing scheme that uses Shamir's secret sharing scheme as its building block and encodes k - 2 additional secrets within the shares of the message originally intended to be shared. And the scheme may be used as a computational secret sharing scheme, effectively resulting in smaller shares, by dividing a secret into smaller pieces and then simulating a multi-secret sharing scheme. Since the proposed algorithm generates shares on the order of size of secrets encoded, smaller pieces will give rise to smaller shares. Moreover, the proposed scheme does not require any encryption key.

An efficient method for sharing multiple secrets with security based on assumption of hardness of discrete logarithm problem is presented in [\cite=ref26]. Whereas [\cite=ref23] proposes a scheme based on systematic block codes and [\cite=ref24] propose schemes based on Shamir's secret sharing scheme but require a large amount of side information to be stored as public knowldege and further [\cite=ref23] [\cite=ref24] [\cite=ref30] attempt to maintain ideal security. Other schemes [\cite=ref28] [\cite=ref29] focus at improving efficiency of computations involved in share creation and secret reconstruction rather than space and transmission efficiency.

In an earlier paper [\cite=ref5] [\cite=ref6], a 2-out-of-2 (k = 2 and n = 2) recursive scheme for secret sharing was proposed. In this method, if k secrets are chosen such that they double in size, then all of the smaller secrets can be recursively stored in the shares of larger secrets, so that two shares of size 2m can encode 2m + 1 - 1 bits of information. For example, if we are to share 3 secrets s1 = 1, s2 = 01, and s3 = 1011, then the two shares for s1 would be Ds11 = 0 and Ds12 = 1; where exclusive-OR operation is used for secret reconstruction. The shares of s1 can be used to create two shares of s2 as follows: Ds21 = Ds110 = 00 and Ds22 = 0Ds12 = 01. Here Ds110 denotes concatenation of share 1 of secret s1 with 0; and 0Ds12 denotes concatenation of 0 with share 2 of secret s1, and so on. Similarly, we can recursively use the shares of s2 to create the shares of s3: Ds31 = Ds2110 = 0010 and Ds32 = 10Ds22 = 1001. As a result, the final two shares for all the three secrets are 0010 and 1001. Consequently, using 8 bits of shares we have encoded 7 bits of secrets. This is in comparison with conventional methods that would require a total 14 bits of shares.

The above efficiency increase is obtained as a tradeoff against security of the scheme. A non-recursive scheme would require 7 bits for each share but the recursive scheme requires 4 bits per share, and a player only needs to determine 4 bits to break the scheme. However, in practice secrets are thousands of bits long. For example, a secret of 1048 bits length would be encoded in approximately 1024 bits per share, and would still require 21024 combinations to break. This may be sufficient for many cases.

Space efficient secret sharing

We propose a method to hide k - 2 secrets of size b, within the shares of a secret S of size b, using a (k,n) modified Shamir's secret sharing scheme. The secret is divided into n shares using modified Shamir's secret sharing scheme such that any k of them can be brought together for reconstruction.

Algorithm 1 (Modified Shamir's secret sharing scheme)

Choose a prime p, p > max(S,n), where S is the secret.

Choose k - 1 random numbers y1, y2, ..., yk - 1, uniformly and independently, from the field [formula].

Map these random numbers yis as y coordinates of points: (i,yi), for all 1  ≤  yi  ≤  (k - 1).

Map the secret S as point (0,S).

Using k points (i,yi), for all 1  ≤  yi  ≤  (k - 1) and (0,S) interpolate a polynomial p(x) of degree k - 1 modulo prime p.

Sample p(x) at n points Di = p(i), k  ≤  i  ≤  k + n - 1 such that the shares are given by (i,Di).

The reconstruction procedure for the secret follows the conventional method [\cite=ref1].

Now consider k - 2 secrets s1s2...sk - 2, [formula] for all 1  ≤  i  ≤  (k - 2) or pieces of a larger message. Therefore our task is to recursively hide si's within the shares of secret S. Further, we use the notation ylm to denote the y-coordinates of points. Here the first subscript l is the index of the step in the recursive process and subscript m is index of share to which that y-coordinate belongs to. For example, the y-coordinate of share 3 in the 5th recursion is written y53.

The proposed algorithm works as follows - randomly and uniformly choose a number y11 and map it as point (1,y11). Using (0,s1) and (1,y11) interpolate 1st degree polynomial p1(x). Sample p1(x) at two points y21 = p1(x = 2) and y22 = p1(x = 3). Now map the sampled points as (1,y21) and (2,y22). Using the next piece as point (0,s2) and the newly generated points (1,y21) and (2,y22) interpolate 2nd degree polynomial p2(x). Evaluate p2(x) at 3 points y31 = p2(x = 3), y32 = p2(x = 4), and y33 = p2(x = 5). We then use these 3 points as y-coordinates for x=1, 2, 3 and along with the third piece of the message as point (0,s3) interpolate 3rd degree polynomial p3(x). We continue this process until we have used all the pieces and reached (0,sk - 2) and interpolated (k - 2)th degree polynomial pk - 2(x). We then sample pk - 2(x) at k - 1 points y(k - 1)1 = pk - 2(k - 1), y(k - 1)2 = pk - 2(k), y(k - 1)3 = pk - 2(k + 1), ..., y(k - 1)(k - 1) = pk - 2(2k - 3).

Mapping these k - 1 samples as points (1,y(k - 1)1), (2,y(k - 1)2), ..., (k - 1,y(k - 1)(k - 1)) along with (0,S) construct a (k - 1)th degree polynomial pk - 1(x). We can now sample pk - 1(x) at n points such that any k points would reconstruct the secret and the hidden information.

The process of share creation and information hiding is formally described in Algorithm 2.

Algorithm 2 - Dealing Phase

Consider k - 2 secrets [formula], 1  ≤  i  ≤  (k - 2).

Choose prime p = max(si,S), for all 1  ≤  i  ≤  k - 2.

Randomly and uniformly choose a number [formula] and map it as point (1,y11).

Do for 1  ≤  i  ≤  (k - 2)

Interpolate points (0,si) and (j,yij), for all 1  ≤  j  ≤  i to generate a ith degree polynomial pi(x).

Sample the polynomial pi(x) at i + 1 points: y(i + 1)j = pi(j + i), for all 1  ≤  j  ≤  (i + 1).

Map the i + 1 points as: (j,y(i + 1)j), for all 1  ≤  j  ≤  (i + 1).

Interpolate points (0,S) and (j,y(k - 1)j), for all 1  ≤  j  ≤  (k - 1) to generate (k - 1)th degree polynomial pk - 1(x).

Sample pk - 1(x) at n points to generate n shares: (i,pk - 1(i)), for all k  ≤  i  ≤  k + n - 1.

Algorithm 2 - Reconstruction Phase

Interpolate any k shares to generate (k - 1)th degree polynomial pk - 1(x) = S + a1x + a2x2 + ... + ak - 1xk - 1.

Evaluate S = pk - 1(0).

Do for i = k - 2 down to 1

Map the coefficients of polynomial pi(x) as points: (j,aj), for all (i + 1)  ≤  j  ≤  2(i + 1).

Interpolate (j,aj), for all (i + 1)  ≤  j  ≤  2(i + 1), to generate polynomial pi(x) of degree i.

Evaluate si = pi(0).

Security of the proposed method: Algorithm 2 works by repetitive application of Algorithm 1. The first iteration of the algorithm is a direct application of (2,2) Shamir's secret sharing scheme. It uses a polynomial of degree 1 and generates two shares for the first secret s1 of the message. These two shares may be viewed as random numbers, such that given any number [formula], [formula]. They are then used to create a quadratic equation along with the second secret s2 mapped at x=0 (the free term of the equation). This quadratic equation is then sampled at 3 points to generate 3 shares of s2. These three shares are then used as random points to generate a 4th degree equation and encode s3 and so on, until we have encoded all the k - 2 pieces and generated k - 1 shares. These k - 1 shares are then used as points along with secret S at x=0 to generate a polynomial of degree k - 1, which can then be sampled at n points to create the final shares. These final shares have the shares of the smaller pieces hidden within them. The security of the protocol is predicated upon the random and uniform choice of the first coefficient y11.

Example. Suppose we want to hide 3 secrets s1 = 46, s2 = 69, and s3 = 72 within the shares of a secret S=65. Let k = 5 and n = 7, i.e. we are to create 7 pieces such that 5 of them must come together to recreate the secret and the hidden message. We execute the algorithm as follows,

Choose a prime p = 131.

Randomly and uniformly choose a number y11∈Z131, say y11 = 102. Map it as point (1,102).

Interpolate (0,s1) = (0,46) and (1,102) to generate p1(x) = 56x + 46.

Sample p1(x) at two points x = 2,3: y21 = p1(2) = 27 and y22 = p1(3) = 83.

Map these new points as (1,y21) = (1,27) and (2,y22) = (2,83).

Interpolate (0,s2) = (0,69), (1,27) and (2,83) to generate p2(x) = 49x2 + 40x + 69.

Sample p2(x) at three points x = 3,4,5: y31 = p2(3) = 106, y32 = p2(4) = 96 and y33 = p2(5) = 53.

Map the new points as: (1,y31) = (1,106), (2,y32) = (2,96) and (3,y33) = (3,53).

Interpolate (0,s3) = (0,72), (1,106), (2,96) and (3,53) to generate p3(x) = 111x3 + 38x2 + 16x + 72.

Sample p3(x) at 4 points x = 4,5,6,7: y41 = p3(4) = 119, y42 = p3(5) = 43, y43 = p3(6) = 98 and y44 = p3(7) = 33.

Map the new points as (1,y41) = (1,119), (2,y42) = (2,43), (3,y43) = (3,98) and (4,y44) = (4,33).

Interpolate (0,S) = (0,65), (1,119), (2,43), (3,98) and (4,33) to generate p4(x) = 66x4 + 106x3 + 72x2 + 72x + 65.

Sample p4(x) at 7 points x = 5,6,7,8,9,10,11 to create 7 shares: (5,p4(5)) = (5,2); (6,p4(6)) = (6,40); (7,p4(7)) = (7,63); (8,p4(8)) = (8,130); (9,p4(9)) = (9,50); (10,p4(10)) = (10,37) and (11,p4(11)) = (11,55).

Any five out of the seven shares can be interpolated to regenerate the polynomial p4(x). This polynomial can then be sampled to obtain S = p4(0). The y-coordinates of the samples of p4(x) at points x = 1,2,3,4 can the be mapped as points at x = 4,5,6,7 and then interpolated to reconstruct p3(x), which can be sampled at x = 0 to obtain s3 = p3(0). Polynomial p3(x) can be sampled at x = 1,2,3 to obtain y-coordinates and map them at x = 3,4,5. Interpolating these new points we obtain p2(x) and so on. The pieces of the hidden secrets are retrieved in the reverse order.

Conclusions

We have proposed a recursive techniques to hide additional information within the shares of Shamir's secret sharing schemes. This hidden information may be used for validation of shares at the time of secret reconstruction. Further it may be looked upon as a way to share large secrets by dividing the secret in smaller pieces and recursively hiding them in the shares.

Such a scheme is useful for secure transmission of information over parallel channels. Suppose the transmitter and receiver share secret identifications.The transmitter can then divide the identification into pieces and recursively encode it into the shares of the message to be sent over parallel lines. Transmission of shares over parallel channels provided implicit security and reliability. Further, the scheme may be used for information dispersal in storage networks.

Future Work: It includes implementing a distributed data storage scheme on the Web where different servers store data by creating shares of the data using the proposed scheme. This implicitly prevents any one (compromised) server from having access all the user data [\cite=ref31]. Such an idea may be useful in cloud computing, Chord protocol and FreeNets. Issues regarding addressing of data shares on the network need to be investigated.

Acknowledgment

This research has been partly funded by the Center for Telecommunication and Network Security (CTANS), Oklahoma State University, Stillwater.