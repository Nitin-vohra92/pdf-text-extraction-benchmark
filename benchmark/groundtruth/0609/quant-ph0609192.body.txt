Proposition Lemma Corollary Definition Fact Conjecture

Mayet-Godowski Hilbert Lattice Equations

Introduction

When we deal with quantum systems and its theoretical Hilbert space, we know that there is a Hilbert lattice that is isomorphic to the set of subspaces of any infinite-dimensional Hilbert space and that we can establish a correspondence between elements of the lattice and solutions of a Schrödinger equation that corresponds to such a Hilbert space. Therefore we might attempt to arrive at an algebra which would enable us to introduce quantum problems in a would-be quantum computer in the same way in which we can introduce Boolean algebra problem into a classical computer. The gain is exponential-- any quantum problem could be solved in a polynomial time.

But there is an essential problem here. Any Hilbert lattice is a structure based on first-order predicate calculus, and we simply cannot have a constructive procedure to introduce statements like there is or for all into a quantum computer. What we might do instead is to find classes of polynomial lattice equations that can serve in place of quantified statements. How far we have advanced down this road we recently reviewed in Refs. [\cite=pavicic-book-05] and [\cite=pm-ql-l-hql2], and in this paper we consider recent results we obtained for particular classes of such equations--Mayet-Godowski ones.

In 1985, René Mayet [\cite=mayet85] described a new equational variety of lattices, which he called OM*S, that included all Hilbert lattices and were included in a related variety of equations found by Radoslaw Godowski [\cite=godow] in 1981. However, it was not known whether the new variety was smaller than Godowski's (i.e., whether its equations were independent from Godowski's).

Recently, the authors showed [\cite=pm-ql-l-hql2] that Mayet's variety is indeed strictly included in Godowski's. In order to achieve this result, several new algorithms had to be developed to find counterexamples efficiently, to generate new equations in the family that were violated by the counterexamples, and to prove that the new equations were independent from every equation in the infinite family found by Godowski. This paper describes these algorithms, which were incorporated into the computer programs that found this result.

In the last section, we show the solution to an open problem posed by Mayet [\cite=mayet06], related to another new family of equations that he found, based on strong sets of Hilbert-space-valued states.

Definitions for lattice structures

We briefly recall the definitions we will need. For further information, see Refs. [\cite=beran] [\cite=mpoa99] [\cite=pm-ql-l-hql1] [\cite=pm-ql-l-hql2].

A lattice is an algebra [formula] such that the following conditions are satisfied for any a,b,c∈LO:

[formula]

Binary relation ≤   defined on L as

[formula]

is a partial ordering

An ortholattice (OL) is an algebra [formula] such that [formula] is a lattice with unary operation ' called orthocomlementation which satisfies the following conditions for a,b∈LO (a' is called the orthocomplement of a):

[formula]

An orthomodular lattice (OML) is an OL in which the following condition holds:

[formula]

where [formula], where [formula]

We say that a and b commute in OML, and write aCb, when either of the following equivalent equations hold:

[formula]

An orthomodular lattice which satisfies the following conditions is a Hilbert lattice, [formula].

Completeness: The meet and join of any subset of an [formula] exist.

Atomicity: Every non-zero element in an HL is greater than or equal to an atom. (An atom a is a non-zero lattice element with 0 < b  ≤  a only if b = a.)

Superposition principle: (The atom c is a superposition of the atoms a and b if c  ≠  a, c  ≠  b, and [formula].)

Minimal length: The lattice contains at least three elements a,b,c satisfying: 0 < a < b < c < 1.

A state (also called probability measures or simply probabilities [\cite=kalmb83] [\cite=kalmb86] [\cite=kalmb98] [\cite=maczin] ) on a lattice L is a function m:L  →  [0,1] such that m(1) = 1 and [formula], where [formula] means a  ≤  b'.

The following properties hold for any state m:

[formula]

A nonempty set S of states on L is called a strong set of states if

[formula]

Every Hilbert lattice admits a strong set of states.

Definitions of equational families related to states

First we will define the family of equations found by Godowski, introducing a special notation for them. These equations hold in any lattice admitting a strong set of states and thus, in particular, any Hilbert lattice. [\cite=mpoa99]

Let us call the following expression the Godowski identity:

[formula]

Godowski's equations [\cite=godow]

[formula]

hold in all ortholattices, OL's, with strong sets of states. An OL to which these equations are added is a variety smaller than OML.

We shall call these equations n-Go ( 3-Go, 4-Go, etc. ). We also denote by nGO ( 3GO, 4GO, etc. ) the OL variety determined by n-Go and call it the nGO law.

Next, we define a generalization of this family, first described by Mayet. [\cite=mayet85] These equations also hold in all lattices admitting a strong set of states, and in particular in all HLs.

A Mayet-Godowski equation ( MGE) is an equality with n  ≥  2 conjuncts on each side:

[formula]

where each conjunct ti (or u1) is a term consisting of either a variable or a disjunction of two or more distinct variables:

[formula]

and where the following conditions are imposed on the set of variables in the equation:

All variables in a given term ti or ui are mutually orthogonal.

Each variable occurs the same number of times on each side of the equality.

We will call a lattice in which all MGEs hold an MGO; i.e., MGO is the class (equational variety) of all lattices in which all MGEs hold.

The following three theorems about MGEs and MGOs are proved in Ref. [\cite=pm-ql-l-hql2].

A Mayet-Godowski equation holds in any ortholattice L admitting a strong set of states and thus, in particular, in any Hilbert lattice.

The family of all Mayet-Godowski equations includes, in particular, the Godowski equations ; in other words, the class MGO is included in n GO for all n.

The class MGO is properly included in all n GOs, i.e., not all MGE equations can be deduced from the equations n- Go.

A condensed state equation is an abbreviated version of an MGE constructed as follows: all (orthogonality) hypotheses are discarded, all meet symbols, [formula], are changed to +  , and all join symbols, [formula], are changed to juxtaposition.

For example, the 3-Go equation can be expressed as: [\cite=pm-ql-l-hql2]

[formula]

which, in turn, can be expressed by the condensed state equation

[formula]

The one-to-one correspondence between these two representations of an MGE should be obvious.

Checking n-Go equations on finite lattices

For the general-purpose checking of whether an equation holds in a finite lattice, the authors have primarily used a specialized program, latticeg.c, that is specialized to check an equation provided by the user against a list of Greechie diagrams (OMLs) provided by the user. This program has been described in Ref. [\cite=bdm-ndm-mp-1]. While it has proved essential to our work, a drawback is that the run time increases quickly with the number of variables in and size of the input equation, making it impractical for huge equations.

But there is another limitation in principle, not just in practice, for the use of the latticeg.c program. In our work with MGEs, we are particularly interested in those lattices having no strong set of states but on which all of the successively stronger n-Gos pass, for all n less than infinity. This would prove that any MGE failing in that lattice is independent from all n-Gos and thus represents a new result. The latticeg.c program can, of course, check only a finite number of such equations, and when n becomes large the program is too slow to be practical. And in any case, it cannot provide a proof, but only evidence, that a particular lattice does not violate n-Go for any n.

Both of these limitations are overcome by a remarkable algorithm based on dynamic programming, that was suggested by Brendan McKay. This algorithm was incorporated into a program, latticego.c, that is run against a set of lattices. No equation is given to the program; instead, the program tells the user the first n for which n-Go fails or whether it passes for all n. The program runs very quickly, depending only on the size of the input lattice, with a run time proportional to the fourth power of the lattice size, rather than increasing exponentially with n as with the latticeg.c that checks against arbitrary equations.

To illustrate the algorithm, we will consider the specific case of 7-Go. From this example, the algorithm for the general case of n-Go will be apparent. We consider 7-Go written in the following equivalent form: [\cite=mpoa99]

[formula]

We define intermediate "operations" [formula] along with a predicate which provides the the answer:

[formula]

Sets of values [formula] are computed as follows:

[formula]

For example, V4(a1,a5) is the set of values E4(a1,a2,a3,a4,a5) can have when a2,a3,a4 range over all possibilities. If (a1,a7) is true for all possible a1 and a7, then 7-Go holds in the lattice, otherwise it fails.

The computation time is estimated as follows, where n is the number of nodes in the test lattice:

[formula]

So the total time is O(n4).

The program is written so that it only has to compute additional "inner terms" to process the next n-Go equation. Remarkably, when a lattice does not violate any n-Go, the addition of new terms tends to converge to a fixed value rather quickly, meaning that Vn for (n + 1)-Go remains the same as Vn - 1 for n-Go. This almost always happens for n < 10, and when it does, we can terminate the algorithm and say with certainty that no further increase in n will cause an n-Go equation to fail in the lattice. (If it doesn't happen, the program will tell us that, but such a case has so far not been observed. The program has an arbitrary cut-off point of n = 100, after which the algorithm will terminate. Observed runs have always either converged or failed far below this point, and in any case the cut-off can be increased with a parameter setting.) Convergence provides a proof that the entire class of Godowski equations (for all n <   ∞  ) will pass in the lattice. Such a feat is not possible with ordinary lattice-checking programs, since an infinite number of equations would have to be tested.

When a lattice does violate some n-Go, that result tends to be found even faster, and the algorithm terminates, and the program tells us the first n at which an n-Go equation fails in the lattice. Since n-Go can be derived from n + 1-Go, failure is also implied for all greater n.

The success of latticego.c depends crucially on the structure of a particular representation of the n-Go equations, where variables appear only on one side of the equation and are localized to an adjacent pair of conjuncts in a chain of conjuncts. So far, efforts to adapt the approach to other equational families, such as the nOA (generalized orthoarguesian) laws, [\cite=mpoa99] haven't been successful but are still being explored.

Finding states on finite lattices

It is possible to express the set of constraints imposed by states as a linear programming (LP) problem. Linear programming is used by industry to minimize cost, labor, etc., and many efficient programs have been developed to solve these problems, most of them based on the simplex algorithm.

We will examine a particular example in detail to illustrate how the problem is expressed. For this example we will consider a Greechie diagram with 3-atom blocks, although the principle is easily extended to any number of blocks.

If m is a state, then each 3-atom block with atoms a, b, c and complements a', b', c' imposes the following constraints:

[formula]

To obtain Eq. ([\ref=eqn:mmm]), note that in any Boolean block, [formula], so [formula].

Let us take the specific example of the Peterson lattice, which we know does not admit a set of strong states. The Greechie diagram for this lattice, shown in Fig. [\ref=fig:peterson], can be expressed with the textual notation (see Ref. [\cite=pm-ql-l-hql2]), where each digit or letter represents an atom, and groups of them represent blocks (edges of the Greechie diagram).

Referring to the textual notation, we designate the atoms by [formula] and their orthocomplements by [formula]. We will represent the values of state m on the atoms by [formula]. This gives us the following constraints for the 10 blocks:

[formula]

In addition, we have m(a')  +  m(a)  =  1, m(a)  ≥  0, and m(a')  ≥  0 for each atom a, adding potentially an additional 15  ×  3 = 45 constraints. However, we can omit all but one of these since most orthocomplemented atoms are not involved this problem, the given constraints are sufficient to ensure that the state values for atoms are less than 1, and the particular linear programming algorithm we used assumes all variables are nonnegative. This speeds up the computation considerably. The only one we will need is m(7)  +  m(7') = 1 because, as we will see, the orthocomplemented atom 7' will be part of the full problem statement.

We pick two incomparable nodes, 1 and 7', which are on opposite sides of the Peterson lattice. (The program will try all possible pairs of incomparable nodes, but for this example we have selected a priori a pair that will provide us with the answer.) Therefore it is the case that   ~  1  ≤  7'. If the Peterson lattice admitted a strong set of states, for any state m we would have:

[formula]

Since the the conclusion is false, for some m we must have

[formula]

So this gives us another constraint:

[formula]

and for a set of strong states to exist there must be some m such that

[formula]

So, our final linear programming problem becomes (expressed in the notation of the publicly available program lp_solve): which means "minimize m(7'), subject to constraints [formula]." The variable to be minimize, m(7), is called the objective function (or "cost function"). When this problem is given to lp_solve, it returns an objective function value of 1. This means that regardless of m, the other constraints impose a minimum value of 1 on m(7'), contradicting the requirement that m(7')  <  1. Therefore, we have a proof that the Peterson lattice does not admit a set of strong states.

The program states.c that we use reads a list of Greechie diagrams and, for each one, indicates whether or not it admits a strong set of states. The program embeds the lp_solve algorithm, wrapping around it an interface that translates, internally, each Greechie diagram into the corresponding linear programming problem.

Generation of MGEs from finite lattices

When the linear programming problem in the previous section finds a pair of incomparable nodes that prove that the lattice admits no strong set of states, the information in the problem can be used to find an equation that holds in any OML admitting a strong set of states, and in particular in HL, but fails in the OML under test. Typically, an OML to be tested was chosen because it does not violate any other known HL equation. Thus, by showing an HL equation that fails in the OML under test, we will have found a new equation that holds in HL and is independent from other known equations.

The set of constraints that lead to the objective function value of 1 in our linear programming problem turns out to be redundant. Our algorithm will try to find a minimal set of hypotheses (constraints) that are needed. The equation-finding mode of states.c program incorporates this algorithm, which will try to weaken the constraints of the linear programming problem one at a time, as long as the objective function value remains 1 (as in the problem in the previous section). The equation will be constructed based on a minimal set of unweakened constraints that results.

The theoretical basis for the construction is described in the proof of Theorem 30 of Ref. [\cite=pm-ql-l-hql2]. Here, we will describe the algorithm by working through a detailed example.

Continuing from the final linear programming problem of the previous section, the program will test each constraint corresponding to a Greechie diagram block, i.e. each equation with 3 terms, as follows. It will change the right-hand side of the constraint equation from =  1 to ≤  1, thus weakening it, then it will run the linear programming algorithm again. If the weakened constraint results in an objective function value m(7') < 1, it means that the constraint is needed to prove that the lattice doesn't admit a strong set of states, so we restore the r.h.s. of that constraint equation back to 1. On the other hand, if the objective function value remains m(7') = 1 (as in the original problem), a tight constraint on that block is not needed for the proof that the lattice doesn't admit a strong set of states, so we leave the r.h.s. of that constraint equation at ≤  1.

After the program completes this process, the linear programming problem for this example will look like this: Six out of the 10 blocks have been made weaker, and the linear programming algorithm will show that the objective function has remained at 1. We now have enough information to construct the MGE, which we will work with in the abbreviated form of a condensed state equation (Definition [\ref=def:stateeqn]).

Since m(1) = 1, the other atoms in the two blocks (3-term equations) using it will be 0. Thus m(2) = m(3) = m(B) = m(C) = 0.

For each of the four blocks that have = 1 on the r.h.s., we suppress the atoms that are 0 and juxtapose the remaining 2 atoms in each block. For example, in m(3) + m(4) + m(5) = 1, we ignore m(3) = 0, and collect the atoms from the remaining two terms to result in 45 (4 juxtaposed with 5). Then we join all four pairs with +   to build the l.h.s. form for the condensed state equation:

[formula]

For the r.h.s. of the equation, we scan the blocks with weakened constraints. From each block, we pick out and juxtapose those atoms that also appear on the l.h.s. and discard the others. For example, in m(5) + m(6) + m(7)  ≤  1, 5 and 6 appear in Eq. ([\ref=eq:lhs]) but 7 doesn't. Joining the juxtaposed groups with +  , we build the r.h.s.:

[formula]

Note that out of the 6 weakened constraints, 2 of them have no atoms at all in common with  Eq. ([\ref=eq:lhs]) and are therefore ignored.

Equating the two sides, we obtain the form of the condensed state equation:

[formula]

Replacing the atoms with variables, the final condensed state equation becomes:

[formula]

Finally, the number of occurrences of each variable on must match on each side of the condensed state equation. In this example, that is already the case. But in general, there may be terms that will have to be repeated in order to make the numbers balance. An example with such "degenerate" terms is shown as Eq. (47) of Ref. [\cite=pm-ql-l-hql2].

Eq. ([\ref=eq:state4go]) will be recognized, after converting it to an MGE, as the 4-Go equation, which as is well-known holds in all OMLs that admit a strong set of states but fails in the Peterson lattice Fig. [\ref=fig:peterson]. [\cite=mpoa99]

Solution to an open problem

In Ref. [\cite=mayet06], Mayet shows the following consequence of one of his equations (E*2) derived from Hilbert-space-valued states, and asks whether an OML exists in which it fails. The answer is negative.

The condition

[formula]

holds in all OMLs.

Proof. The following lemma follows using DeMorgan's law, the Foulis-Holland theorem (F-H; see e.g. Ref. [\cite=kalmb83]), and the orthogonality hypothesis [formula], respectively, for its three steps. The orthogonality hypotheses provide the commute relations needed for F-H.

[formula]

From [formula] (in any OL) and [formula] (using [formula]), we have

[formula]

The result then follows by applying the hypotheses, OL, Eq. [\ref=eq:mayetproof2], F-H, the hypothesis [formula], and Eq. [\ref=eq:mayetproof1] to obtain the following steps, respectively:

[formula]

[formula]

Conclusion

In the previous sections we presented several results obtained in the field of Hilbert space equations based on the states defined on the space. The idea is to use classes of Hilbert lattice equations for an alternative representation of Hilbert lattices and Hilbert spaces of arbitrary quantum systems that might eventually enable a direct introduction of the states of the systems into quantum computers. In applications, infinite classes could then be "truncated" to provide us with finite classes of required length. The obtained classes would in turn contribute to the theory of Hilbert space subspaces, which so far is poorly developed.

In Sections [\ref=sec:def2]-[\ref=sec:open] we have considered three classes of Hilbert lattice equations based on the states defined on the lattice by means of Definition [\ref=def:state] and specified in Section [\ref=sec:open].

The algorithms and associated computer programs that were developed for this project were essential to its success. McKay's dynamic programming algorithm for n-Go equations (Section [\ref=sec:dynamic]), together with its quickly convergent behavior for large n, was particularly fortuitous. Without it, the authors see no apparent way that the independence of the MGE equations from all n-Go equations could be answered. At best, only empirical evidence pointing towards that answer could be accumulated, but that of course would not constitute a proof. Indeed, this problem had remained open for nearly 20 years since Mayet's first publication [\cite=mayet85] of these equations.

Thus, there is a strong motivation to find variants of McKay's n-Go dynamic programming algorithm that could be more generally applied to other infinite families, in particular the nOA (generalized orthoarguesian) laws. [\cite=mpoa99] Assuming similar run-time behavior could be achieved, this would provide us with an extremely powerful tool that would let us test finite lattices against the family very quickly (instead of months or years of CPU time) as well as prove independence results for the entire infinite family of equations at once (if the valuation set rapidly converges to a final, fixed value with increasing n, as it does for n-Go). On the surface this appears to be quite a difficult problem, because unlike the special form in which the n-Go equations can be rewritten - so that most of the variables are localized to adjacent conjuncts - the known forms of the nOA laws have their variables distributed throughout their (very long) equations. So another approach would be to discover a new form of the nOA laws that better separates their variable occurrences in such a way that a variant of the n-Go dynamic programming algorithm might be applicable. Both of these approaches are being investigated by the authors.

The authors are unaware of any previous use of linear programming methods for finding states on a finite lattice and in particular (for the present study) determining whether the lattice admits a strong set of states. There appear to be relatively few programs that deal with states, and most of the finite lattice examples in the literature related to states were found by hand. A Pascal program written by Klaey [\cite=klaey] is able to find certain kinds of states on lattices, but for the strong set of states problem it is apparently able only to indicate "yes" (if a strong set of states was found) or "unknown" otherwise. The linear programming method provides a definite answer either way, in the predictable amount of time that the simplex algorithm takes to run. Finally, the linear programming problem itself (with redundant constraints weakened) provides us with the information we need to construct a new Hilbert lattice equation that fails in a given lattice not admitting a strong set of states.

Mayet's recent and important E-equation results [\cite=mayet06] provide us with powerful new method, the use of Hilbert-space-valued states, to find previously unknown families of equations that hold in Hilbert lattices. For further investigation of these equations, it will be highly desirable to have a program analogous to our states.c (which works with only real-valued states) that will tell us whether or not a finite lattice admits a strong set of Hilbert-space-valued states. This problem seems significantly harder than that of finding real-valued states, and possible algorithms for doing this are being explored by the authors.

The programs latticego.c and states.c described above can be downloaded from http://us.metamath.org/#downloads.