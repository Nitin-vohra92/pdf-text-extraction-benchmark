Updates in Answer Set Programming: An Approach Based on Basic Structural Properties

Introduction

In recent years, a lot of theoretical work has been devoted to explore the relationships between intuitionistic logic and answer set programming (ASP) [\cite=LiPeVa01] [\cite=lopstr01] [\cite=tplp04] [\cite=apal04]. These results have provided a characterization of ASP by intuitionistic logic as follows: a literal is entailed by a program in the answer set semantics if and only if it belongs to every intuitionistically complete and consistent extension of the program formed by adding only negated literals [\cite=tplp04]. The idea of these completions using intermediate logics in general is due to Pearce [\cite=Pea99]. This logical approach provides the foundations to define the notion of nonmonotonic inference of any propositional theory (using the standard connectives) in terms of a monotonic logic (namely intuitionistic logic), see [\cite=LiPeVa01] [\cite=lopstr01] [\cite=tplp04]. As Pearce et al. noticed, if we include strong negation we just have to move to Nelson logics [\cite=LiPeVa01]. We select here [formula] logic, because it characterizes adequately strong equivalence. A formalization of [formula] can be obtained from intuitionistic logic by adding the axiom schema [formula] and the axioms of Nelson logic.

When an intelligent agent obtains new knowledge consistent with its current information that knowledge is added to the agent's knowledge base. If however the new knowledge contradicts the agent's current information, a method for incorporating this new knowledge must be developed. In this paper we present our approach to update nonmonotonic knowledge bases represented as logic programs under the answer set semantics [\cite=GelLif88] [\cite=gelfond91classical]. Some well-known recent proposals are presented in [\cite=updcaus] and [\cite=ap02] accompanied by very good reviews with many references.

In particular, with the purpose of obtaining a reliable update process for providing agents with advanced reasoning capabilities, the authors of [\cite=updcaus] present an approach in which new information is incorporated into the current knowledge base subject to a causal rejection principle. Causal rejection enforces that in case of conflicts between rules, more recent rules are preferred and older rules are overridden [\cite=updcaus]. As was noted in [\cite=updcaus], causal rejection is not novel, and what they provided was a simple and rigorous realization of this principle, as well as the formalization of a semantics for updating logic programs based on it. We developed the present work based on this principle also, aiming to express program updates succinctly while preserving relevant properties.

In our work we analyze the approach presented in [\cite=updcaus] because under this approach a program is explicitly constructed. We believe that this is important from a computational perspective and also that such an approach is more suitable to study the properties of updates based on the causal rejection principle, since it provides insight into the operation of the principle itself. We go a step further by presenting an alternative but equivalent definition of update sequences as presented in [\cite=updcaus], for the case when considering two programs and that avoids the need of new atoms. We consider our definition to be more concise and accessible.

In this paper we consider many of the properties presented in [\cite=updcaus] because there the authors present a comprehensive analysis about the properties that an update operator should have. Moreover, we present new properties for update operators through an extensive analysis and making use of the new characterization of ASP by intermediate logics [\cite=LiPeVa01] [\cite=lopstr01] [\cite=tplp04]. In this paper, we consider properties similar to the well-known AGM postulates. We think that it is necessary to reinterpret them in the context of nonmonotonic reasoning via ASP. As a starting point, we study Dalal's Principle [\cite=km91] of Independence of Syntax, according to which the meaning of the knowledge that results from an update must be independent of the syntax of the original knowledge, as well as independent of the syntax of the update itself. In [\cite=updcaus] the authors analyze and interpret the AGM postulate corresponding to Dalal's principle as follows:

[formula] implies [formula]

where T1 and T2 are any theories, [formula] denotes that T1 and T2 are equivalent, i.e. they have the same answer sets. By S(P) we denote the set of all answer sets of P, [formula] is a general update operator. This interpretation expresses a very demanding principle of independence of syntax, due to the fact that the AGM postulates were introduced for monotonic logics. We propose to reconsider the AGM postulates [\cite=agm85] under our new interpretation. To this aim we have introduced in [\cite=oz03] a new property, which we call Weak Independence of Syntax, as follows:

(WIS): [formula] implies [formula]

where T1 and T2 are any theories, [formula] denotes that T1 and T2 are equivalent in [formula], in which case we say that they are equivalent knowledge. We consider this property to be desirable for any update operator based on ASP. We show that the proposal introduced in [\cite=updcaus] for updates satisfies this principle to a great extent. In fact we show that for programs without tautologies, this principle holds. We should point out that this property is accepted as much in belief revision as in updates, as it is shown in [\cite=updcaus].

The main contributions of our paper can be summarized as follows. First, we present a reinterpretation of the AGM postulates for ASP based on Nelson logics. Second, we present an analysis of how the update semantics presented in [\cite=updcaus] can be expressed in an alternative form without relying on new atoms. Finally, we analyze the semantics presented in [\cite=updcaus] and our equivalent form in terms of our adaptation of the AGM postulates.

Our paper is structured as follows: in Section [\ref=background] we present the general syntax of clauses, we also provide the definition of answer sets for logic programs as well as some background on logic, in particular on [formula] logic. In addition, we review the AGM postulates and present the definition of update sequences given in [\cite=updcaus]. Next, in Section [\ref=properties] we introduce our [formula] properties motivated by the AGM postulates. Section [\ref=basicdef] presents an approach for update programs characterized by its simplicity. In Section [\ref=altdef] we introduce an alternative but equivalent definition for update programs as presented in [\cite=updcaus] and analyze its properties. Finally, the conclusions are drawn in Section [\ref=conclusions].

Background

In this section we present a brief background on intuitionistic and intermediate logics and introduce the notation and key concepts to be used in this paper. In addition we discuss the AGM postulates and present the definition of update sequences given in [\cite=updcaus].

Intuitionistic and Intermediate Logics

Intuitionistic Logic was introduced at the beginning of the twentieth century and it was developed as a formal system around the 30s. It is often referred to as Heyting's Constructive Logic and here we will represent it by the symbol [formula]. It was proposed as an alternative to standard propositional logic, which we will represent by [formula]. The main feature of intuitionistic logic is that in order to be true a proposition must be constructively verified, i.e. a proof of it must be constructed. For this reason, intuitionism is usually bound to concepts like proof and knowledge, rather than to the traditional classical notion of truth. The set [formula] denotes the connectives of intuitionistic logic. All the connectives in [formula] are 2-place connectives, except for the 0-place [formula], known as falsum. For any formula p, the expression [formula] will be understood as an abbreviation of [formula] and [formula] is an abbreviation of [formula]. In addition, in this paper we may use the ← operator instead of the →   operator solely as a notational convenience.

For a well known axiomatic formalization of [formula] see [\cite=Men87]. [formula] is strictly contained in classical logic in the sense that all theorems of [formula] are also theorems of [formula], but the converse doesn't hold. Note that many well known theorems of [formula] are not theorems of [formula]. The best known examples usually involve negation, like [formula], and [formula], but there are also formulas without negation that are theorems of [formula] and are not provable in [formula], for example ((p  →  q)  →  p)  →  p (Pierce's law).

By adding supplementary axioms to intuitionistic logic, we obtain the logics that are usually known in the literature as intermediate logics. All of them contain all of the intuitionistic theorems, and are contained in the theorems of classical logic. If this containment is strict, they are called proper intermediate logics. Here we will just use the term intermediate logic or [formula]-logic to refer to any logic that is as least as strong as [formula], but strictly weaker than [formula]. Intermediate logics form a lattice in which the supremum of all intermediate logics is the unique lower cover of [formula]. Many names for this logic can be found in the literature, like Smetanich logic, the logic of Here and There, and Gödel 3-valued Logic ([formula]).

Gödel Multivalued Logics

These logics are defined by generalizing the idea of truth tables and evaluation functions of classical logic. Gödel defined the multivalued logics [formula], with values in [formula], with the following evaluation function I:

I(B←A)  =  i - 1 if I(A)  ≤  I(B) and I(B) otherwise.

[formula].

[formula].

[formula].

An interpretation is a function [formula] that assigns a truth value to each atom in the language. The interpretation of an arbitrary formula is obtained by propagating the evaluation of each connective as defined above. Recall that [formula] and [formula] were introduced as abbreviations of other connectives.

For a given interpretation I and a formula F we say that I is a model of F if I(F)  =  i - 1. Similarly I is a model of a program P if it is a model of each of the formulas contained in P. If F is modeled by every possible interpretation we say that F is a tautology.

Notice that [formula] coincides with classical logic. The 3-valued logic [formula] is particularly useful for some of our results.

Intermediate Logics and Strong Negation Extensions

In [\cite=nelson49falsity] Nelson introduces a logic that extends intuitionistic logic by adding a new negation connective called strong negation and represented by ~  . Intuitively, the strong negation connective means that something is known to be false, not only assumed false due to the absence of a proof. It allows the constructive falsification of a proposition, in the same sense as intuitionistic logic allows constructive verification. This logic is given by the standard connectives of intuitionistic propositional logic, [formula], plus the strong negation connective ~  .

We will denote by [formula] the logic obtained by adding the following axiom schema to Heyting's axiomatization of intuitionistic logic [\cite=Men87] (α  ↔  β stands for [formula]). A1: [formula] A2: [formula] A3: [formula] A4: α  ↔    ~    ~  α A5: [formula] A6: [formula] for atomic α

Since [formula] is a theorem in [formula] for any α (not only atoms)[\cite=Dal86] [\cite=gurev], the ~   connective is called strong negation. These axioms are given in [\cite=vorobev52a] [\cite=vorobev52b], where [formula] is presented as an extension of intuitionistic logic [formula], i.e. formulas without the ~   connective are theorems of [formula] iff they are theorems of [formula]. Moreover, the same axioms A1 to A6 can be added to any intermediate logic [formula] to obtain a least strong negation extension of [formula], which we will denote by [formula]. Strong negation extensions of intermediate logics are sometimes called constructive logics, but here we will just call them [formula]-logics following [\cite=kra98]. Sometimes, we will refer to the intuitionistic fragment of a [formula]-logic [formula], i.e. the intermediate logic whose theorems are exactly those of [formula] on the fragment without ~  . This fragment will be denoted as [formula]. Least strong negation extensions of intermediate logics form a lattice that was deeply studied by Kracht in [\cite=kra98]. There he used algebraic techniques to prove many results, some of which will be used in this work. Two particular elements of this lattice will be important for the present work: the logic [formula], extension of [formula] and lower bound of the lattice, and the unique upper bound of it, i.e. the extension of [formula] which we will denote by [formula]. The logic [formula] can be obtained by adding the axiom schema [formula] to [formula].

A particular feature of is that the defined connective ↔   is not in general congruential. For instance, it is known that [formula] is a theorem, however [formula] is not a theorem. For the restricted class of formulas where ~   only applies to atoms, our ↔   connective is again congruential as discussed in [\cite=magd]. We will assume this result freely in the rest of the paper.

It is well-known that provability in [formula] can be reduced to provability in intuitionistic logic following a simple syntactic transformation [\cite=ra74]. First, strong negation is moved towards the atoms using axioms A1 to A5. Next, for every atom a of the underlying language, a new atom a' is introduced and all the formulas ~  a are replaced by a'. Finally, formulas of the form [formula] are added for each of the new atoms a'. For example, if we want to know if [formula] [formula] is a theorem in [formula], we can just check if [formula] [formula] is a theorem in intuitionistic logic. By abuse of notation we can understand ~  a as a new atom and we only ask if [formula] →   (  ~  a [formula] ~  b) →   [formula] is a theorem in [formula]. Similarly, provability in [formula] can be reduced to provability in [formula], the details of this reduction can be found in [\cite=magd]. We will assume this result freely in the rest of the paper.

General Notation

We will represent the set of connectives of Nelson's logics by [formula], where ~   is an unary connective. [formula]-formulas are the formulas constructed as in standard propositional logic using the connectives in [formula]. For any formulas α, β the formula α  ↔  β is an abbreviation of [formula]. As was mentioned before, the [formula] connective can be defined alternatively as [formula]. Formulas are constructed over a set of atoms A. An atom is just a propositional variable. A ~  -literal is either an atom a or the strong negation of an atom, ~  a. A [formula]-literal is either an atom a or the weak negation of an atom, [formula]. When we use the term literal alone, we mean an ~  -literal l. For a literal l, the complementary literal, ~  l, is ~  a if l = a, and a if l = ~  a, for some atom a. For a set S of literals, we define ~  S = {~  l|l∈S}. Similarly, for a set S of formulas we define [formula] = {[formula]}. Also, if S = {P1,...,Pn} is a set of formulas, we define [formula] = [formula] and [formula] = [formula]. We denote by LitA the set A [formula] ~  A of all literals over a set of atoms A. In addition, we define [formula] = [formula]. A theory is just a finite set of formulas. An rule is an expression of the form

A←B1,...,Bm, [formula] [formula] (1)

where A and each Bi are literals, [formula], or [formula]. If [formula] is [formula] then rule (1) is a fact and may be written simply as A. If A is [formula] then rule (1) is a constraint, on the other hand, if A is [formula] then the rule is a tautology. An extended logic program (ELP) [\cite=gelfond91classical] is a finite set of rules. Usually, A will be identified with the set of all atoms occurring in a program P, in which case we call it the signature of program P. Every rule can be identified with a corresponding formula of the form [formula], where α and each βi are literals. Also, a rule r may be abbreviated as H(r)←B(r), where H(r) and B(r) represent the formulas that comprise the head and body of the rule, respectively.

Due to transformations, our programs can surpass the class of extended logic programs. Hence, it is convenient to define an augmented logic program [\cite=LiTaTu99] as a finite set of formulas F that adhere to the following CFG:

R :: =  F  →  l [formula], where l is a literal [formula]

For example, the formula [formula] can be derived according to the previous CFG. Parentheses may be omitted following the usual conventions regarding the precedence of operators and conjunction may be expressed with the comma operator instead. Henceforth, when we use the term program alone, we mean an augmented logic program.

With respect to update operators, [formula] stands for a general update operator, while [formula] for some i such that 1  ≤  i  ≤  n represents a specific update operator whose definition is introduced.

Answer Sets

Following the characterization of answer sets for logic programs in terms of intermediate logics provided by Pearce in [\cite=Pea99], we adopt the following theorem as a definition of an answer set, which is discussed in detail in [\cite=OsNaAr:apal04].

Let us introduce the notation [formula] to stand for the phrase T is consistent and [formula]. We also clarify that by a consistent set of literals M, we mean that for all literals l∈M we have either l∈M or ~  l∈M, but not both. Finally, we define the complement of M as [formula].

[\cite=OsNaAr:apal04] [\cite=magd]. Let P be a program over a set of atoms A, and let M be a consistent set of literals such that M  ⊆  LitA. M is an answer set of P iff [formula].

Our definition yields different results with respect to that given in [\cite=gelfond91classical] only in that according to ours inconsistent programs have no answer sets.

In addition we adopt the notion of strong equivalence, which represents a property that is useful in our work.

[\cite=LiPeVa01]. For any programs P1 and P2, [formula] iff for every program P, [formula] and [formula] have the same answer sets.

We also take into account the notion of conservative extension, a property in which a program preserves its original meaning despite the addition of rules.

[\cite=baral03:cambridge] Let P and P' be a pair of programs over sets of atoms A and [formula] respectively such that P  ⊆  P'. We say that P' is a conservative extension of P if the following condition holds: M is an answer set for P iff there is an answer set M' for P' such that [formula].

Finally, we will introduce two additional results. But first we introduce the following clarification.

We define that a literal l occurs in a formula F recursively as follows l occurs in l where l is a literal l occurs in [formula] iff l occurs in α or l occurs in β

where α and β are formulas and [formula] denotes one of the operators with which we construct our formulas as presented in the CFG introduced in Section [\ref=subsectNotation]. The previous definition allows us to resolve possible ambiguities. For instance, a does not occur in ~  a and similarly ~  a does not occur in a.

We say that a literal occurs under the scope of the [formula] symbol when it is affected directly by the [formula] symbol, or is part of a formula affected by the [formula] symbol. For example, in the formula [formula] the literal x occurs under the scope of [formula]. Now consider the formula [formula]. In this formula, the first occurrence of x is not under the scope of [formula] while the second does occur under the scope of [formula]. We are interested in the case when a literal may only occur under the scope of the [formula] symbol for some formula F, and consequently in a program P, where the previous condition holds for all formulas F identified with the rules of P.

The first result can be considered of interest by itself .

Let P be a program over a set of atoms A and x a literal that does not occur in P. Let F be a formula over a set of atoms F such that LitF  ⊆  LitA. Then [formula].

See [\ref=appendixb].

The second result is the following theorem.

Let P be a program over a set of atoms A and x a literal that if occurs in P, it occurs only under the scope of the [formula] symbol. Let F be a formula over a set of atoms F such that LitF  ⊆  LitA and x does not belong to LitF. Then [formula].

For a set of literals M we denote by PM(x) the program obtained by substituting x by [formula] if x∈M or by [formula] if x∉M. The substitution only occurs under the scope of a [formula] symbol in P.

M is an answer set of [formula] iff M is an answer set of [formula] (by Lemma [\ref=formercorollary1], [formula]) iff M is an answer set of [formula] iff M is an answer set of [formula].

AGM Postulates

Although it is not possible to characterize a revision exclusively on logical terms, the general properties of its associated revision function can be defined and algorithms to compute it can be developed, at least for some cases [\cite=agm85]. In order to prove if an algorithm is adequate, we need to establish whether its associated function follows the properties that would normally be expected to hold in a belief revision process. In [\cite=agm85] several rationality postulates are proposed as a standard for analyzing revision functions. These are referred to as the AGM postulates, in honor of their authors, and are described next. K-1: for any sentence φ and any belief set K, [formula] is a belief set. K-2: [formula]. K-3: [formula]. K-4: if [formula] then [formula]. K-5: [formula] if and only if [formula]. K-6: if [formula] then [formula].

In the previous statements [formula] represents an arbitrary revision operator as discussed in [\cite=agm85] and not specifically based on answer set semantics, +   represents the expansion of a belief set, i.e. adding a sentence regardless of the consistency of the new belief set. A revision operator represents a function taking a belief set and a sentence as arguments and producing a belief set as a result. By belief set we mean a set of sentences closed under logical consequences. The first postulate requires that the output of the revision function must be a belief set. The second postulate guarantees that the new sentence φ will be accepted. The third postulate states that a revision knows at most, as much as the expansion. In the case in which the new information φ does not contradict the belief set K which means [formula], the K-4 postulate guarantees, in conjunction with K-3, that revision will be equivalent to expansion. Because the goal of revision is to produce a new consistent belief set, postulate K-5 establishes that the new belief set has to be consistent, unless the input sentence φ is inconsistent itself. The content of the input sentence φ should determine the revision independently of its syntax. This means belief revisions should be analyzed on the knowledge level and not on the syntactic level, therefore logically equivalent sentences should lead to equivalent revisions as postulate K-6 says.

Postulates K-1 to K-6 establish the fundamental properties that any belief revision function should satisfy, for this reason they are called the basic set of postulates. Together, these postulates aim to capture the basic properties that should be respected in an ideal form of belief revision.

In [\cite=kat92] the authors argue that the AGM postulates are adequate for the incorporation of new information about a static world, but not for new information about changes in the world caused by an agent. They formalize the latter behavior by a set of update postulates. However, all of the basic AGM postulates except K-1 have direct correspondences in the update postulates presented in [\cite=kat92], hence they can be considered as a core set of postulates for belief revision as well as for update.

Update Programs

In [\cite=updcaus] an update sequence P is defined as a series (P1,P2,...,Pn) of extended logic programs (ELPs). Let us consider the definition of update sequence given in [\cite=updcaus] but only for the case of two programs and let us make a slight change of notation. Our proposal can be extended to general case (P1,P2,...,Pn) in the iterative form as shown in [\cite=updcaus]. Under certain conditions, which exclude possibilities for local inconsistencies, the iterativity property holds [\cite=updcaus]. P is an update sequence over a set of atoms A A represents the set of atoms occurring in the rules of the constituting elements Pi of P (1 ≤   i ≤   2). Given an update sequence P = (P1, P2) over A, we assume a set A* extending A by new, pairwise distinct atoms rej(r) and Ai, for each r occurring in P, each atom A ∈A, and each i, 1 ≤   i ≤   2. We further assume an injective naming function N(·  ,  ·  ), which assigns to each rule r in a program Pi a distinguished name, N(r,Pi), obeying the condition N(r,Pi) [formula] N(r',Pj) whenever [formula]. With a slight abuse of notation we shall identify r with N(r,Pi) as usual. Finally, for a literal L, we write Li to denote the result of replacing the atomic formula A of L by Ai.

[\cite=updcaus] Given an update sequence P = (P1,P2) over a set of atoms A, we define the update program P[formula] = P1 [formula] P2 over A* consisting of the following items:

(i) all constraints in P1 [formula] P2; (ii) for each r ∈ P1; [formula] if H(r)  =  L; (iii) for each r ∈ P2; L2 ← B(r). if H(r)  =  L; (iv) for each literal L occurring in P; L1 ← L2 L ← L1.

This definition relies on the fact that rules in program P2 cannot be rejected, which allows us to construct a simplified program as was noted in [\cite=updcaus]. It is important to note that the update sequence P is also an extended logic program. The answer sets of P are defined in terms of the answer sets of P[formula].

[\cite=updcaus] Let P = (P1,P2) be an update sequence over a set of atoms A. Then, S  ⊆  LitA is an update answer set of P S  =  S' [formula] A for some answer set S' of P[formula]. The collection of all update answer sets of P is denoted by U(P).

An important remark in relation to update programs is presented in [\cite=updcaus]. Update programs do not satisfy many of the properties defined in the literature. This is partly explained by the nonmonotonicity of logic programs and the causal rejection principle embodied in the semantics, which strongly depends on the syntax of rules [\cite=updcaus].

Properties

In this section we present some basic properties about update operators. The first four are taken from [\cite=updcaus] and are all satisfied by the [formula] operator. The remaining are adapted versions of the AGM postulates. In the statements that follow [formula] denotes an arbitrary update operator and P a program. Given two programs P and P', we write [formula] if they have the same answer sets.

Initialization: [formula]

The authors of [\cite=updcaus] present this property as follows: this property states that the update of an initial empty knowledge base yields just the update itself.

Idempotence: [formula]

This property means that the update of program P by itself has no effect [\cite=updcaus].

Noninterference: If P1 and P2 are programs defined over disjoint alphabets, then [formula]

This property implies that the order of updates which do not interfere with each other is immaterial [\cite=updcaus].

Augmented update: If P1  ⊆  P2 then [formula]

Updating with additional rules makes the previous update obsolete [\cite=updcaus]. Note that the idempotence property represents a special case of this property.

The following properties are motivated by the AGM postulates. We observe that the interpretation given in [\cite=updcaus] of the AGM postulates is sometimes very demanding, particularly because the AGM postulates were introduced for monotonic logics. However, since answer set programming is related to the well known [formula] monotonic logic, it makes sense to consider properties that relate the monotonic part of answer sets to its non-monotonic side. That is the objective of the following properties.

Let P,P1,P2, and R be programs and x a rule.

BK-1: [formula] is a program. BK-2: [formula] BK-3: [formula] [formula] BK-4: if [formula] has answer sets then [formula]. BK-5: [formula] [formula] BK-6: if [formula] then [formula].

In the following we call these properties the BK-ASP properties. In Section [\ref=agmpostulates] we restated the 6 principles introduced in [\cite=agm85] (K-1,..., K-6), we now translate principle K-i from [\cite=agm85] to property BK-i in our approach. However, it should be noted that this is not the only translation possible. In BK-1 the notion of belief set is replaced by logic program. In the AGM postulates a sentence is part of a belief set whenever the belief set logically entails the sentence, for BK-2 and BK-3 we require that a program has to be inferred in [formula]. Like their counterparts, together properties BK-3 and BK-4 state that program update should be equivalent to expansion whenever possible, only that equivalence is understood as having the same answer sets. BK-5 establishes that an inconsistent program in [formula] will lead to an inconsistent update. We adopt only one of the implications of the original K-5 postulate; because we consider excessive, in our context, to demand an update operator to derive from an inconsistent program, a new consistent program given a possibly completely independent update. BK-6 says that equivalent programs should lead to equivalent updates, but the programs have to be equivalent in [formula], i.e., strongly equivalent and it is only expected that the updates will have the same answer sets. Finally, we present an additional property and prove that it is in fact equivalent to BK-6.

An update operator [formula] satisfies the BK-6 (WIS) property if and only if it satisfies the following property

BK-0: if [formula] then [formula].

To prove the right implication we have that [formula] implies [formula] now by applying BK-6 we obtain [formula] as desired. For the left implication, by applying BK-0 we obtain P [formula] P1 [formula] P [formula] ( [formula] ) similarly, P [formula] P2 [formula] P [formula] ( [formula] ) hence P [formula] P1 [formula] P [formula] P2 as desired.

A Basic Definition for Updates

In this section we present a simpler new definition for updates. We also prove that it is equivalent to [formula] for a class of programs involving tautologies, which we will define as tau-comp. The relevance of this approach relies on its simplicity and the insight it provides on the [formula] operator, which will become clearer when we introduce a possible refinement of this new operator as well as our alternative definition of [formula]. The notational conventions presented in Section [\ref=secupd] apply to this section as well.

Given an update sequence P = (P1,P2) over a set of atoms A, we define the update program P[formula] = [formula] over A* consisting of the following items:

(i) all constraints in [formula]; (ii) for each r ∈ P1; L ← [formula]. if H(r)  =  L; (iii) all rules r ∈ P2.

To illustrate this definition consider the following update sequence.

Let P1 be: sleep ← night, [formula]watch-tv, [formula]other. night. tv-on ← [formula]tv-broke. watch-tv ← tv-on.

Let P2 be: ~  tv-on ← power-failure. ~  tv-on ← assignment-due, working. assignment-due. working. other ← working.

If we update P1 with P2 we obtain the following program P1 [formula] P2:

sleep ← night, [formula]watch-tv, [formula]other, [formula]sleep. night ← [formula]night. tv-on ← [formula]tv-broke, [formula]tv-on. watch-tv ← tv-on, [formula]watch-tv. ~  tv-on ← power-failure. ~  tv-on ← assignment-due, working. assignment-due. working. other ← working.

This program has a unique expected answer set, namely {night, other, assignment-due, working, ~  tv-on}.

We say that a program P is tau-comp w.r.t. a signature A if every rule of the form l←l belongs to P, where l is a literal over A.

We will now prove that [formula] and [formula] are equivalent for tau-comp programs. The proof is based on results from [\cite=lopstr01] [\cite=tplp04] [\cite=Pea99:negation].

Let P1 and P2 be extended logic programs, if P2 is tau-comp then [formula]

The idea of the proof is to apply transformations to [formula] with respect to answer sets over the A signature, to obtain [formula] At some point we may delete rules involving a particular literal that we regard as temporary, i. e., a literal that does not form part of the A signature of the programs in the update sequence. This is due to the fact that the program that contains such rules is a conservative extension of the program that excludes them.

Consider a particular positive literal L (i.e. a literal consisting of an atom a not preceded by ~  ). By construction of [formula] (defined in Point (iv) of Definition [\ref=DZach3] given in Section [\ref=secupd]) the program includes the formulas L1←L2 and L←L1 for the literal L.

Also, since P2 is tau-comp then it includes the rules L2←L for the literal L.

Hence, [formula] and [formula].

So we can replace each of the L1 and L2 literals by L in the rest of the program as discussed in [\cite=ra74] [\cite=magd] . Then, we can eliminate rules in Point (iv) of Definition [\ref=DZach3] given previously as well as rules of the form L2←L (L1 and L2 are temporary literals).

So, the rules become L←B(r), [formula] and rej(r) ←B(r), ~  L corresponding to program P1. L←B(r) corresponding to program P2.

Now, observe that by Theorem [\ref=equivtheorem] the answer sets of the program are the same if we replace rej(r)←B(r), ~  L by [formula]. Observe that this transformation creates a rule whose form is different from that of rules of ELPs, however this situation is already considered in [\cite=tplp04] [\cite=Pea99:negation] [\cite=magd]. Then we can replace rej(r) in L← [formula] [formula] to obtain: [formula] (*)

then we can delete the rule [formula] since rej(r) is a temporary literal. Finally, to obtain the desired program, the rule of the form (*) can be replaced by [formula] following the next transformation [formula] by applying the De Morgan law, and [formula] [formula] [formula] by applying the distributive property. The previous rule can in turn be divided into two rules [formula] (1) [formula] (2) Rule (1) is a tautology and can therefore be eliminated, leaving only rule (2) which has the desired form according to Definition [\ref=deftautcomp]. This process can be applied analogously for the rest of the literals. In this way, except for the tautologies of P2, which have no effect on the answer sets of the derived program, we reach program [formula] as desired.

The update operator [formula] satisfies the properties BK-1, BK-2, BK-3, BK-5, and BK-6.

Properties BK-1, BK-2, BK-3, and BK-5 follow directly by construction. The BK-6 property follows straightforward by construction and Theorem [\ref=strongequiv].

This allows us to formalize our first result regarding the satisfability of the WIS property for the [formula] operator.

Let P be an ELP program and let P1 and P2 be tau-comp ELPs. If [formula] then [formula]

The result is immediate from the equivalence of the [formula] and [formula] operators for tau-comp programs presented in Theorem [\ref=theorem-tautcomp].

The BK-4 property is not satisfied in general. Consider the following example inspired from [\cite=bab03].

Let P1 be: day ← [formula]night. night ← [formula]day. see-stars ← night, [formula]cloudy. ~  see-stars.

The only answer set of this program is {~  see-stars, day}. Now, suppose that P1 is updated with: Let P2 be: see-stars ← see-venus. see-venus ← see-stars.

Applying the [formula] operator the answer sets of [formula] are: {see-stars, see-venus, night}, {~  see-stars, day}, and {~  see-stars, night}, while [formula] has the unique answer set {~  see-stars, day}. As we can see, the update process results in additional answer sets, so BK-4 doesn't hold.

This proposal satisfies the initialization, idempotence, and augmented update properties. The initialization property follows directly by construction. The augmented update property is satisfied because [formula] is equivalent in to P2 whenever P1  ⊆  P2. Since the idempotence property is actually a special case of the augmented update property, it holds also. As the following example shows, this new update operator ([formula]) doesn't satisfy the noninterference property.

This example shows that the noninterference property is not satisfied by the [formula] operator.

Let P1 be: day ← [formula]night. night ← [formula]day. see-stars ← night, [formula]cloudy. ~  see-stars.

Let P2 be: ~  tv-on ← power-failure. power-failure.

If we update P1 with P2 we obtain the following results:

[formula], because [formula] has only one answer set, while [formula] adds more models. Thus, the update operator [formula] doesn't satisfy the noninterference property.

With a slight modification in the definition of [formula], this property can be satisfied. We simply need to add the weakly negated literals only to those rules r in program P1 for which there is a conflictive rule r' in P2, i.e., rules for which H(r)  =    ~  H(r'). We denote this modified update operator by [formula]. However, this results in the loss of the BK-6 property, as the following example shows.

Consider the following programs. Let P be: [formula]. Let P1 be: a←a. Let P2 be: b. ~  a. b.

Here P1 and P2 are equivalent in [formula]. For the update program [formula] we obtain the answer sets {a,b} and {  ~  a,b}, while [formula] has the unique answer set {  ~  a,b}, therefore BK-6 (WIS) fails. In addition, the BK-4 property is still not satisfied, as applying the [formula] operator to the update sequence of Example [\ref=alf] would show. In the next section we present Example [\ref=exam-operators], where [formula] also yields unintended answer sets.

An Alternative Definition for Updates

In this section we introduce an alternative definition for updates as defined by the [formula] operator, prove that it is equivalent for single updates (i.e., update sequences consisting of two programs), and analyze its properties.

Given an update sequence P = (P1,P2) over a set of atoms A, we define the update program P[formula] = [formula] over A* consisting of the following items:

(i) all constraints in [formula]; (ii) for each r∈P1; L←B(r), [formula]sup(comp(L),P2). if H(r)  =  L; (iii) all rules r∈P2. where comp(L)  =   ~  L. comp(  ~  L)  =  L.

Also, for a program P and a literal L let

KL = { B(r)|H(r) = L,r∈P }

and

Note that sup(L,P) essentially takes a disjunction of the bodies of the rules that have L in their head, or evaluates to [formula] in case L does not appear in any of the heads of the rules of program P. Also note that sup(L,P) evaluates to [formula] if L appears as a fact in P, i.e., a rule of the form [formula].

We apply this definition to the update sequence presented in Example [\ref=firstexample]. If we update P1 with P2 we obtain the following program P1 [formula] P2:

sleep ← night, [formula]watch-tv, [formula]other. night. tv-on ← [formula]tv-broke, [formula](power-failure [formula] (assignment-due [formula] working)) watch-tv ← tv-on. ~  tv-on ← power-failure. ~  tv-on ← assignment-due, working. assignment-due. working. other ← working.

This program has the same unique answer set that was obtained in Example [\ref=firstexample], namely {night, other, assignment-due, working, ~  tv-on}.

It is important to consider that the updated program is no longer an extended logic program. The following lemma shows that our approach is equivalent to the [formula] operator.

For any extended logic programs P1 and P2, [formula]

We apply a series of transformations to [formula] with respect to answer sets over the A signature, to obtain [formula]. At some point we may delete rules involving a particular literal that we regard as temporary, i. e., a literal that does not form part of the A signature of the programs in the update sequence. This is due to the fact that the program that contains such rules is a conservative extension of the program that excludes them.

Note: in our proof we will apply the following transformation several times. For a subset of rules [formula] of a program P, where L denotes a particular literal and each αi an arbitrary formula representing the body of its respective rule, we join the rules of the subset into a single rule of the form [formula] by taking the disjunction of the bodies of all the rules. Thus, such subset of rules can be replaced by a single rule in program P, as long as all the rules that have L as its head have been taken into consideration. This transformation can also be applied inversely to decompose a rule.

Considering a particular literal L, the rules of [formula] are of the form L1←B(r), [formula] * rej(r)←B(r), ~  L2 L2←B(r')* L1←L2 L←L1 where r represents a rule from program P1, r' a rule from program P2, and * denotes the possible existence of multiple rules of the same form (i.e. rules with the same head but different bodies). The first two types of rules come from Point (ii) of Definition [\ref=DZach3], while the third comes from Point (iii) and the last two from Point (iv). Constraints are omitted since they undergo no changes. First, we apply the unfolding transformation (see [\cite=baral03:cambridge]). The rule L1←L2 is unfolded with respect to the rules L2←B(r'), i.e., the rule L1←L2 is replaced by n rules of the form L1←B1(r') ; ... ; L1←Bn(r') resulting from each of the n rules L2←B1(r') ; ... ; L2←Bn(r'). Thus the following equivalent set of rules is derived L1←B(r), [formula] * rej(r)←B(r), ~  L2 L2←B(r')* L1←B(r')* L←L1 By Theorem [\ref=equivtheorem] the answer sets of the program are the same if we replace the rule rej(r)←B(r), ~  L2 by [formula]). Then we can replace rej(r) in all rules [formula] [formula] to obtain rules of the form [formula]) (1) and afterwards we can delete the rule [formula]) since rej(r) is a temporary literal. The rule of the form (1) can be replaced by [formula] following the next transformation. First, by applying the De Morgan law we obtain [formula] Then, by the distributive property the previous rule becomes [formula] This rule can in turn be divided into two rules [formula] (a) [formula] (b) Rule (a) is a tautology and can therefore be eliminated. In this way we arrive to the following set of rules L1←B(r), [formula] * L2←B(r')* L1←B(r')* L←L1 Now we join all the rules that contain ~  L2 in the head into a single rule ~  L2 [formula] (c) where r'' represents a rule of program P2. By Theorem [\ref=equivtheorem] this allows us to replace ~  L2 in rules (b) to obtain rules of the form [formula] (d) Note that rule (d) has the form of Point (ii) of our definition and that rule (c) can be eliminated since ~  L2 is a temporary literal. Now we join the bodies of all rules (d) and L1←B(r') into a single rule L1←α where α abbreviates the composed body. Similarly, we also join the bodies of all the rules L2←B(r') to obtain the rule L2←β. Thus we derive a new set of rules L1←α L2←β L←L1 Then we can delete the rule L2←β since L2 is a temporary literal. Next we replace L1 in the third rule for α generating the rule L←α. At this point the rule L1←α can be eliminated because L1 is a temporary literal. By decomposing the remaining rule L←α we can generate the rules [formula] * L←B(r')* The first rule represents the set of rules of the Point (ii) of Definition [\ref=operator3], while the second rule represents the set of rules created with Point (iii). We can apply this process analogously for the rest of the literals. After this sequence of transformations we obtain the same set of rules as by applying our definition, thus the two operators are equivalent.

Initially, it may appear that the [formula] operator could be equivalent to the [formula] operator discussed in Section [\ref=basicdef]. However, as the following example shows, this is not the case.

Consider the following programs. Let P1 be: [formula]. Let P2 be: a←c. ~  a. b. ~  c.

The updated program [formula] has the answer sets {~  a, b, ~  c} and {a, b, ~  c} while [formula] has the unique answer set {~  a, b, ~  c}. For this particular example, we can say that the [formula] operator incorporates the new knowledge more accurately, since a should not be derived if it depends on c, which is not true in the first place. Nevertheless, for the cases in which there are no conflicting literals in the first of the programs, the operators in question would be equivalent.

Next we will discuss how this definition of update programs relates to the BK-ASP properties presented earlier.

A program P is tau-free w.r.t. a signature A if no rule of the form l←l,α belongs to P, where α is a formula which could be empty and l a literal over A. By abuse of notation we define a tau-free rule as a rule that does not follow the structure just described.

The update operator [formula] satisfies the BK-ASP properties BK-1, BK-2, BK-3 and BK-5 for any extended logic programs P, P1, and P2 as well as BK-6 if P1 and P2 are tau-free ELPs.

The first four properties follow directly by construction. The proof that BK-6 holds for tau-free ELPs for the operator [formula] is presented in Lemma [\ref=LZach2] of [\ref=appendixa]. Because the operator [formula] is equivalent to the operator [formula] that result applies as well.

We now make use of the examples of Section [\ref=basicdef] to demonstrate that the properties BK-4 and BK-6 are not satisfied in general by the update operator [formula] and equivalently by [formula].

First, we apply the operator [formula] to the update sequence in Example [\ref=alf]. The answer sets of [formula] are: {see-stars, see-venus, night} and {~  see-stars, day}, while [formula] has the unique answer set {~  see-stars, day}. As we can see, the update process adds a second answer set, so BK-4 doesn't hold.

Now, when we consider the update sequences of Example [\ref=exam-wis] we obtain the following results. The programs P1 and P2 are equivalent in [formula]. For the update program [formula] we obtain the answer sets {a,b} and {  ~  a,b}, while [formula] has the unique answer set {  ~  a,b}, therefore BK-6 (WIS) fails.

In order to resolve the previous discrepancies, the update semantics can be refined in the following way

where P2' is P2 without tautologies. In this way all of the BK-ASP properties we have presented are satisfied.

The update operator [formula] satisfies the BK-ASP properties BK-1 to BK-6 for any extended logic programs.

Because of the refinement just introduced, property BK-4 holds and the rest of the first five properties follow directly by construction. We prove that BK-6 holds for the operator [formula] as follows. For the ELPs P1 and P2 we assume [formula]. Now if [formula] has answer sets, by Theorem [\ref=strongequiv] these are the same answer sets of [formula], which is [formula] according to our definition. If [formula] does not have answer sets, then Lemma [\ref=LZach2] (see [\ref=appendixa]) applies, since tautologies are removed from the right operand, i.e., the program that introduces the new rules.

The previous theorem demonstrates that in principle it is possible to define a semantics that satisfies all of the BK-ASP properties, which is important from a mathematical viewpoint. However, this semantics is not free of counterintuitive and undesirable behaviors, as was brought to our attention by one of our anonymous reviewers with the following examples (adapted to include strong negation).

Consider the following programs. Let P be: see-stars. Let P1 be: see-stars ← see-stars. ~  see-stars. Let P2 be: see-stars ← see-venus. see-venus ← see-stars.

The program [formula] does not have answer sets, as would normally be expected. However, the program [formula] has the single answer set {see-stars, see-venus}, which intuitively should not have been derived from the new information in P2.

Consider the following programs. Let P1 be: open-school. Let P2 be: ~  open-school ← holiday. holiday ← [formula]workday. workday ← [formula]holiday. Let P3 be: see-stars. Let P4 be: ~  see-stars.

Program [formula] has the single answer set {open-school, workday}, which is the same single answer set of [formula]. However, program [formula] has two answer sets, namely {open-school, workday, ~  see-stars} and {holiday, ~  open-school, ~  see-stars}. The addition of rules affects the interpretation of other rules, despite having disjoint alphabets. Therefore the [formula] operator violates the general principle that completely independent parts of a program should not interfere with each other.

The existence of such undesirable behaviors suggests the need of analyzing alternative semantics for logic program updates, considering for instance the semantics presented in [\cite=dylps] and [\cite=homola01]. We consider this to be an interesting direction for future work.

Conclusions

We have presented a set of properties based on [formula] logic that provide a reinterpretation the AGM postulates into the context of answer set programming. These properties hold for update programs following the definition presented in [\cite=updcaus] after an unsubstantial modification of its semantics. In addition, we introduced an alternative definition for update programs that is equivalent, yet more concise and intuitive. There are many aspects to consider in the theory of belief revision and update. The desired behavior in a particular situation may prove inappropriate in a different setting. It is essential to characterize the properties that ought to be respected in the process of belief change, however, it is unlikely that such characterization can be reduced to a set of generally accepted and applicable postulates. We can also conclude that the approach based on [formula] logic for the characterization of answer sets has proven useful to obtain a better understanding of the answer set semantics, as well as to study many of its interesting properties.

We emphasize that with the properties presented in this paper we aim only to provide a starting point for the analysis of belief revision under answer set semantics. Still more work needs to be done to identify new interesting properties and define alternative operators for belief change.

Acknowledgements

We would like to thank Vladimir Lifschitz for his remark regarding Lemma [\ref=formercorollary1].

Analysis of the WIS property

We prove that the operator [formula] satisfies the Weak Independence of Syntax property for tau-free programs.

[\cite=updcaus] Let us call two rules r1 and r2 conflicting H(r1)  =   ~  H(r2), we denote this by [formula].

[\cite=updcaus] For an update sequence P = (P,...,Pn) over a set of atoms A and S  ⊆  LitA based on the principle of founded rule rejection, we define the rejection set of S by Rej(S, P) =   [formula] Reji(S, P), where Rejn(S, P) =   [formula] and, for n  >  i  ≥  1,

Reji(S, P) =   [formula] P), for some j∈{i + 1,...,n} such that [formula] and [formula]

[\cite=updcaus] For an update sequence P = (P,...,Pn) over a set of atoms A and S  ⊆  LitA, let us define

Rej'(S, P) =   [formula], for some j∈{i + 1,...,n} such that [formula] and [formula]

Note a: Observe that Rej and Rej' coincide for two programs. Furthermore [formula], such that [formula], and [formula]. So Rej' only contains clauses from P1 and not from P2, i.e., only rules from P1 are rejected.

We denote by [formula] the set of all rules occurring in [formula], i.e., [formula] = [formula]. By PS we denote the standard reduct of a program P with respect to a set of literals S.

Let P = (P1,P2) be an update sequence over a set of atoms A and S  ⊆  LitA a set of literals. Then, S is an answer set of P S is an answer set of [formula].

S is an answer set of P S is the minimal model of [formula] (by Theorem 4 given in [\cite=updcaus]) S is an answer set of [formula] S is an answer set of [formula] (by Note a) as desired.

Let P be an extended logic program, x a literal, and M a set of literals. If [formula] and [formula], then [formula] r∈P such that r has the form x←β and [formula].

Due to the translation from Nelson logics to intermediate logics, we may suppose to be in [formula]. The translation adds more rules to the programs but these are constraints, so the result is not affected. Additionally, this allows us to replace the literal x by an atom a. Assume by contradiction that [formula] such that r has the form a←β, [formula] is false. We need to prove that [formula] is false. Let us construct an interpretation I based on [formula]. If an atom belongs to [formula] we assign to it the value 2. If the negation of an atom belongs to [formula] we assign to it the value 0. Since [formula] then clearly I models P. Now we construct another interpretation I' based on I as follows. All atoms but a are assigned the same value as in I, while a is assigned the value 1. It is easy but tedious to check that I' also models P. However, I' does not model a, as desired.

Let P1, P2, {c}, and {r} be extended logic programs where r∈P1 and c is a tau-free rule. Let M be a set of literals. Suppose [formula], [formula], and [formula]. Also, r and c are conflicting rules. Then [formula] r'∈P2 such that r' is a conflicting rule with r and [formula]

Let c and r be formulas of the form x←θ and ~  x←β, respectively. We assume that r∈P1, [formula], and that c and r are conflicting rules. Furthermore, we assume [formula]. Also by hypothesis [formula], therefore [formula]. Then by Lemma [\ref=new_lemma], [formula] [formula] such that r' is of the form x←B(r') and [formula]. Moreover r'∈P2, due to the restriction that c is a tau-free rule and consequently cannot contain x in its body.

Let P1, P2, and {c} be extended logic programs where {c} is tau-free. Suppose [formula] and [formula]. Then Rej'(S,(P1,P2)) = [formula].

We need to prove two cases:

Case 1) [formula] Clearly holds.

Case 2) [formula]

Let [formula] then [formula] such that [formula] Here we have two cases: a) If r'∈P2 then r∈Rej'(S,(P1,P2)) as desired. b) If r'  =  c, we have r∈P1, [formula], [formula], r and c are conflicting rules, and by hypothesis [formula]. Then by Lemma [\ref=Lg3], [formula] such that r and r" are conflicting rules and [formula]. Hence, r∈Rej'(S,(P1,P2)) as desired.

Note b: [formula] implies [formula]

Let P1, P2, and {c} be extended logic programs where {c} is tau-free. If [formula] then [formula]

S is an answer set of [formula] iff by Lemma [\ref=LZach6] S is an answer set of [formula] iff by Lemma [\ref=LZachnew] S is an answer set of [formula] iff by Note b S is an answer set of [formula] iff by Lemma [\ref=LZach6] S is an answer set of [formula]

Hence, [formula] as desired.

Now we can present our main result.

Let P1, P2, and R be extended logic programs where R is tau-free. Suppose that [formula], then P1 [formula] P2 [formula] P1 [formula] [formula]

By induction on the size of R. Base case: Let [formula], the result is immediate. Induction step: Let P2, R, and {c} be extended logic programs where R and {c} are tau-free. We need to show:

if [formula] then [formula]

But we know that [formula] means that [formula] and [formula], then by applying the induction hypothesis [formula] (I) By Lemma [\ref=LZach1], if [formula] then [formula] [formula] (II)

Now, from (I) and (II) we have [formula] Since [formula] [formula] we obtain [formula] as desired.

We have proven that the BK-0 property holds for the [formula] operator if R is tau-free. If we apply the proof of Theorem [\ref=bk0] of Section [\ref=properties] under this restriction, this results in the fact that BK-6 holds provided P1 and P2 are tau-free.

Proof of Lemma [\ref=formercorollary1]

Recall that an alternative proof is presented in [\cite=fer05b].

Let P be a program over a set of atoms A and x a literal that does not occur in P. Let F be a formula over a set of atoms F such that LitF  ⊆  LitA. Then [formula].

If we apply the definition of an answer set given in Theorem [\ref=answersetdef], then we only need to prove

[formula] iff [formula]

First, we apply the transformation described in Section [\ref=nelsonlogic] to reduce the previous statement to provability in , obtaining

[formula] iff [formula]

where P' represents program P after the change of literals ~  l by atoms l', F' the formula F after the same changes, and C' the set of added constraints (excluding the constraint involving x). Now we have two cases.

I) x∉M so [formula]

In this case the statement to prove becomes

[formula] iff [formula]

where [formula] denotes the set [formula] excluding the atom x. It is easy to show that [formula] so the statement holds for both implications.

II) x∈M so [formula]

In this case the statement to prove becomes

[formula] iff [formula]

where M' denotes the set M' excluding the atom x. It is easy to show that this statement can be reduced to

[formula] iff [formula]

We will abbreviate the statement above in the following way

[formula] iff [formula]

It is important to remark that x does not occur in H or in F'. For consistency, the right implication clearly holds. We prove the left implication as follows. We assume [formula] is consistent and complete. By the results obtained in [\cite=tplp04] [\cite=lopstr01] F'  →  x,H is also consistent and complete. So there is an interpretation I such that I(H)  =  2. We construct a new interpretation I' that differs from I only in that I'(x)  =  I(F), so I' models F'  ↔  x,H. Therefore F'  ↔  x,H is consistent. Since by hypothesis [formula] (because x∈M) then clearly [formula]. So [formula] is consistent.

In respect to logical consequence, the right implication clearly holds. We will prove the left implication for every atom a∈M. Again from the results obtained in [\cite=tplp04] [\cite=lopstr01] we can replace [formula] by F'  ↔  x,H in our proof, so we only need to prove

if [formula] then [formula]

We will prove its contrapositive, i.e.

if [formula] [formula] then [formula] [formula]

If a  =  x then we have several cases. If [formula] and I(a)  =  I(x)  =  0 then I(F') must evaluate to 0, so with I': = I the statement holds. The case when [formula] and I(x)  =  0 is analogous. For the case when [formula] and I(x)  =  1, if I(F')  =  1 then we define I': = I as in the previous cases. Now if I(F')  =  0 we take I' to be equal to I except for the fact that we define I'(x)  =  0, which satisfies the desired condition. The proof for the case when x  ≠  a is analogous but simpler, and is therefore omitted.