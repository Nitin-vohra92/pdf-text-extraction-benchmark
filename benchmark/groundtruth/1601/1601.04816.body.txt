=0mm

Remark Definition

Tetrisation of triangular meshes and its application in shape blending

Introduction

In the seminal paper [\cite=ARAP], they introduced a morphing algorithm called the As-Rigid-As-Possible (ARAP, for short) shape interpolation. Since then, the technique has been successfully applied to various shape deformation applications. In their original paper, tetrahedral volume meshes are used to produce interpolation of shapes. However, in most computer graphic systems it is common to represent shapes by surface meshes. To convert a surface mesh to a volume mesh is a non-trivial task (see, for example, [\cite=tetgen]) and the resulting volume mesh tends to have many extra internal vertices, which makes applications inefficient. Instead of considering volume meshes, one can "fatten" surface meshes. A common practice is to associate a tetrahedral structure to a triangular surface mesh by adding the normal vector for every triangle (see, for example, [\cite=Sumner2]). Although this simple trick has been widely used, it does not capture important geometric features of the mesh. For example, the relation between adjacent triangles is neglected.

One of the main purposes of this paper is to introduce a new construction to associate a tetrahedral structure to a triangular mesh, which we call tetrisation (§[\ref=sec:tetrisation]). Our method encodes inter-triangular properties such as the angle between adjacent triangles so that one can keep track of global geometry such as curvature while working locally on tetrahedra.

We also discuss an improvement of the ARAP (§ [\ref=sec:arap]) in how to interpolate local transformations (§ [\ref=sec:blend]) and how to stitch fragmented tetrahedra by a new error function (§ [\ref=sec:error]). We demonstrate our improvement by a shape blending application (Fig. [\ref=fig:penguins]). Given an arbitrary number of isomorphic surfaces, our algorithm produces inter/extrapolation of the shapes according to the weights given by the user. Roughly speaking, we define a "linear combination" of shapes

[formula]

where [formula] are weights and Qi are shapes. In particular, when the number of shapes is two, w1Q1  +  (1 - w1)Q2 for 0  ≤  w1  ≤  1 gives a morphing between them. Note that our algorithm is highly non-linear although we described the procedure as taking the linear combination of shapes. We implemented the algorithm as the Autodesk Maya plugin. Its MIT licensed source code is available at [\cite=code].

Notation

We begin with listing some notation. We assume all tranformations are represented by real matrices, acting on real column vectors by the multiplication from the left.

[formula]: the group of 3D rotations. Its element is a 3  ×  3 special orthogonal matrix.

[formula]: the set of 3D shears. Its element is a 3  ×  3 positive definite symmetric matrix.

[formula]: the group of (invertible) 3D linear transformations consisting of compositions of rotation, shear, and reflection. Its element is a 3  ×  3 regular matrix.

[formula]: the group of (invertible) 3D affine transformations consisting of compositions of rotation, shear, reflection, and translation. Its element is a 4  ×  4 regular homogeneous matrix.

[formula]: the subgroups of the reflection free (positive determinant) elements in the corresponding groups.

[formula]: the linear part (3  ×  3 upper-left corner) of [formula].

At: the transpose of a matrix A.

[formula]: the squared Frobenius norm of a matrix A.

#  U: the cardinality of a set U.

As-rigid-as-possible deformation framework

In this section, we recall the ARAP framework by describing an algorithm for shape blending. Note that although we discuss shape blending as the primary application, the framework and our improvement is not limited to it. Indeed, after being introduced in [\cite=ARAP] initially as a morphing algorithm, the ARAP technique has been serving as one of the fundamental frameworks for various kinds of shape deformation applications (see, for example, [\cite=BS] [\cite=probe] [\cite=Sorkine] [\cite=Sumner2] [\cite=Sumner]).

Our problem setting is as follows. We are given a rest shape V0 and m its deformations Vj (1  ≤  j  ≤  m). That is, a vertex correspondence between V0 and each of Vj (1  ≤  j  ≤  m) is assumed. We would like to compute the deformation [formula] by blending the given shapes {Vj} according to the user specified weights [formula]. We insist that it interpolates the given shapes, i.e., [formula], and [formula] when [formula]. Notice we allow negative weights and weights greater than one so that the system can not only interpolate but also extrapolate.

A basic shape blending is achieved by simply taking the linear combination of the coordinates of the vertices. This method is very fast and widely used to produce variations of shapes, in particular, facial expressions. However, since the geometry of shapes is disregarded, it does not always produce plausible outputs (Fig. [\ref=fig:linear-blendshape]). The ARAP based method which we will describe below takes geometry into account to obtain better results.

We assume that the rest shape is equipped with a non-degenerate tetrahedral structure (V0,T). We will discuss in § [\ref=sec:tetrisation] a method to associate one to a triangular mesh.

A tetrahedral structure is a pair (V,T), where the vertex set V consists of three dimensional vectors and the set of tetrahedra T  =  {Ti|1  ≤  i  ≤  n} consists of ordered tuples of four distinct vertices Ti = (vi1,vi2,vi3,vi4). Each vertex in V must be contained in at least one tetrahedron. A tetrahedral structure is said to be non-degenerate when the vertices of each tetrahedron are not co-planar.

We emphasise that a triangle can be shared by three or more tetrahedra, and for this reason, we use the terminology "tetrahedral structure" rather than tetrahedral mesh.

The information of a tetrahedral structure (V,T) can be packed into a collection of 4  ×  4-matrices:

[formula]

where [formula] is the vector representing the position of the vertex vij∈V.

We denote by {P0i|1  ≤  i  ≤  n} the matrices associated to the rest shape (V0,T). Since (V0,T) is assumed to be non-degenerate, all the P0i are regular. For each deformation Vj, we use the same set of tetrahedra T to obtain {Pji|1  ≤  i  ≤  n}. Note that Pji need not be regular. We define a series of affine transformations

[formula]

which maps the vertices V0 of the rest shape to the ones Vj in the deformed shape. Obviously, Ajiv = Aji'v when v∈V0 is contained in two tetrahedra Ti and Ti'. Thus, {Pji|1  ≤  i  ≤  n} can be considered as a piecewise linear map defined on (V0,T) with (Vj,T) as its image.

Now, we have m piecewise linear maps [formula] and the problem is rephrased as to blend them according to the user specified weights wj (1  ≤  j  ≤  m). We first consider locally and blend P̂ji (1  ≤  j  ≤  m) for a single tetrahedron Ti to obtain [formula]. Intuitively, Ci stipulates the local transformation for the tetrahedron Ti. We discuss a method to compute Ci in § [\ref=sec:blend]. The last step is to find a global piecewise linear map on (V0,T), whose image we take as the output. Since we cannot assume Civ agrees with Ci'v for a vertex v∈V0 which is contained in two tetrahedra Ti and Ti', we have to "stitch" them. What we do is to find a piecewise linear map which is closest to the collection {Ci|1  ≤  i  ≤  n} with respect to an error function. We discuss different error functions in § [\ref=sec:error]. The deformed shape [formula] is computed as the minimiser of the error function.

In the following sections, we discuss each step in detail.

Tetrisation

In computer graphics systems, shapes are usually represented by surface meshes. To apply the ARAP technique described in the previous section, we have to have a tetrahedral structure. Here, we consider a method to build a tetrahedral structure from a given triangular surface mesh.

For a triangular mesh, we denote an element of the vertex set V by a three dimensional vector and an element of the set of (face) triangles F by an ordered tuple of three vertices (v1,v2,v3). For (v1,v2,v3)∈F, we call the ordered tuples v1v2,v2v3 and v3v1 the oriented edges. A triangular mesh is said to be non-degenerate when the vertices of each triangle are not co-linear.

Given a triangular mesh, we would like to associate a tetrahedral structure which we can apply the ARAP framework to.

Given a non-degenerate triangular mesh (V,F). A tetrisation of (V,F) is a tetrahedral structure which consists of the vertex set [formula] and the set of tetrahedra T. We require (,T) to satisfy the following conditions:

V  ⊂  . That is, [formula] is obtained by adding ghost vertices to V.

Each triangle in F has to be contained in at least one tetrahedron in T.

Each tetrahedron is non-degenerate, that is, the four vertices are not co-planar.

These conditions are exactly what are required in the ARAP framework.

We give three methods to produce tetrisation in the following. Recall that the unit normal vector n(F) of a triangle F = (v1,v2,v3) is computed by [formula], where the denominator |(v2 - v1)  ×  (v3 - v1)| is twice the area [formula] of F.

Face-normal tetrisation

We begin with a simple method which has been commonly used in various applications. For each triangle F = (v1,v2,v3) in F, add the ghost vertex

[formula]

and form a tetrahedron (v0,v1,v2,v3). The resulting tetrahedral structure has #  T  =    #  F and #    =    #  V  +    #  T.

A problem with this tetrisation when applied to the ARAP framework is that this does not capture the relation between adjacent triangles. For example, consider two triangles sharing an edge as in Fig. [\ref=fig:face-normal]. Any rotation invariant error function (see § [\ref=sec:error]) with C1 = C2 = Id will be minimised regardless of the angle between the two triangles. In other words, folds do not cause any penalty in the error function.

Edge-normal tetrisation

We assume each oriented edge appears only once among all the triangles. In other words, an unoriented edge should be contained at most two triangles with opposite orientations. Also, we assume all the triangles have at least one shared edge, that is, there is no "lone" triangle. (We can remove this assumption by adding ghost vertices not only for shared edges but also for all edges. However, this is inefficient and makes no sense.)

For each shared edge v1v2, denote by F1 = (v1,v2,v3) and F2 = (v1,v4,v2) the two triangles adjacent to it. Add a ghost vertex

[formula]

and form two tetrahedra (v0,v1,v2,v3) and (v0,v1,v4,v2). The resulting tetrahedral structure has [formula] and [formula]. The idea of this tetrisation is to encode the angle between adjacent triangles, which is neglected by the face-normal tetrisation.

Vertex-normal tetrisation

We assume that every vertex has a neighbourhood homeomorphic to the plane or the half plane. In other words, the mesh is a manifold (with boundary). Also, we assume all the triangles have at least one shared vertex. (Again, we can remove this assumption as in the previous subsection.)

For each shared vertex v, denote the adjacent triangles by [formula] and Fk. Add a ghost vertex

[formula]

and form k tetrahedra by adding v0 to the triangles Fi (1  ≤  i  ≤  k). The resulting tetrahedral structure has [formula] and [formula]. An advantage of this method is that it extends straightforwardly to general polyhedral meshes. The idea of this tetrisation is to encode the angle around internal vertices, which is neglected by the face-normal tetrisation.

Blending linear maps

In this section, we discuss how to blend local transformations [formula] with regard to the weights [formula] to obtain the blended local transformation [formula]. For this purpose, we use a function [formula] which satisfies the obvious requirement for interpolation. Then, we set

[formula]

We investigate two such interpolation functions.

First, decompose each Âki by the polar decomposition (see, for example, [\cite=Higham] [\cite=polar])

[formula]

where [formula] is the rotation and [formula] is the shear. In [\cite=Sumner], they suggest

[formula]

where log  is the principal matrix logarithm and I is the identity matrix. This coincides with the one used in [\cite=ARAP] when m = 1. On the other hand, we suggest

[formula]

where log c is the "continuous" logarithm such that it chooses the nearest branch of logarithm to the adjacent tetrahedra when i varies (see [\cite=Kaji-Ochiai] for details). The indeterminacy of log  for [formula] is in the rotation angle and log c chooses the angle continuously for adjacent tetrahedra. Note that [\cite=Kaji-Ochiai] provides a direct and fast formula for [formula] which does not require the polar decomposition.

They look similar but there are two significant differences; blending for the shear part and logarithm for [formula]. The value of [formula] can fall out of [formula] due to the linear blending of the shear part, which causes distortion in the output (Fig. [\ref=fig:sym-linear]). The use of the continuous logarithm enables the system to produce a smoother morph among shapes which performs large rotation in between (Fig. [\ref=fig:large-rotation]). Note that in [\cite=ARAP] which discusses morphing of two shapes, they suggest to use the quaternions and SLERP ([\cite=SLERP]) to interpolate the rotation part and the linear interpolation for the shear part. (With three or more shapes, one can use the linear blending of the quaternions for the rotation part as in [\cite=DLB].) However, this method shows similar deficiency as [formula].

Error function

In this section, we consider error functions to stitch fragmented tetrahedra. Fix the vertex positions V0 of the rest shape and the local transformations {Ci|1  ≤  i  ≤  n} of the tetrahedra. An error function is a function of the deformed vertex positions V'. By Equation [\eqref=eq:local-trans], a piecewise linear map {Ai|1  ≤  i  ≤  n} and V' are linearly related and we identify them. In [\cite=ARAP], they introduced

[formula]

and it has been used in many of the ARAP based shape deformation applications including [\cite=nway] [\cite=Sumner2] [\cite=Sumner] [\cite=Yu]. Note that the function is translation invariant but not rotation invariant. Rotation invariance is sometimes preferable in shape deformation (see, for example, [\cite=Lipman] [\cite=Sorkine] and Fig. [\ref=fig:comparison]). We propose an alternative error function which is rotation and translation invariant:

[formula]

where S(X) for [formula] is the shear factor of the polar decomposition of X (see [\cite=polar]). Intuitively, this error function measures how much each tetrahedron is distorted. Despite the simplicity and its invariance property, ES has not been considered in the literature as far as the author is aware. We believe this error function gives a good alternative to ET in some applications (see Fig. [\ref=fig:comparison]).

We can assign a weight [formula] to each tetrahedron Ti to specify its contribution to the error function. It is done simply by replacing the summation [formula] with the weighted one [formula] in the definitions of the error functions. For notational simplicity, we omit them in this paper.

As we described in § [\ref=sec:arap], we define the output as the minimiser of the error function. In other words, we compute the piecewise linear function {Ai|1  ≤  i  ≤  n} which is closest to {Ci|1  ≤  i  ≤  n} with respect to the error function. Computing the minimiser for ET is reduced to solving a sparse linear system (see [\cite=ARAP] [\cite=Sumner]). For ES, the computation is not linear. An iterative way similar to [\cite=Sorkine] is given as follows:

Compute the minimiser of ET(V',{Ci}) and set Âi.

Compute the polar decomposition Âi = RiSi.

Compute the minimiser of ET(V',{RiS(Ci)}) to update {Âi}.

Repeat (2) and (3) until {Âi} converge.

Note that there is some indeterminacy of the minimiser coming from the symmetry of the error function. For example, any translation of a minimiser is also a minimiser. To obtain a unique minimiser, one can impose additional constraints; for ET fixing the position of the barycentre and for ES fixing the position of the barycentre and the orientation of some tetrahedra.

Implementation

We implemented our algorithm as the Autodesk Maya plugin ([\cite=code]). In our system, the user can specify the weight for each shape with sliders, or the ball controller which computes the weights by [\cite=Floater] from the configuration of the balls representing the shapes (Fig. [\ref=fig:maya]).

The ARAP framework was also applied to shape blending in [\cite=nway] in the 2D setting and in [\cite=Sumner] in the 3D setting. We demonstrate our improvement discussed in § [\ref=sec:tetrisation] and § [\ref=sec:error] by comparing with [\cite=Sumner]. First, we note that in [\cite=Sumner], (i) the face-normal tetrisation, (ii) the error function ET, (iii) and the blending function [formula] are used. We have already seen the difference between the blending functions [formula] and [formula] at the end of § [\ref=sec:blend]. We will turn our attention to (i) and (ii). Fig. [\ref=fig:comparison] visually compares different tetrisations in § [\ref=sec:tetrisation] and the error functions ET and ES in § [\ref=sec:error]. We observe that ES produces more natural results than ET but much slower as we see in Table [\ref=table:timing]. With ES, the face-normal tetrisation causes extra wrinkles compared to the edge-normal and the vertex-normal tetrisations. As far as we experimented, it depends on the character of shapes to be blended which tetrisation gives the best result. In general, with ET the output is more or less similar regardless of the choice of tetrisation. With ES, the vertex-normal tetrisation seems to be a good choice.

Table [\ref=table:timing] shows a timing comparison for different tetrisations and error functions. We blended two 3D models each with 26k triangles on a Macbook Air with 1.7GHz Intel Core i7 and 8GB memory. Initialisation part involves the Cholesky decomposition of the space matrix necessary to solve the minimiser of the error functions. This is computed only once in the initialisation process. Note that the matrix is dependent on the tetrahedral structure but independent of the choice of the error function. Runtime part consists of finding the minimiser of the error functions and the computation of [formula] functions.

Acknowledgement

This work was partially supported by the Core Research for Evolutional Science and Technology (CREST) Program titled "Mathematics for Computer Graphics" of the Japan Science and Technology Agency (JST), by KAKENHI Grant-in-Aid for Young Scientists (B) 26800043, and by JSPS Postdoctoral Fellowships for Research Abroad.