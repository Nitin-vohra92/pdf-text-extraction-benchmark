Theorem Proposition Fact Claim Corollary Conjecture

Definition Remark Example

Notation

Meaningful Information

Introduction

The information contained by an individual finite object (like a finite binary string) is objectively measured by its Kolmogorov complexity--the length of the shortest binary program that computes the object. Such a shortest program contains no redundancy: every bit is information; but is it meaningful information? If we flip a fair coin to obtain a finite binary string, then with overwhelming probability that string constitutes its own shortest program. However, also with overwhelming probability all the bits in the string are meaningless information, random noise. On the other hand, let an object x be a sequence of observations of heavenly bodies. Then x can be described by the binary string pd, where p is the description of the laws of gravity, and the observational parameter setting, while d is the data-to-model code accounting for the (presumably Gaussian) measurement error in the data. This way we can divide the information in x into meaningful information p and data-to-model information d.

The main task for statistical inference and learning theory is to distil the meaningful information present in the data. The question arises whether it is possible to separate meaningful information from accidental information, and if so, how.

In statistical theory, every function of the data is called a "statistic" of the data. The central notion in probabilistic statistics is that of a "sufficient" statistic, introduced by the father of statistics R.A. Fisher [\cite=Fi22]: "The statistic chosen should summarise the whole of the relevant information supplied by the sample. This may be called the Criterion of Sufficiency [formula] In the case of the normal curve of distribution it is evident that the second moment is a sufficient statistic for estimating the standard deviation." For traditional problems, dealing with frequencies over small sample spaces, this approach is appropriate. But for current novel applications, average relations are often irrelevant, since the part of the support of the probability density function that will ever be observed has about zero measure. This is the case in, for example, complex video and sound analysis. There arises the problem that for individual cases the selection performance may be bad although the performance is good on average. There is also the problem of what probability means, whether it is subjective, objective, or exists at all.

To simplify matters, and because all discrete data can be binary coded, we consider only data samples that are finite binary strings. The basic idea is to found statistical theory on finite combinatorial principles independent of probabilistic assumptions, as the relation between the individual data and its explanation (model). We study extraction of meaningful information in an initially limited setting where this information be represented by a finite set (a model) of which the object (the data sample) is a typical member. Using the theory of Kolmogorov complexity, we can rigorously express and quantify typicality of individual objects. But typicality in itself is not necessarily a significant property: every object is typical in the singleton set containing only that object. More important is the following Kolmogorov complexity analog of probabilistic minimal sufficient statistic which implies typicality: The two-part description of the smallest finite set, together with the index of the object in that set, is as concise as the shortest one-part description of the object. The finite set models the regularity present in the object (since it is a typical element of the set). This approach has been generalized to computable probability mass functions. The combined theory has been developed in detail in [\cite=GTV] and called "Algorithmic Statistics."

Here we study the most general form of algorithmic statistic: recursive function models. In this setting the issue of meaningful information versus accidental information is put in its starkest form; and in fact, has been around for a long time in various imprecise forms unconnected with the sufficient statistic approach: The issue has sparked the imagination and entered scientific popularization in [\cite=GM94] as "effective complexity" (here "effective" is apparently used in the sense of "producing an effect" rather than "constructive" as is customary in the theory of computation). It is time that it receives formal treatment. Formally, we study the minimal length of a total recursive function that leads to an optimal length two-part code of the object being described. ("Total" means the function value is defined for all arguments in the domain, and "partial" means that the function is possibly not total.) This minimal length has been called the "sophistication" of the object in [\cite=Ko87] [\cite=Ko88] in a different, but related, setting of compression and prediction properties of infinite sequences. That treatment is technically sufficiently vague so as to have no issue for the present work. We develop the notion based on prefix Turing machines, rather than on a variety of monotonic Turing machines as in the cited papers. Below we describe related work in detail and summarize our results. Subsequently, we formulate our problem in the formal setting of computable two-part codes.

Related Work

A.N. Kolmogorov in 1974 [\cite=Ko74] proposed an approach to a non-probabilistic statistics based on Kolmogorov complexity. An essential feature of this approach is to separate the data into meaningful information (a model) and meaningless information (noise). Cover [\cite=Co85] [\cite=CT91] attached the name "sufficient statistic" to a model of which the data is a "typical" member. In Kolmogorov's initial setting the models are finite sets. As Kolmogorov himself pointed out, this is no real restriction: the finite sets model class is equivalent, up to a logarithmic additive term, to the model class of computable probability density functions, as studied in [\cite=Sh83] [\cite=Sh99] [\cite=ViLi99]. Related aspects of "randomness deficiency" were formulated in [\cite=Ko83] [\cite=KU88] and studied in [\cite=Sh83] [\cite=Vy87]. Despite its evident epistemological prominence in the theory of hypothesis selection and prediction, only selected aspects of the theory were studied in these references. Recent work [\cite=GTV] can be considered as a comprehensive investigation into the sufficient statistic for finite set models and computable probability density function models. Here we extend the approach to the most general form: the model class of total recursive functions. This idea was pioneered by [\cite=Ko87] [\cite=Ko88] who, unaware of a statistic connection, coined the cute word "sophistication." The algorithmic (minimal) sufficient statistic was related to an applied form in [\cite=ViLi99] [\cite=GLV00]: the well-known "minimum description length" principle [\cite=BRY] in statistics and inductive reasoning.

In another paper [\cite=VeVi02] (chronologically following the present paper) we comprehensively treated all stochastic properties of the data in terms of Kolmogorov's so-called structure functions. The sufficient statistic aspect, studied here, covers only part of these properties. The results on the structure functions, including (non)computability properties, are valid, up to logarithmic additive terms, also for the model class of total recursive functions, as studied here.

This Work:

It will be helpful for the reader to be familiar with initial parts of [\cite=GTV]. In [\cite=Ko74], Kolmogorov observed that randomness of an object in the sense of having high Kolmogorov complexity is being random in just a "negative" sense. That being said, we define the notion of sophistication (minimal sufficient statistic in the total recursive function model class). It is demonstrated to be meaningful (existence and nontriviality). We then establish lower and upper bounds on the sophistication, and we show that there are objects the sophistication achieves the upper bound. In fact, these are objects in which all information is meaningful and there is (almost) no accidental information. That is, the simplest explanation of such an object is the object itself. In the simpler setting of finite set statistic the analogous objects were called "absolutely non-stochastic" by Kolmogorov. If such objects have high Kolmogorov complexity, then they can only be a random outcome of a "complex" random process, and Kolmogorov questioned whether such random objects, being random in just this "negative" sense, can occur in nature. But there are also objects that are random in the sense of having high Kolmogorov complexity, but simultaneously are are typical outcomes of "simple" random processes. These were therefore said to be random in a "positive" sense [\cite=Ko74]. An example are the strings of maximal Kolmogorov complexity; those are very unsophisticated (with sophistication about 0), and are typical outcomes of tosses with a fair coin--a very simple random process. We subsequently establish the equivalence between sophistication and the algorithmic minimal sufficient statistics of the finite set class and the probability mass function class. Finally, we investigate the algorithmic properties of sophistication: nonrecursiveness, upper semicomputability, and intercomputability relations of Kolmogorov complexity, sophistication, halting sequence.

Preliminaries

A string is a finite binary sequence, an element of {0,1}*. If x is a string then the length l(x) denotes the number of bits in x. We identify N, the natural numbers, and {0,1}* according to the correspondence

[formula]

Here ε denotes the empty word. Thus, l(ε) = 0. The emphasis is on binary sequences only for convenience; observations in any alphabet can be so encoded in a way that is 'theory neutral'. Below we will use the natural numbers and the strings interchangeably.

A string y is a proper prefix of a string x if we can write x = yz for z  ≠  ε. A set [formula] is prefix-free if for any pair of distinct elements in the set neither is a proper prefix of the other. A prefix-free set is also called a prefix code and its elements are called code words. An example of a prefix code, that is useful later, encodes the source word [formula] by the code word

[formula]

This prefix-free code is called self-delimiting, because there is fixed computer program associated with this code that can determine where the code word x̄ ends by reading it from left to right without backing up. This way a composite code message can be parsed in its constituent code words in one pass, by the computer program. (This desirable property holds for every prefix-free encoding of a finite set of source words, but not for every prefix-free encoding of an infinite set of source words. For a single finite computer program to be able to parse a code message the encoding needs to have a certain uniformity property like the [formula] code.) Since we use the natural numbers and the strings interchangeably, l(x̄) where x is ostensibly an integer, means the length in bits of the self-delimiting code of the string with index x. On the other hand, [formula] where x is ostensibly a string, means the self-delimiting code of the string with index the length l(x) of x. Using this code we define the standard self-delimiting code for x to be [formula]. It is easy to check that [formula] and l(x') = n + 2 log n + 1. Let 〈  ·  〉 denote a standard invertible effective one-one encoding from N  ×  N to a subset of N. For example, we can set 〈x,y〉  =  x'y or 〈x,y〉  =  x̄y. We can iterate this process to define 〈x,〈y,z〉〉, and so on.

Kolmogorov Complexity

For definitions, notation, and an introduction to Kolmogorov complexity, see [\cite=LiVi97]. Informally, the Kolmogorov complexity, or algorithmic entropy, K(x) of a string x is the length (number of bits) of a shortest binary program (string) to compute x on a fixed reference universal computer (such as a particular universal Turing machine). Intuitively, K(x) represents the minimal amount of information required to generate x by any effective process. The conditional Kolmogorov complexity K(x|y) of x relative to y is defined similarly as the length of a shortest program to compute x, if y is furnished as an auxiliary input to the computation. For technical reasons we use a variant of complexity, so-called prefix complexity, which is associated with Turing machines for which the set of programs resulting in a halting computation is prefix free. We realize prefix complexity by considering a special type of Turing machine with a one-way input tape, a separate work tape, and a one-way output tape. Such Turing machines are called prefix Turing machines. If a machine T halts with output x after having scanned all of p on the input tape, but not further, then T(p) = x and we call p a program for T. It is easy to see that {p:T(p) = x,x∈{0,1}*} is a prefix code.

A function f from the natural numbers to the natural numbers is partial recursive, or computable, if there is a Turing machine T that computes it: f(x) = T(x) for all x for which either f or T (and hence both) are defined. This definition can be extended to (multi-tuples of) rational arguments and values.

Let [formula] be a standard enumeration of all prefix Turing machines with a binary input tape, for example the lexicographical length-increasing ordered syntactic prefix Turing machine descriptions, [\cite=LiVi97], and let [formula] be the enumeration of corresponding functions that are computed by the respective Turing machines (Ti computes φi). These functions are the partial recursive functions of effectively prefix-free encoded arguments. The Kolmogorov complexity of x is the length of the shortest binary program from which x is computed by such a function.

The prefix Kolmogorov complexity of x is

[formula]

where the minimum is taken over p∈{0,1}* and [formula]. For the development of the theory we actually require the Turing machines to use auxiliary (also called conditional) information, by equipping the machine with a special read-only auxiliary tape containing this information at the outset. Then, the conditional version K(x|y) of the prefix Kolmogorov complexity of x given y (as auxiliary information) is is defined similarly as before, and the unconditional version is set to K(x) = K(x|ε).

From now on, we will denote by [formula] an inequality to within an additive constant, and by [formula] the situation when both [formula] and [formula] hold.

Two-Part Codes

Let [formula] be the standard enumeration of Turing machines, and let U be a standard Universal Turing machine satisfying U(〈i,p〉)  =  Ti(p) for all indices i and programs p. We fix U once and for all and call it the reference universal prefix Turing machine. The shortest program to compute x by U is denoted as x* (if there is more than one of them, then x* is the first one in standard enumeration). It is a deep and useful fact that the shortest effective description of an object x can be expressed in terms of a two-part code: the first part describing an appropriate Turing machine and the second part describing the program that interpreted by the Turing machine reconstructs x. The essence of the theory is the Invariance Theorem, that can be informally stated as follows: For convenience, in the sequel we simplify notation and write U(x,y) for U(〈x,y〉). Rewrite

[formula]

Here the minima are taken over p,q,r∈{0,1}* and [formula]. The last equalities are obtained by using the universality of U = Tu with [formula]. As consequence,

[formula]

Thus, K(x) and KU(x) differ by at most an additive constant depending on the choice of U. It is standard to use

[formula]

instead of [\eqref=eq.KC] as the definition of prefix Kolmogorov complexity, [\cite=LiVi97]. However, we highlighted definition [\eqref=eq.KC] to bring out the two-part code nature. By universal logical principles, the resulting theory is recursively invariant under adopting either definition [\eqref=eq.KC] or definition [\eqref=eq.KCU], as long as we stick to one choice. If T stands for a literal description of the prefix Turing machine T in standard format, for example the index j when T = Tj, then we can write [formula]. The string j* is a shortest self-delimiting program of K(j) bits from which U can compute j, and subsequent execution of the next self-delimiting fixed program α will compute [formula] from j. Altogether, this has the effect that U(ε,j*αr) = Tj(r). If (j0,r0) minimizes the expression above, then Tj0(r0) = x, and hence [formula], and [formula]. It is straightforward that [formula], and therefore we have [formula]. Altogether, [formula]. Replacing the minimizing j = j0 by the minimizing T = Tj0 and l(r0) by K(x|T), we can rewrite the last displayed equation as

[formula]

Meaningful Information

Expression [\eqref=eq.kcmdl] emphasizes the two-part code nature of Kolmogorov complexity: using the regular aspects of x to maximally compress. Suppose we consider an ongoing time-series [formula] and we randomly stop gathering data after having obtained the initial segment

[formula]

We can encode this x by a small Turing machine representing "the repeating pattern is 01," and which computes x, for example, from the program "13." Intuitively, the Turing machine part of the code squeezes out the regularities in x. What is left are irregularities, or random aspects of x relative to that Turing machine. The minimal-length two-part code squeezes out regularity only insofar as the reduction in the length of the description of random aspects is greater than the increase in the regularity description. In this setup the number of repetitions of the significant pattern is viewed as the random part of the data.

This interpretation of K(x) as the shortest length of a two-part code for x, one part describing a Turing machine, or model, for the regular aspects of x and the second part describing the irregular aspects of x in the form of a program to be interpreted by T, has profound applications.

The "right model" is a Turing machine T among the ones that halt for all inputs, a restriction that is justified later, and reach the minimum description length in ([\ref=eq.kcmdl]). This T embodies the amount of useful information contained in x. It remains to decide which such T to select among the ones that satisfy the requirement. Following Occam's Razor we opt here for the shortest one--a formal justification for this choice is given in [\cite=ViLi99]. The main problem with our approach is how to properly define a shortest program x* for x that divides into parts x* = pq such that p represents an appropriate T.

Symmetry of Information

The following central notions are used in this paper. The information in x about y is I(x:y) = K(y) - K(y|x*). By the symmetry of information, a deep result of [\cite=Ga74],

[formula]

Rewriting according to symmetry of information we see that [formula] and therefore we call the quantity I(x:y) the mutual information between x and y.

Model Classes

Instead of the model class of finite sets, or computable probability density functions, as in [\cite=GTV], in this work we focus on the most general form of algorithmic model class: total recursive functions. We define the different model classes and summarize the central notions of "randomness deficiency" and "typicality" for the canonical finite set models to obtain points of reference for the related notions in the more general model classes.

Set Models

The model class of finite sets consists of the set of finite subsets S  ⊆  {0,1}*. The complexity of the finite set S is K(S)--the length (number of bits) of the shortest binary program p from which the reference universal prefix machine U computes a listing of the elements of S and then halts. That is, if [formula], then [formula]. The conditional complexity K(x|S) of x given S, is the length (number of bits) in the shortest binary program p from which the reference universal prefix machine U, given S literally as auxiliary information, computes x. For every finite set S  ⊆  {0,1}* containing x we have

[formula]

Indeed, consider the selfdelimiting code of x consisting of its ⌈ log |S|⌉ bit long index of x in the lexicographical ordering of S. This code is called data-to-model code. Its length quantifies the maximal "typicality," or "randomness," data (possibly different from x) can have with respect to this model. The lack of typicality of x with respect to S is measured by the amount by which K(x|S) falls short of the length of the data-to-model code, the randomness deficiency of x in S, defined by

[formula]

for x∈S, and ∞   otherwise. Data x is typical with respect to a finite set S, if the randomness deficiency is small. If the randomness deficiency is close to 0, then there are no simple special properties that single it out from the majority of elements in S. This is not just terminology. Let S  ⊆  {0,1}n. According to common viewpoints in probability theory, each property represented by S defines a large subset of S consisting of elements having that property, and, conversely, each large subset of S represents a property. For probabilistic ensembles we take high probability subsets as properties; the present case is uniform probability with finite support. For some appropriate fixed constant c, let us identify a property represented by S with a subset S' of S of cardinality |S'|  >  (1 - 1 / c)|S|. If δ(x|S) is close to 0, then x satisfies (that is, is an element of) all properties (that is, sets) S'  ⊆  S of low Kolmogorov complexity K(S')  =  O( log n). The precise statements and quantifications are given in [\cite=LiVi97] [\cite=VeVi02], and we do not repeat them here.

Probability Models

The model class of computable probability density functions consists of the set of functions P:{0,1}*  →  [0,1] with [formula]. "Computable" means here that there is a Turing machine TP that, given x and a positive rational ε, computes P(x) with precision ε. The (prefix-) complexity K(P) of a computable (possibly partial) function P is defined by K(P)  =   min i{K(i):Ti    P}.

Function Models

The model class of total recursive functions consists of the set of functions f:{0,1}*  →  {0,1}* such that there is a Turing machine T such that T(i)  <    ∞   and f(i)  =  T(i), for every i∈{0,1}*. The (prefix-) complexity K(f) of a total recursive function f is defined by K(f)  =   min i{K(i):Ti    f}. If f* is a shortest program for computing the function f (if there is more than one of them then f* is the first one in enumeration order), then K(f) = l(f*).

In the definitions of K(P) and K(f), the objects being described are functions rather than finite binary strings. To unify the approaches, we can consider a finite binary string x as corresponding to a function having value x for argument 0. Note that we can upper semi-compute x* given x, but we cannot upper semi-compute P* given P (as an oracle), or f* given f (again given as an oracle), since we should be able to verify agreement of a program for a function and an oracle for the target function, on all infinitely many arguments.

Typicality

To explain typicality for general model classes, it is convenient to use the distortion-rate [\cite=Sh48] [\cite=Sh59] approach for individual data recently introduced in [\cite=GV03] [\cite=VV04]. Modeling the data can be viewed as encoding the data by a model: the data are source words to be coded, and models are code words for the data. As before, the set of possible data is D  =  {0,1}*. Let R+ denote the set of non-negative real numbers. For every model class M (particular set of code words) we choose an appropriate recursive function d:D  ×  M  →  R+ defining the distortion d(x,M) between data x and model M.

The choice of distortion function is a selection of which aspects of the data are relevant, or meaningful, and which aspects are irrelevant (noise). We can think of the distortion as measuring how far the model falls short in representing the data. Distortion-rate theory underpins the practice of lossy compression. For example, lossy compression of a sound file gives as "model" the compressed file where, among others, the very high and very low inaudible frequencies have been suppressed. Thus, the distortion function will penalize the deletion of the inaudible frequencies but lightly because they are not relevant for the auditory experience.

Let us look at various model classes and distortion measures:

(i) The set of models are the finite sets of finite binary strings. Let S  ⊆  {0,1}* and |S|  <    ∞  . We define d(x,S)  =   log |S| if x∈S, and ∞   otherwise.

(ii) The set of models are the computable probability density functions P mapping {0,1}* to

[formula]

If M is a model class, then we consider distortion balls of given radius r centered on M∈M:

[formula]

This way, every model class and distortion measure can be treated similarly to the canonical finite set case, which, however is especially simple in that the radius not variable. That is, there is only one distortion ball centered on a given finite set, namely the one with radius equal to the log-cardinality of that finite set. In fact, that distortion ball equals the finite set on which it is centered.

Let M be a model class and d a distortion measure. Since in our definition the distortion is recursive, given a model M∈M and diameter r, the elements in the distortion ball of diameter r can be recursively enumerated from the distortion function. Giving the index of any element x in that enumeration we can find the element. Hence, [formula]. On the other hand, the vast majority of elements y in the distortion ball have complexity [formula] since, for every constant c, there are only 2log |BM(r)| - c  -  1 binary programs of length   <   log |BM(r)| - c available, and there are |BM(r)| elements to be described. We can now reason as in the similar case of finite set models. With data x and r = d(x,M), if [formula], then x belongs to every large majority of elements (has the property represented by that majority) of the distortion ball |BM(d(x,M))|, provided that property is simple in the sense of having a description of low Kolmogorov complexity.

the randomness deficiency of x with respect to model M under distortion d is defined as

[formula]

Data x is typical for model M∈M (and that model "typical" or "best fitting" for x) if

[formula]

If x is typical for a model M, then the shortest way to effectively describe x, given M, takes about as many bits as the descriptions of the great majority of elements in a recursive enumeration of the distortion ball. So there are no special simple properties that distinguish x from the great majority of elements in the distortion ball: they are all typical or random elements in the distortion ball (that is, with respect to the contemplated model).

Continuing Example [\ref=ex.11] by applying [\eqref=eq.typical] to different model classes:

(i) Finite sets: For finite set models S, clearly [formula]. Together with [\eqref=eq.typical] we have that x is typical for S, and S best fits x, if the randomness deficiency according to [\eqref=eq:randomness-deficiency] satisfies [formula].

(ii) Computable probability density functions: Instead of the data-to-model code length log |S| for finite set models, we consider the data-to-model code length log 1 / P(x) (the Shannon-Fano code). The value log 1 / P(x) measures how likely x is under the hypothesis P. For probability models P, define the conditional complexity K(x|P,⌈ log 1 / P(x)⌉) as follows. Say that a function A approximates P if |A(y,ε) - P(y)| < ε for every y and every positive rational ε. Then K(x|P,⌈ log 1 / P(x)⌉) is defined as the minimum length of a program that, given ⌈ log 1 / P(x)⌉ and any function A approximating P as an oracle, prints x.

Clearly [formula]. Together with [\eqref=eq.typical], we have that x is typical for P, and P best fits x, if [formula]. The right-hand side set condition is the same as P(y)  ≥  P(x), and there can be only ≤  1 / P(x) such y, since otherwise the total probability exceeds 1. Therefore, the requirement, and hence typicality, is implied by [formula]. Define the randomness deficiency by δ(x|P)  =   log 1 / P(x)  -  K(x|P,⌈ log 1 / P(x)⌉). Altogether, a string x is typical for a distribution P, or P is the best fitting model for x, if [formula].

(iii) Total Recursive Functions: In place of log |S| for finite set models we consider the data-to-model code length (actually, the distortion d(x,f) above)

[formula]

Define the conditional complexity [formula] as the minimum length of a program that, given [formula] and an oracle for f, prints x.

Clearly, [formula]. Together with [\eqref=eq.typical], we have that x is typical for f, and f best fits x, if [formula]. There are at most [formula]- many y satisfying the set condition since [formula]. Therefore, the requirement, and hence typicality, is implied by [formula]. Define the randomness deficiency by [formula] Altogether, a string x is typical for a total recursive function f, and f is the best fitting recursive function model for x if [formula], or written differently,

[formula]

Note that since [formula] is given as conditional information, with [formula] and f(d) = x, the quantity [formula] represents the number of bits in a shortest self-delimiting description of d.

We required [formula] in the conditional in [\eqref=eq.typp]. This is the information about the radius of the distortion ball centered on the model concerned. Note that in the canonical finite set model case, as treated in [\cite=Ko74] [\cite=GTV] [\cite=VeVi02], every model has a fixed radius which is explicitly provided by the model itself. But in the more general model classes of computable probability density functions, or total recursive functions, models can have a variable radius. There are subclasses of the more general models that have fixed radiuses (like the finite set models).

(i) In the computable probability density functions one can think of the probabilities with a finite support, for example Pn(x)  =  1 / 2n for l(x) = n, and P(x) = 0 otherwise.

(ii) In the total recursive function case one can similarly think of functions with finite support, for example [formula] for [formula], and fn(x) = 0 for l(x)  ≠  n.

The incorporation of te radius in the model will increase the complexity of the model, and hence of the minimal sufficient statistic below.

Sufficient Statistic

A statistic is a function mapping the data to an element (model) in the contemplated model class. With some sloppiness of terminology we often call the function value (the model) also a statistic of the data. The most important concept in this paper is the sufficient statistic. For an extensive discussion of this notion for specific model classes see [\cite=GTV] [\cite=VeVi02]. A statistic is called sufficient if the two-part description of the data by way of the model and the data-to-model code is as concise as the shortest one-part description of x. Consider a model class M.

A model M∈M is a sufficient statistic for x if

[formula]

If M is a sufficient statistic for x, then [formula], that is, x is typical for M.

We can rewrite [formula]. The first three inequalities are straightforward and the last equality is by the assumption of sufficiency. Altogether, the first sum equals the second sum, which implies the lemma.

Thus, if M is a sufficient statistic for x, then x is a typical element for M, and M is the best fitting model for x. Note that the converse implication, "typicality" implies "sufficiency," is not valid. Sufficiency is a special type of typicality, where the model does not add significant information to the data, since the preceding proof shows [formula]. Using the symmetry of information [\eqref=eq.soi] this shows that

[formula]

This means that:

(i) A sufficient statistic M is determined by the data in the sense that we need only an O(1)-bit program, possibly depending on the data itself, to compute the model from the data.

(ii) For each model class and distortion there is a universal constant c such that for every data item x there are at most c sufficient statistics.

Finite sets: For the model class of finite sets, a set S is a sufficient statistic for data x if

[formula]

Computable probability density functions: For the model class of computable probability density functions, a function P is a sufficient statistic for data x if

[formula]

For the model class of total recursive functions, a function f is a sufficient statistic for data x if

[formula]

Following the above discussion, the meaningful information in x is represented by f (the model) in K(f) bits, and the meaningless information in x is represented by d (the noise in the data) with f(d) = x in [formula] bits. Note that [formula], since the two-part code (f*,d) for x cannot be shorter than the shortest one-part code of K(x) bits, and therefore the d-part must already be maximally compressed. By Lemma [\ref=lem.V2], [formula], x is typical for f, and hence [formula].

Minimal Sufficient Statistic

Consider the model class of total recursive functions. A minimal sufficient statistic for data x is a sufficient statistic [\eqref=eq.ss] for x of minimal prefix complexity. Its length is known as the sophistication of x, and is defined by [formula].

Recall that the reference universal prefix Turing machine U was chosen such that U(T,d) = T(d) for all T and d. Looking at it slightly more from a programming point of view, we can define a pair (T,d) to be a description of a finite string x, if U(T,d) prints x and T is a Turing machine computing a function f so that f(d) = x. For the notion of minimal sufficient statistic to be nontrivial, it should be impossible to always shift, if f(d) = x and [formula] with [formula], always information information from f to d and write, for example, f'(d') = x with [formula] with [formula]. If the model class contains a fixed universal model that can mimic all other models, then we can always shift all model information to the data-to-(universal) model code. Note that this problem doesn't arise in common statistical model classes: these do not contain universal models in the algorithmic sense. First we show that the partial recursive recursive function model class, because it contains a universal element, does not allow a straightforward nontrivial division into meaningful and meaningless information.

Assume for the moment that we allow all partial recursive programs as statistic. Then, the sophistication of all data x is [formula].

Let the index of U (the reference universal prefix Turing machine) in the standard enumeration [formula] of prefix Turing machines be u. Let Tf be a Turing machine computing f. Suppose that U(Tf,d) = x. Then, also U(u,〈Tf,d〉) = U(Tf,d)  =  x.

This shows that unrestricted partial recursive statistics are uninteresting. Naively, this could leave the impression that the separation of the regular and the random part of the data is not as objective as the whole approach lets us hope for. If we consider complexities of the minimal sufficient statistics in model classes of increasing power: finite sets, computable probability distributions, total recursive functions, partial recursive functions, then the complexities appear to become smaller all the time eventually reaching zero. It would seem that the universality of Kolmogorov complexity, based on the notion of partial recursive functions, would suggest a similar universal notion of sufficient statistic based on partial recursive functions. But in this case the very universality trivializes the resulting definition: because partial recursive functions contain a particular universal element that can simulate all the others, this implies that the universal partial recursive function is a universal model for all data, and the data-to-model code incorporates all information in the data. Thus, if a model class contains a universal model that can simulate all other models, then this model class is not suitable for defining two-part codes consisting of meaningful information and accidental information. It turns out that the key to nontrivial separation is the requirement that the program witnessing the sophistication be total. That the resulting separation is non-trivial is evidenced by the fact, shown below, that the amount of meaningful information in the data does not change by more than a logarithmic additive term under change of model classes among finite set models, computable probability models, and total recursive function models. That is, very different model classes all result in the same amount of meaningful information in the data, up to negligible differences. So if deterioration occurs in widening model classes it occurs all at once by having a universal element in the model class.

Apart from triviality, a class of statistics can also possibly be vacuous by having the length of the minimal sufficient statistic exceed K(x). Our first task is to determine whether the definition is non-vacuous. We will distinguish sophistication in different description modes:

For every finite binary string x, the sophistication satisfies [formula].

By definition of the prefix complexity there is a program x* of length l(x*) = K(x) such that U(x*,ε)  =  x. This program x* can be partial. But we can define another program x*s  =  sx* where s is a program of a constant number of bits that tells the following program to ignore its actual input and compute as if its input were ε. Clearly, x*s is total and is a sufficient statistic of the total recursive function type, that is, [formula].

The previous lemma gives an upper bound on the sophistication. This still leaves the possibility that the sophistication is always [formula], for example in the most liberal case of unrestricted totality. But this turns out to be impossible.

(i) For every x, if a sufficient statistic f satisfies [formula], then [formula] and [formula].

(ii) For x as a variable running through a sequence of finite binary strings of increasing length, we have

[formula]

(iii) For every n, there exists an x of length n, such that every sufficient statistic f for x that satisfies [formula] has [formula].

(iv) For every n there exists an x of length n such that [formula].

(i) If f is a sufficient statistic for x, then

[formula]

Since [formula], given an O(1) bit program q we can retrieve both [formula] and and also K(f)  =  l(f*) from f*. Therefore, we can retrieve [formula] from qf*. That shows that [formula]. This proves both the first statement, and the second statement follows by ([\ref=eq.pd]).

(ii) An example of very unsophisticated strings are the individually random strings with high complexity: x of length l(x)  =  n with complexity [formula]. Then, the identity program ι with ι(d) = d for all d is total, has complexity [formula], and satisfies [formula]. Hence, ι witnesses that [formula]. This shows ([\ref=eq.liminf]).

(iii) Consider the set Sm  =  {y:K(y)  ≤  m}. By [\cite=GTV] we have [formula]. Let m  ≤  n. Since there are 2n strings of length n, there are strings of length n not in Sm. Let x be any such string, and denote k = K(x). Then, by construction k  >  m and by definition [formula]. Let f be a sufficient statistic for x. Then, [formula]. By assumption, there is an O(1)-bit program q such that [formula]. Let d witness [formula] by f(d) = x with [formula]. Define the set [formula]. Clearly, d∈D. Since x can be retrieved from f and the lexicographical index of d in D, and [formula], we have [formula]. Since we can obtain D from qf* we have [formula]. On the other hand, since we can retrieve x from D and the index of d in D, we must have [formula], which implies [formula]. Altogether, therefore, [formula].

We now show that we can choose x so that [formula], and therefore [formula]. For every length n, there exists a z of complexity [formula] such that a minimal sufficient finite set statistic S for z has complexity at least [formula], by Theorem IV.2 of [\cite=GTV]. Since {z} is trivially a sufficient statistic for z, it follows [formula]. This implies [formula]. Therefore, we can choose m  =  n  -  c2 for a large enough constant c2 so as to ensure that [formula]. Consequently, we can choose x above as such a z. Since every finite set sufficient statistic for x has complexity at least that of an finite set minimal sufficient statistic for x, it follows that [formula]. Therefore, [formula], which was what we had to prove.

(iv) In the proof of (i) we used [formula]. Without using this assumption, the corresponding argument yields [formula]. We also have [formula] and [formula]. Since we can retrieve x from D and its index in D, the same argument as above shows [formula], and still following the argument above, [formula]. Since [formula] we have [formula]. This proves the statement.

The useful ([\ref=eq.pcondx]) states that there is a constant, such that for every x there are at most that constant many sufficient statistics for x, and there is a constant length program (possibly depending on x), that generates all of them from x*. In fact, there is a slightly stronger statement from which this follows:

There is a universal constant c, such that for every x, the number of f*d such that f(d)  =  x and [formula], is bounded above by c.

Let the prefix Turing machine Tf compute f. Since U(Tf,d) = x and [formula], the combination f*d (with self-delimiting f*) is a shortest prefix program for x. From [\cite=LiVi97], Exercise 3.3.7 item (b) on p. 205, it follows that the number of shortest prefix programs is upper bounded by a universal constant.

Relation Between Sufficient Statistic for Different Model Classes

Previous work studied sufficiency for finite set models, and computable probability mass functions models, [\cite=GTV]. The most general models that are still meaningful are total recursive functions as studied here. We show that there are corresponding, almost equivalent, sufficient statistics in all model classes.

(i) If S is a sufficient statistic of x (finite set type), then there is a corresponding sufficient statistic P of x (probability mass function type) such that [formula], [formula], and [formula].

(ii) If P is a sufficient statistic of x of the computable total probability density function type, then there is a corresponding sufficient statistic f of x of the total recursive function type such that [formula], [formula], and [formula].

(i) By assumption, S is a finite set such that x∈S and [formula]. Define the probability distribution P(y)  =  1 / |S| for y∈S and P(y) = 0 otherwise. Since S is finite, P is computable. Since [formula], and log |S|  =  ⌈ log 1 / P(x)⌉, we have [formula]. Since P is a computable probability mass function we have [formula], by the standard Shannon-Fano code construction [\cite=CT91] that assigns a code word of length  log 1 / P(x) to x. Since by ([\ref=eq.soi]) we have [formula] it follows that [formula]. Hence, [formula]. Therefore, by ([\ref=eq.soi]), [formula] and, by rewriting K(x,P) in the other way according to ([\ref=eq.soi]), [formula].

(ii) By assumption, P is a computable probability density function with P(x)  >  0 and [formula]. The witness of this equality is a shortest program P* for P and a code word sx for x according to the standard Shannon-Fano code, [\cite=CT91], with [formula]. Given P, we can reconstruct x from sx by a fixed standard algorithm. Define the recursive function f from P such that f(sx)  =  x. In fact, from P* this only requires a constant length program q, so that Tf = qP* is a program that computes f in the sense that U(Tf,d) = f(d) for all d. Similarly, P can be retrieved from f. Hence, [formula] and [formula]. That is, f is a sufficient statistic for x. Also, f is a total recursive function. Since f(sx) = x we have [formula], and [formula]. This shows that [formula], and since x can by definition be reconstructed from f* and a program of length K(x|f*), it follows that equality must hold. Consequently, [formula], and hence, by ([\ref=eq.soi]), [formula] and [formula].

We have now shown that a sufficient statistic in a less general model class corresponds directly to a sufficient statistic in the next more general model class. We now show that, with a negligible error term, a sufficient statistic in the most general model class of total recursive functions has a directly corresponding sufficient statistic in the least general finite set model class. That is, up to negligible error terms, a sufficient statistic in any of the model classes has a direct representative in any of the other model classes.

Let x be a string of length n, and f be a total recursive function sufficient statistic for x. Then, there is a finite set S∋x such that [formula].

By assumption there is an O(1)-bit program q such that [formula]. For each y∈{0,1}*, let iy  =   min {i:f(i) = y}. Define [formula]. We can compute S by computation of f(i), on all arguments i of at most [formula] bits, since by assumption f is total. This shows [formula]. Since [formula], we have [formula]. Moreover, [formula]. Since x∈S, [formula], where we use the sufficiency of f to obtain the last inequality.

Algorithmic Properties

We investigate the recursion properties of the sophistication function. In [\cite=Ga74], Gács gave an important and deep result ([\ref=eq.gacs]) below, that quantifies the uncomputability of K(x) (the bare uncomputability can be established in a much simpler fashion). For every length n there is an x of length n such that:

[formula]

Note that the right-hand side holds for every x by the simple argument that K(x)  ≤  n  +  2 log n and hence [formula]. But there are x's such that the length of the shortest program to compute K(x) almost reaches this upper bound, even if the full information about x is provided. It is natural to suppose that the sophistication function is not recursive either. The following lemma's suggest that the complexity function is more uncomputable than the sophistication.

The function [formula] is not recursive.

Given n, let x0 be the least x such that (x)  >  n  -  2 log n. By Theorem [\ref=h-sophI] we know that there exist x such that (x)  →    ∞   for x  →    ∞  , hence x0 exists. Assume by way of contradiction that the sophistication function is computable. Then, we can find x0, given n, by simply computing the successive values of the function. But then [formula], while by Lemma [\ref=lem.exists] [formula] and by assumption (x0)  >  n  -  2 log n, which is impossible.

The halting sequence [formula] is the infinite binary characteristic sequence of the halting problem, defined by χi  =  1 if the reference universal prefix Turing machine U halts on the ith input: U(i)  <    ∞  , and 0 otherwise.

Let f* be a total recursive function sufficient statistic of x.

(i) We can compute K(x) from f* and x, up to fixed constant precision, which implies that [formula].

(ii) If also [formula], then we can compute K(x) from f*, up to fixed constant precision, which implies that [formula].

(i) Since f is total, we can run f(e) on all strings e in lexicographical length-increasing order. Since f is total we will find a shortest string e0 such that f(e0) = x. Set [formula]. Since l(f*) = K(f), and by assumption, [formula], we now can compute [formula].

(ii) follows from item (i).

Given an oracle that on query x answers with a sufficient statistic f* of x and a [formula] as required below. Then, we can compute the Kolmogorov complexity function K and the halting sequence χ.

By Lemma [\ref=lem.compKs] we can compute the function K(x), up to fixed constant precision, given the oracle (without the value cx) in the statement of the theorem. Let cx in the statement of the theorem be the difference between the computed value and the actual value of K(x). In [\cite=LiVi97], Exercise 2.2.7 on p. 175, it is shown that if we can solve the halting problem for plain Turing machines, then we can compute the (plain) Kolmogorov complexity, and vice versa. The same holds for the halting problem for prefix Turing machines and the prefix Turing complexity. This proves the theorem.

There is a constant c, such that for every x there is a program (possibly depending on x) of at most c bits that computes (x) and the witness program f from x,K(x). That is, [formula]. With some abuse of notation we can express this as [formula].

By definition of sufficient statistic f*, we have [formula]. By ([\ref=eq.pcondx]) the number of sufficient statistics for x is bounded by an independent constant, and we can generate all of them from x by a [formula] length program (possibly depending on x). Then, we can simply determine the least length of a sufficient statistic, which is (x).

There is a subtlety here: Lemma [\ref=lem.chisoph] is nonuniform. While for every x we only require a fixed number of bits to compute the sophistication from x,K(x), the result is nonuniform in the sense that these bits may depend on x. Given a program, how do we verify if it is the correct one? Trying all programs of length up to a known upper bound, we don't know if they halt or if they halt they halt with the correct answer. The question arising is if there is a single program that computes the sopistication and its witness program for all x. In [\cite=VeVi02] this much more difficult question is answered in a strong negative sense: there is no algorithm that for every x, given x,K(x), approximates the sophistication of x to within precision l(x) / (10 log l(x)).

For every x of length n, and f* the program that witnesses the sophistication of x, we have [formula]. For every length n, there are strings x of length n, such that [formula].

Let f* witness the (x): That is, [formula], and l(f*)  =  (x). Using the conditional version of ([\ref=eq.soi]), see [\cite=GTV], we find that K(K(x),f*|x)

[formula]

In Lemma [\ref=lem.compKs], item (i), we show [formula], hence also [formula]. By Lemma [\ref=lem.chisoph], [formula], hence also [formula]. Substitution of the constant terms in the displayed equation shows

[formula]

This shows that the shortest program to retrieve f* from x is essentially the same program as to retrieve x* from x or K(x) from x. Using [\eqref=eq.gacs], this shows that

[formula]

Since f* is the witness program for l(f*)  =  (x), we have [formula].

A function f from the rational numbers to the real numbers is upper semicomputable if there is a recursive function H(x,t) such that H(x,t + 1)  ≤  H(x,t) and lim t  →    ∞H(x,t) = f(x). Here we interprete the total recursive function H(〈x,t〉)  =  〈p,q〉 as a function from pairs of natural numbers to the rationals: H(x,t) = p / q. If f is upper semicomputable, then - f is lower semicomputable. If f is both upper-a and lower semicomputable, then it is computable.

Recursive functions are computable functions over the natural numbers. Since K(  ·  ) is upper semicomputable, [\cite=LiVi97], and from K(  ·  ) we can compute (x), we have the following:

(i) The function (x) is not computable to any significant precision.

(ii) Given an initial segment of length 22l(x) of the halting sequence [formula], we can compute (x) from x. That is, [formula].

(i) The fact that (x) is not computable to any significant precision is shown in [\cite=VeVi02].

(ii) We can run U(p,d) for all (program, argument) pairs such that l(p) + l(d)  ≤  2l(x). (Not l(x) since we are dealing with self-delimiting programs.) If we know the initial segment of χ, as in the statement of the theorem, then we know which (program, argument) pairs halt, and we can simply compute the minimal value of l(p) + l(d) for these pairs.

Discussion

"Sophistication" is the algorithmic version of "minimal sufficient statistic" for data x in the model class of total recursive functions. However, the full stochastic properties of the data can only be understood by considering the Kolmogorov structure function λx(α) (mentioned earlier) that gives the length of the shortest two-part code of x as a function of the maximal complexity α of the total function supplying the model part of the code. This function has value about l(x) for α close to 0, is nonincreasing, and drops to the line K(x) at complexity α0  =  (x), after which it remains constant, λx(α) = K(x) for α  ≥  α0, everything up to a logarithmic addive term. A comprehensive analysis, including many more algorithmic properties than are analyzed here, has been given in [\cite=VeVi02] for the model class of finite sets containing x, but it is shown there that all results extend to the model class of computable probability distributions and the model class of total recursive functions, up to an additive logarithmic term.

Acknowledgment

The author thanks Luis Antunes, Lance Fortnow, Kolya Vereshchagin, and the referees for their comments.