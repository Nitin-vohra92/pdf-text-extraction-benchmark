A better lower bound for quantum algorithms searching an ordered list

Introduction

One of main results in quantum computation is Grover's algorithm[\cite=Grover]. This quantum algorithm allows to search an unordered list of n elements by examining just [formula] of them. Any classical algorithm needs to examine all n elements. Grover's algorithm is very important because it can be applied to any search problem (not just searching a list). For example, it can be used to find a Hamilton cycle in an n-vertex graph by checking only [formula] out of n! possible Hamilton cycles.

After Grover's paper appeared, unordered search and related problems received a lot of attention in quantum computation community. It was shown that [formula] is optimal[\cite=BBBV]. Then, Grover's algorithm has been used as subroutine in other quantum algorithms[\cite=Counting] [\cite=Collision]. Optimality proof of [\cite=BBBV] has been generalized as well[\cite=Polynomials] [\cite=BW].

Grover's algorithm works well for unordered lists but cannot be used for searching ordered lists. An ordered list of n elements can be searched by examining just log 2n elements classically and there is no evident way of speeding it up by methods similar to Grover's algorithm.

Searching ordered lists by a quantum algorithm was first considered by Buhrman and de Wolf[\cite=BW] who proved a [formula] lower bound for quantum case. This lower bound was improved to log n / 2 log  log n by Farhi, Goldstone, Gutmann and Sipser[\cite=Sipser]. The log n / 2 log  log n bound was independently discovered (but not published) by the author of this paper in June 1998. We improve the lower bound to [formula], showing that only a constant speedup is possible for the ordered search.

The best quantum algorithm for ordered search uses 0.53 log n queries[\cite=Sipser2]. Thus, a constant speedup is possible.

The proof of our lower bound combines the method of [\cite=BBBV] (adapted to ordered case by [\cite=Sipser]) with a new idea inspired by weighted majority algorithms in the learning theory[\cite=BFP] [\cite=LW].

Preliminaries

Quantum binary search

In the binary search problem, we are given [formula] such that [formula] and have to find the smallest i such that y  ≤  xi. Normally, x1, [formula], xn are accessed by queries. The input to the query is i, the answer is xi. This is a classical problem in computer science and it is well known that log 2n queries are both necessary and sufficient to solve it classically.

In this paper, we consider how many queries one needs in the quantum world. We will prove a [formula] lower bound. For our proof, it is enough to consider the case when x1∈{0,1}, [formula], xn∈{0,1} and y = 1. Then the problem becomes following.

0-1 valued binary search. Given x1∈{0,1}, [formula], xn∈{0,1} such that [formula], find the smallest i such that xi = 1.

Similarly to classical world, we consider algorithms that access the input by queries. A quantum algorithm A can be represented as a sequence of unitary transformations

[formula]

on a state space with finitely many basis states. Uj's are arbitrary unitary transformations that do not depend on [formula] and O's are queries to the input. We use Ok to denote the query transformation corresponding to the input [formula], [formula].

To define Ok, we represent the basis states as |i,b,z〉 where i consists of ⌈ log n⌉ bits, b is one bit and z consists of all other qubits. Then, Ok maps |i,b,z〉 to [formula]. (I.e., the first ⌈ log n⌉ qubits are interpreted as an index i for an input bit xi and this input bit is XORed on the next qubit.)

Running a quantum algorithm A on an input [formula], [formula] means applying the transformation [formula] to the initial state |0〉 and measuring the first ⌈ log n⌉ bits of the final state. The algorithm computes the binary search function if, for any input [formula], [formula], this process gives k with probability at least 3/4.

Technical lemmas

In this section, we state several results that we will use. The first result is the well-known formula for the sum of decreasing geometric progression. If q > 1, then

[formula]

The second result is a lemma from [\cite=BV]. It relates the l2-distance between two superpositions and the variational distance between probability distributions that we obtain by observing two superpositions. The variational distance between two probability distributions p(x) and p'(x) is just the sum [formula].

[\cite=BV] Let ψ and φ be superpositions such that [formula]. Then the total variational distance resulting from measurements of φ and ψ is at most 4ε.

In our case, ψ and φ are final superpositions of a quantum algorithm A on two different inputs [formula], [formula] and [formula], [formula]. For the first input, j is the correct answer and the measurement must return j with probability at least [formula]. The probability that the measurement gives k can be at most [formula]. For the second input, the probability of j can be at most [formula] and the probability of k must be at least [formula]. This means that the variational distance must be at least [formula]. By Lemma [\ref=BVTheorem], this is only possible if [formula]. We have shown

If ψ and φ are final superpositions of a quantum binary search algorithm, then [formula].

Result

log n / 2 log  log n lower bound

We start with a sketch of log n / 2 log  log n lower bound discovered independently by the author of this paper and Farhi, Gutmann, Goldstone and Sipser[\cite=Sipser]. After that, we describe how to modify this argument to obtain an Ω( log n) lower bound.

Assume we are given a quantum algorithm A for binary search that uses less than log n / 2 log  log n queries. We construct an input on which A works incorrectly. In the first stage, we partition

[formula]

that is queried with probability that less than or equal to 1 /  log 2n. We answer the first query of A with xi = 0 for i  ≤  l  ·  n /  log 2n and xi = 1 for i > l  ·  n /  log 2n. Then, we split the interval

[formula]

be the final interval. Consider two inputs [formula], [formula] and [formula], [formula]. The only value where these two inputs differ is xlm and, by our construction, it is queried with a probability at most 1 /  log 2n in each of log n / 2 log  log n steps. By a hybrid argument similar to [\cite=BBBV], this implies that the final superpositions of the quantum algorithm A on these two inputs are within distance O(1 /  log  log n). Hence, the results of measuring final superpositions on two inputs will be close as well (cf. Lemma [\ref=BVTheorem]).

log n / 12 lower bound

To obtain an Ω( log n) lower bound, we must split the interval into a constant number of pieces at every step (rather than log 2n pieces). However, if we split the interval into a constant number of pieces, we can only guarantee that the new interval has the probability of being queried smaller than some constant (not smaller than 1 /  log 2n). Then, it may happen that xlm gets queried with a constant probability in each of c log n queries, giving the total probability much higher than 1. In this case, the quantum algorithm A can easily distinguish two inputs that differ only in xlm.

To avoid this, we do the splitting in a different way. Instead of considering just the probabilities of an interval being queried in the last step, we consider the probabilities of it being queried in the previous steps as well and try to decrease them all. This is done by using a weighted sum of these probabilities. The precise argument follows.

Let q∈I R, q > 1, t∈I N, u∈I N and

[formula]

be such that q(q')u < 1. Then, at least [formula] queries are necessary for the quantum binary search on n elements.

Proof: Assume we are given a quantum algorithm A doing binary search on [formula] with less than [formula] queries where the constant c will be specified later. We construct two inputs that A cannot distinguish.

First, we describe an auxiliary procedure subdivide. This procedure takes an interval

[formula]

.

subdivide(m,l,s):

Let m' = m / t. Split

[formula]

,

[formula]

.

Simulate the first s query steps (and unitary transformations between these steps) of A on the input [formula], [formula]. Let

[formula]

be the superposition before the ith query step, |ψi〉 be its part corresponding to querying xk for k∈[(l  -  1)m  +  1,lm] and |ψi,r〉 be the part of |ψi〉 corresponding to querying xk for k∈[(l  -  1)m  +  (r  -  1)m'  +  1,(l  -  1)m  +  rm'].

For every [formula], compute the sum

[formula]

Take the r minimizing Sr and set l' = (l - 1)k + r. Then,

[formula]

.

Next, we analyze this procedure. Let

[formula]

Let φ'i and ψ'i be the counterparts for φi and ψi, given the input [formula], [formula]. We define [formula].

[formula]

Proof: We bound the difference between superpositions |ψ'i〉 (used to define S') and |ψi,r〉 (used to define Sr). To do that, we first bound the difference between |φi〉 and |φ'i〉.

[formula]

Proof: By induction. If i = 1, then |φi〉 = |φ'i〉.

Next, we assume that [formula]. φi is the result of applying UiOlm to |φi - 1〉 and |φ'i〉 is the result of applying UiOl'm' to |φ'i - 1〉. Ui is just a unitary transformation and it does not change distances. Hence, we have

[formula]

[formula]

The second part is just [formula] and it is at most [formula] by inductive assumption. To bound the first part, let |φi - 1〉 = |φi - 1〉 - |ψi - 1〉. Then, |φi - 1〉 is the part of superposition |φi - 1〉 corresponding to querying k∉[(l  -  1)m  +  1,lm]. Olm and Ol'm' are the same for such k. Therefore, Olm(|φi - 1〉) = Ol'm'(|φi - 1〉) and

[formula]

[formula]

[formula]

Consider the subspace of the Hilbert space consisting of states that correspond to querying k∈[(l'  -  1)m',l'm']. |ψi,r〉 and |ψ'i〉 are projections of |φi〉 and |φ'i〉 to this subspace. Hence, |ψi,r〉 - |ψ'i〉 is the projection of |φi〉 - |φ'i〉. For any vector, the norm of its projection is at most the norm of the vector itself. Therefore, we have

[formula]

This means

[formula]

[formula]

The first term is just Sr. Next, we bound the second term.

[formula]

[formula]

Putting ([\ref=e3]), ([\ref=e4]) together, we get [formula]. Next, we bound Sr.

[formula]

Proof: We have [formula]. This implies

[formula]

By a Cauchy-Schwartz inequality

[formula]

Therefore,

[formula]

S is just a weighted sum of [formula] and S1, [formula], St are weighted sums of [formula], [formula], [formula], respectively. Hence, [formula] and

[formula]

By definition of r, Sr is the smallest of S1, [formula], St. This implies ([\ref=e5]). [formula]

Claim [\ref=C3] gives

[formula]

This completes the proof of Lemma [\ref=L1]. [formula]

Next, we use the subdivide procedure to construct two inputs that are not distinguished by A. This is done as follows. Let v be [formula].

Let m = n, l = 1, s = 1.

While m  ≥  tv, repeat:

u times do subdivide(m,l,s) and set l = l', m = m'.

s = s + 1.

v - u times do subdivide(m,l,s) and set l = l', m = m'.

At the beginning, m = n. Each execution of step 2 decreases m by a factor of tu and step 2 is repeated while m  ≥  tv. Hence, it gets repeated at least

[formula]

times.

The final interval

[formula]

is |ψi〉. This is the only part of |φi〉 on which Olm and Olm - 1 are different. Therefore,

[formula]

The next transformations ([formula]) are the same again. This implies ([\ref=e2]). [formula]

By triangle inequality (and formulas ([\ref=e2]) and ([\ref=geom])),

[formula]

However, |φ0〉 is the final superposition for the input [formula], [formula], |φs〉 is the final superposition for the input [formula], [formula] and, by Lemma [\ref=distance], the distance between them must be at least 1/4.

This shows that there is no quantum algorithm A that solves the binary search problem with at most [formula] queries. [formula]

By optimizing the parameters in theorem [\ref=main], we get

At least [formula] queries are necessary for quantum binary search on n elements.

Proof: Substitute q = 18.3, t = 8, u = 4 into Theorem [\ref=main]. [formula]

Conclusion

We have shown that any quantum algorithm needs at least log 2n / 12 queries to do binary search. This shows that at most a constant speedup is possible for this problem in the query model (compared to the best classical algorithm).

Similarly to other lower bounds on quantum algorithms, this result should not be considered as pessimistic. First, the classical binary search is very sequential algorithm and, therefore, it is not so surprising that it is impossible to speed it up by using quantum algorithms. Second, the classical binary search is already fast enough for most (if not all) practical purposes.

We hope that our lower bound technique will be useful for proving other lower bounds on quantum algorithms. One of main open problems in this area is the collision problem[\cite=Collision] for which there is no quantum lower bounds at all.

Acknowledgments. I thank Ashwin Nayak for suggesting this problem and Ronald de Wolf for useful comments.