Classical simulation complexity of extended Clifford circuits

Introduction

The notion of classical simulation of quantum computation provides a mathematically precise tool for studying fundamental questions that are often only vaguely formulated - questions of the relationship between classical and quantum computing power and the computational possibilities engendered by particular kinds of quantum resources. We may consider a restricted class A of quantum circuits defined by specified limited quantum ingredients and ask whether it can be classically efficiently simulated or not. Computational hardness is notoriously difficult to establish and in the latter case we are generally content to establish that the efficient simulation of A would imply some further property such as P=  NP, that is widely regarded as implausible. In the former case of A being classically efficiently simulatable we may consider enlarging A to A' by inclusion of some extra specific quantum ingredient P and investigating the resulting change in classical simulation complexity. If for example, A' allows universal quantum computation then in this mathematically precise sense, P may be regarded as an "essential resource for quantum computational power" (relative to a background of quantum effects that are "computationally lame"). Below we will see examples of seemingly quite modest expansions of resources leading to dramatic changes in simulation complexity, indicating that the computational landscape between classical and quantum computing power is a richly complex one.

This paper is devoted to developing a case study of simulation of Clifford circuits supplemented with a variety of extra ingredients. The choice of Clifford circuits is a particularly interesting and relevant one for a variety of reasons. Clifford computations provide one of the earliest significant examples of classically simulatable quantum computations in the Gottesman-Knill theorem [\cite=Go99] (see also [\cite=nc] [\cite=De03] [\cite=Aa04] [\cite=An06] [\cite=Va10]), showing in particular that the presence of non-trivial entanglements in a quantum computation is not necessarily a signature of computational speed-up. Clifford gates also have a rich associated pure mathematical theory that may be drawn upon in the study of simulation properties, as well as having a rich physical and practical significance in the theory and implementation of quantum computation. For example Clifford operations feature prominently in the theory of quantum error correction and fault tolerance [\cite=cliff] [\cite=nc] [\cite=Br05] and in measurement-based quantum computation [\cite=Ra01] [\cite=Ra03].

It is well known that the Clifford gates supplemented with any non-Clifford operation generate a dense subgroup of U(2n) and are hence universal for quantum computation [\cite=Ne03] [\cite=Ne06]. Here we will consider extensions of Clifford circuits of a different, perhaps seemingly more innocuous kind. More precisely we will characterise the classical simulation complexity of sixteen cases of extended Clifford circuits that are defined by four binary choices. Our main results are summarised in figure 1. The acronyms in figure 1 that define the extensions and their classical simulation complexities are all explained in detail in section [\ref=prelim] below, and briefly they are as follows: IN(BITS) and IN(PROD) refer to allowing computational basis states and general product states as inputs. OUT(1) and OUT(MANY) refer to having single bit and multi-bit outputs. NONADAPT and ADAPT refer to circuits with intermediate measurements, with the circuit gates being respectively fixed or chosen adaptively as a function of previous measurement outcomes. WEAK and STRONG refer to two notions of classical simulation that provide respectively a sample of the output distribution and a calculation of actual probability values. In the body of the tables, Cl-P denotes that classical efficient simulation is possible, QC-hard denotes that universal quantum computation is possible, and #P-hard asserts that classical simulation could be used to solve arbitrary problems in the classical class #P (and hence NP too).

These results demonstrate a remarkable sensitivity of the classical simulation complexity of Clifford circuits under various small modifications. In section [\ref=mainresults] we highlight some interesting comparisons amongst these simulation complexities. In particular the issue of the last sentence of the abstract above is discussed in Example 2 of section [\ref=mainresults]. Finally in section [\ref=proofs] we provide proofs of all results given in figure 1. For completeness we indicate proofs for all sixteen cases. Some cases were previously known (cf references in our text) but to the best of our knowledge others have not previously been given in the literature.

Finally we mention here some related work on the classical simulation complexity of various extensions and generalizations of Clifford circuits. See [\cite=Aa04] for simulation of Clifford circuits supplemented with few non-stabilizer (pure or mixed) inputs and/or few non-Clifford gates; see [\cite=Br05] for quantum computing with adaptive Clifford circuits with product state inputs (we will revisit this scenario as one of the sixteen cases in figure 1); see [\cite=jm08] [\cite=Va11] for simulations of Clifford circuits supplemented with certain non-Clifford gates by restricting the circuit structure; see [\cite=Go99b] [\cite=Ho05] [\cite=De13] [\cite=Va12] [\cite=Be12] for generalizations of the Gottesman-Knill theorem to higher-dimensional systems; see [\cite=cjl] for generalizations of Clifford circuits based on projective normalisers of finite unitary groups.

Preliminary definitions and notations

Clifford circuits: NONADAPT and ADAPT

Let I,X,Y,Z denote the standard 1-qubit Pauli matrices [\cite=nc] (amongst which we include the identity matrix). An n-qubit Pauli operator is any operator of the form [formula] where γ∈{  ±  1,  ±  i} and each Pi is a Pauli matrix.

An n-qubit unitary operation C is called a Clifford operation if the set of all Pauli operators is preserved under conjugation by C i.e. for any n-qubit Pauli operator P, [formula] is again a Pauli operator. It is known that C is Clifford iff C can be expressed as a circuit of the following gates (cf [\cite=nc]): the 1-qubit Hadamard gate H, the phase gate T = diag(1,i) and the 2-qubit controlled-Z gate CZ, which we call basic Clifford gates. Moreover any n-qubit Clifford operation can be expressed as a circuit of O(n2) basic Clifford gates (see [\cite=De03] and theorem 10.6 of [\cite=nc]).

A unitary Clifford circuit is a circuit comprising only the basic Clifford gates. The size of the circuit is the number of gates of which it consists.

As a further extension we will allow measurements in the body of the circuit. The term measurement will always mean a single qubit measurement in the computational basis. Let Mi(x) denote a measurement of the ith qubit line with outcome x∈{0,1}. Then a Clifford circuit with K intermediate measurements has the form

[formula]

where Ci are unitary Clifford circuits (possibly of size zero). We assume that measurements are non-destructive and the measured qubit, set to the designated post-measurement state, may generally be an input into subsequent operations e.g. Mi1(x1) sets qubit line i1 to [formula] which may then be input into C1.

A non-adaptive Clifford circuit is a Clifford circuit with intermediate measurements in which the choice of operations in the circuit does not depend on the outcomes of (previous) measurements. Hence such a circuit is fully defined by eq. ([\ref=cmmt]) where the Cj's and measurement line labels ij's are fixed a priori.

By the term adaptive Clifford circuit we will mean a process of the form eq. ([\ref=cmmt]) in which the choice of operations is allowed to depend on previous measurement outcomes. To make this dependency explicit we can expand the notation of eq. ([\ref=cmmt]) as

[formula]

Note that the size of the circuits [formula] may vary with [formula]. The total number N of operations in the adaptive circuit eq. ([\ref=adaptcliff]) is defined to be the maximum number of elementary Clifford gates and measurements over all possible choices of measurement outcomes [formula]. Alternatively we could uniformise the size of each Cj by including additional identity gates to make its size independent of [formula]. Similarly to uniformise the number of intermediate measurements in the adaptive process (as a function of measurement outcomes) we could formally allow [formula] to be zero (for qubit lines labelled 1 to n) to indicate that a measurement is not performed, but replaced by an identity gate.

The scenarios of non-adaptive and adaptive Clifford circuits will be denoted respectively by the acronyms NONADAPT and ADAPT.

We mention here two elementary simplifications of circuit structures that will be useful in proofs of classical simulation properties. Stated informally we have the following facts (with formal statements and proofs given in lemmas [\ref=lemmacu] and [\ref=lemmacad] in section [\ref=proofs] below): (i) without loss of generality (wlog) non-adaptive circuits may be assumed to be unitary; (ii) in (adaptive or non-adaptive) circuits with intermediate measurements, wlog the measured qubits may be assumed to always be discarded after measurement (and not used in subsequent operations). Furthermore for adaptive circuits the choice of lines for intermediate measurements may be assumed to be non-adaptive.

Inputs and outputs: IN(BITS), IN(PROD), OUT(1) and OUT(MANY)

In addition to the circuit itself there are two further ingredients for the full specification of a computational process viz. specification of the input and of the output. We will distinguish two classes of input states - computational basis input states, denoted by the acronym IN(BITS), and general product state inputs, denoted IN(PROD). For outputs we will distinguish the scenarios of a single bit output (resulting from a specified final 1-qubit measurement), denoted OUT(1), and the scenario of a many-bit output, denoted OUT(MANY). In the latter case, for an n-qubit circuit the output [formula] results from a final measurement on a specified set [formula] of l lines and generally we can have l = O(n).

Classical simulations: WEAK, STRONG and Cl-P

A description of a Clifford computational task T with N operations on n qubits is made up of the following ingredients: (i) a description of an (adaptive, non-adaptive or unitary) Clifford circuit on n lines comprising N operations. For unitary or non-adaptive circuits we give a list of N basic Clifford gates and intermediate measurements on specified qubit lines; for adaptive circuits (cf eq. ([\ref=adaptcliff])) we require that each [formula] and [formula] is given as a function computable in classical poly(N) time; (ii) specification of an input state [formula] which we always take to be either a computational basis state or a general product state; (iii) specification of one or more output measurement lines [formula]. Let [formula] denote the output probability distribution of the corresponding quantum process.

We will consider sets of computational tasks subject to the restrictions introduced above viz. the eight combinations of ADAPT vs. NONADAPT, IN(BITS) vs. IN(PROD) and OUT(1) vs. OUT(MANY). In each case it is natural to assume that the total length (as a classical bit string) of the full description (i), (ii) and (iii) of the computational task is O(poly(N)). In particular we assume that there are no extraneous qubit lines that are not acted upon (so n = O(N)) and we assume that input product states are specified with O(poly(N)) bits. The latter technical issue of accuracy (for our later purposes of simulation complexity characterisations) may be addressed by setting up a suitable notion of approximation, but we do not elaborate it here for sake of clarity and conceptual transparency.

We introduce two notions of classical simulation for Clifford computational tasks. A weak classical simulation for a set of computational tasks is a classical randomised computation which, given a description of a task T as input, outputs a sample of the output distribution [formula] of T. A strong classical simulation for a set of tasks is a classical computation whose input is a description of a task T and bit values for a subset of its output lines. The output is the value of the corresponding marginal probability of the output distribution of T i.e. we have a classical computation of any desired output probability or marginal probability of T.

A weak or strong classical simulation is called efficient if the corresponding classical computation runs in classical poly(N) time. (Again here for strong simulation, as previously noted for IN(PROD), there is a further technical issue of precision and more formally we would require the output probability or marginal to be computed to k bits of precision in poly(N,k) time).

We will use the acronyms WEAK (resp. STRONG) to indicate that we are considering a weak (resp. strong) classical simulation for a set of tasks. We will use the acronym Cl-P ("classical poly time") to assert that the associated simulation is efficient.

If the computational task T is implemented as a quantum process it will require O(N) quantum computational steps so existence of an efficient weak classical simulation implies that T offers no quantum computational time benefit over classical computation (up to the usual polynomial overheads of resources commonly accepted in complexity theory).

In the case of OUT(MANY) there are generally exponentially many output probabilities [formula] (as l may be O(n)) so in strong efficient simulation we cannot ask for a computation of them all. The inclusion of computation of marginals in the definition of strong simulation guarantees the following eponymously desirable result.

Let [formula] be a probability distribution over n binary variables. Suppose that each of the n marginals [formula] may be efficiently classically computed for any choice of values [formula], and suppose that any 1-bit distribution {po,1 - po} with p0 efficiently computable, may be efficiently sampled. Then [formula] may be efficiently sampled. Hence for any set of computational tasks, efficient strong classical simulation implies efficient weak classical simulation.

For a proof see proposition 1 of [\cite=terdiv1].

For completeness we mention that there are also notions of weak simulations which incorporate various types of approximations [\cite=Va11] [\cite=bjs]; these will however not be relevant for the present work.

Complexity measures: QC-hardness and #P-hardness

We will also be interested in establishing that some sets of Clifford computational tasks are unlikely to have efficient classical simulations and for this purpose we introduce some further complexity notions.

Consider the following classical computational task called #SAT (cf [\cite=AB]): Input: a Boolean function f from n bits to one bit (given say as a bit string encoding a formula in standard 3-cnf form [\cite=AB]). Problem: determine the number #f of n-bit strings [formula] with [formula]. Note that #SAT is a generalisation of the well known NP-complete problem SAT [\cite=AB] (which asks only if #f is non-zero) so it is very unlikely that #SAT has a poly time classical algorithm; indeed the latter would imply equality of the complexity classes P and NP, and also that any problem in #P may be computed in poly time [\cite=AB].

A set A of Clifford computational tasks T is called #P-hard if an efficient strong simulation of A would give rise to an efficient classical solution of #SAT. More precisely A is #P-hard if given any input f of size N for the #SAT problem, it may be converted by a classical poly(N) time computation φ into (a description of) a task φ(f) in A with the following property: #f may be computed by a classical poly(N) time algorithm from the results of strong classical simulation of φ(f). Hence efficient strong classical simulation of A would imply P=  NP and that #P is computable in poly time.

Finally we introduce a notion of QC-hardness for a set A of Clifford computational tasks. This will be used to indicate that A is unlikely to have an efficient weak classical simulation. Broadly speaking A will be QC-hard ("quantum computing hard") if it is rich enough to encode universal quantum computation, so then efficient classical weak simulation of A would imply that all quantum computation could be classically efficiently simulated. More precisely we will adopt the following definition. Let G be the set of basic unitary Clifford gates together with the phase gate S = (1,eiπ / 4). It is known [\cite=nc] that G is a universal set of gates for quantum computation. Let C be any circuit of gates from G with a specified computational basis state input and 1-bit output from measurement of a specified output line. Then A is QC-hard if any such C may be simulated by a member φ(C) of A i.e. T = φ(C) has 1-bit output whose probability distribution for the given computational basis input coincides with that of C. Here as before, φ is a poly time translation of the description of C into the description of a member of A. Hence efficient weak classical simulation of A would imply efficient classical simulation of universal quantum computing.

Main results - statement and discussion

We now consider the sixteen sets of Clifford computational tasks defined by all combinations of the following four binary choices

(i) NONADAPT vs. ADAPT

(ii) IN(BITS) vs. IN(PROD)

(iii) OUT(1) vs. OUT(MANY)

(iv) WEAK vs. STRONG.

The corresponding simulation complexities that we will prove, are summarised in figure 1.

The original Gottesman-Knill theorem [\cite=Go99] asserts that efficient classical simulations exist for the case ADAPT, IN(BITS), OUT(MANY) and WEAK (cf. theorem [\ref=thm5] below). In contrast, we find here that eight of the sixteen cases of extended Clifford circuits are not (likely to be) classically efficiently simulatable.

We draw attention to some examples of extreme changes of simulation complexity resulting from seemingly modest modifications in the defining computational resources. Perhaps the most significant such comparisons for issues of computing power will be cases involving only weak simulations, since implementing the circuit itself as a quantum process yields only one sample of the output probability distribution, in contrast to the far greater information resulting from strong simulation (cf. [\cite=Va10] [\cite=Va11]).

Example 1. For the case of non-adaptive (or equivalently, unitary) circuits with general product state inputs, we have that 1-bit outputs are classically efficiently simulatable in both weak and strong senses. However allowing just many bit outputs results in #P hardness for strong simulation and a more subtle certification of hardness (related to PH collapse) for weak simulation. This indicates a significant increase of computational power associated to the passage from OUT(1) to OUT(MANY) i.e. merely sampling more lines of the same class of quantum processes (and see also [\cite=bjs] where a similar phenomenon is observed for computational processes defined by commuting quantum circuits).

On the other hand, in the case of adaptive circuits with computational basis inputs the passage from one to many output lines remains classically efficiently simulatable in the weak sense (all other adaptive cases already being QC- or #P-hard).

Note also that in our definitions of classical simulation we ask for simulation only of the output distribution of the computational task, and not of intermediate measurement distributions (if there are any). Indeed inclusion of the latter could elevate an OUT(1) scenario to OUT(MANY) via consideration of intermediate measurement outcomes together with the single bit output of the task, and the associated simulation complexity could radically change. [formula]

Example 2. Another particularly interesting comparison is that of weak simulation for general product state inputs and single bit outputs, with the transition from non-adaptive to adaptive circuits i.e. we compare Case A: IN(PROD), OUT(1), WEAK, NONADAPT to Case B: IN(PROD), OUT(1), WEAK, ADAPT. Case A admits efficient weak classical simulation whereas case B is QC-hard. But now note that the passage from Case A to Case B involves the inclusion of a purely classical extra resource viz. classical adaptive choice of gates, without introducing any new gates. Furthermore the class of quantum processes occurring in runs of Case B is exactly the same as the class occurring in runs of Case A, since any single actual run of an adaptive circuit can occur as a run of a non-adaptive circuit (that non-adaptively prescribes the sequence of gates that were adaptively chosen). Indeed from an experimentalist's point of view cases A and B may be claimed to be totally indistinguishable in the following sense: suppose an experimentalist E has the ability to implement basic Clifford gates and measurements. A theorist T directs E by announcing one by one, a sequence of basic gates and measurements, which E successively implements. For each measurement instruction E announces the measurement outcome before further instructions from T. Then E cannot tell whether T is choosing gates adaptively (Case B) or not (Case A) - the demands on E's laboratory are exactly the same, and case B results in no new quantum processes. Yet Case B can perform universal quantum computation whereas Case A is fully classically efficiently simulatable. [formula]

The sixteen cases of extended Clifford circuits give rise to a rich landscape of simulation complexities. Apart from Cl-P, QC-hardness and #P-hardness, we will see in the course of the proofs that connections to other major complexity classes appear as well. For example (cf. remark below theorem [\ref=thm5]), uniform families of adaptive Clifford circuits with computational basis inputs have precisely the same power as a universal randomised classical computation. Thus the class of languages decidable by such Clifford processes in poly-time with bounded error, is precisely BPP. What is more, just changing from computational basis inputs to arbitrary product state inputs (and keeping the other parameters equal) yields universal quantum computation, so in the same poly-time bounded error setting, these Clifford processes now give precisely BQP [\cite=Br05]. We will also find that post-selected non-adaptive Clifford circuits with product state inputs have the same power as BQP with postselection (cf. theorem [\ref=thm7] and [\cite=Br05]), which is known to coincide with the class PP [\cite=aarpp]. Finally we recall that the simulation complexity of non-adaptive Clifford circuits with computational basis inputs and single bit outputs is known to be characterized by the class [formula]L ⊆   P [\cite=Aa04].

Proofs of main results

In this section we give proofs of theorems 1 to 7 that appear as seven of the sixteen cases depicted in figure 1. For the remaining cases it may be easily checked that they all follow from the seven basic cases using the following simple facts: (i) if a set of tasks is Cl-P then any subset is Cl-P too; (ii) if a subset of tasks is QC- or #P-hard then the full set is QC- or #P-hard too; (iii) replacing IN(BITS) by IN(PROD), or replacing OUT(1) by OUT(MANY), increases the set of computational tasks; (iv) by lemma [\ref=lemmaterdiv], if strong simulation is Cl-P, then weak simulation is Cl-P too (keeping all other resource choices unchanged).

We will use the following notations relating to bit strings and Pauli operators. For any n-bit strings [formula] and [formula], [formula] will denote the n-bit string with [formula] (and [formula] being addition mod 2), and [formula] will denote the mod 2 inner product. We will also use the notation [formula] and [formula]. [formula] will denote the computational basis state corresponding to [formula]. Then the following properties are easily verified for any n-bit strings [formula]:

[formula]

Since Y = iXZ, any Pauli operator P can be written uniquely as [formula] for some α∈{  ±  1,  ±  i} and n-bit strings [formula] and [formula]. Labelling the α values by 2-bit strings r1r2, we call the (2n + 2)-bit string [formula] the label of P and α the phase of P. If G is any basic Clifford gate (acting on specified qubit line(s), and extended by I on all other lines), and P is any n-qubit Pauli operator, then the label of [formula] can be easily computed from the label of P in O(n) time. In fact only the phase of P and the label entries pertaining to the line(s) of action of the basic Clifford gate are modified.

We begin by proving two elementary simplifications of circuit structures that were mentioned in section [\ref=prelim]. To formally establish these we use the following construction: let C be any (adaptive or non-adaptive) circuit on n lines with K intermediate measurements, input state [formula] and final output measurements on lines [formula]. Introduce an enlarged unitary circuit C* on n + K lines defined as follows. For each intermediate measurement Mi on line i of C introduce an extra ancilla qubit (line n + i) in state [formula] and replace the measurement operation by the unitary Clifford operation CXi,n + i (where CXj,k is the 2-qubit controlled-X operation with source j and target k).

Suppose C with input and output as above is a non-adaptive circuit with K intermediate measurements. Then there is a unitary circuit C' on n + K lines which is equivalent to C in the following sense: if C' has input [formula] then measurement of lines [formula] of C' will result in the same probability distribution of outputs as C on [formula].

Proof. We just take C' to be C* as defined above. [formula]

Suppose C as above is an adaptive circuit. Then there is an adaptive circuit [formula] on n + K lines which is equivalent to C (in the sense given in lemma [\ref=lemmacu] above) and (i) in [formula] after each intermediate measurement Mi(xi) the line i and its post-measurement state are not further used in any subsequent operations of [formula]. Furthermore the choice of line i here is always non-adaptive i.e. independent of previous measurement outcomes. (ii) In [formula] the set of output lines [formula] is disjoint from the set of intermediate measured lines.

Proof. To construct [formula] we take C* as above, but after each extra CXi,n + i operation we immediately measure line n + i, and use its output as the result of the intermediate measurement Mi of C, for subsequent adaptations. [formula]

We are now ready to prove our seven theorems.

NONADAPT, IN(PROD), OUT(1) and STRONG: Cl-P

Let A be the set of computational tasks defined by non-adaptive Clifford circuits, general product state inputs and single bit outputs. Then A may be strongly efficiently classically simulated.

Proof. This result has been proved in [\cite=cjl] and we summarise the argument here. Using lemma [\ref=lemmacu] we may assume wlog that the Clifford circuit is unitary. Let [formula] be a unitary Clifford circuit with product state input [formula]. Write [formula]. We may assume that the output, with probabilities p0,p1 is obtained from line 1 (as the swap gate is Clifford). Let [formula]. Then [formula]. Now A is a Pauli operator so after successive conjugations by the Ci's we get [formula] where the label of the latter is easily computed in poly(N) time. Thus [formula] and the latter expression, being a product of n 2  ×  2 matrix expectation values, is readily computable in poly(N) time, providing the efficient strong classical simulation (as p0 + p1 = 1 too). [formula]

Remark. The simple method of the above proof does not generalise to the case of OUT(MANY) with O(n) output lines. Indeed we will see (cf theorems [\ref=thm4] and [\ref=thm6] below) that this case is #P-hard but remains classically efficiently strongly simulatable if we restrict the input states to just computational basis states i.e. to IN(BITS).

ADAPT, IN(BITS), OUT(1) and STRONG: #P-hard

Let A be the set of computational tasks defined by adaptive Clifford circuits, computational basis state inputs and single bit outputs. Then the strong classical simulation of A is #P-hard.

Proof. With the availability of adaptation we are able to apply the gate CXjk or the identity gate Ijk (on lines j and k) chosen conditionally according to the result of a measurement on another line i. Thus if these lines are promised to be in computational basis states we can apply the Toffoli gate. (Note however that we cannot by this method apply the Toffoli gate coherently on general quantum states because the adaptation requires a measurement on line i). Then with the availability of computational basis state inputs, using X and this Toffoli construction, we can efficiently implement universal classical computation. Thus if f is any Boolean function from n bits to one bit, we can implement the transformation [formula] (so long as the input is a computational basis state). Consider now the following process which is allowed in A: starting with n qubits each in state [formula], apply H to each and measure each to generate a uniformly random n-qubit computational basis state [formula]. Then apply Af and finally measure the qubit line of [formula] to give a single bit output. Clearly the probability of obtaining 1 is #  f / 2n so strong simulation of this process is #P-hard. [formula]

ADAPT, IN(PROD), OUT(1) and WEAK: QC-hard

Let A be the set of computational tasks defined by adaptive Clifford circuits, general product state inputs and single bit outputs. Then the weak classical simulation of A is QC-hard.

Proof. This result is well known, see e.g. [\cite=Br05]. It suffices to show that within the given resource constraints, the phase gate S = diag(1,eiπ / 4) may be implemented on any desired qubit line. This is achieved by introducing an extra ancilla qubit labelled a, in state [formula] (respecting availability of product state inputs) and then applying the process of lemma [\ref=sgate] below, and finally applying the Clifford gate T = S2 to line i conditionally on the value of the ancilla measurement outcome (which is possible since adaptation is available). [formula]

Let [formula] be an n-qubit state on lines 1 to n and let S = diag(1,eiπ / 4). Let [formula] be an extra ancillary qubit. Then

[formula]

where Si denotes the application of S to qubit i, and CXai is the application of CX to lines a and i with i as target line.

Proof of lemma. A straightforward calculation. [formula]

NONADAPT, IN(BITS), OUT(MANY) and STRONG: Cl-P

Let A be the set of computational tasks defined by non-adaptive Clifford circuits, computational basis state inputs and multiple bit outputs. Then A may be strongly efficiently classically simulated.

Proof. The techniques of [\cite=De03] and alternatively [\cite=Va10] may be used to prove theorem [\ref=thm4]. Here we give a proof using a third method. Let C be a non-adaptive Clifford circuit with computational basis input [formula] and let [formula] be any subset of the output lines. We will show that the corresponding marginal probability [formula] may be efficiently classically computed. We may assume the following standardised situation: (i) C is unitary (by lemma [\ref=lemmacu]); (ii) [formula] and [formula] (since we can pre- and post- include extra X gates on lines where xi or yj are 1); (iii) [formula] for m  ≤  n (since swap gates are Clifford operations). Thus for C unitary with input [formula] let [formula] be the probability of obtaining 0 from measurement of each of the lines 1 to m. Using [formula] and writing [formula] for m-bit strings we have

[formula]

where [formula] is the n-qubit Pauli operator [formula] obtained by extending the m-qubit operator [formula] by (n - m) I's. This is a sum with potentially exponentially many terms (e.g. if m = O(n)) yet it can be evaluated in poly(n) time as follows. Using the Clifford conjugation relations we have

[formula]

with [formula] and [formula]. Furthermore, for each [formula] these labels can be computed efficiently.

Next, introduce basis vectors [formula] in [formula] (having 1 in the jth slot) for [formula]. Then since [formula] and [formula] we have

[formula]

Next note that since [formula] we have

[formula]

Furthermore if [formula] then

[formula]

and since [formula] we must have [formula], so that

[formula]

with [formula]. Furthermore, using [formula] we get

[formula]

Introducing [formula] we thus get

[formula]

Next we characterise T0. We have [formula] iff [formula] so by eq. ([\ref=basis]), T0 is the subspace of [formula] given by the solution space of [formula] where A is the n  ×  m sized matrix with [formula] for [formula] as the columns. Using the label update rules for Clifford conjugations, all [formula]'s can be computed in poly(n) time. Thus we can compute a basis [formula] of T0 (and hence also the information of its dimension l) in poly(n) time. Then [formula] iff [formula] for [formula] and

[formula]

Finally recalling that [formula] we see from eqs ([\ref=star1]) and ([\ref=star2]) that [formula] is a linear function of [formula], so writing [formula] and [formula] we have

[formula]

Now [formula] is a balanced function for [formula] (i.e. taking values ±  1 equally often) so

[formula]

concluding our efficient classical computation of p. To summarise: given the description of the circuit C we first compute [formula] for [formula] (from the Clifford conjugation relations) giving the matrix A via columns. Then we compute any basis [formula] of ker(A), and compute the l-bit string [formula] (again from the Clifford conjugation relations in eq. ([\ref=cliff]) with [formula] there). Then p = 2l - m if [formula] and p = 0 otherwise. [formula]

ADAPT, IN(BITS), OUT(MANY) and WEAK: Cl-P

Let A be the set of computational tasks defined by adaptive Clifford circuits, computational basis state inputs and multiple bit outputs. Then A may be weakly efficiently classically simulated.

Remark. Note that by theorem [\ref=thm2] strong simulation in this scenario even with single bit outputs, is #P-hard. The weak simulation that we give in the proof of theorem [\ref=thm5] below will use the strong simulation result of theorem [\ref=thm4]. A different proof of theorem [\ref=thm5] may be given in terms of the stabiliser formalism (see [\cite=nc], especially the Gottesman Knill theorem 10.7 therein) which develops a description of the evolving state through the course of the computation.

Remark. A family of Clifford computational tasks [formula], where Tn acts on n qubits, is said to be uniform if the description of Tn can be computed in poly(n) time by a (deterministic) classical Turing machine on input of n. Theorem [\ref=thm5] shows that uniform families of adaptive Clifford circuits with computational basis state inputs and multiple bit outputs do not have additional power over polynomial-time randomised classical computation. Interestingly, the power of such uniform families of Clifford computational tasks in fact coincides with polynomial-time randomised classical computation. This follows from the constructions in the proof of theorem [\ref=thm2] where it was shown how to generate random bits and realize Toffoli gates with adaptive Clifford circuits acting on computational basis state inputs (see also [\cite=An09] for related insights on realizing universal classical computation with adaptive stabilizer measurements). Finally we note the interesting comparison with the case of product states (replacing computational basis states) as inputs (keeping all other parameters the same) where the associated uniform families of Clifford computational tasks have precisely the same power as universal quantum computation (which similarly immediately follows from the proof of theorem [\ref=thm3]).

Proof. Let C be an adaptive circuit on n qubit lines with K intermediate measurements, input [formula] and l output lines. By lemma [\ref=lemmacad] we may wlog instead work with an extended circuit [formula] on n + K lines having the following form (rearranging the order of lines in lemma [\ref=lemmacad]): [formula] has input [formula] and the output measurements are on lines [formula] (wlog, as swap operations are Clifford). Furthermore the ith intermediate measurement yielding outcome yi for 1  ≤  i  ≤  K is on line i and then line i is not further used in [formula]. As such, these measurements can be viewed as outputs too with the caveat that subsequent choices of gates may depend on the values [formula] as they sequentially emerge. A full run of [formula] (including its l output measurements) samples an associated probability distribution [formula].

Now if [formula] for j  ≤  K are specified then the circuit up to the jth measurement becomes non-adaptive (i.e. the adaptive choices have been specified) and hence we can efficiently compute the marginal [formula] by theorem [\ref=thm4]. Similarly if j  ≥  K + 1 all adaptations have been specified and by theorem [\ref=thm4] we can again efficiently compute the corresponding marginals [formula]. Hence by lemma [\ref=lemmaterdiv] we can efficiently sample the distribution [formula] and the last l bits of the sample provides a weak efficient classical simulation of [formula] and hence of C too. [formula]

NONADAPT, IN(PROD), OUT(MANY) and STRONG: #P-hard

Let A be the set of computational tasks defined by non-adaptive Clifford circuits, general product state inputs and multiple bit outputs. Then the strong classical simulation of A is #P-hard.

Remark. Note that by theorem [\ref=thm1] the same scenario with just 1-bit outputs is classically strongly efficiently simulatable.

Proof. We will show that efficient strong simulation of A would imply efficient strong simulation of universal quantum computation and hence provide an efficient solution of the #SAT problem (using the process described in the proof of theorem [\ref=thm2] to express #  f for any Boolean f as a probability value).

Thus let D be any quantum circuit comprising basic Clifford gates and S gates with a product state input, and single bit output denoted y. Consider again the process of lemma [\ref=sgate]. In our present scenario for A we do not have adaptation available so we cannot implement S gates as we did in the proof of theorem [\ref=thm3]. Instead we proceed as follows. Suppose there are K S gates in D. For each such gate introduce an ancilla in state [formula] and replace the S gate by the sequence of operations in lemma [\ref=sgate], resulting in a non-adaptive circuit D' now involving only basic Clifford gates. Then D' has K + 1 outputs viz. y and measurements of the K ancilla lines denoted [formula], and we have

[formula]

Strong classical efficient simulation of A (which allows multi-line outputs) implies that we can compute both of the D' probabilities in the above quotient and hence ProbD(y) i.e. we then get a strong efficient simulation of D. [formula]

NONADAPT, IN(PROD), OUT(MANY) and WEAK: collapse of PH

Let A be the set of computational tasks defined (as in theorem [\ref=thm6]) by non-adaptive Clifford circuits, general product state inputs and multiple bit outputs. If A could be weakly efficiently classically simulated, then the polynomial hierarchy PH would collapse to its third level.

Remark. For the definition of PH we refer to [\cite=AB]. The proof of theorem [\ref=thm7] below rests on techniques introduced in [\cite=bjs] and below we will be content to describe the relationship of the class A in theorem [\ref=thm7] to the constructions of [\cite=bjs] and refer to the latter for further details of the proof.

Remark. Theorem [\ref=thm7] provides a partial answer to an open problem raised in [\cite=Aa04] viz. the question of the computational power of non-adaptive Clifford circuits with product state inputs and multiple bit outputs.

Proof. Consider again the process of lemma [\ref=sgate]. Now instead of utilising adaptation (as we did in the proof of theorem [\ref=thm3]) or conditional probabilities (as we did above in theorem [\ref=thm6]), we could alternatively implement S using the process of lemma [\ref=sgate] if we were able to post-select on measurement outcomes viz. we post-select the value 0 of the ancilla measurement. It follows that our class A together with post-selection contains universal quantum computation, and even more, universal quantum computation with post-selection. Aaronson [\cite=aarpp] has shown that the class BQP with post-selection coincides with the classical class PP (cf [\cite=AB] for definitions). Thus our class A with post-selection contains PP.

Now let K be any class of bounded error quantum circuits such that K with post-selection contains PP. Then (as elaborated in [\cite=bjs]) weak efficient classical simulation of K for output measurements on many lines, implies that K with post-selection is contained in BPP with post-selection [\cite=bjs]. Then according to a result of classical complexity theory (cf [\cite=bjs] for details), the latter inclusion (implying that PP is contained in BPP with post-selection) implies that PH collapses to its third level. Hence weak efficient classical simulation of our class A would imply this collapse. [formula]

Acknowledgments

RJ was supported in part by the EC networks Q-ESSENCE and QCS. Preliminary versions of this work were presented at the conferences AQIS12 (Suzhou China, September 2012) and QANSAS11 (Agra India, December 2011).