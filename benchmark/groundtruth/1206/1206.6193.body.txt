Corollary

Data Structures on Event Graphs

A preliminary version appeared as B. Chazelle and W. Mulzer, Data Structures on Event Graphs in Proc. 20th ESA, pp. 313-324, 2012

Introduction

In contrast with the traditional adversarial assumption of worst-case analysis, many data sources are modeled by Markov chains (e.g., in queuing, speech, gesture, protein homology, web searching, etc.). These models are very appealing because they are widely applicable and simple to generate. Indeed, locality of reference, an essential pillar in the design of efficient computing systems, is often captured by a Markov chain modeling the access distribution. Hence, it does not come as a surprise that this connection has motivated and guided much of the research on self-organizing data structures and online algorithms in a Markov setting [\cite=Chassaing93] [\cite=Hotz93] [\cite=KapoorRe91] [\cite=KarlinPhRa00] [\cite=KonnekerVa81] [\cite=LamLeSi84] [\cite=PhatarfodPrDy97] [\cite=SchulzSc96] [\cite=ShedlerTu72] [\cite=VitterKr96]. That body of work should be seen as part of a larger effort to understand algorithms that exploit the fact that input distributions often exhibit only a small amount of entropy. This effort is driven not only by the hope for improvements in practical applications (e.g., exploiting coherence in data streams), but it is also motivated by theoretical questions: for example, the key to resolving the problem of designing an optimal deterministic algorithm for minimum spanning trees lies in the discovery of an optimal heap for constant-entropy sources [\cite=Chazelle00]. Markov chains have been studied intensively, and there exists a huge literature on them (e.g., [\cite=LevinPeWi09]). Nonetheless, the focus has been on state functions (such as stationary distribution or commute/cover/mixing times) rather than on the behavior of complex objects evolving over them. This leads to a number of fundamental questions which, we hope, will inspire further research.

Let us describe our model in more detail. Our object of interest is a structure T(X) that evolves over time. The structure T(X) is defined over a finite subset X of a universe U. In the simplest case, we have [formula] and T(X)  =  X. This corresponds to the classic dictionary problem where we need to maintain a subset of a given universe. We can also imagine more complicated scenarios such as [formula] with T(X) being the Delaunay triangulation of X. An event graph G = (V,E) specifies restrictions on the queries and updates that are applied to T(X). For simplicity, we assume that G is undirected and connected. Each node v∈V is associated with an item xv∈U and corresponds to one of three possible requests: (i) insert(xv); (ii) delete(xv); or (iii) query(xv). Requests are specified by following a walk in G, beginning at a designated start node of G and hopping from node to neighboring node. We consider both adversarial walks, in which the neighbors can be chosen arbitrarily, and random walks, in which the neighbor is chosen uniformly at random. The latter case corresponds to the classic Markov chain model. Let vt be the node of G visited at time t and let Xt  ⊆  U be the set of active elements, i.e., the set of items inserted prior to time t and not deleted after their last insertions. We also call Xt an active set. For any t > 0, [formula] if the operation at vt is an insertion and [formula] in the case of deletion. The query at v depends on the structure under consideration (successor, point location, ray shooting, etc.). Another way to interpret the event graph is as a finite automaton that generates words over an alphabet with certain cancellation rules.

Markov chains are premised on forgetting the past. In our model, however, the structure T(Xt) can remember quite a bit. In fact, we can define a secondary graph over the much larger vertex set V  ×  2U|V, where U|V  =  {xv|  v∈V} denotes those elements in the universe that occur as labels in G, see Fig. [\ref=fig:decorated_ex]. We call this larger graph the decorated graph, [formula], since the way to think of this secondary graph is to picture each node v of G being "decorated" with the subsets X  ⊆  U|V. (We define the vertex set using 2U|V in order to allow for every possible initial subset X.) Let n be the number of nodes in G. Since |U|V|  ≤  n, an edge (v,w) in the original graph gives rise to up to 2n edges (v,X)(w,Y) in the decorated graph, with Y derived from X in the obvious way. A trivial upper bound on the number of states is n2n, which is essentially tight. If we could afford to store all of [formula], then any of the operations at the nodes of the event graph could be precomputed and the running time per step would be constant. However, the required space might be huge, so the main question is

Can the decorated graph be compressed with no loss of performance?

This seems a difficult question to answer in general. In fact, even counting the possible active sets in decorated graphs seems highly nontrivial, as it reduces to counting words in regular languages augmented with certain cancellation rules. Hence, in this paper we focus on basic properties and special cases that highlight the interesting behavior of the decorated graph. Beyond the results themselves, the main contribution of this work is to draw the attention of algorithm designers to a more realistic input model that breaks away from worst-case analysis.

Our Results.

The paper has two main parts. In the first part, we investigate some basic properties of decorated graphs. We show that the decorated graph [formula] has a unique strongly connected component that corresponds to the limiting phase of a walk on the event graph G, and we give characterizations for when a set X  ⊆  U|V appears as an active set in this limiting phase. We also show that whether X is such an active set can be decided in linear time (in the size of G).

In the second part, we consider the problem of maintaining a dictionary that supports successor searches during a one-dimensional walk on a cycle. We show how to achieve linear space and constant expected time for a random walk. If the walk is adversarial, we can achieve a similar result with near-linear storage. The former result is in the same spirit as previous work by the authors on randomized incremental construction (RIC) for Markov sources [\cite=ChazelleMu09]. RIC is a fundamental algorithmic paradigm in computational geometry that uses randomness for the construction of certain geometric objects, and we showed that there is no significant loss of efficiency if the randomness comes from a Markov chain with sufficiently high conductance.

Basic Properties of Decorated Graphs

We are given a labeled, connected, undirected graph G  =  (V,E). In this section, we consider only labels of the form x and x, where x is an element from a finite universe U and i and d stand for insert and delete. We imagine an adversary that maintains a subset X  ⊆  U while walking on G and performing the corresponding operations on the nodes. Since the focus of this section is the evolution of X over time, we ignore queries for now.

Recall that U|V denotes the elements that appear on the nodes of G. For technical convenience, we require that for every x∈U|V there is at least one node labeled ix and at least one node labeled dx. The walk on G is formalized through the decorated graph [formula]. The graph [formula] is a directed graph on vertex set V': = V  ×  2U|V. The pair ((u,X),(v,Y)) is an edge in E' if and only if {u,v} is an edge in G and [formula] or [formula] depending on whether v is labeled ixv or dxv, see Fig. [\ref=fig:decorated_ex].

By a walk W in a (directed or undirected) graph, we mean any finite sequence of nodes such that the graph contains an edge from each node in W to its successor in W (in particular, a node may appear multiple times in W). Let A be a walk in [formula]. Recall that the nodes in A are tuples, consisting of a node in G and a subset of U|V. By taking the first elements of the nodes in A, we obtain a walk in G, the projection of A, denoted by [formula]. For example, in Fig. [\ref=fig:decorated_ex], the projection of the walk [formula] in the decorated graph is the walk 1,2,1,1 in the event graph. Similarly, let W be a walk in G with start node v, and let X  ⊆  2U|V. Then the lifting of W with respect to X is the walk in [formula] that begins at node (v,X) and follows the steps of W in [formula]. We denote this walk by [formula]. For example, in Fig. [\ref=fig:decorated_ex], we have [formula].

Since [formula] is a directed graph, it can be decomposed into strongly connected components that induce a directed acyclic graph D. We call a strongly connected component of [formula] a sink component (also called essential class in Markov chain theory), if it corresponds to a sink (i.e., a node with out-degree 0) in D. First, we observe that every node of G is represented in each sink component of [formula], see Fig [\ref=fig:decorated_comps].

Let C be a sink component of [formula]. For each vertex v of G, there exists at least one subset Y  ⊆  U|V such that (v,Y) is a node in C. In other words, v is the first element of at least one node in C.

Let (w,X) be any node in C. Since G is connected, there is a walk W in G from w to v, so [formula] ends in a node in C whose first element is v.

Next, we show that to understand the behaviour of a walk on G in the limit, it suffices to focus on a single sink component of [formula].

In [formula] there exists a unique sink component C such that for every node [formula] in [formula], C is the only sink component that [formula] can reach.

Suppose there is a node v in G such that [formula] can reach two different sink components C and C' in [formula]. By Lemma [\ref=lem:all-first-nodes], both C and C' must contain at least one node with first element v. Call these nodes (v,X) (for C) and (v,X') (for C'). Furthermore, by assumption [formula] contains a walk A from [formula] to (v,X) and a walk A' from [formula] to (v,X'). Let [formula] and [formula]. Both W and W' are closed walks in G that start and end in v, so their concatenations WW'W and W'W'W are valid walks in G, again with start and end vertex v. Consider the lifted walks [formula] and [formula] in [formula]. We claim that these two walks have the same end node (v,X''). Indeed, for each x∈U|V, whether x appears in X'' or not depends solely on whether the label ix or the label dx appears last on the original walk in G. This is the same for both WW'W and W'W'W. Hence, C and C' must both contain (v,X'), a contradiction to the assumption that they are distinct sink components. Thus, each node [formula] can reach exactly one sink component.

Now consider two distinct nodes [formula] and [formula] in [formula] and assume that they reach the sink components C and C', respectively. Let W be a walk in G that goes from v to w and let [formula], where A is a walk in [formula] that connects w to C'. Since G is undirected, the reversed walk WR is a valid walk in G from w to v. Now consider the walks Z1: = WWRWW' and Z2: = WRWW'. The walk Z1 begins in v, the walk Z2 begins in w, and they both have the same end node. Furthermore, for each x∈U|V, the label ix appears last in Z1 if and only if it appears last in Z2. Hence, the lifted walks [formula] and [formula] have the same end node in [formula], so C  =  C'. The lemma follows.

Since the unique sink component C from Lemma [\ref=lem:uniqueSink] represents the limit behaviour of the set X during a walk in G, we will henceforth focus on this component. Let us begin with a few properties of C. First, we characterize the nodes in C.

Let v be a node of G and X  ⊆  U|V. We have (v,X)∈C if and only if there exists a closed walk W in G with the following properties:

the walk W starts and ends in v:

for each x∈U|V, there is at least one node in W with label ix or dx;

we have x∈X if and only if the last node in W referring to x is an insertion and [formula] if and only if the last node in W referring to x is a deletion.

We call the walk W from Lemma [\ref=lem:C-characterization] a certifying walk for the node (v,X) of C. For example, as we can see in Fig. [\ref=fig:decorated_comps], the sink component of our example graph contains the node (2,{2}). A certifying walk for this node is 2,2,1,2,2.

First, suppose there is a walk with the given properties. By Lemma [\ref=lem:all-first-nodes], there is at least one node in C whose first element is v, say (v,Y). The properties of W immediately imply that the walk [formula] ends in (v,X), which proves the "if"-direction of the lemma.

Now suppose that (v,X) is a node in C. Since C is strongly connected, there exists a closed walk A in C that starts and ends at (v,X) and visits every node of C at least once. Let [formula]. By Lemma [\ref=lem:all-first-nodes] and our assumption on the labels of G, the walk W contains for every element x∈U|V at least one node with label ix and one node with label dx. Therefore, the walk W meets all the desired properties.

This characterization of the nodes in C immediately implies that the decorated graph can have only one sink component.

The component C is the only sink component of [formula].

Let (v,X) be a node in [formula]. By Lemmas [\ref=lem:all-first-nodes] and [\ref=lem:C-characterization], there exists in C a node of the form (v,Y) and a corresponding certifying walk W. Clearly, the walk [formula] ends in (v,Y). Thus, every node in [formula] can reach C, so there can be no other sink component.

Next, we give a bound on the length of certifying walks, from which we can deduce a bound on the diameter of C.

Let (v,X) be a node of C and let W be a corresponding certifying walk of minimum length. Then W has length at most O(n2), where n denotes the number of nodes in G. There are examples where any certifying walk needs Ω(n2) nodes. It follows that C has diameter O(n2) and that this is tight.

Consider the reversed walk WR. We subdivide WR into phases: a new phase starts when WR encounters a node labeled ix or dx for an x∈U|V that it has not seen before. Clearly, the number of phases is at most n. Now consider the i-th phase and let Vi be the set of nodes in G whose labels refer to the i distinct elements of U|V that have been encountered in the first i phases. In phase i, the walk WR can use only vertices in Vi. Since W has minimum cardinality, the phase must consist of a shortest walk in Vi from the first node of phase i to the first node of phase i + 1. Hence, each phase consists of at most n vertices and the length of W is O(n2).

We now describe the lower bound construction. Let m  ≥  2 be an integer. The event graph P is a path with n  =  2m  +  1 vertices. The first m vertices are labeled [formula], in this order. The middle vertex is labeled m, and the remaining m vertices are labeled [formula], in this order, see Fig. [\ref=fig:large-diameter]. Let v be the middle vertex of P and C be the unique sink component of [formula]. First, note that (v,X) is a node of C for every [formula]. Indeed, given [formula], we can construct a certifying walk for X as follows: we begin at v, and for [formula], we walk from v to k or k, depending on whether k lies in X or not, and back to v. This gives a certifying walk for X with [formula] steps. Now, we claim that the length of a shortest certifying walk for the node [formula] is Θ(m2)  =  Θ(n2). Indeed, note that the set [formula] contains exactly the odd numbers between 1 and m - 1. Thus, a certifying walk for Y must visit the node 1 after all visits to node 1, the node 2 after all visits to 2, etc. Furthermore, the structure of P dictates that any certifying walk performs these visits in order from largest to smallest, i.e., first comes the last visit to the node for m - 1, then the last visit to the node for m - 2, etc. To see this, suppose that there exist i  <  j such that the last visit to the node for i, wi, comes before the last visit to the node for j, wj. Then the parity of i and j must differ, because otherwise the walk must cross wi on the way from wj to v. However, in this case, on the way from wj to v, the certfying walk has to cross the node with the wrong label for i (insert instead of delete, or vice versa), and hence it could not be a certifying walk. It follows that any certifying walk for (v,Y) has length Ω(n2).

We now show that any two nodes in C are connected by a walk of length O(n2). Let (u,X) and (v,Y) be two such nodes and let Q be a shortest walk from u to v in G and W be a certifying walk for (v,Y). Then [formula] is a walk of length O(n2) in C from (u,X) to (v,Y). Hence, the diameter of C is O(n2). Again, the lower bound example from the previous paragraph applies: the length of a shortest walk in C between [formula] and [formula] is Θ(n2), as can be seen by an argument similar to the argument for the shortest certifying walk.

Next, we describe an algorithm that is given G, a node v∈V, and a set X  ⊆  U|V and then decides whether (v,X) is a node of the unique sink or not. For W  ⊆  V, let U|W denote the elements that appear in the labels of the nodes in W. For U  ⊆  U, let V|U denote the nodes of G whose labels contain an element of U.

Given an event graph G, a node v of G and a subset X  ⊆  U|V, we can decide in O(|V| + |E|) steps whether (v,X) is a node of the unique sink component C of [formula].

The idea of the algorithm is to construct a certifying walk for (v,X) through a modified breadth first search.

In the preprocessing phase, we color a vertex w of G blue if w is labeled ix and x∈X, or if w is labeled dx and [formula]. Otherwise, we color w red. If v is colored red, then (v,X) cannot be in C, and we are done. Otherwise, we perform a directed breadth first search that starts from v and tries to construct a reverse certifying walk. Our algorithm maintains several queues. The main queue is called the blue fringe B. Furthermore, for every x∈U|V, we have a queue Rx, the red fringe for x. At the beginning, the queue B contains only v, and all the red fringes are empty.

The main loop of the algorithm takes place while B is not empty. We pull the next node w out of B, and we process w as follows: if we have not seen the element xw∈U|V for w before, we color the set V|{xw} of all nodes whose label refers to xw blue, append all the nodes of Rxw to B, and we delete Rxw. Next, we process the neighbors of w as follows: if a neighbor w' of w is blue, we append it to B if w' has not been inserted into B before. If w' is red and labeled with the element xw', we append w' to Rxw', if necessary, see Fig. [\ref=fig:bfs_ex].

The algorithm terminates after at most |V| iterations. In each iteration, the cost is proportional to the degree of the current vertex w and (possibly) the size of one red fringe. The latter cost can be charged to later rounds, since the nodes of the red fringe are processed later on. Let [formula] be the union of the remaining red fringes after the algorithm terminates.

If [formula], we obtain a certifying walk for (v,X) by walking from one newly discovered vertex to the next inside the current blue component and reversing the walk. Now suppose [formula]. Let A be the set of all vertices that were traversed during the BFS. Then [formula] has at least two connected components (since there must be blue vertices outside of A). Furthermore, [formula]. We claim that a certifying walk for (v,X) cannot exist. Indeed, suppose that W is such a certifying walk. Let [formula] be the element in the label of the last node w in W whose label refers to an element in [formula]. Suppose that the label of w is of the form ixw; the other case is symmetric. Since W is a certifying walk, we have xw∈X, so w was colored blue during the initialization phase. Furthermore, all the nodes on W that come after w are also blue at the end. This implies that w∈A, because by assumption a neighor of w was in B, and hence w must have been added to B when this neighbor was processed. Hence, we get a contradiction to the fact that [formula], so W cannot exist. Therefore, [formula].

The proof of Theorem [\ref=thm:decide] gives an alternative characterization of whether a node appears in the unique sink component or not.

The node (v,X) does not appear in C if and only if there exists a set A  ⊆  V(G) with the following properties:

[formula] has at least two connected components.

[formula], where B denotes the vertex set of the connected component of [formula] that contains v.

For all x∈U, A contains either only labels of the form ix or only labels of the form dx (or neither). If A has a node with label ix, then [formula]. If A has a node with label dx, then x∈X.

A set A with the above properties can be found in polynomial time.

Given [formula] and a node (v,X)∈C, it is NP-complete to decide whether there exists a certifying walk for (v,X) of length at most k.

The problem is clearly in NP. To show completeness, we reduce from Hamiltonian path in undirected graphs. Let G be an undirected graph with n vertices, and suppose the vertex set is [formula]. We let [formula] and take two copies G1 and G2 of G. We label the copy of node i in G1 with ii and the copy of node i in G2 with di. Then we add two nodes v1 and v2, and we connect v1 to v2 and to all nodes in G1 and G2, We label v1 with i(n + 1) and v2 with (n + 1). The resulting graph G' has 2n + 2 nodes and meets all our assumptions about an event graph. Clearly, G' can be constructed in polynomial time. Finally, since by definition a certifying walk must visit for each element i either i or i, it follows that G has a Hamiltonian path if and only if the node [formula] has a certifying walk of length at most n + 2. This completes the reduction.

Successor Searching on Cycle Graphs

We now consider the case that the event graph G is a simple cycle [formula] and the item xvi at node vi is a real number. Again, the structure T(X) is X itself, and we now have three types of nodes: insertion, deletion, and query. A query at time t asks for   Xt(xvt) =  min {  x∈Xt  |  x  ≥  xvt  } (or ∞  ). Again, an example similar to Fig. [\ref=fig:large-diameter] shows that the decorated graph can be of exponential size: let n be even. For [formula], take xvi  =  xvn + 1 - i  =  i, and define the operation at vi as xvi for [formula], and xvn + 1 - i for [formula]. It is easy to design a walk that produces any subset of [formula] at either v1 or vn, which implies a lower bound of Ω(2n / 2) on the size of the decorated graph.

We consider two different walks on G. The random walk starts at v1 and hops from a node to one of its neighbors with equal probability. The main result of this section is that for random walks, maximal compression is possible.

Successor searching in a one-dimensional random walk can be done in constant expected time per step and linear storage.

First, however, we consider an adversarial walk on G. Note that we can always achieve a running time of O( log  log n) per step by maintaining a van Emde Boas search structure dynamically [\cite=vEmdeBoasKaZi76] [\cite=vEmdeBoas77], so the interesting question is how little storage we need if we are to perform each operation in constant time.

Successor searching along an n-node cycle in the adversarial model can be performed in constant time per operation, using O(n1 + ε) storage, for any fixed ε > 0.

Before addressing the walk on G, we must consider the following range searching problem (see also [\cite=CrochemoreIlKuRaWa12]). Let [formula] be a sequence of n distinct numbers, and consider the points (k,yk), for [formula]. A query is given by two indices i and j, together with a type. The type is defined as follows: the horizontal lines x  ↦  yi and x  ↦  yj divide the plane into three unbounded open strips R1, R2, and R3, numbered from top to bottom. For a  =  1,2,3, let [formula]. The type is specified by the number a together with a direction →   or ←. The former is called a right query, the latter a left query. Let us describe the right query: if [formula], the result is [formula]. If Sa contains an index larger than i, we want the minimum index in Sa larger than i. If all indices in Sa are less than i, we want the overall minimum index in Sa. The left query is defined symmetrically. See Fig. [\ref=fig:fig12](left) for an example.

Thus, there are six types of queries, and we specify a query by a triplet (i,j,σ), with σ to being the type. We need the following result, which, as a reviewer pointed out to us, was also discovered earlier by Crochemore et al.[\cite=CrochemoreIlKuRaWa12]. We include our proof below for completeness.

Any query can be answered in constant time with the help of a data structure of size O(n1 + ε), for any ε > 0.

Using Lemma [\ref=range-search], we can prove Theorem [\ref=adversarial-cycle].

At any time t, the algorithm has at its disposal: (i) a sorted doubly-linked list of the active set Xt (augmented with ∞  ); (ii) a (bidirectional) pointer to each x∈Xt from the first node vk on the circle clockwise from vt, if it exists, such that [formula] (same thing counterclockwise)--see Fig. [\ref=fig:fig12](right). Assume now that the data structure of Lemma [\ref=range-search] has been set up over [formula]. As the walk enters node vt at time t, [formula] is thus readily available and we can update Xt in O(1) time. The only remaining question is how to maintain (ii). Suppose that the operation at node vt is a successor request and that the walk reached vt clockwise. If x is the successor, then we need to find the first node vk on the cycle clockwise from vt such that [formula]. This can be handled by two range search queries (i,j,σ): for i, use the index of the current node vt; and, for j, use the node for x in the first query and the node for x's predecessor in Xt in the second query. An insert can be handled by two such queries (one on each side of vt), while a delete requires pointer updating, but no range search queries.

We define a single data structure to handle all six types simultaneously. We restrict our discussion to the type (2,  →  ) from Fig. [\ref=fig:fig12](left) but kindly invite the reader to check that all other five types can be handled in much the same way. We prove by induction that with scn1 + 1 / s storage, for a large enough constant c, any query can be answered in at most O(s) table lookups. The case s = 1 being obvious (precompute all queries), we assume that s > 1. Sort and partition Y into consecutive groups [formula] of size n1 - 1 / s each. We have two sets of tables:

Ylinks: for each yi∈Y, link yi to the highest-indexed element yj to the left of i (j < i) within each group [formula], wrapping around the strip if necessary (left pointers in Fig. [\ref=fig:fig34](left)).

Zlinks: for each yi∈Y, find the group [formula] to which yi belongs and, for each k, define Zk as the subset of Y sandwiched between yi and the smallest (resp. largest) element in Yk if [formula] (resp. [formula]). Note that this actually defines two sets for [formula], so that the total number of Zk's is really n1 / s + 1. Link yi to the lowest-indexed yj (j > i) in each Zk (right pointers in Fig. [\ref=fig:fig34](left)), again wrapping around if necessary.

Prepare a data structure of type s - 1 recursively for each Yi.

Given a query (i,j) of type (2,  →  ), we first check whether it fits entirely within [formula] and, if so, solve it recursively. Otherwise, we break it down into two subqueries: one of them can be handled directly by using the relevant Zlink. The other one fits entirely within a single Yk. By following the corresponding Ylink, we find yi' and solve the subquery recursively by converting it into another query (i',j) of appropriate type (Fig. [\ref=fig:fig34](right)). By induction, it follows that this takes O(s) total lookups and storage

[formula]

for some constant d and for c large enough, since

[formula]

Using Theorem [\ref=adversarial-cycle] together with the special properties of a random walk on G, we can quickly derive the algorithm for Theorem [\ref=markov-cycle].

The idea is to divide up the cycle into [formula] equal-size paths [formula] and prepare an adversarial data structure for each one of them right upon entry. The high cover time of a one-dimensional random walk is then invoked to amortize the costs. De-amortization techniques are then used to make the costs worst-case. The details follow. As soon as the walk enters a new Pk, the data structure of Lemma [\ref=range-search] is built from scratch for ε = 1 / 3, at a cost in time and storage of O(n2 / 3). By merging Lk  =  {  xvi  |  vi∈Pk  } with the doubly-linked list storing Xt, we can set up all the needed successor links and proceeds just as in Theorem [\ref=adversarial-cycle]. This takes O(n) time per interpath transition and requires O(n2 / 3) storage. There are few technical difficulties that we now address one by one.

Upon entry into a new path Pk, we must set up successor links from Pk to Xt, which takes O(n) time. Rather than forcing the walk to a halt, we use a "parallel track" idea to de-amortize these costs. (Fig. [\ref=fig:fig5]). Cover the cycle with paths Pi' shifted from Pi clockwise by [formula]. and carry on the updates in parallel on both tracks. As we shall see below, we can ensure that updates do not take place simultaneously on both tracks. Therefore, one of them is always available to answer successor requests in constant time.

Upon entry into a new path Pk (or Pk'), the relevant range search structure must be built from scratch. This work does not require knowledge of Xt and, in fact, the only reason it is not done in preprocessing is to save storage. Again, to avoid having to interrupt the walk, while in Pk we ensure that the needed structures for the two adjacent paths Pk - 1,Pk + 1 are already available and those for Pk - 2,Pk + 2 are under construction. (Same with Pk'.)

On a path, we do not want our range queries to wrap around as in the original structure. Thus, if a right query returns an index smaller than i, or a left query returns an index larger than i, we change the answer to [formula].

The range search structure can only handle queries (i,j) for which both yi and yj are in the ground set. Unfortunately, j may not be, for it may correspond to an item of Xt inserted prior to entry into the current Pk. There is an easy fix: upon entering Pk, compute and store [formula] for [formula]. Then, simply replace a query (i,j) by (i,j') where j' is the successor (or predecessor) in Lk.

The key idea now is that a one-dimensional random walk has a quadratic cover time [\cite=MotwaniRa95]; therefore, the expected time between any change of paths on one track and the next change of paths on the other track is Θ(n). This means that if we dovetail the parallel updates by performing a large enough number of them per walking step, we can keep the expected time per operation constant. This proves Theorem [\ref=markov-cycle].

Conclusion

We have presented a new approach to model and analyze restricted query sequences that is inspired by Markov chains. Our results only scratch the surface of a rich body of questions. For example, even for the simple problem of the adversarial walk on a path, we still do not know whether we can beat van Emde Boas trees with linear space. Even though there is some evidence that the known lower bounds for successor searching on a pointer machine give the adversary a lot of leeway [\cite=Mulzer09], our lower bound technology does not seem to be advanced enough for this setting. Beyond paths and cycles, of course, there are several other simple graph classes to be explored, e.g., trees or planar graphs.

Furthermore, there are more fundamental questions on decorated graphs to be studied. For example, how hard is it to count the number of distinct active sets (or the number of nodes) that occur in the unique sink component of [formula]? What can we say about the behaviour of the active set in the limit as the walk proceeds randomly? And what happens if we go beyond the dictionary problem and consider the evolution of more complex structures during a walk on the event graph?

Acknowledgments

We would like to thank the anonymous referees for their thorough reading of the paper and their many helpful suggestions that have improved the presentation of this paper, as well as for pointing out [\cite=CrochemoreIlKuRaWa12] to us.

W. Mulzer was supported in part by DFG grant MU3501/1.