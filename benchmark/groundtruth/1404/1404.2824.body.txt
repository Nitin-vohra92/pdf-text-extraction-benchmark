Normal, Abby Normal, Prefix Normal

Keywords: prefix normal words, binary jumbled pattern matching, normal forms, enumeration, membership testing, binary languages

Introduction

Consider the binary word w = 10100110110001110010. Does it have a substring of length 11 containing exactly 5 ones? In Fig. [\ref=fig:esempio] the word w is represented by the black line (go up and right for a 1, down and right for a 0), while the grid points within the area between the two lighter lines form the Parikh set of w: the set of vectors (x,y) s.t. some substring of w contains exactly x ones and y zeros. Since the point (5,6) lies within the area bounded by the two lighter lines, we see that the answer to our question is 'yes'. (Don't worry, more detailed explanation will follow soon.) Now, this paper is about the lighter lines, called prefix normal words.

Prefix normal words: A binary word w is called prefix normal (with respect to 1) if no substring of w has more 1s then the prefix of the same length. For example, 110101101100100 is not prefix normal because it has a substring of length 5 with 4 ones, while the prefix of length 5 has only 3 ones. In [\cite=FL11] it was shown that to every word w, one can assign two prefix normal words, the prefix normal forms (PNF) of w (w.r.t. 1 and w.r.t. 0), and that these are precisely the lines bounding w's Parikh set from above (w.r.t. 1) resp. from below (w.r.t. 0), interpreted as binary words.

Prefix normal games: Before we further elaborate on the connection between the initial problem and prefix normal words, let's see how well you have understood the definition. To this end, we define a two-player game. At the start of the game Alice and Bob have n free positions. Alice moves first: she picks a position and sets it to 0 or 1. Then in alternating moves, they pick an empty position and set it. The game ends after n moves. Alice wins if and only if the resulting binary word is prefix normal.

Here is an example run. We have n = 5. Alice sets the first bit to 1, then Bob sets the second bit to 0. Now Alice sets the 4th bit to 0, and she has won, since whichever position Bob chooses, she will set the remaining position to 0, thus ensuring that the word is prefix normal.

The solution to the following exercise can be found in Section [\ref=sec:games].

Find the maximum n such that Alice has a winning strategy.

Binary Jumbled Pattern Matching: The problem of deciding whether a particular pair (x,y) lies within the Parikh set of a word w is known as binary jumbled pattern matching. There has been much interest recently in the indexed version, where an index for the Parikh set is created in a preprocessing step, which can then be used to answer queries fast. The Parikh set can be represented in linear space due to the interval property of binary strings: If w has k-length substrings with x1 resp. x2 ones, where x1  <  x2, then it also has a k-length substring with y ones, for every x1  ≤  y  ≤  x2 (folklore). Thus the Parikh set can be represented by storing, for every 1  ≤  k  ≤  |w|, the minimum and maximum number of 1s in a substring of length k. Much recent research has focused on how to compute these numbers efficiently [\cite=CFL09] [\cite=MR10] [\cite=MR12] [\cite=CLWY12] [\cite=BFKL13] [\cite=GG13] [\cite=GHLW13]. The problem has also been extended to graphs and trees [\cite=GHLW13] [\cite=CGGLLRT13], to the streaming model [\cite=LLZ12], and to approximate indexes [\cite=CLWY12]. There is also interest in the non-binary variant [\cite=BEL04] [\cite=CFL09] [\cite=KRR13]. A closely related problem is that of Parikh fingerprints [\cite=AALS03]. Applications in computational biology include SNP discovery, alignment, gene clusters, pattern discovery, and mass spectrometry data interpretation [\cite=Boecker07] [\cite=Benson03] [\cite=BoeckerJMS08] [\cite=DuhrkopLMB13] [\cite=Parida06].

The current best construction algorithms for the linear size index for binary jumbled pattern matching run in O(n2  /   log n) time [\cite=BCFL10] [\cite=MR10], for a word w of length n, with some improvements for special cases (compressible strings [\cite=GHLW13] [\cite=BFKL13], bit-parallel operations [\cite=MR12] [\cite=GG13]). As we will see later, computing the prefix normal forms is equivalent to creating an index for the Parikh set of w. Currently, we know no faster computation algorithms for the prefix normal forms than already exist for the linear-size index. However, should better algorithms be discovered, these would immediately carry over to the problem of indexed binary jumbled pattern matching.

Testing: It turns out that even testing whether a given word is prefix normal is a nontrivial task. We can of course compute w's prefix normal form, in [formula] time using one of the above algorithms: obviously w is prefix normal if and only if [formula]. In [\cite=pn1], we gave a generating algorithm for prefix normal words, which exhaustively lists all prefix normal words of a fixed length. The algorithm was based on the fact that prefix normal words are a bubble language, a recently introduced class of binary languages [\cite=RSW12] [\cite=Wi09]. As a subroutine of our algorithm, we gave a linear time test for words which are obtained from a prefix normal word via a certain operation. In Section [\ref=sec:testing], we present an algorithm to test whether an arbitrary word is prefix normal, based on similar ideas. Our algorithm is quadratic in the worst case but we believe it performs much better than other algorithms once some simple cases have been removed.

We further demonstrate how using several simple linear time tests can be used as a filtering step, and conjecture, based on experimental evidence, that these lead to expected O(n) time algorithms. But first the reader is kindly invited to try for herself.

Decide whether the word 111010100110110011 is prefix normal.

Enumerating: Another very interesting and challenging problem is the enumeration of prefix normal words. It turns out that even though the number of prefix normal words grows exponentially, the fraction of these words within all binary words goes to 0 as n goes to infinity. In Sections [\ref=sec:enum1] to [\ref=sec:enum3], we present both asymptotic and exact results for prefix normal words, including generating functions for special classes and counting extensions for particular words. Some of the proofs in this part of the paper are rather technical: they will be available in the full version.

Mechanical algorithm design: We contribute to the area of mechanical algorithm design by presenting an algorithm for computing the Parikh set which uses the new sandbeach technique, a technique we believe will be useful in many other applications (Sec. [\ref=sec:testing]).

We would like to point out that prefix normal words, albeit similar in name, are not to be confused with so-called Abby Normal (a.k.a.  abnormal or AB normal), words, or rather, brains, introduced in [\cite=MelBrooks].-- And now it is time to wish you, the reader, as much fun in reading our paper as we had in writing it!

Prefix normal words

A binary word (or string) [formula] over Σ  =  {0,1} is a finite sequence of elements from Σ. Its length n is denoted by |w|. For any 1  ≤  i  ≤  |w|, the i-th symbol of a word w is denoted by wi. We denote by Σn the words over Σ of length n, and by [formula] the set of finite words over Σ. The empty word is denoted by ε. Let w∈Σ*. If w = uv for some u,v∈Σ*, we say that u is a prefix of w and v is a suffix of w. A substring of w is a prefix of a suffix of w. A binary language is any subset L of Σ*. We denote by |w|c the number of occurrences in w of character c∈{0,1}; |w|1 is called the density of w.

Let w∈Σ*. For [formula], we set [formula], the number of 1s in the i-length prefix of w, and [formula], the maximum number of 1s over all substrings of length i.

Prefix normal words, prefix normal equivalence and prefix normal form were introduced in [\cite=FL11]. A word w∈{0,1}* is prefix normal (w.r.t. 1) if, for all 1  ≤  i  ≤  |w|, F(w,i)  =  P(w,i). In other words, a word is prefix normal if no substring contains more 1s than the prefix of the same length.

We give all 23 prefix normal words of length n = 6: 000000, 100000, 100001, 100010, 100100, 101000, 101001, 101010, 110000, 110001, 110010, 110011, 110100, 110101, 110110, 111000, 111001, 111010, 111011, 111100, 111101, 111110, 111111.

Two words w,w' are prefix normal equivalent (w.r.t. 1) if and only if F(w,i)  =  F(w',i) for all i. Given w∈Σ*, the prefix normal form (w.r.t. 1) of w, [formula], is the unique prefix normal word w' which is prefix normal equivalent (w.r.t. 1) to w. Prefix normality w.r.t. 0, prefix normal equivalence w.r.t. 0, and [formula] are defined analogously. When not stated explicitly, we are referring to the functions w.r.t. 1. For example, the words 0000111 and 1110000 are prefix normal equivalent both w.r.t. 0 and 1. See [\cite=FL11] [\cite=pn1] for more examples.

In Fig. [\ref=fig:esempio], we see an example string w and its prefix normal forms. The interval property (see Introduction) can be graphically interpreted as vertical lines. The vertical line through point (5,6) represents length-11 substrings: the grid points within the enclosed area are (7,4),(6,5), and (5,6), so all length-11 substrings have between 7 and 5 ones. We can interpret, for each length k, the intersection of the kth vertical line with the top grey line as the maximum number of 1s, and with the bottom grey line as the minimum number of 1s. Now it is easy to see that, passing from k to k + 1, this maximum, F1(w,  ·  ), can either remain the same or increase by one. This means that the top grey line allows an interpretation as a binary word. A similar interpretation applies to the bottom line and prefix normal words w.r.t 0.

It should now be clear, also graphically, that the maximum number of 1s for a substring of length k, F(w,k), is precisely the number of 1s in the k-length prefix of [formula] (the upper grey line); and similarly for the maximal number of 0s (equivalently, the minimal number of 1s) and [formula] (the lower grey line). Moreover, these values can be obtained in constant time with constant-time rank-operations [\cite=Munro96] [\cite=GHLW13].

We list a few properties of prefix normal words that will be useful later.

Every prefix of a prefix normal word is also prefix normal.

If w is prefix normal, then w0 is also prefix normal.

Given w of length n, it can be decided in O(n2) time whether w is prefix normal.

We denote the language of prefix normal words by [formula], the number of prefix normal words of length n by (n), and the number of prefix normal words of length n and density d by (n,d). The first few values of the sequence (n) are listed in [\cite=sloane2].

Asymptotic bounds on the number of prefix normal words

We give lower and upper bounds on the number of prefix normal words of length n. Our lower bound on (n) is proved in Section [\ref=sec:games].

There exists c > 0 such that

[formula]

If we consider the length of the first 1-run, we obtain an upper bound.

For n  ≥  1, we have [formula].

Let k = k(n) > 0 be a number to be specified later. Partition [formula] into two classes according to the length of the first 1-run. Case 1: If w is prefix normal and the first 1-run's length is less than k, then there are no k consecutive 1s in w. Write w as the concatenation of ⌊n / k⌋ blocks of length k and a final, possibly shorter block: [formula] For each block we have at most 2k - 1 possibilities, so there can be at most (2k - 1)⌈n / k⌉ words in this class. Case 2: The length of the first 1-run in w is at least k. Since the first k symbols of w are already fixed as 1s, there can only be 2n - k  =  2n / 2k words in this class.

If we balance the two cases by letting k be the largest integer such that 2k  ·  k2  ·   ln 2  ≤  n, then we have k = Θ( ln n) and as stated.

Exact formulas for special classes of prefix normal words

Words with fixed density.

We formulate an equivalent definition of the prefix normal property that will be useful in the enumeration of prefix normal words. Let [formula] be a prefix normal word of density d > 0. Denote by [formula] the distances between consecutive occurrences of 1 in w, and set rd so that [formula] holds. We can thus write [formula]. For w = 110100010, we have d = 4, r1 = 1, r2 = 2, r3 = 4 and r4 = 2. The prefix normal property is equivalent to requiring that for all k, one of the shortest substrings containing exactly k ones is a prefix. This gives us the following lemma.

The binary word w is prefix normal if and only if the following inequalities hold:

For [formula], we have the generating functions [formula]:

Similar formulas can be derived for (n,n - d) for small values of d. Unfortunately, no clear pattern is visible for fd(x) that we could use for calculating (n).

Words with a fixed prefix.

We now fix a prefix w and give enumeration results on prefix normal words with prefix w. Our first result indicates that we have to consider each w separately.

If w is a binary word, let [formula], and [formula]. Let (w,m,d)  =  |{w':ww'|w| + md}|, and [formula].

Let v,w∈1{0,1}* be both prefix normal. If v  ≠  w then [formula].

We were unable to prove that the growth of these two extension languages also differ.

Let v,w∈1{0,1}* be both prefix normal. If v  ≠  w then the infinite sequences [formula] and ((w,m))m  ≥  1 are different.

The values (w,m,d) seem hard to analyze. We give exact formulas for a few special cases of interest. Using Lemma [\ref=lemma:equivDefPn], it is possible to give formulas similar to those in Lemma [\ref=lemma:genFunc] for (w,m,d) for fixed w and d. We only mention one such result.

For 1  ≤  d  ≤  n we have (10,n + d - 3,d)  =  (n,d).

Let w be an arbitrary prefix normal word of length n and density d with 1 as its first symbol. Insert a 0 before each subsequent occurrence of 1. It is easy to see that this operation creates a bijection between the two sets that we want to enumerate.

The following lemma lists exact values for (w,|w|) for some infinite families of words w.

Let F(n) denote the nth Fibonacci number: F(1) = F(2) = 1 and F(n + 2)  =  F(n + 1) + F(n). Then for all values of n where the exponents are nonnegative, we have the following formulas:

For w = 1n, w = 1n - 10, w = 1n - 201 and w = 1n - 200, it is easy to count those extensions that fail to give prefix normal words. Similarly, for w = 10n - 21, w = 10n - 1 and w = 0n, counting the extensions that give prefix normal words gives the results in a straightforward way.

Let n be even. For [formula], note that ww' is prefix normal if and only if w' avoids 11. The number of such words is known to equal F(n + 2). For n odd, the argument is similar.

Experimental results about prefix normal words

We consider extensions of prefix normal words by a single symbol to the right. It turns out that this question has implications for the enumeration of prefix normal words.

We call a prefix normal word w extension-critical if w1 is not prefix normal. Let (n) denote the number of extension-critical words in [formula].

For n  ≤  1 we have

[formula]

From this it follows that

[formula]

From Theorem [\ref=thm:lowBound] we have:

For n going to infinity, lim  inf (n) / (n)  =  0.

We conjecture that in fact the ratio of extension-critical words converges to 0. We study the behavior of (n) / p(n) for n  ≤  49. The left plot in Fig. [\ref=figCrit] shows the ratio of extension-critical words for n  ≤  49. These data support the conjecture that the ratio tends to 0. Interestingly, the values decrease monotonically for both odd and even values, but we have (n + 1) / (n + 1)  >  (n) / (n) for even n. We were unable to find an explanation for this.

The right plot in Fig. [\ref=figCrit] shows the ratio of extension-critical words multiplied by n /  ln n. Apart from a few initial data points, the values for even n increase monotonically and the values for odd n decrease monotonically, and the values for odd n stay above those for even n.

Based on empirical evidence, we conjecture the following:

[formula]

Note that the second estimate follows from the first one by [\eqref=eq:critProduct].

Prefix Normal Games

Variant 1: Prefix normal game starting from empty positions. See Introduction.

For n  ≥  7 Bob has a winning strategy in the game starting from empty positions.

Variant 2: Prefix normal game with blocks. The game is played as follows. Now a block length of 2k is also specified, and we require that 2k divides n. The first 4k symbols are set to 1 before the game starts (in order to give Alice a fair chance). Divide the remaining empty positions into blocks of length 2k. Then Bob starts by picking a block with empty positions, and setting half of the positions of the block arbitrarily. Alice moves next and she sets the remaining k positions in the same block as she wants. Now this block is completely filled. Then Bob picks another block, fills in half of it, etc. Iterate this process until every position is filled in.

Alice has a winning strategy in the game with blocks, for any k  ≥  1.

Alice can always achieve that the current block contains exactly k 1s and k 0s. Now consider a substring v of length m of the word w = 14ku that is obtained in the end. We have to show that the prefix of the same length has at least as many 1s. Clearly, only m  ≥  4k has to be considered, and we can also assume that v starts after position 4k. The substring v contains some 2k-blocks in full, and some others partially. Let [formula], then [formula], while the number of 1s in the prefix of length m is at least [formula], as claimed.

As a corollary, we can prove the lower bound in Theorem [\ref=thm:lowBound].

(of Theorem [\ref=thm:lowBound]). There are at least as many prefix normal words of length n as there are distinct words resulting after a game with blocks that Alice has won using the above strategy. Note that with this strategy, each block has exactly k many 0s and Bob is free to choose their positions within the block. Moreover, for different choices of 0-positions by Bob, the resulting words will be different. So overall, Bob can achieve at least [formula] different outcomes. If we set [formula], and note that for 2k not dividing n, we can use (n)  ≥  (⌊n / 2k⌋  ·  2k), then we obtain: [formula] and the statement follows.

Construction and testing algorithms

In this section, for strings w  ≠  1n, we use the notation w = 1s0tγ, with s  ≥  0,t > 0 and [formula]. Note that this notation is unique. We call 1s0t the critical prefix of w.

A mechanical algorithm for computing the prefix normal forms

We now present a mechanical algorithm for computing the prefix normal form of a word w. It uses a new algorithm technique we refer to as sandy beach technique, a technique that we think will be useful for many other similar problems.

First observe that if you draw your word w as in Fig. [\ref=fig:esempio], then the Parikh set of w will be the region spanned by drawing all the suffixes of w starting from the origin. As we know, the prefix normal forms of w will be the upper and the lower contour of the Parikh set, respectively. This leads to the following algorithm, that we can implement in any sand beach--for example, Lipari's Canneto (Fig. [\ref=fig:zollstock]).

Take a folding ruler (see Fig. [\ref=fig:zollstock]) and fold it in the form of your word. Now designate an origin in the sand. Put the folding ruler in the sand so that its beginning coincides with the origin. Next, move it backwards in the sand such that the position at the beginning of the (n - 1)-length suffix coincides with the origin; then with the next shorter suffix and so on, until the right end of the folding ruler reaches the origin. The traced area to the right of the origin is the Parikh set of w, and its top and bottom boundaries, the prefix normal forms of w (that you can save by taking a photo).

Analysis: The algorithm requires a quadratic amount of sand, but can outperform existing ones in running time if implemented by a very fast person.

Testing algorithm

It can be tested easily in O(n2) time if a word is prefix normal, by computing its F-function and comparing it to its prefixes; several other quadratic time tests were presented in [\cite=FL11]. Currently, the fastest algorithms for computing F run in worst-case [formula] time (references in the Introduction). Here we present another algorithm, which, although O(n2) in the worst-case, we believe could well outperform other algorithms when iterated on prefixes of increasing length.

Given a word w of length n and density d, w = 1s0tγ. Since the cases d = 0,n are trivial, we assume 0 < d < n. Notice that, then, in order for w to be prefix normal, s > 0 must hold. Now build a sequence of words [formula], where v0 = 1d0n - d and vd - s = w, in the following way: for every i, vi + 1 is obtained from vi by swapping the positions d - i and j, where j is the rightmost mismatch between vi and w. So for example, if w = 110100101, we have the following sequence of words: 111110000, 111100001, 111000101, 110100101.

The following lemma follows straightforwardly from the results of [\cite=pn1]:

Given w∈Σn with |w|1 = d, and the sequence [formula], we have that w is prefix normal if and only if every vi is.

Moreover, as was shown there, it can be checked efficiently whether these strings are prefix normal. We summarize in the following lemma, and give a proof sketch and an example.

Given a prefix normal word w = 1s0tγ. Let w' = 1s - 10i10t - iγ, then it can be decided in linear time whether w' is prefix normal.

We will give an intuition via a picture, see Fig. [\ref=fig:proof_childpnf]. If w' is not prefix normal, then there must be a k and a substring u of length k s.t. u has more 1s than the prefix of length k. It can be shown that it suffices to check this for one value of k only, namely for k = s - 1 + t, the length of the critical prefix length of w'. The number of 1s in this prefix is s - 1. Now if such a u exists, then it is either a substring of γ, in which case F(γ,k) > s - 1; or it is a substring which contains the position of the newly swapped 1 (both in grey in the third line). This latter case can be checked by computing the number of 1s in the prefix of the appropriate length of γ (in slightly darker grey) and checking whether it is greater than s - 2.

Thus, for [formula], we test if vi + 1 is prefix normal. If at some point, we receive a negative answer, then the test returns NO, otherwise it returns YES. Additional data structures for the algorithm are the F-function, which is updated to the current suffix following the critical prefix, up to the length of the next critical prefix (in linear time); and a variable z containing the number of 1s in the appropriate length prefix of γ.

Example: We test whether the word w = 110101101100100 is prefix normal.

[formula]

At this point we have z  +  1  =  4  >  3 = s - 1 and therefore, we stop. Indeed, we can see that the next word to be generated, v6  =  1110001101100100 is not be prefix normal, since it has a substring of length 5 with 4 ones, but the prefix of length 5 has only 3 ones.

Analysis: The running time of the algorithm is [formula] in the worst case, where the pi are the positions of the 1s in w, so in the worst case quadratic.

Iterating version. The algorithm tests a condition on the suffixes starting at the 1s, in increasing order of length, and compares them to a prefix where the remaining 1s but one are in a block at the beginning. This implies that for some w which are not prefix normal, e.g. w = 101n,n > 1, the algorithm will stop very late, even though it is easy to see that the word is not prefix normal. This problem can be eliminated by running some linear time checks on the word first; the power of this approach will be demonstrated in the next section.

Since we know that a word w is prefix normal iff every prefix of w is, we have that a word which is not prefix normal has a shortest non-prefix-normal prefix. We therefore adapt the algorithm in order to test the prefix normality on the prefixes of w of length powers of 2, in increasing order. In the worst case, we apply the algorithm log n times. Since the test on the prefix of length 2i takes O(22i) time, we have an overall [formula] worst case running time, so no worse than the original algorithm.

We believe that our algorithm will perform well on strings which are "close to prefix normal" in the sense that they have long prefix normal prefixes, or they have passed the filters, i.e. that it will be expected strongly subquadratic, or even linear, time even on these strings.

Membership testing with linear time filters

In this section, we provide a two-phase membership tester for prefix normal words. Experimental evidence indicates that on average its running time is O(n).

Suppose there is an O(n) test that can be used to reject 2n  -  2n / n of the binary strings outright (Phase I). For the remaining 2n / n strings, apply the worst case O(n2) algorithm (Phase II). This gives an O(n)-amortized time algorithm when taken over all 2n strings. For such a two-phase approach, let M denote the strings not rejected by the first phase. We are interested in the ratio nM  /  2n. As n grows, if it appears as though this ratio is bounded by a constant, then we would conjecture that such a membership tester runs in O(n) average case time.

First we try a trivial O(n) test: a string will not be prefix-normal if the longest substring of 1s is not at the prefix. Applying this test as the first phase, the resulting ratios for some increasing values of n are given in Table [\ref=tab:ratios](a). Since the ratios are increasing as n increases, we require a more advanced rejection test.

The next attempt uses a more compact run-length representation for w. Let w be represented by a series of c blocks, which are maximal substrings of the form 1*0*. Each block Bi is composed of two integers (si,ti) representing the number of 1s and 0s respectively. For example, the string 11100101011100110 can be represented by B1B2B3B4B5  =  (3,2)(1,1)(1,1)(3,2)(2,1). Such a representation can easily be found in O(n) time. A word w will not be prefix normal word if it contains a substring of the form 1i0j1k such that i + j + k  ≤  s1  +  t1 and i + k  >  s1 (the substring is no longer, yet has more 1s than the critical prefix). Thus, a word will not be prefix normal, if for some 2  ≤  i  ≤  c:

[formula]

By applying this additional test in our first phase, we obtain algorithm MemberPN(w), consisting of the two rejection tests, followed by any simple quadratic time algorithm.

The ratios that result from this algorithm are given in Table [\ref=tab:ratios](b). Since the ratios are decreasing as n increases, we make the following conjecture.

The membership tester MemberPN(w) for prefix normal words in average case O(n)-time.

We note that there are several other trivial rejection tests that run in O(n) time, however these two were sufficient to obtain our desired experimental results.

Acknowledgements. We thank Ferdinando Cicalese who pointed us to [\cite=MelBrooks] and thus contributed to the fun part of our paper.