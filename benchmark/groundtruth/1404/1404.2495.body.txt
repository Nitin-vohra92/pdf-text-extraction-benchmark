Corrolary Theorem Proposition Definition Conjecture Fact

Simple scheme for encoding and decoding a qubit in unknown state for various topological codes

Introduction

Interaction of a quantum system with environment leads to decoherence of its state. Protecting quantum state from decoherence can be regarded as the simplest quantum computation protocol. The so called threshold theorem [\cite=Aharonov98] states that every quantum computation can be realised with arbitrary precision provided the error probability is below some threshold value, with polylogarithmic overhead in space and time. The assumption here is that the noise is local in a sense that error correlations decay exponentially both in space and time. Ref. [\cite=Alicki13] presents a recent review of the Hamiltonian open system description of fault tolerant schemes.

Entanglement distribution in noisy quantum networks would allow for realisation of quantum cryptography tasks [\cite=Bennett84] [\cite=Ekert91] and distributed quantum computation [\cite=Grover97]. Quantum repeaters idea [\cite=Dur99] [\cite=repeatersPRL] was one of the first approaches to entanglement distribution. It relies on application of entanglement purification protocol and entanglement swapping. The latter requires storage of quantum states in every node, with size of quantum memory scaling logarithmically with size of the network. Recently, a new idea for entanglement distribution that does not require local quantum memory was proposed. It is based on the isomorphism between storing quantum information in D-dimensional quantum network and establishing quantum communication in network of dimension D + 1 [\cite=perseguers-2008-78]. Namely, possibility of encoding, storing and decoding an unknown state of a physical qubit into D-dimensional network, implies possibility of communication over long distances using D + 1-dimensional network. Actually, the task of protecting qubit is of independent interest on its own.

Stabilizer formalism [\cite=Gottesman97], analogical to construction of classical binary linear codes, offers a framework for description of many codes granting protection in the sense of threshold theorem. Quantum information is stored here in the codespace of total Hilbert space . This logical subspace is spanned by states that remain invariant under action of operators belonging to a stabilizer group that defines the code. In topological stabilizer codes, stabilizer group can be generated by local operators, which implies that logical subspace is protected from the local noise. One of the example of topological stabilizer code is a surface Kitaev code [\cite=kitaevft], which uses topological properties (the fact that operators acting on the logical subspace form loops on the physical space that are uncontractible to a point) to provide protection whenever the qubit error rate is below some threshold value. For longer logical operator lines (i.e. for bigger code) one has lower logical error rate. In [\cite=kitajewpreskill-ftmem] [\cite=Horsman12], authors present a way of encoding an unknown state into the Kitaev topological code by gradually enlarging the system of code qubits in a series of local CNOT operations. As the logical state of the code is vulnerable to decoherence for small code dimensions, this procedure requires fast qubit initialisation and measurements. Elaborated methods for creating maximally entanglement pairs between distant nodes of a 3-dimensional cluster state network were considered in [\cite=raussendorf-2005-71] [\cite=Raussendorf06] [\cite=perseguers2009-fid]. All these methods rely on measurements and operations actively performed on the code structure. Recently, Dengis, König, and Pastawski proposed a scheme for dissipative state encoding into a Kitaev code, assuming Markovianity of bath [\cite=dengis14].

In [\cite=grudka12] a simple, active single shot scheme (which does not require gradual enlarging) for state encoding into a planar Kitaev code was proposed and it was shown to be equivalent to state teleportation into a code via the entangled pair of virtual qubits existing within the total Hilbert space. The protocol leads to lower bound on storing fidelity in large code size limit: 1 - O(p), with p being the probability of bit-flip, phase-flip error as well as preparation and syndrome measurement errors in single time step. This enlightens the use of Kitaev planar code as quantum memory able to store an unknown state. Additionally, it provides an analytical lower bound for fidelity of quantum communication in 3D by the aforementioned isomorphism [\cite=perseguers-2008-78].

There exists a large variety of code constructions for quantum memory, focusing on different objectives. Among others, Kitaev toric code can store two qubits (in contrast with one qubit in its planar version) while keeping high threshold value [\cite=kitajewpreskill-ftmem]. Planar codes with holes are able to store multiple qubits and enable CNOT operations by braiding [\cite=Raussendorf07] [\cite=Bombin09]. Topological subsystem codes [\cite=Bravyi12] aim at increasing the locality in stabilizer measurements, while Haah in [\cite=Haah11] introduces a three-dimensional topological code with no logical operators forming strings in physical code space.

In this paper we provide simple single shot protocol for encoding and decoding an unknown qubit state for CSS codes. In the case when logical operators XL and ZL cross at a single physical qubit, our procedure requires preparation of qubits in a product state, and similarly, the final measurement is performed in a product basis. For CSS codes with logical operators crossing on larger number of physical qubits, it relies on preparation/measurement of entangled pairs of qubits. This can be performed locally if qubits where logical operators cross are situated on adjacent vertices of the lattice (we illustrate it using Haah code [\cite=Haah11]).

Our general procedure works in the case of ideal preparation and measurements. However it can be adapted to the case of non-ideal preparation and measurements for several topological codes: Kitaev toric code, planar codes with holes [\cite=Raussendorf07] [\cite=Bombin09] and topological subsystem codes [\cite=Bravyi12]. We present it on the example of topological subsystem code. We show that in a noisy preparation and measurement scenario the bound on the error for encoding/storage/decoding process, that uses our scheme, is of order of noise acting on a single physical qubit per time step, in a large code size limit. We assume that the noise is local and take into account bit-flip and phase-flip storage, preparation and syndrome measurement errors.

The article is organised as follows. In Section II we present a review of a stabilizer formalism and introduce the general intuition behind the encoding/decoding scheme for a subgroup of stabilizer codes, namely CSS codes. In Section III we proceed with detailed description of the noiseless procedure for Kitaev topological code on torus, planar code with holes and subsystem topological code. We also consider the code without logical string operators introduced by Haah. In Section IV we describe in details noisy scenario for subsystem topological code and derive analytical upper bound on the error for this code. We conclude in Section V.

Encoding/decoding procedure for CSS codes without noise

In this section we present the procedure of encoding and decoding qubit (or several qubits) for CSS codes, and show that it works perfectly when the noise is completely absent (i.e. preparation and measurements are ideal and there are no storage errors). Before introducing the procedure, we briefly recapitulate the stabilizer formalism [\cite=Gottesman97] and the notion of CSS codes.

CSS codes. The logical codespace Hlog, i.e. the subspace of the Hilbert space [formula] of N qubits, with i-th qubit defined on Hilbert space Hi (dimHi = 2), is spanned by eigenvectors with eigenvalue 1 of the stabilizer group elements S: [formula]. Here S is an abelian subgroup of Pauli group PN such that [formula], where I is an identity operator on Hsystem, and PN is generated by {σAi}, where bottom index indicates particular qubit [formula], upper index [formula] describes one of the Pauli matrices given by [formula], [formula] and [formula] and [formula]. G(S), generator of S, can always be found to be the set of hermitian mutually commuting operators from the Pauli group PN. Logical operators of the code are those operators from PN which commute with all operators from G(S), but are not generated by them. Because S is abelian, logical operators are defined modulo G(S). If we denote by N - |G(S)| = D, where |G(S)| is the number of elements of G(S), then we can write dimHlog = 2D and [formula]. The set of operators commuting with S is [formula]. ZL,i,XL,i create a pair of complementary observables (logical operators) acting on HL,i, i.e. i-th logical qubit subsystem of Hlog ( dimHL,i=2). They obey the following commutation and anticommutation relations: ZL,iXL,i =  - XL,iZL,i and = 0 for i  ≠  j as well as = 0 and = 0 for arbitrary i and j.

We now consider one of N physical qubits which is labelled by index i∈[null]. Without loss of generality we assume that it is in a αi|0〉i  +  βi|1〉i state (where {|0〉i,|1〉i} is the set of eigenvectors of Zi), i.e. it is non entangled with other qubits. We define encoding i-th qubit into the i-th logical qubit described on system HL,i as a process after which the i-th logical qubit is in the state |ΨLi〉  =  αi|0〉L,i  +  βi|1〉L,i, where {|0〉L,i,|1〉L,i} is the set of eigenvectors of a logical operator ZL,i on subsystem HL,i. We define decoding as reversed process.

Because the fidelity of quantum process depends only on the outcomes of measurements on two complementary sets of input states [\cite=hofmann2004-fidelity], to prove the correctness of encoding/decoding procedure it is enough to show that it performs a mapping between the eigenstates of Xi, Zi (acting on Hi) and XL,i, ZL,i (acting on HL,i), respectively.

The Calderbank-Shor-Steane (CSS) codes [\cite=Shor95] [\cite=Steane96] [\cite=Calderbank96] are stabilizer codes that are characterised by the fact that their generator contains operators from PN that are only a tensor product of identity operators I and either X or Z Pauli operators. This implies that logical operators are also of this form, therefore nontrivial elements of ZL,i involve only Z operators, while nontrivial elements of XL,i are only given by X Pauli operators. The anticommutation relation ZL,iXL,i =  - XL,iZL,i is provided by the fact that ZL,i and XL,i cross on the odd number of physical qubits (act nontrivially on those qubits). A very useful property of CSS codes is that correction of phase errors is decoupled from correction of bit errors, so that one can consider them separately.

Logical operators crossing at a single qubit. Let us now present a general idea for encoding a state into a subsystem HL,i of a CSS stabilizer code, where ZL,i and XL,i cross at a single point.

We select Hi arbitrarily and identify the corresponding vertex of the lattice with an intersection point of logical operators (Fig.[\ref=logical_operators](a)). Using the fact that in CSS codes ZL,i (XL,i) is a tensor product of Z (X) single qubit operators and identities, we make the parity of operators ZL,i (XL,i) dependent only on the state of the i-th physical qubit. To this end we prepare all other qubits on which ZL,i (XL,i) acts nontrivially (labelled here by k (l)) in eigenstates associated with + 1 eigenvalues of Zk (Xl). Since we assumed that ZL,i and XL,i operators cross at a single point, preparing procedures are independent. We will use the convention: Zi|0〉i =  + |0〉i, Zi|1〉i =  - |1〉i, Xi| + 〉i =  + | + 〉i, Xi| - 〉i =  - | - 〉i. Remaining qubits (i.e. those on which logical operators ZL,i and XL,i act trivially) are prepared in such a way that qubits on which ZL,i (XL,i) acts nontrivially are surrounded by qubits in |0〉 (| + 〉) states.

In order to drive a system state into a subspace Hlog, we measure stabilizer generators and join those of Z-type (X-type) that gave outcome - 1 by chains of X (Z) operators. Chains of X (Z) that cross logical operators ZL,i (XL,i) change their parity. However, as we can track the number of times it happens, we can revert this parity change by performing additional XL,i (ZL,i) operation whenever this number is odd. Moreover, in specific cases of CSS codes considered in this paper it happens that the matching can always be performed in a way that does not affect the parity of logical operators and no additional corrections are needed at all. Therefore, the desired mapping |0〉i  →  |0〉L,i, |1〉i  →  |1〉L,i, | + 〉i  →  | + 〉L,i, | - 〉i  →  | - 〉L,i is realised, where |0〉L,i, |1〉L,i, | + 〉L,i, | - 〉L,i are eigenvectors of logical operators ZL,i, XL,i.

Decoding procedure of a logical qubit stored within HL,i logical subspace of CSS code, with ZL,i, XL,i logical operators crossing at a single physical qubit i, consists of performing single qubit measurement in Zk (Xl) basis on all the qubits where ZL,i (XL,i) is nontrivially defined, except for the i-th physical qubit (Fig.[\ref=logical_operators](a)). From those measurements the parity of truncated operator ZT,i (XT,i) is calculated, where truncated operators are analogous to logical operators ZL,i and XL,i, with the only difference that they act on i-th qubit trivially. If computed parity is odd, an operator Xi (Zi) is applied to the qubit defined on Hi. This performs a demanded mapping |0〉L,i  →  |0〉i, |1〉L,i  →  |1〉i, | + 〉L,i  →  | + 〉i, | - 〉L,i  →  | - 〉i.

Logical operators crossing on odd number of qubits. Below we present an extension of the encoding/decoding procedure to topological stabilizer CSS codes where logical operators cross at more than one qubit. This case is illustrated schematically in Fig.[\ref=logical_operators](b), where ZL,i, XL,i operators act nontrivially on line of qubits. However, the following schemes are applicable to codes with arbitrary structure of logical operators. In addition, if logical operators ZL,i and XL,i cross at neighbouring qubits, then our encoding will be local. This is the case for Haah code [\cite=Haah11], where ZL,i, XL,i are nontrivially defined on surfaces of 3-dimensional rectangular lattice, with every vertex occupied by two qubits. To our best knowledge, no encoding scheme applicable to important class of Haah codes was proposed so far.

The first step of the encoding procedure for codes with logical operators crossing at a single physical qubit was to make the parity of ZL,i, XL,i dependent only on a state of physical qubit we want to encode. This was achieved by putting that qubit on the intersection of logical operators and preparing all other qubits k, on which ZL,i (XL,i) acts nontrivially, in |0〉k (| + 〉k) states, stabilised by Zk (Xk). This was crucial for the state of N-qubit system to be an eigenstate of ±  ZL,i and ±  XL,i, with signs dependent only on the sign of operators ±  Zi and ±  Xi, respectively, that were stabilising the i-th qubit.

Similarly we treat the case when logical operators cross at larger number of physical qubits. By (i,k) we denote qubits on which at least one of logical operators ZL,i, XL,i acts nontrivially. We choose a qubit to be encoded (i,l) as one of the qubits at intersection points. As before, we prepare all physical qubits on which only one logical operator acts nontrivially in the appropriate eigenstate of single qubit Pauli operators Zi,k (for ZL,i) and Xi,k (for XL,i). Even number of qubits on which both logical operators act nontrivially (not taking here into account the (i,l) qubit) can always be divided into pairs consisting of qubits (i,j1) and (i,j2) that are prepared in eigenstates of [formula] and [formula] corresponding to eigenvalues 1, i.e. maximally entangled states [formula]. Note that these operators commute. Such preparation scheme makes the parity of ZL,i (XL,i) dependent only on the eigenvalue of Zi,l (Xi,l), as required. We drive the state of the system into Hlog by performing a sequence of measurements and applying appropriate corrections (bit-flips and phase-flips operations) that either do not change the parity of logical operators (due to obeyed commutation relations) or change the parity (which can be fixed by applying additional logical operator to the code, as explained before).

Decoding procedure relies on measuring the parity of truncated operators ZT,i and XT,i. In case of codes with logical operators crossing at one qubit i, the parity of truncated operators can be calculated from the measurements of single qubit Pauli operators, as there is no qubit k enforcing anticommutation relation of Zk and Xk measurements. Decoding procedure for codes with logical operators crossing at larger number of qubits relies on the same idea for solving the noncommutativity problem as the encoding one: we divide an even number of qubits on which both truncated operators act nontrivially, and perform commuting measurements of [formula] and [formula]. After the parity of truncated logical operators is calculated, the (i,l) qubit is flipped by Xi,l (Zi,l) if the parity of ZT,i (XT,i) is odd.

As said above, our encoding/decoding schemes rely on local entanglement preparation and measurements for every code with intersection points of logical operators situated on adjacent vertices of the lattice, which is the case of the Haah code.

Examples

Kitaev toric code

Below we investigate a topological code discovered by Kitaev [\cite=kitaevft] and developed in [\cite=kitajewpreskill-ftmem]. In the particular case of its planar version, the encoding procedure was already presented in [\cite=grudka12]. Using similar approach, we show here how to encode logical qubits in its toric architecture.

Code geometric structure. Qubits are situated on links of a 2D lattice with periodic boundary conditions (see Fig. [\ref=kitaev](a)). Stabilizer group S is generated by local four-qubit observables of two types - the plaquette observables Zp and the star observables Xs:

[formula]

Here s stands for a star associated with a vertex and it denotes all links that touch the vertex, while p stands for plaquette and it denotes all links that form the plaquette. Logical qubit operators are defined by lines of Pauli operators uncontractible to the point. There are two types of them: XL,1, ZL,1 and XL,2, ZL,2, as there are two logical qubits encoded. XL,i and ZL,i cross at one point, which provides correct anticommutation relation. Let us assume that a distance of the code is an odd number. As depicted in Fig. [\ref=kitaev](b) we draw a dashed line from top left corner of the lattice to the bottom right one, and the other line from top right corner to bottom left one. On the intersection points of two dashed lines (due to periodic boundary conditions, there are two such points) we insert two physical qubits which we want to encode. We choose a pair of logical operators XL,i and ZL,i that meet at a point occupied by each inserted qubit. The remaining qubits on which given operator XL,i (ZL,i) acts nontrivially, are initialised in | + 〉 (|0〉) states. We prepare the remaining qubits surrounding XL,i (ZL,i) in | + 〉 (|0〉) states; qubits on the boundary dashed line are prepared in | + 〉 states, see Fig. [\ref=kitaev](b). This way we lock XL,i and ZL,i operators within | + 〉 and |0〉 states, respectively. This ends the stage of lattice preparation for the encoding procedure.

Encoding procedure. Now we are ready to encode two physical qubits into the code. Firstly, local stabilizer measurements are performed. Since Xs and Zp commute, we can consider the protection against phase-flip errors (detected by Xs measurements) and bit-flip errors (detected by Zp measurements), separately. We measure Xs (Zp) stabilizers associated with each vertex (plaquette) of the lattice and store defects, i.e nontrivial outcomes, in the vertices of the original lattice (virtual lattice, where plaquettes are replaced with stars). In case of noiseless syndrome measurement and state preparation, it is sufficient to measure only such Xs (Zp) stabilizers that include at least one green (blue) qubit since the outcomes of remaining syndrome measurements are already known. Afterwards, we remove X (Z)-defects by joining them by chains of Pauli operators Z (X) so that we do not cross lines of logical operators XL,i (ZL,i) that anticommute with the chains. It is always possible to find such paths due to periodic boundary conditions. This ensures that the parity of logical operators XL,i (ZL,i) stays intact throughout our encoding procedure. Since the initial parity is equal to the phase (bit) value of selected red qubit, we are guaranteed that states of the physical qubits are directly encoded as logical qubits (αi|0〉i  +  βi|1〉i  →  αi|0〉L,i  +  βi|1〉L,i). It can be shown that similarly one can encode three physical qubits into three dimensional version of a considered code, introduced in [\cite=kitajewpreskill-ftmem]. Different codes with periodic boundary conditions can be addressed in this manner as well. We note, that a similar idea of encoding into toric code (although using a different approach of dissipative encoding) was put forward independently in [\cite=dengis14].

Decoding procedure. For each logical qubit the same following procedure is applied. We measure the qubits arranged along the logical operator XL,i (ZL,i) in | + 〉, | - 〉 (|0〉, |1〉) basis, with exception of the red qubit. Next, the parity of outcomes is computed and if it is odd, phase (bit)-flip is applied to the red qubit. To prove that this procedure correctly decode a qubit let us focus on decoding the first logical qubit when the code is in the state |0〉L,1|ψ〉L,2. Then the parity of line where logical operator ZL,1 is defined is even. Hence, measuring all the qubits belonging to that line except for the red qubit 1 we obtain that the parity is equal to the bit of the red qubit. Since we wish to decode |0〉L,1 into |0〉 state we have to flip the red qubit, when obtained parity is odd. The explanation for |1〉L,1 and |  ±  〉L,1 encoded states is analogous.

Planar code with holes

Another example of the code suited to the proposed encoding/decoding scheme is the one proposed in [\cite=Raussendorf07] [\cite=Bombin09], enabling CNOT logical operations by braiding.

Code geometric structure. Stabilizer group is generated by 4-weight star and plaquette operators acting on a planar rectangular lattice as depicted in Fig. [\ref=holes](a). Qubits are placed on the links of the lattice. The code is deformed in such a way that in two regions stabilizers are not measured, i.e. holes are created, and these 4-weight star operators which interfere into the 'empty' region are turned into 3-weight star operators. Logical operators are such that XL is a chain of X Pauli operators joining the holes and ZL is ZL,1 or ZL,2, where ZL,i is any closed loop of Z Pauli operators around i-th hole. Let us encode one qubit into this code starting from a lattice arranged in the following way. Firstly, we have to choose the shape of logical operators ZL,1 and ZL,2 which will prevent from occurrence of infinitely many short nontrivial loops, which becomes relevant in a noisy scenario where such loops are dangerous. Hence, lines of logical operators have to be separated as much as possible and should meet at one point where we place a qubit to be encoded (the red one), see Fig. [\ref=holes](b). Operator XL joins two holes together and goes through a red qubit. Similarly to Kitaev toric code, here, lattice is divided into regions of qubits in | + 〉 states (marked in blue, which belong to XL operator and its neighbourhood confined by lines of logical ZL,1 or ZL,2 logical operators) and qubits in |0〉 states (remaining qubits outside the holes, marked in green).

Encoding procedure. If we want to encode an unknown state |Ψ〉  =  α|0〉  +  β|1〉 of a physical qubit into a logical qubit, we have to make sure that the parity measured by logical operators depends on this state (whichever ZL,i we choose as our logical phase flip operator). In order to drive the system into the codespace we measure all Zp and Xs stabilizers (because we are working in a noiseless scenario we may measure only such Zp (Xs) which touch at least one qubit in a | + 〉 (|0〉)) state and correct syndromes by joining them by chains of X (Z) Pauli operators. This can always be done without crossing the line of the logical operator anticommuting with the chain thus without changing its parity. From this we see that the state of logical qubit depends only on |Ψ〉, what fulfils the requirement of successful encoding.

Decoding procedure. Similarly to the example described above, all qubits lying along the logical operator XL (ZL) except for red one are measured in | + 〉, | - 〉 (|0〉, |1〉) basis. If parity calculated from the results is odd we have to apply phase (bit)-flip to the red qubit.

Bravyi subsystem code

As the next example we will use the structure of a surface subsystem topological CSS code introduced in [\cite=Bravyi12].

Code geometric structure. Fig. [\ref=bravyi](a) presents planar version of the code. Qubits are placed on the vertices of the lattice. Stabilizers are generated by pairs of 3-weight operators which are placed on the opposite side of every square frame and by 2-weight operators on the boundary. For L denoting the number of columns of the code structure, there are L2 + 1 logical qubits encoded. Bottom triangles of every square frame are logical operators of L2 logical qubits, and, by measuring them, we can make the measurement of 6-weight stabilizers local on the price of destroying L2 logical qubits, so that only one logical qubit is left for the encoding purposes. Its ZL (XL) operator is an arbitrary string of Z (X) operators joining bottom (left) boundary with its upper (right) counterpart. W.l.o.g. we consider ZL operator along left-most column and XL operator along bottom line. Their intersection point defines the vertex to host a physical qubit we want to encode. As usually, we prepare qubits in |0〉 (| + 〉) states along ZL (XL) operators. Additionally, we divide a lattice into two parts along a diagonal and surround the lines of qubits in |0〉 and | + 〉 states with qubits in |0〉 and | + 〉 states, respectively (see Fig. [\ref=bravyi](b)).

Encoding procedure. All X-type and Z-type syndrome measurements are performed and then corrections are applied. Perfect preparation of |0〉 and | + 〉 states ensures that the parity detected by logical operators depends only on the state of a physical qubit to be encoded as long as all syndromes are corrected by chains of X and Z Pauli operators toward right and upper boundary, respectively, so that logical operators ZL and XL remain untouched. Because all stabilizers in the code are represented by plaquettes (except for boundary stabilizers) we consider a graphical representation of the recovery procedure in a virtual lattice, where virtual edges are associated with code qubits and virtual vertices with plaquettes. Due to the structure of the code, we have to create separate virtual lattices for correcting bit and phase errors. Let us focus on correction of X-type errors. The scheme of single shot encoding in the virtual lattice is shown in the Fig. [\ref=bravyi_virtual](a). Thin lines represent the original lattice. Each diamond corresponds to 6-weight Z-type stabilizer and each circle to 2-weight Z-type boundary stabilizer. Virtual links marked in red, blue and green represent qubits prepared in |Ψ〉, | + 〉 and |0〉 states, respectively. After measuring 6-weight and 2-weight Z-stabilizers, we record measurement results on virtual nodes. Then we join the defects together or with one of the boundaries without touching a line of logical operator. Procedure for repairing phase errors goes similarly but virtual lattice is rotated by 90 degrees, see Fig. [\ref=bravyi_virtual](b).

Decoding procedure. All qubits situated in the line of logical operator XL (ZL) except for the red one are measured in | + 〉, | - 〉 (|0〉, |1〉) basis. If parity obtained from the results is odd, phase (bit)-flip has to be applied to the red qubit.

Haah code

All topological CSS codes considered above fulfil the requirement that logical operators XL and ZL cross only at one point. Hence, the proposed encoding/decoding scheme could be there directly implemented. Below we discuss how to modify the procedure in order to encode an unknown state into topological CSS codes where both logical operators act nontrivially on larger (odd) number of qubits. We will investigate the case of three dimensional topological stabilizer CSS code of [\cite=Haah11].

Code geometric structure. The code is constructed on a [formula] lattice with 2 physical qubits on its every vertex. Stabilizers act on every cube of the lattice and are generated by operators depicted in Fig. [\ref=haah](a). We denote by L the size of the lattice. For odd L in the range [formula] and L  ≠  15n, L  ≠  63n, where [formula], there are two logical qubits with logical operators acting on planes of physical qubits in the lattice. We show here the procedure for one of these qubits. Logical operators are given by [formula] and [formula], where planes of physical qubits are identified by vectors orthogonal to them. As logical operators cross on a line, the requirement that they intersect on a single point is not fulfiled. Below we show how to prepare a lattice in order to still be able to encode a qubit in unknown state into this code. Let's split a line of intersection between XL and ZL into 2 strings, first composed of first qubits from each pair lying on that line, and second composed of qubits on which both XL and ZL act nontrivially, i.e. second qubits from each pair. We substitute one qubit from second string by a physical qubit in a state |Ψ〉 we want to encode. The choice of its position on the string is such that it divides the odd number of qubits into regions consisted of even number of qubits. Inside these regions, qubits are grouped into pairs. Each pair is locally prepared in a singlet state [formula] (see Fig. [\ref=haah](b)). The rest of the protocol is similar to the original procedure: qubits on which only operator XL (ZL) acts nontrivially, are initialised in states | + 〉 (|0〉). Remaining qubits are prepared in such a way that areas of | + 〉 and |0〉 states surround the planes of logical operators from one or both sides (blue and green regions in Fig. [\ref=haah](b)).

Encoding procedure. Stabilizers depicted in Fig. [\ref=haah](a) are measured and then corrections are applied. During the correction stage, we have to count the number of times that anticommuting operators X (Z) touch the plane of logical operator ZL (XL). Another logical operator ZL (XL) is applied to the code whenever this number is odd. It is easy to show that the above scheme is a proper encoding procedure due to the stabilizer measurements and subsequent corrections. The following applications of logical operators do not take us out of the codespace. Preparation of singlet states, stabilised by pairs of XX and ZZ operators, as well as preparation of | + 〉 and |0〉 states on given positions, ensures that the parity measured by ZL and XL operators depends only on the physical state |Ψ〉 placed on the intersection line. As all stabilizers commute with logical operators, we cannot affect parity by stabilizer measurements. Applying proper logical operators triggered by the odd number of crossings of the logical operator by anticommuting correction chains ensures that the logical qubit of the code is in the |Ψ〉L state.

Decoding procedure. The crucial thing about decoding is to establish a parity on areas where logical operators are defined with exception of a place occupied by the red qubit. In previous cases, we performed single qubit measurements in X, Z eigenbasis within mentioned areas affected by XL, ZL, respectively. These anticommuting measurements were allowed since they were made on separate qubits (the only qubit which was under the influence of both logical operators was not measured). Here, as logical operators intersect on the line, and solely the one qubit lying on it is not measured, we need to modify our procedure in order to avoid performing noncommuting measurements on the rest of the qubits contained within that line. Instead of measuring single qubit operators we measure operators XiXi + 1 , ZiZi + 1 on neighboring qubits above and below red qubit. The remaining procedure goes as before, namely in places where either XL or ZL operator acts nontrivially, individual qubits are measured in X or Z eigenbasis, then the parity of truncated logical operators is computed. When the obtained parity is odd, phase or bit-flip has to be applied to the red qubit.

Encoding/decoding procedure in a presence of noise

In this section, we consider a noisy scenario, where qubits are subjected to bit-flip and phase-flip errors (while being stored and prepared) and where measurements can be faulty. Such noisy syndrome measurement is modelled by flipping the ideal measurement outcome with some probability. We assume that probabilities of a bit-flip, phase-flip and syndrome measurement errors are equal to p. The general idea is to prepare all qubits as described in Section III, measure Xs and Zp stabilizers many times in the area confined by the whole lattice (except for the last time step where X and Z operators are measured), store all error syndromes and use them to apply error correcting procedure. Below we describe it in detail for Bravyi subsystem topological code. One can perform similar analysis for Kitaev toric code and defected lattice code. However, we have not been able to find a noisy scheme for Haah code.

Since the schemes for protecting quantum information from bit-flip and phase-flip errors are considered in the separate virtual lattices (Fig. [\ref=bravyi_virtual](a) and Fig. [\ref=bravyi_virtual](b)), we focus on phase-flip errors. The reasoning for bit-flip errors is similar. Our encoding/storage/decoding scheme which protects against phase-flip errors can be graphically represented on the 3D lattice. Each horizontal plane corresponds to a lattice of qubits at consecutive time steps k = 0,1,2...T, see Fig. [\ref=bravyi_3D]. Syndrome measurements are performed on qubits placed on each horizontal plane, and their outcomes are stored in vertical links. Bottom plane is prepared identically to the 2D virtual lattice considered in the case of noiseless scenario (Fig. [\ref=bravyi_virtual](b)), i.e. there are two separate regions of qubits initialised in | + 〉 (marked in blue) and |0〉 (marked in green) states. A qubit in a |Ψin〉 state which we want to encode is chosen to be placed in the front left corner (black thick link in Fig. [\ref=bravyi_3D]). The top plane (k = T) is graphically divided into three parts: black, blue and green.

After preparation of a lattice, we measure Xs stabilizers in all time steps except the last one (we also measure Zp stabilizers but they are irrelevant when considering phase-flip errors). Squares and circles in Fig. [\ref=bravyi_3D] (see also Fig. [\ref=bravyi_virtual](b)) represent 6-weight and 2-weight Xs stabilizers, respectively. By red crosses we denote defects, i.e. nontrivial error syndromes in the first time step and changes of syndromes in all subsequent time steps. In the last time step T we measure X operator on each qubit in blue triangle (which corresponds to the bottom triangle where | + 〉 states were prepared) and Z operator on each qubit in green triangle (which corresponds to the bottom triangle where |0〉 states were prepared). Subsequently, a syndrome Xs is computed by classically multiplying the outcomes of single qubit measurements for vertices in top triangle marked in blue. Hence, for blue region we obtain ideal syndrome. For green region the syndrome is unknown. The consequences of that will be discussed later on.

The next step is to apply corrections. We use the following terminology. S indicates a set of links with nontrivial error syndrome - 1. Its boundary δS is determined by defects (red crosses), apart from the green region on the top slice. Links on which an actual error occurs compose a set of errors E (horizontal and vertical red thick lines in Fig. [\ref=bravyi_3D]). The boundary of E is associated with vertices that lie outside of top green region and on which syndrome changes or, in the case of k = 0 plane, is nontrivial. Namely, δE = δS, apart from the top green region. Clearly, there exist many hypothetical sets of errors E' that could lead to the same defects (δS). The most probable set (i.e. containing the shortest paths of errors due to a metric presented below) is denoted by Emin, see horizontal and vertical blue thick lines in Fig. [\ref=bravyi_3D]. Weights of links building a 3D lattice are given by a formula [formula] [\cite=kitajewpreskill-ftmem], where pi stands for the probability of error on the i-th qubit. For qubits in the green bottom triangle [formula], as they are prepared in |0〉 state, i.e. they are not prepared in eigenstate of X-type operators. Since within the green top triangle single-qubit measurements are performed in {|0〉,|1〉}) basis, also for that area we assign [formula]. Black qubit is exposed to storage error, thus pi = p. For qubits in the blue top triangle pi = p since they are subjected to preparation error. To qubits located in the blue bottom triangle we ascribe pi = p as single-qubit measurement gives erroneous outcome with probability p. For qubits in all other time slices pi = p due to storage error. Probability pi = p is also assigned to all vertical links as syndrome measurement gives there erroneous outcome with probability p. Given those weights we can determine Emin by minimising the sum of weights. If the set of actual errors E is the most probable one, then Emin = E.

To recover from Z-type errors we have to connect observed defects (by chains of Pauli operators Z) with each other or with one of the code boundaries. We recognise code boundaries as front and back vertical planes (geometrical boundaries) as well as green triangles (due to ascribed weights equal to 0 within these regions). In order to maximise a probability of successful correction, we annihilate defects along the shortest paths from the set Emin. Hence, a disjoint union S + Emin and also E + Emin have no boundary. Therefore, within E + Emin there are only closed or nontrivial paths.

In order to proceed to the decoding procedure, after determining the set Emin, we need to calculate a parity of a line belonging to the logical operator XL, excluding a black qubit at position n = 1. We pretend that the true error that occurred during storage process is given by Emin. Then the mentioned parity could have been modified by applying noncommuting corrections (Z operators) from the set Emin. To see if the parity was affected we make a projection of Emin on the k = T plane and count the number of times it crosses a curved line of logical operator. If this number is odd, parity was affected and has to be flipped. Afterwards, when the corrected parity of truncated logical operator XT is odd, we apply phase flip to the black qubit, obtaining ρout. Thus, after protecting the state for time T, it is possible to decode it.

If the true errors were just Emin, we would decode the initial state perfectly (up to the last flip, which is noisy). Even more: if E + Emin had an even number of nontrivial paths, we still would have such perfect decoding. Thus the recovery procedure is not successful when, as a result of applied corrections, we create an odd number of nontrivial paths in E + Emin set. This is due to the fact that such paths cross a logical operator XL an odd number of times, i.e. they change its parity. The probability of an error is bounded by the probability that the set E + Emin has a nontrivial path. In order to obtain upper bound on probability of erroneous encoding, storage and decoding of phase we overestimate the number of nontrivial paths of length l, multiply it by probability that a particular path of length l is in E + Emin, and sum over l. Let us choose the line of logical operator XL to be a curved front line in a virtual lattice (denoted in Fig. [\ref=bravyi_virtual](b) by thick black line for k = 0). Each nontrivial path or its projection on a plane k = T has to cross the logical operator in the slice k = T. Therefore, we take into account every path that starts at any point (n,k) on the front geometrical boundary and goes toward the opposite boundary, or top or bottom green regions (which are boundaries as well). Indices [formula] and k = 0,1,...,T enumerate points in space and time directions respectively. Fig. [\ref=bravyi_phase] shows bottom surface of the 3D code structure for k = 0. An odd number N denotes a distance of a code. Now we divide paths into two sets. The first set consists of nontrivial paths of length l = 1. There are 4 such paths which start at points (n,k) = (0,0),(1,0),(0,T),(1,T) and each path occurs with probability p. The second set consists of nontrivial paths of length l  ≥  2. At any point in front geometrical boundary can start at most 8l nontrivial paths of length l which are in the set E + Emin. The factor 8l comes from fact that once a path reaches a particular point it can go to no more than 8 other points. We note that not all lengths are allowed. More precisely at point (n,k) there can only start nontrivial path of length l  ≥   min (k + n,(T - k) + n). The probability that such a path is in E + Emin is [formula] [\cite=kitajewpreskill-ftmem]. Taking it all into account we can write the probability of failure as where [formula] and [formula] for p  ≤  0.0039. In the limit of large code size N  →    ∞   we obtain

[formula]

RHS of ([\ref=bound3]) was largely overestimated and decreases below 1 / 2 for p  ≤  0.000154. The bound for a case of bit encoding/decoding is slightly different:

[formula]

RHS of ([\ref=bound4]) was largely overestimated and decreases below 1 / 2 for [formula]. Hence the fidelity of the protected qubit is 1 - O(p) for small p.

Conclusions

In this paper we introduced a simple, single shot procedures for encoding/decoding an unknown state into/from logical subspace of CSS codes. The encoding procedure relies on preparing a system in a way that makes the parity of logical operators dependent only on the state of a selected qubit of the system, and on driving the state of the system into a logical subspace by sequence of operations that commute with logical operators.

For topological subsystem code [\cite=Bravyi12] we calculated lower bound on the fidelity of a process of encoding/storage/decoding of an unknown state under the assumption of presence of preparation and syndrome measurement error as well as local noise introducing phase and bit storage errors (we assumed that probability of each error is p). Noisy syndrome measurement was modelled by ideal measurement followed by classical error acting on the outcome with probability p. In the limit of large code size, the bound for the fidelity was found to be 1 - O(p). In a similar way one can obtain fidelity bounds for Kitaev code on a torus and planar code with holes.

In our analysis, we have assumed, that there is no back reaction from syndrome measurements to the code. For Kitaev planar surface code, Fowler et al. [\cite=fowler10] proposed modified measurement schemes aimed at avoiding the effect of back-action. The analysis, affected the value of the threshold, but not its existence. Similarly, we believe that the implementation of these ideas could lead to modification of the bound for fidelity of encoding/storing/decoding process obtained in this paper. However its existence should be not affected.

Proposed general encoding/decoding processes require entanglement preparation/measurement, hence it may be, in principle, nonlocal for some codes. However, when the qubits at which logical operators cross are situated on the adjacent vertices of the code structure, this can be achieved locally, as in the Haah code. For the latter code we have provided noiseless version, and we are leaving as an open question, how to encode unknown state into Haah code in presence of noise.

Acknowledgements

This work was supported by ERC Advanced Grant QOLAPS and National Science Centre project Maestro DEC-2011/02/A/ST2/00305. MH and PM acknowledge support of MNiSW Ideas-Plus Grant IdP2011000361. PM was supported by the International PhD Project "Physics of future quantum-based information technologies": grant MPD/2009-3/4 from Foundation for Polish Science.