=1

Coactive Learning for Locally Optimal Problem Solving

Introduction

This work is motivated by situations where a domain expert must solve a sequence of related problems. One way to reduce the expert's effort is for an automated solver to produce initial solutions that can then be improved, if necessary, by the expert with less effort than solving the problem from scratch. This requires that the solver has a good estimate of the expert's utility function, which is often unknown and must be learned through experience. This general notion of online learning from the improved solutions of an in situ expert is captured by the framework of coactive learning [\cite=DBLP:journals/corr/abs-1205-4213], [\cite=icml2013_raman13], [\cite=raman12], [\cite=ecml:raman13].

The current state-of-the-art in coactive learning generally assumes that the solver can either find a globally optimal solution (according to its current estimate of the utility function) to the problem, or at least a solution which can be proven to be at least α-close to the optimal solution (for example, using a greedy algorithm for a sub-modular utility function [\cite=raman12], [\cite=ecml:raman13]). It is also assumed that the expert can always improve the solution if there is a possible improvement.

Unfortunately in many planning and combinatorial optimization problems, neither of these assumptions is realistic. The current paper relaxes these assumptions by extending coactive learning to the cases where the system can only guarantee locally optimal solutions and the expert is only assumed to make a sequence of local improvements, but not required to return a locally optimal solution.

For example, consider a Traveling Salesperson Problem, where each edge of the graph is described by a number of numerical features, and the edge costs are known to be a linear combination of these features with unknown weights. We have an approximate solver which, for a given estimate of the edge-cost function, will give a reasonably good (but perhaps not optimal) solution to the TSP problem. The solver presents a candidate solution to an expert (who knows the actual cost function). The expert can either accept the solution or spend some effort making improvements to it. The more accurate the learner's estimate of the cost function, the less effort the expert needs to spend to adapt the candidate solution into one which is acceptable.

More generally, we assume that we have a planning or a combinatorial optimization problem, where finding a globally optimal solution for the problem is intractable, and where it is hard for an expert to do anything more than a sequence of local improvements to a candidate solution. We assume that we have a black-box solver which, for a given problem and current estimate of the cost function, will output a locally optimal solution. Assuming that the expert and the system have the same notion of 'locality', changes made by the expert will be very likely due to the estimate of the distance function being different from the actual distance function. With these assumptions, the expert feedback will allow the learner to improve its estimate of the proper cost function, eventually removing the need for the expert.

It is important to note that the local optimality assumptions of our framework strictly generalize those of prior coactive learning work, where the learner and the expert were assumed to be within a factor of α of the true optimal solution. Another important aspect our framework is that we allow the learner to observe the effort expended by the expert, or cost, when producing improvements. The learner can exploit this additional feedback to put more emphasis on mistakes that are more costly from the expert's perspective, ideally leading to a faster reduction of expert effort.

Perhaps the closest related work to ours is on learning trajectory preferences for robot manipulation [\cite=jainlearning]. In this work, the authors describe a coactive learning approach that learns a scoring function based on improvements made by experts to automatically generated trajectories of robot manipulation tasks. Our main contributions in relation to this work are to formalize coactive learning in the context of locally optimal planning and demonstrate better learning algorithms with tighter performance bounds by making them cost-sensitive.

In addition to introducing the generalized coactive learning framework, our other primary contribution is to propose and analyze the cumulative cost of simple online learning algorithms for linearly parameterized cost functions. In particular, we describe cost-insensitive and cost-sensitive variants of the Perceptron and Passive Aggressive (PA) learning algorithms. We empirically evaluate these algorithms on four different domains and show that, the cost-sensitive Perceptron tends to perform better than all others when there is noise in the data. Also, unlike in classification setting, here the perceptron algorithms perform better than the PA algorithms. One reason for this is that the PA algorithms aggressively correct for any new data, meaning that any amount of noise can degrade the performance significantly.

Problem Setup

Let X be the set of all problems in the domain of interest, e.g. a class of TSP graphs, and Y be the set of all possible problem solutions, e.g. possible tours. The quality of solutions is judged by the expert's utility function [formula] which gives the relative merit of a given candidate solution for a given problem.

For the purposes of learning we assume that the utility function can be well approximated by a linear function [formula]. Here [formula] is a real-valued feature function of problem-solution pairs and [formula] is a real-valued weight vector. In this work, we assume a bounded feature vector length: [formula].

A critical part of our coactive learning framework is the improvement of solutions by the expert. For this purpose we consider a set O of operators which can be used by the expert to transform a candidate solution into a different candidate solution: Oi∈O:〈x,y〉  →  〈x,y'〉. The specific operators are highly domain and user-interface dependent. For example, in a TSP application, the operators might allow for local modifications to a current tour.

We assume a black-box solver S:X  →  Y which can be parameterized by the utility function weight vector [formula] in order to optimize solutions according to Û. For many planning problems, including TSP, exactly optimizing Û will be intractable. Thus, for the purposes of our analysis we make the more realistic assumption that S is locally optimal with respect to Û and the set of expert operators O.

We can now specify our coactive learning protocol. The learner is presented with an arbitrary sequence of problems [formula] from X. Upon receiving each xt, the learner uses S to present the expert with a candidate solution yt based on its current utility estimate Û. The expert will then perform a sequence of operators [formula] to the solution as long as significant local improvements are possible according to the true utility function U. We formalize this as a second assumption: The constant κ reflects the minimum utility improvement required for the expert to go through the effort of applying an operator. Thus, according to this assumption the expert will monotonically improve a candidate solution until they are satisfied with it or they have reached diminishing returns for local improvements. The expert cost Ct for example xt is then equal to the number of operator applications, which reflects the amount of expert effort spent improving the candidate solution. The average cumulative cost [formula] quantifies the average effort of the expert over T steps. The goal of learning is to quickly diminish this cost.

We note that it is straightforward to generalize the framework to account for operator dependent costs.

Learning Algorithms

We consider online Perceptron-style algorithms that maintain a weight vector wt that is initialized to w0 = 0 and potentially updated after each training experience. At iteration t the learner presents the expert with solution S(xt) and observes the corresponding improvement operator sequence with cost Ct. Whenever Ct  >  0 our learning algorithms will adjust the weight vector in the direction of [formula].

Algorithm 1 gives the schema used by our learning algorithms for updating the weight vector after the interaction involving problem xt. In the tradition of the Perceptron, this update is passive in the sense that whenever Ct  =  0, meaning that the expert is satisfied with the solution produced, the weight vector is not altered. Our four algorithms differ only in the choices they make for the learning rate λt, which controls the magnitude of the weight update. Below we specify each of our four variants that are analyzed and empirically evaluated in the following sections.

Perceptron (PER) (λt  =  1). This instance of the algorithm corresponds to the classic Perceptron algorithm, which uses a uniform, cost-insensitive learning rate. This so-called preference perceptron algorithm was previously proposed for coactive learning, although its analysis was for their more restrictive assumption of global optimality [\cite=DBLP:journals/corr/abs-1205-4213].

Cost-Sensitive Perceptron (CSPER) (λt  =  Ct). Notice that the above Perceptron algorithm completely ignores the observed cost Ct. Intuitively, one would like to put more emphasis on examples where the cost is high, to potentially decrease the cumulative cost more rapidly. The Cost-Sensitive Perceptron (an online version of the perceptron introduced in [\cite=geibel2003perceptron]) takes the cost into account by simply allowing the learning rate to scale with the cost, in this case being equal to the cost. This is an approximation of what would happen if the original Perceptron update was applied Ct times per instance. This is similar to a standard approach to obtain an example-dependent cost-sensitive learner [\cite=zadrozny2003cost], where the probability of each example to be considered by the algorithm is proportional to the cost of misclassifying it. The algorithm presented here can be seen as a simplified online version of this.

Passive Aggressive (PA) ([formula]). The framework of PA algorithms has been well-studied in the context of more traditional online learning problems [\cite=crammer2006online] and has shown advantages compared to more traditional Perceptron updates. Here we consider whether the PA framework can show similar advantage in the context of coactive learning.

The PA update principle is to be passive, just as for the Perceptron algorithms. In addition, unlike the Perceptron, PA updates are aggressive in the sense that the weights are updated in a way that are guaranteed to correct the most recent mistake. In our coactive setting, this PA principle corresponds to minimizing the change to the weight vector while ensuring that the new vector assigns the improved solution y' a higher utility than yt. More formally:

[formula]

where M is a user specified target value for the margin. As in prior work [\cite=crammer2006online] the solution to this problem is easily derived via Lagrangian methods resulting in an update with [formula]. Note that either version of the Perceptron algorithm may either not correct the mistake, or update the weights much more than necessary to correct the mistake. In our experiments we set M = 1 throughout, noting that in the coactive learning setting the specific value of M only results in a different scaling of the weight vectors, without changing the behavior or the obtained costs.

Cost-Sensitive PA (CSPA) ([formula]). Since the margin M indicates how strongly an example influences the weight vector, a natural way to include the cost into the PA algorithm is by making the margin for an update equal to the cost. This approach effectively instantiates the idea of margin-scaling, e.g., as employed for structured prediction [\cite=Taskar2005learning], within the PA framework.

Cost Bounds

In this section we will present upper bounds on the average cost over time for all four algorithms presented in the previous section, in the realizable learning setting where the actual utility function is a linear function of the feature vector, represented by the weight vector [formula]. Since the cost is an integer, this effectively provides a bound on the number of examples where the expert is able to make any improvement on the solution.

The most similar prior analysis done for coactive learning focused on the Perceptron algorithm under the assumptions of global optimality. That analysis provided a bound on the average regret, rather than expert cost, where regret is the utility difference between the globally optimal solution and the learner's solution. Thus the novelty of our analysis is in directly bounding the expert cost, which is arguably more relevant, generalizing to the setting of local optimality, and analyzing a wider set of algorithms. The analysis in [\cite=DBLP:journals/corr/abs-1205-4213] also provides a lower bound on the average difference in utlity between the expert solution and initial solution of [formula]. For one of our algorithms, the upper bound on the cost we obtain is better than this, ([formula], indicating the difference between utility and cost. In fact, working out the specific example given as proof of the bound in [\cite=DBLP:journals/corr/abs-1205-4213] does provide a worst-case example, where the average cost is equal to the upper bound.

We will make one extra assumption for our theoretical analysis in addition to Assumptions 1 and 2 regarding local optimality. This assumption assures us that the learner will favor its own solution yt over the final locally optimal improvement provided by the expert. In practice, this can be guaranteed by observing the entire sequence of candidate solutions the expert goes through to obtain their final solution and taking the last candidate in the sequence where the learner disagrees with it being an improvement on the original candidate solution. There will be at least one such solution in the sequence because of the assumption of local optimality of the original candidate solution. Of course, this implies that the actual effort will potentially be larger than the effort until the presented solution was found. However, since any such case has a cost of at least 1, we still have an upper bound on the number of times where the expert is able to provide improvements on the solution by local changes.

We now state the main result providing cost bounds for our four algorithms. The proof can be found in appendix A.

We first observe that the cost-sensitive Perceptron bound decreases significantly faster than the other bounds, achieving a rate of O(1 / T) compared to [formula]. This implies that there is a constant bound on the summed costs. At least when comparing PER and CSPER, this shows the potential benefit of introducing cost into the learning process. Rather, we do not see such a rate reduction for cost-sensitive PA versus PA, which both achieve the same bound. It is not clear whether or not this is due to a loose analysis or is inherent in the algorithms. We do not yet have lower bounds on the rates of these algorithms, which would shed light on this issue. We do see however, that the bounds for both cost-sensitive algorithms hold for the average squared cost, which are strictly better bounds in our setting. Thus, even in the PA case, these results suggest that there is a potential advantage to introducing cost into learning.

Similar error bounds for the PER and CSPER algorithms in the case where there is noise in the expert's assessment, i.e. the expert might mis-estimate the relative utilities of the original solution and a suggested improvement by a term ξt are presented in appendix B.

Experiments

Experiments were performed in 4 different problem domains. All reported results are averages over 10 runs of the experiments. In the first 3 domains the utility function is a linear function of the features. In each domain, two different settings were tested. In one of the settings, there are 10 dimensions to the feature vectors. In the other, there are 11 features, but one of the features is only available to the expert, not to the solver. This adds noise to the experiment, and learning a weight vector which does not incur any cost is impossible. The coefficients of the expert weight vector were generated uniformly at random from

[formula]

distribution. The slack variable κ has value 0.1. Results are shown in figures [\ref=fig:TSP_0_1] and [\ref=fig:TSP_1_1]. As in the previous experiments, CSPER outperforms the other algorithms.

Multi-TSP Multi-TSP (mTSP) is a generalization of TSP to multiple salespersons. Given a set of 40 points, and 4 salespersons each with their own start and end locations among the given points, the goal is to determine a tour for each of the salespersons such that the total tour cost is minimized, and each point is visited exactly once by at least one salesperson.

For this experiment, a random set of 40 points are generated with their connecting edges described by feature vectors. The solver is a generalization of the TSP solver introduced in the previous section. It finds the tours for each salesperson incrementally, by finding a point that can be added to the existing tours with least cost. It repeats this strategy until no more points are left. It then applies 2-OPT adaptations to find a locally optimal solution. Similar to the TSP experiment, the expert uses 2-OPT heuristic to improve tours.

Results are shown in figures [\ref=fig:mTSP_0_1] and [\ref=fig:mTSP_1_1]. For the noisy setting, CSPER clearly outperforms the other algorithms. For the settings without noise, it performs worst, however. One possible explanation is that it focuses too much on the first few data points (where costs are high), relative to later points. The regular perceptron does not have this behavior, and results for this algorithm are good in all the settings.

Learning to Rank Dataset A final experiment was performed using the Yahoo! Learning to Rank dataset [\cite=LTRC], a real-world dataset consisting of web-based queries and lists of documents which were returned for those queries. Human experts labeled the documents with scores from 0 to 4 according to relevance to the query. All documents are described by a 700-dimensional feature vector. The learner sorts all documents according to decreasing estimated utility. The expert then iterates over this list, exchanging the order of two subsequent elements if the latter one is substantially better than the first (a score difference of 2 or more). The effort is the number of such exchanges until no such exchanges are possible. All reported results are averages over 10 random permutations of the original dataset.

Results are shown in figure [\ref=fig:webscope_raw] (notice the linear scale on the Y-axis). The classic perceptron algorithm performs best, with CSPER second-best. The relatively poor performance of the PA-based algorithms can be easily explained by the noise in the dataset. Since the PA algorithms aggressively correct the last observed error, any amount of noise could have a potentially disastrous effect. Note that CSPER does not perform as well as in most of the other experiments. One possible reason for this is that, as in the noise-free multi-TSP setting, the effort for the first few examples was large, resulting in a large jump in the weight vector. Subsequent costs are much smaller, which means it takes longer to fine-tune the weight vector. To test this, the experiment was repeated using an upper bound on the effort the expert was willing to make. For each example, a random integer between 5 and 15 was generated as the maximum "budget" for the expert. Results are shown in Figure [\ref=fig:webscope_lim] (notice the linear scale on the Y-axis). It is clear that this bound on the maximum cost greatly benefits the CSPER algorithm, which now only performs slightly worse than the perceptron.

Conclusions

In this paper, a novel problem statement for coactive learning was introduced. The main difference with existing work on coactive learning is that the problems are assumed to be so hard that finding the globally optimal solution is intractable, and an expert can be expected to only make small, local changes to a solution. We assume that there exist locally optimal solvers that can provide high-quality solutions when having an accurate estimate of the expert's utility function.

Four algorithms were presented for this task. Since the objective is to minimize the effort spent to improve the candidate solutions, two of the algorithms directly take this cost into account in their update functions. Theoretical bounds on the average cost for the four algorithms were shown, where the cost-sensitive perceptron algorithm was shown to have a much stronger bound. Empirically it was verified that in most settings, the cost-sensitive versions of the algorithms outperform their cost-insensitive versions. The cost-sensitive perceptron performs best in most datasets, specifically when noise was present. However, in some cases it was observed that cost sensitivity hurt performance in cases where early high-cost problems significantly alter the weight vector. Our empirical results suggest that bounding the maximum change in weight vector can help in these cases. This leaves an open question of how to most robustly and effectively take cost into account in the co-active learning setting.

Our final empirical observation was that the Passive Aggressive algorithms perform the worst, which is in contrast to such algorithms in the context of online classification. The reason for this might be that the algorithms are too aggressive in their updates, effectively overfitting the last seen example. This leads to some possible directions for future work including investigation of (mini-)batch learning algorithms and versions of the PA algorithm which limit the aggressiveness [\cite=crammer2006online].

Appendix A: Proof of Theorem 1

Each bound is derived using a similar strategy in the tradition of Perceptron-style analysis. The proof ignores all steps where no update occurs since these have cost equal to 0 and would only reduce the average cost. First, we show an upper bound on [formula]. Then, for each algorithm, we provide a lower bound on [formula] in terms of the sum of costs [formula] or sum of squared costs [formula].

Using the general update [formula], we get the following bound for ||wT + 1||2: [formula] [formula] [formula] where the last step follows by induction. The second step follows from Assumption [\ref=assum:localopt].

Then, we use the Cauchy-Schwarz inequality [formula] to obtain an upper bound on the sum of costs, which can be trivially turned into a bound on the average cost. Note that in the setting of the paper, where the costs are natural numbers, the sum of the squares of the costs is an upper bound on the sum of the costs: [formula] Below we derive bounds for each algorithm in turn.

Perceptron. We get the upper bound [formula]. For the lower bound on [formula] we get: [formula] Here the first inequality follows from Assumptions 2 and 3. In particular by Assumption 2 we have that for any step where Ct  >  0, U(xt,y') - U(xt,yt)  ≤  κ  ·  Ct.

Applying Cauchy-Schwarz we get: [formula]

Cost-Sensitive Perceptron. We have the upper bound [formula] and a lower bound on [formula] [formula]

Applying Cauchy-Schwarz we get: [formula] [formula] ⇒   [formula]

PA. We will use the shorthand [formula]. We begin with proving an upper bound on [formula]. We know that [formula]. From the Cauchy-Schwarz inequality we then have that [formula]. This implies that [formula]. Since we only consider those examples where the cost is non-zero, this means that [formula].

An upper bound on [formula] [formula] [formula] [formula] [formula] [formula]

Now a lower bound on [formula] [formula]

[formula]

Applying Cauchy-Schwarz we get [formula]

Cost-Sensitive PA. Here we will use the shorthand [formula], and the bound [formula].

An upper bound on [formula] [formula] [formula] [formula] [formula] [formula]

Now a lower bound on [formula] [formula] [formula] [formula] Using this and applying Cauchy-Schwarz we get: [formula]

Appendix B: Bounds for Noisy Data

In this appendix, we present the analysis of the average cost bounds for the PER and CSPER algorithms in the case where there is noise in the expert's assessment, i.e. the expert might mis-estimate the relative utilities of the original solution and a suggested improvement by a term ξt so that Assumption 3 is relaxed, and we only have the assumption that for each example xt, U(〈xt,y'〉)  -  U(〈xt,y〉)  ≥  κCt  -  ξt. In this case, for the simple perceptron algorithm we get the bound [formula], which is comparable to the bound presented in [\cite=DBLP:journals/corr/abs-1205-4213]. For the CSPER algorithm, we obtain the bound [formula] [formula].

It is not clear whether similar bounds hold for the PA-based algorithm, since they are susceptible to noise.

PER For the Perceptron algorithm, we have the following bound on [formula]:

[formula]

For the lower bound on [formula] we get:

[formula]

[formula]

Combining these and applying Cauchy-Schwarz we get:

[formula]

[formula]

CSPER

For the CSPER algorithm, we have the following bound on [formula]:

[formula]

and the following bound on [formula]:

[formula]

Combining these, using Cauchy-Schwarz, we get:

[formula]

Using the shorthand notation [formula], we can rewrite this as:

[formula]

This is a quadratic inequality in terms of θ. The upper bound for θ we get from this is:

[formula]

For simplicity, we can safely rewrite this (using [formula]) as:

[formula]

Since [formula], we get:

[formula]

Acknowledgements

The authors acknowledge support of the ONR ATL program N00014-11-1-0105.