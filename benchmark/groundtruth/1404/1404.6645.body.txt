Proposition Lemma Corollary

Space-Time Storage Codes for Wireless Distributed Storage Systems

Introduction

Our society relies on wireless communications and data storage over unreliable channels and networks more than ever, largely due to increasing demand for wireless services, social networks and different types of peer-to-peer (p2p) systems such as digital video broadcasting, Facebook, Google, Oracle, and various video-on-demand (VoD) services.

Distributed storage systems (DSSs) enable reliable data storage by storing data on separate devices in a redundant way. The simplest form of distributed storage is that of replication: by storing some number of replicas of the original file on the devices in the storage network, one is able to maintain and retrieve the data even when some of the nodes fail, provided at least one of them survives. Node failure is common, and can be caused by hardware corruption, system overload (e.g. in p2p systems), or by a node leaving the system.

If the data is stored over n storage nodes by using an (n,k) maximum distance separable (MDS) code, the whole data file can be reconstructed by contacting any k out of n nodes. In addition to storing the file, the system has to be repaired by replacing a node with a new one whenever some node fails. This can be done by using, e.g., regenerating codes [\cite=DGWWR07]. If the newcomer node replacing the failed node has to contact d helper nodes in order to restore the contents of the lost node, we call the code an (n,k,d) code. Recent work [\cite=DGWWR07] [\cite=me] considers tradeoffs between the storage capacity, secrecy capacity, and repair bandwidth. Explicit storage code constructions achieving some of the tradeoffs can be found in [\cite=RR10] [\cite=DRWS10] [\cite=rashmietal], among many others. Regenerating codes by definition achieve the storage capacity-repair bandwidth tradeoff.

In this paper, we will consider the physical layer functionality of distributed storage systems, where the storage nodes are scattered in a wireless network, or data lying in a (wired) data center is retrieved over a wireless access network. When a data collector requests a file, or a newcomer requests help from some survivor nodes in order to replace a lost node, the data transmissions that follow will thus take place over a wireless fading channel. Being able to perform transmission requests, in principle, requires a feedback (uplink) channel or a base station performing these requests. In the present paper, we will ignore this aspect and only concentrate on the protection of the downlink transmissions, i.e., of the transmissions from the storage nodes to a data collector or to a newcomer.

Contributions and related work

Most storage-related research focuses on the (logical) network layer, while the physical layer functionality is usually ignored due to the fact that many storage systems in big data centers are wired. Nonetheless, the authors are aware of some interesting works considering the physical layer. In [\cite=gong], a so-called partial downloading scheme is proposed that allows for data reconstruction with limited bandwidth by downloading only parts of the contents of the helper nodes. In [\cite=Ning], the use of a forward error correction code (e.g., LDPC code) is proposed in order to correct bit errors caused by fading. In [\cite=rashmi_erasure], optimal storage codes are constructed for the error and erasure scenario. The present paper deviates from the previous work in that it addresses the actual encoding of the transmitted repair data in order to fight the effects caused by fading.

Isolated from the storage point of view, on the other hand, a plethora of research has been carried out during the past two decades in wireless communications (see [\cite=oggierviterbo2] and the references therein). Motivated by this work, we will introduce the notion of space-time storage codes, a class of codes that should be able to resist fading of the signals during repair transmissions, while also maintaining the repair property of the underlying storage code.

The contributions of this paper are listed below.

For the first time, protecting a distributed storage system from physical layer errors is considered in conjunction with the encoding of the repair and reconstruction transmissions in order to overcome the defect caused by fading.

It is pointed out that the data reconstruction and repair transmissions can be modeled as a multiple access channel (MAC), providing us with a rich theory of MAC systems to be harnessed in the context of data storage. Further, a joint design of a storage code and a MAC space-time code, referred to as a space-time storage code, is proposed as a protocol for wireless storage transmissions.

Tentative design criteria for such codes are proposed based on earlier work on MAC space-time codes.

Simulations are carried out to confirm the merit of the proposed protocol.

Open questions and some problems are addressed to motivate further research.

Space-time storage codes

Space-time coding has gathered an enormous amount of interest during the past 15 years due to many practical applications, among which are mobile phones, digital video broadcasting, satellite communications, and multiple access channels. Especially algebraic number theory has offered a wide range of tools for packing the information into vectors and further into matrices in a robust and efficient way to reduce the required transmission power and the error probability [\cite=oggierviterbo2].

A space-time (ST) code is a finite subset of the space of nt  ×  T complex matrices [formula], where nt denotes the number of transmit antennas, and T is the number of channel uses, also called decoding delay. In order to avoid accumulation among codewords, it is preferable to consider codes with a lattice structure. A lattice Λ is a discrete finitely generated abelian subgroup of some ambient space V, e.g., [formula].

A space-time lattice code CST is of the form

[formula]

where [formula] is a lattice basis for some lattice [formula], and S is a finite signaling alphabet, e.g., pulse amplitude modulation (PAM).

We refer the reader to [\cite=oggierviterbo2] for a general introduction to space-time lattice codes.

Equivalence of wireless storage transmissions and MAC

In a noncooperative multiple access channel, multiple users are simultaneously communicating to a joint destination, hence the destination receives a combination of all the transmissions. Virtually, this can be considered as a MIMO space-time code satisfying certain properties. The key difference to single-user ST codes is that the transmissions of different users (corresponding to different (groups of) antennas in the single-user case) should be independent of each other, whereas in the single-user case the message is encoded over many (groups of) antennas to provide better diversity. In the case of data storage applications, the different storage nodes typically neither share the same storage contents nor cooperate, and hence the protocol resembles the MAC case rather than a single-access channel. Hence, the following observation is immediate.

In a distributed storage system, the repair (resp. reconstruction) transmission over a wireless fading channel can be modeled as a multiple access channel. The number of MAC users K corresponds to the number of helpers involved in the repair (resp. reconstruction) process K = d (resp. K = k). Furthermore, the MAC transmission can be virtually modeled as a multiple-input multiple-output (MIMO) transmission described by the channel equation

[formula]

where X is the overall transmitted matrix of the K users, H and W are the random fading and noise matrices, and Y is the received matrix.

We refer the reader to [\cite=kuser] for more details.

Suppose now that a node fails, and that an incoming node unew has to contact K∈{d,k} nodes for repair/reconstruction. Let us write [formula] for the nodes contacted by unew. Each uij would like to send its contents x̄ij to unew over a Rayleigh fading channel. To do this, we incorporate into our coding strategy a bijective lift function

[formula]

where X is the set of possible encoded file fragments, and C is a finite symbol set of size equal to the size of X. We define L(x̄i)  =  xi. To be more precise, we define below what we mean by a space-time storage code.

A space-time storage code consists of the following:

a DSS system with parameters defined as above, employing an (n,k) MDS code or some other type of storage code,

a symbol set C carved from [formula] or [formula],

a bijective lift function L:X  →  C, where X is the set of possible encoded file fragments, and

a MAC space-time transmission protocol using C as information symbols.

We point out the generality of this definition: it does not address the details of the storage code nor the space-time code. Here, we will concentrate on algebraic space-time lattice codes.

Now let us consider a distributed storage system employing a storage code, e.g., a regenerating code, and where the storage nodes are scattered in a wireless network. The data collector and newcomers connect to the helper nodes over a fading channel, and download data symbols from these nodes.

We assume a Rayleigh fading channel, with the channel equation

[formula]

where xi is the codeword transmitted by the ith helper node, hi is the corresponding channel gain, and w is the noise at the receiver. Here [formula] are i.i.d. Rayleigh distributed random variables with zero mean, [formula], and [formula], where K is the number of helper nodes, so either K = d for repair, or K = k for file reconstruction. The above channel equation can be transformed into an equivalent MIMO channel (cf. Prop. [\ref=mac-equality]) as

[formula]

The lift function

In a storage system, a,b∈GF(2)m  =  {0,1}m, or more generally a,b∈GF(q)m, usually with [formula] for [formula]. The entries of a space-time code matrix, on the other hand, are typically drawn from a complex alphabet [formula], e.g., from a ring of algebraic integers of a suitable number field. How should one deal with this potential conflict of different alphabets? This is exactly where the lift function

[formula]

comes into the picture. There are various ways to design such a lift function, see e.g. [\cite=Lusina] [\cite=Lu-Kumar]. The simplest option (q = 2) is to map bit strings directly to PAM or quadrature amplitude modulation (QAM) alphabet via Gray-mapping and then map the PAM or QAM symbols to algebraic integers via an integral basis over [formula] or [formula], respectively. Below, we describe yet another possibility to match bit strings to algebraic integers.

Let [formula] be an imaginary quadratic field. The ring of integers OE of E embeds as a lattice into [formula] via the canonical embedding ψ. Now let It = (2t), an ideal in OE, which via the canonical embedding is a sublattice of OE. Notice that we have a chain of inclusions:

[formula]

There is a simple way to put cosets of It in OE in bijection with bit strings of length 22t. The structure of the quotient ring OE  /  It depends on the factorization of the ideal (2) in OE, which is easy to calculate given E. We can write

[formula]

where the left-most arrow is the above outlined process, the middle arrow is choosing a coset representative, and the right-most arrow is the canonical embedding. Hence, we can identify the set of bit strings of length 22t with a finite subset of [formula] of the same size.

Space-time storage codes over MAC

For simplicity, we start by a simple example (see Fig. [\ref=toy]), which will be then generalized in the end of this section.

Assume we have mapped a,b,c = a + b∈{0,1}m to ring of integers in a number field E as described above, and denote the resulting elements by a',b',c'∈OE. Assume the first node fails. The first helper, node 2, transmits the vector {b',τ(b')}, while the second helper transmits {c,τ(c')}. Here τ is an automorpism of E. No collaboration between nodes required, and it is not even necessary for them to know who the other helpers are.

The receiver observes

[formula]

This corresponds to a MIMO MAC space-time code, which are known ([\cite=kuser] [\cite=remarks]) to perform well and to achieve the so-called diversity-multiplexing gain tradeoff (DMT) [\cite=ZT-MAC], when the field is chosen well. With sufficient SNR, the receiver is able to decode the message with very high probability and gets b',c', which he can map back to bit strings b,c = a + b and further reveal a = b + (a + b).

Let us now consider the above setting in more generality. We denote by [formula] the bit vectors stored at each node, with some redundancy (for instance, in our toy example we would have b3 = b1 + b2). Let each node be occupied with nt transmit antennas. Assume in addition that the DSS uses an (n,k,d) storage code. Let E  ⊇  E1  ⊇  E2 be a chain of cyclic Galois extension of degrees = 2,   = d and τ the generator of the cyclic Galois group of E1 / E2, and σ the generator of the cyclic Galois group of E / E1. Let A be a cyclic division algebra (CDA) with center E1 and with a maximal subfield E, i.e.,

[formula]

where ent  =  γ, [formula] for [formula], and xe = eσ(x) for all x∈E. See [\cite=oggierviterbo2] for more details.

Each element [formula], of A can be represented as a nt  ×  nt matrix via the left regular representation (LRR) ψ. Denote by [formula] the elements corresponding to each of the d helpers, obtained by mapping the bit strings bi to OE, and by [formula] the matrices containing these elements obtained via the LRR. The MAC ST code matrix suitable for the repair transmission is described as follows:

[formula]

We refer to [\cite=kuser] for more details on the construction of MAC-DMT optimal space-time codes.

Now, after successfully decoding X from Y = HX + W, we can map the xij back to the corresponding bit strings bj. Then, the actual repair can be performed by using the repair rule of the assigned storage code. We point out that decoding by a linear decoder such as sphere decoder requires the receiver to have d antennas. This is an evident drawback for the proposed scheme when d is large.

Design criteria for space-time storage codes

'Successfully' above requires that the SNR experienced at the receiver is high enough. As the channel quality is imposed by nature, we will concentrate on designing the space-time code as well as possible. To this end, the ST code CST consisting of a finite number of the matrices [\eqref=RST] should have the following property that we recite from [\cite=remarks].

If the minimum of the nonzero determinants of the matrices X defined as above is bounded from below by a positive constant, i.e.,

[formula] [formula]

we say that the code CST has the conditional non-vanishing determinant (CNVD) property.

If X is not a square matrix, we extend our definition to consider det (XX†), where X† is the complex conjugate transpose of X.

In order to achieve good performance, all the submatrices S(j)(S(j))† consisting of j  ≤  d helpers should have CNVD (cf. [\cite=kuser]), where

[formula]

corresponds to any subset of j helpers, j = 1,...,d.

Let now d denote the number of helpers all equipped with nt transmit antennas, and let A be a E1-central algebra. The following theorem [\cite=CNVD] is the key to achieving the CNVD, but may impose restrictions on the parameters d and nt and on the mapping τ.

Let [formula] be a finite dimensional simple algebra, where [formula] is an index nt division algebra. Then A is central simple over its center E1, and the center is the same for A as for [formula]. The norm of an element X of the matrix algebra A is the determinant of the matrix X.

Hence, det (X)∈E1, and further det (X)∈OE1, when we are using an OE1-order [formula]. If E1 is either [formula] or [formula], we get | det (X)|  ≥  1 whenever it is nonzero.

In addition to the ST code having a CNVD, the underlying storage code should be designed in such a way that the probability of successful repair given the result X̂ of the decoding of the received signal Y = HX + W, is maximized. In the next section we will analyze the probability of successful repair in some example cases.

The code in Ex. [\ref=bb-example] has CNVD if the twisting element i is removed. Removing it does not affect the simulation results. The code is MAC-DMT optimal without the twisting element [\cite=kuser], and we believe it is optimal also with the twisting element.

Simulation results

We have proposed to use MAC ST storage codes for wireless repair transmissions. In order to justify our proposition, we compare the repair bit errors of MAT ST storage codes to uncoded repair transmission carried out by simple (virtual) single or double spatial multiplexing, as explained in detail below.

The plots in Figure 2 represent the slow fading scenario, assuming that the repair fragment size is 4 bits. Simulations were carried out to investigate the repair of a failed node for the storage code in our toy example case (cf. Fig. [\ref=toy]), where communication between the nodes takes place in a fading environment. Each helper node transmits their assigned bit string bi of 4 bits, and the bitwise XOR   =  1  +  2 is calculated after decoding the received signal, where we denote the decoding outcome by 1 and 2. That is, if the decoding was successful, b1  =  1,b2  =  2. Each of b1 and b2 is modulated according to the particular coding strategy used. We assume two antennas at the receiver for each scheme.

Double Spatial Multiplexing (DSM): Each of the bi, i = 1,2 is split in half as bi  =  bi1bi2, and each substring of two bits is modulated into a 4-QAM symbol using the Gray-mapping g, working as our lift function (cf. Def. [\ref=ST-storage]). We define xij: = g(bij) for i = 1,2 and j = 1,2. Node i then transmits xi1 over the first channel use, and xi2 over the second channel use. The virtual MIMO channel is described by the equation Y  =  HX  +  W, where

[formula]

H is the 2  ×  2 channel matrix, W is the 2  ×  2 noise matrix, and Y is the received matrix. Maximum likelihood decoding is performed to calculate [formula] where X' ranges over all possible X of the above form assuming 4-QAM, and ||  ·  || is the Frobenius norm. We thereby obtain estimates x̂ij, to which g- 1 can be applied to obtain   =  1  +  2  =  1112  +  2122 where ij  =  g- 1(x̂ij), the reconstituted fragment. A bit error occurs whenever one of the bits of b and [formula] differ.

MAC Storage Code: The setup is exactly the same as in the DSM case, except the 4-QAM symbols are further encoded using the MAC code described in Ex. [\ref=bb-example].

Single Spatial Multiplexing (SSM): Each of the bi, i = 1,2 is modulated into a 16-QAM symbol using the Gray-mapping g. We define xi  =  g(bi) for i = 1,2. Node i then transmits xi over the channel. Only one channel use is needed to reconstruct the lost fragment. Maximum likelihood decoding is again performed to obtain X̂ and thereby x̂i for i = 1,2. The reconstructed file fragment is   =  1  +  2,  i  =  g- 1(x̂i) and a bit error occurs whenever one of the bits of b and [formula] differ.

We should note that the three coding strategies do not have the same data rate. In particular, The DSM and MAC Storage Code strategies transmit 4 bits per channel use (bpcu), while the SSM transmits 8 bpcu. Thus the comparison is not between codes of the same rate, but rather transmission schemes for recovering file fragments of the same size. One can see from the simulation results that the DSM and MAC Storage Code strategies have a lower BER, while taking two channel uses to repair. However, the SSM strategy can recover the file in just one channel use, at the expense of requiring more energy for the same BER.

The plots in Figure 3 represent the fast fading scenario, where the channel change every channel use, and is independent of the previous channel state. The fragment sizes and coding strategies are otherwise identical to the slow fading scenario.

Since the SSM strategy requires only one channel use, its performance is the same over slow and fast fading channels.

Protocol for nt = 1, nr = 2, and K users

Let [formula] denote the set of K users, and let U denote the set of all 2-subsets of K, i.e.,

[formula]

With the above, the proposed scheme is the following. Let U = {u1,u2} be a random variable uniformly distributed over U. Given U, only replacing nodes u1 and u2 transmit during the period of U. Note that [formula] for any k∈K. This means that in order to achieve an average multiplexing gain r, each replacing node k, when is chosen according to U, i.e. k∈U, should actually transmit at multiplexing gain [formula]. Specifically, we have the following scheme:

Randomly pick U = {u1,u2} from the ensemble U.

The repairing nodes u1 and u2 transmit using the DMT-optimal MIMO-MAC code given in [\cite=kuser] for nt = 1, two users, and multiplexing gain [formula].

It should be noted that at each time instant, only two repairing nodes transmit to the replacing node; as nr  =  2nt it follows from [\eqref=eq:4] the scheme is efficiently sphere-decodable.

Discussion

We have defined space-time storage codes that are able to maintain and repair data that lies in storage systems operating over wireless fading channels. Here, the focus was on embedding a storage code into a MAC space-time code, but what is potentially more interesting is the question as to how to jointly design a ST storage code from scratch such that probability that the system maintains its functionality is maximized. Studying this probability may give rise to new, more delicate design criteria for ST storage codes, instead of just optimizing the storage code and the space-time code separately. Combining optimal MAC ST codes and storage codes is problematic also due to high complexity: the MAC ST storage codes proposed in this paper require K antennas at the receiver in order to perform sphere decoding when there are K helper nodes. Hence, new repair transmission protocols with lower complexity are called for, while ideally maintaining good performance and achieving the DMT.

Acknowledgments

This work was partly supported by the Academy of Finland (grant #268364 to D. Karpuk) and Magnus Ehrnrooth Foundation, Finland, through grants to C. Hollanti and D. Karpuk. The support from the COST Action IC1104 is gratefully acknowledged.