Quantum algorithms for the hidden subgroup problem on a class of semidirect product groups

Introduction

Most of exponentially fast quantum algorithms can be cast into the hidden subgroup problem (HSP), which is considered a paradigm for the development of quantum algorithms. The HSP on the finite group G can be described as follows. Let X be a finite set and f:G  →  X a function such that f(g1) = f(g2) if and only if g1 and g2 are in the same left coset of some subgroup H in G. The problem consists in determining generators for H by querying the function f. If the computational complexity of the algorithm is O( log |G|) considering that each query counts as one computational step, we say that the HSP is solved efficiently. It is usual to say that the function f hides the subgroup H in G. Simon [\cite=Simon] and Shor [\cite=Shor] algorithms solve special cases of the abelian HSP. When the group G is abelian, there is an efficient solution in the general case [\cite=Kitaev] [\cite=Lomont].

If G is not abelian but is "close" to abelian in some sense, the HSP may be solved by reduction to the abelian HSP. There are many examples of this method in the literature [\cite=Ivanyos1] [\cite=Ivanyos2], which may not employ new quantum algorithms directly. Recently, Inui and Le Gall [\cite=Inui] have presented an efficient algorithm for the HSP on the group [formula] for odd prime p and positive integer r employing direct quantum techniques. Using the classification of the subgroups of [formula] presented in [\cite=Inui], it is possible to use the Ettinger-Høyer reduction [\cite=Ettinger] to simplify the algorithm to the abelian HSP [\cite=Bacon]. There is an alternative form to reduce Inui and Le Gall's algorithm to the abelian HSP by employing the results of Ref. [\cite=Ivanyos1] on normal subgroups of solvable groups. We discuss this method in Sec. [\ref=sec5]. In Ref. [\cite=Chi], the authors have extended the solution of the HSP to the group [formula] where N is factorized as [formula] and p does not divide each pi - 1 for 1  ≤  i  ≤  n.

In the present work we address the HSP on the group [formula] for any odd prime p and any integer r such that r > 4. We present an efficient solution for the HSP both by using direct quantum algorithms and by reducing to the abelian HSP. We also address the HSP on the group [formula] where N is factorized as [formula] and p does not divide each pi - 1.

This paper is organized as follows. In Sec. [\ref=sec1] we describe the structure of the group [formula] and give the complete list of subgroups. There are two classes of non-trivial isomorphic groups depending on the homomorphism φ. In Sec. [\ref=sec2] we list the abelian subgroups that can be used to run the abelian HSP in order to obtain information about H (the hidden subgroup). In Sec. [\ref=sec3] we address the case when H is cyclic in the first class of groups. In Sec. [\ref=sec4] we address the non-cyclic case also in the first class. In Sec. [\ref=sec5] we address the second class. In Sec. [\ref=sec5dot5] we address the HSP on the group [formula] with some restrictions over the values of the integer N. In Sec. [\ref=sec6] we present our conclusions.

The structure of [formula]

The group [formula] is the set [formula] with the group operation (a1,b1)(a2,b2) = (a1  +  φ(b1)(a2), ~ b1 + b2), where φ is any group homomorphism from [formula] into the group of automorphims of [formula]. The group [formula] is generated by x = (1,0) and y = (0,1) and φ is completely determined by the value α  =  φ(1)(1), which is in [formula]. For r > 4 the possible values of α are τpr - 2 + 1, where 0  ≤  τ < p2. There are two classes of non-trivial isomorphic groups.

Class (1) is characterized by the values of τ such that gcd(τ,p2) = 1. We take τ = 1, that is α = pr - 2 + 1 with no loss of generality. Using that (a,b) = xayb and φ(b)(a) = aαb we get

[formula]

Class (2) is characterized by the values of τ such that gcd(τ,p2) = p. We take τ = p, that is, α = pr - 1 + 1 with no loss of generality. The product of two group elements is given by

[formula]

The subgroups of [formula] for both classes have the following forms:

[formula]

where 0  ≤  i  ≤  r, 0  ≤  j  ≤  1, and [formula] where l =  min {r - i, 2 - j},

[formula]

where 0  ≤  i < r, 0  ≤  j  ≤  1, and

[formula]

where 0  ≤  i < r and [formula].

The subgroups are characterized by 3 parameters: t, i, and j. This is too complex for any direct attempt to build a quantum algorithm. As usual, the strategy we will use is the following. Let G be an abelian subgroup of [formula] and suppose that the function f hides H in [formula]. If H is subgroup of G, then the generators of H can be found efficiently by restricting f to G and by employing the algorithms of the abelian HSP. If H is not a subgroup of G, this method finds efficiently the generators of [formula], which may yield partial information about H. We will see that this strategy eliminates the parameter i. The remaining parameters t and j will be determined by two methods: (1) direct quantum algorithms and (2) reduction using the algorithms described in Ref. [\cite=Ivanyos1].

Reduction to abelian subgroups

The abelian subgroups of [formula] that we use in this part of the reduction are [formula] and [formula]. Let [formula] and [formula]. Function fx defined by fx(a) = f(a,0) hides Hx in [formula]. Function fy defined by fy(b) = f(0,b) hides Hy in [formula]. The solution of the abelian HSP on [formula] and [formula] with oracles fx and fy respectively determines the generators for Hx and Hy. The form of these groups are [formula] and [formula], where 0  ≤  m  ≤  r e 0  ≤  n  ≤  2. Therefore, the abelian reduction yields the values of m and n efficiently.

Using the values of m and n it is possible to determine whether H is cyclic or not. If H is generated by two elements, either formula ([\ref=sg2]) or ([\ref=sg3]), one can verify that Hx and Hy cannot be the trivial group. One eventually concludes that if m = r or n = 2 then H is cyclic, that is, H is described by formula ([\ref=sg1]); and if 0  ≤  m < r and 0  ≤  n < 2 then H is not cyclic, that is, either H is described by formula ([\ref=sg2]) or by formula ([\ref=sg3]).

In the following sections we address the groups in class (1). In Sec. [\ref=sec5] we address the groups in class (2).

The cyclic case

Suppose that m = r or n = 2. By running the abelian HSP on the subgroup [formula] with the oracle f restricted to this subgroup, either we determine generators for H or in the worst case we obtain partial information about H. The way to proceed at this point is to calculate the intersection of the groups of the form given by formula ([\ref=sg1]) with [formula]. We split into 3 cases: (i) m = r and n = 2, (ii) m = r and n < 2, and (iii) m < r and n = 2.

In case (i), the groups of the form given by formula ([\ref=sg1]) are subgroups of [formula], therefore the abelian reduction provides the values of the parameters t, i, and j. The possible forms of H are [formula] where [formula], [formula] where [formula], and [formula].

Case (ii) is similar to case (i), because H is a subgroup of [formula]. The abelian reduction provides the values of the parameters t, i, and j. The possible forms of H are [formula] when n = 0 and [formula] when n = 1 where [formula], 0  ≤  j  ≤  1.

In case (iii), if m = 0 or m  ≥  4, H is subgroup of [formula]. The abelian reduction provides completely the values of the parameters t, i, and j. The possible forms of H are [formula] when m = 0 and [formula] or [formula] when m  ≥  4 where [formula] and 0  ≤  j  ≤  1. The remaining cases are m = 1, m = 2, and m = 3.

If m = 1, the abelian reduction eliminates the parameter i. The values of t and j remain unknown. The possible forms of H are [formula] and [formula] where [formula]. We have to decide between these two forms and in the last form we have to determine the value of t. We proceed by employing a quantum algorithm. We prepare the quantum computer in the initial state

[formula]

Now we measure the third register in the computational basis. The result depends on the form of H. Suppose by now that [formula], for some [formula]. The result is

[formula]

for some a0 and b0 such that 0  ≤  a0  <  p and 0  ≤  b0  <  p2 randomly distributed. We have disregarded the third register since it will be irrelevant from now on. Now we apply the Fourier transform operator F[formula]Fp2 on state [formula]. The result is

[formula]

where ωp (ωp2) is the primitive p-root (p2-root) of the unity. Now we measure the state [formula] in the computational basis and get values a and b such that [formula]. If [formula], then we calculate t1 =  - a( - 1)b   mod  p. If f(xt1yp) = f(1) then [formula] otherwise [formula]. The success probability is 1 - 1 / p.

If m = 2 the possible forms of H are [formula], [formula] where [formula], and [formula] where [formula]. We have to decide among those forms and then we have to determine the value of t. We proceed by using a quantum algorithm. We use the initial state

[formula]

and after measuring the third register we apply the Fourier transform operator F[formula]Fp2. The way to proceed is similar to the case m = 1. At the end, if [formula], then we calculate t1 =  - a( - 1)b   mod  p2 and t2 =  - a( - 1)b   mod  p. If f(xt1y) = f(1) then [formula]. If f(xt2pyp) = f(1) then [formula] otherwise [formula].

If m = 3 the possible forms of H are [formula], [formula] where [formula], and [formula] where [formula]. This case is very similar to the case m = 2. The only differences are that the first sum of the state [formula] runs from 0 to p3 - 1 and the Fourier transform operator is F[formula]Fp2. The remaining analysis of the algorithm is similar to the case m = 2.

The non-cyclic case

Suppose that 0  ≤  m < r and 0  ≤  n < 2. Either H has the form given by formula ([\ref=sg2]) or the form of formula ([\ref=sg3]). If n = 0 then there is only one possible form which is [formula]. From now on we consider the case n = 1. If m = 0 then there is only one possibility which is [formula]. For m  ≥  3, H is a subgroup of [formula], therefore the abelian reduction over [formula] provides the values of the parameters t, i, and j. The possible forms of H are [formula] and [formula]. The remaining cases are m = 1 and m = 2.

If m = 1 then either [formula] or [formula], [formula]. The abelian reduction does not determine between those two forms and does not provide the value of t. We proceed by employing a quantum algorithm. We prepare the quantum computer in the following initial state

[formula]

We measure the third register in the computational basis. The result depends on the form of H. Suppose by now that [formula], for some [formula]. The result is

[formula]

for some a0 such that 0  ≤  a0  <  p randomly distributed. Now we apply the Fourier transform operator F[formula]Fp on state [formula]. The result is

[formula]

Now we measure the state [formula] in the computational basis and get values a and b such that [formula]. If [formula], then we calculate t1 =  - a( - 1)b   mod  p. If f(xt1y) = f(1) then [formula] otherwise [formula]. The success probability is 1 - 1 / p.

If m = 2 then either [formula] or [formula] where [formula]. For this case we use the same strategy of the case m = 1 with some minor differences.

The use of direct quantum algorithms can be avoided if one notes that all subgroups for which we have employed quantum algorithms in Secs. [\ref=sec3] and [\ref=sec4] are normal in [formula]. The list of those subgroups is [formula] 1  ≤  k  ≤  3, [formula], [formula], [formula], [formula], [formula], [formula], [formula], [formula]; [formula], [formula], [formula]. It is easy to verify because they contain the commutator group of [formula] which is [formula]. We know that [formula] is a finite p-group, therefore it is solvable. Theorem 7 of Ref. [\cite=Ivanyos1] states that if H is a normal hidden subgroup of a solvable group G, then the generators of H can be found by a quantum algorithm in time polynomial in log |G|. In the proof of their result, they show constructively how the problem reduces to the abelian HSP. From this argument we conclude that the HSP on [formula] for odd prime p and r > 4 can be fully reduced to the abelian HSP.

The groups in class (2)

The groups in class (2) are somewhat simpler than the ones in class (1). The main reason is that the subgroup [formula] is normal in [formula] and the quotient group [formula] is isomorphic to [formula] when we take the homomorphism φ that characterizes class (2).

Let us show how the HSP on the groups in class (2) reduces to the abelian HSP. In Sec. [\ref=sec2] we have showed how to determine the values of parameters m and n. Using these values, we can know in advance whether (i) H is completely determined, (ii) H is a subgroup of [formula], or (iii) H is normal. Case (i) occurs when m or n is zero. If m = 0 then [formula] where 0  ≤  n  ≤  2. If n = 0, then [formula] where 0  <  m  ≤  r.

Case (ii) occurs in the following cases. If m = r and 0  ≤  n  ≤  2 then [formula] where either t = 1 when j = n or [formula] when 0  ≤  j < n. If 3  ≤  m < r and n = 2 then [formula] where either t = 1 when j = 2 or [formula] when 0  ≤  j < 2. If 2  ≤  m < r and n = 1 then either [formula] or [formula] where [formula].

Case (iii) occurs in the following cases. If 1  ≤  m  ≤  2 and n = 2 then [formula] where 0  ≤  j  ≤  2. If m = n = 1 then either [formula] or [formula].

The strategy to solve the HSP on [formula] in class (2) is the following. In case (i) we are done. In case (ii) we run the abelian HSP with the function f restricted to the subgroup [formula]. This procedure determines completely the parameters of the generators of H. In case (iii) we employ the algorithms described in Ref. [\cite=Ivanyos1]. We can use them because we know in advance that H is normal.

The same strategy works for the group [formula] which was addressed in Ref. [\cite=Inui]. This group has the following properties. All proper subgroups are abelian and the maximal subgroups are normal. By running the abelian HSP on the subgroups [formula], [formula], [formula], either one obtains the generators of H or learns that H is normal. In the latter case one employs the methods of Ref. [\cite=Ivanyos1].

Groups of the form [formula]

The same kind of reduction presented in Ref. [\cite=Chi] applies to the group [formula], where the prime factorization of N is [formula] and p does not divide each pj - 1, 1  ≤  j  ≤  n.

The following result holds is this case. If p and q are distinct primes satisfying [formula] then [formula] is isomorphic to [formula] for some homomorphism ψ from [formula] into the group of automorphims of [formula]. The proof is similar to the one presented in Lemma 2 of Ref. [\cite=Chi]. Because p must divide the order of [formula], we can choose p1 = p with no loss of generality. Using those results, it is straightforward to show that

[formula]

The orders of the groups in the direct product of the above isomorphism are relatively prime. Therefore, the HSP on [formula] reduces to the HSP on each factor. Either the factor is an abelian group or it is the group [formula], which was addressed in this paper if r1 > 4.

Conclusions

We have described efficient quantum algorithms for the HSP on the group [formula], where p is any odd prime number and r is any integer such that r > 4. The method relies on the classification of all subgroups of [formula]. The subgroups are characterized by three parameters. By using reductions to the abelian HSP, the number of independent parameters decreases and the values of the remaining ones are found either by employing direct quantum algorithms or by using the reduction described in Ref. [\cite=Ivanyos1]. We have also addressed the HSP on the group [formula] where N is factorized as [formula] and p does not divide each pi - 1, by employing an isomorphism between [formula] and the direct product of [formula] with cyclic groups.

The computational complexity of the algorithm can be bounded by the following analysis. The order of the group [formula] is p(r + 2). We have employed abelian reductions, direct quantum algorithms, and the reduction described in Ref. [\cite=Ivanyos1]. In all those parts we can guarantee that the complexity is O(poly((r + 2) log p)). Therefore the overall complexity of the algorithm for solving the HSP on [formula] is O(poly((r + 2) log p)). The algorithm is probabilistic and we guarantee a success probability greater than 1 / 2.

We are currently addressing the HSP on the group [formula] for any odd prime p and integers r and s such that r > 2s. This case seems to be a straightforward generalization of the algorithms presented in this work.

Acknowledgments

We thank Guilherme Leal and Demerson N. Gonalves for useful discussions. This work was funded by FAPERJ and CNPq.