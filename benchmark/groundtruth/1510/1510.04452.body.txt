Quantum Phase Estimation Algorithm for Finding Polynomial Roots

Introduction

Roots finding is a centuries-old problem that has continued to attract considerable research interests and efforts due to its relevance in many fields of mathematics and physics involving geometry, number theory, probability and combinatorics. It is well known that for a polynomial of degree 4 or or less, there exists a formula or procedure to solve for its roots exactly [\cite=Weisstein-crc-2009]. However, such a task is impossible for a polynomial of degree 5 or greater [\cite=Jacobson-dover-2009]. Many root-finding algorithms have been devised for obtain approximated roots of a polynomial of arbitrary degree [\cite=McNamee-elsvr-2007] [\cite=Mekwi01] [\cite=pan-siam-39-187].

The plausibility of a quantum computer--a new type of computation, which embraces quantum mechanics into its information, algorithms, and output measurements--has entailed quantum algorithms. A simple enhancement by rather non-intuitive mathematics of quantum mechanics like superposition, the uncertainty principle, and entanglement, brings quantum algorithms forth to a new level of computation unreachable before by conventional computers with classical algorithms. For example, the Shor's algorithm, an algorithm to factorize a large integer into a product of primes, is proven in principles to overcome the classical-algorithm limit in terms of speed[\cite=sh-conf-94-124]. A breakthrough in quantum simulation is expected to bring eminent impact into science and technology[\cite=ll-sci-273-1073] [\cite=fe-ijtp-82-467]. Recent progress on the actual quantum devices, such as a successful small-molecule simulation [\cite=as-sci-309-1704] [\cite=ma-natphys-7-399] [\cite=brn-prl-97-050504] [\cite=neg-pra-71-032344] or probing the statistics of quantum systems[\cite=mtt-srep-3-1539] [\cite=ovi-jsm-2015-1-P01004] [\cite=crsp-pra-91-013811], have yielded high promises and attracted immense interests. The advancement of computation and simulation in the aforementioned examples owes largely to a common underlying method called phase estimation algorithm (PEA)[\cite=kitaev96]. Still, PEA can be improved, especially at the fundamental algorithm of finding roots of a polynomial.

However, PEA is only applicable to unitary operators which are not always the case for some quantum algorithms; for instance, the phase measurement under the circumstance where decoherence is present in the process[\cite=kac-nphot-4-357360]. In a measurement process of the quantum algorithm, the non-unitary matrices also play key roles as projective operators. In order to modify existing PEA to be suitable for eigenvalue problems comprehensively, a programmable circuit, and measurement of the control and ancillary qubits are recently exploited to tailor-made any arbitrary matrix[\cite=dask-qip-13-333]. The great advantage of this proposed scheme is that any matrix can be constructed and the control gate of the respective matrix can be realized, paving ways to build a quantum computer which can calculate eigenvalue of any matrix. However, some drawbacks exist as the algorithm itself may not be efficient for complicated matrices, which quantum complexity arises following the increasing number of non-zero matrix elements[\cite=dask-jchemphy-137-234112]. Further investigation on the algorithm in terms of appropriate complexity is still needed.

Our main aim in this paper is to propose a modified quantum phase estimation algorithm for finding polynomial roots, where we present a benchmark implementation of quantum non-unitary eigenvalue calculation scheme for polynomials. This specific task represents the least complex eigenvalue, which the algorithm can be fruitful without too much concern over the complexity.

This article is organized as follows. The remaining subsections of this section will cover key concepts and ideas about the phase estimate algorithm, and the iterated phase estimate algorithm (IPEA) for unitary operators, as well as the quantum algorithm to find complex eigenvalues of a general matrix. In Section II, we present our modified PEA and IPEA, together with the companion matrix approach, and more importantly, the circuit design to estimate roots of a polynomial of degree n. There we focus our presentation of the circuit operation and outputs, leaving the discussion and complexity analysis in Section III. Finally, the conclusions are summarized in Section IV.

PEA and IPEA for Eigenvalue Problems of Unitary Operators

In the original version of PEA, a phase φ arising after a unitary evolution U with eigenvalue exp (2πφi) is operated on its basis. Because a quantum evolution can be interpreted by a phase factor [formula], where [formula] is a Hamiltonian of a finite system, the phase as a result of the phase estimation algorithm is indeed the eigenvalue of the Hamiltonian. PEA has also been introduced as a potential quantum tool to effectively solve various eigenvalue problems involving unitary operators[\cite=da-prl-83-5162] [\cite=zhxq-nphot-7-223228] [\cite=wng-pra-82-062303] [\cite=brz-scr-4-6115]. The unitary operators play a central role in all of the quantum algorithms, as they are required for universal quantum computations[\cite=ba-pra-52-3457].

In order to estimate the value of a phase parameter ωj up to the b bit-precision using PEA, b ancillary qubits in control register are required. In practice, however, the number of qubits which can be implemented is very limited. Iterative Phase Estimation Algorithm (IPEA) is an algorithm improved from the original PEA with an aim to estimate ωj up to [formula] digit while using only one ancillary qubit together with b iterations as a result of scalable inverse quantum Fourier transform in a semi-classical manner[\cite=gr-prl-76-3228] [\cite=ch-sci-308-997]. In order to explain the algorithm as illustrated in Fig. [\ref=fig:1], we first assume that the phase parameter ωj has a binary expansion no more than b digits (written as [formula]). Initially, all of the ancillary qubits are prepared in state |0〉 and the target register is prepared in the eigenstate |ψj〉 of unitary operator U. A Hadamard gate is applied to the control register in order to prepare state [formula]. In the first iteration (k = 1), a c-U2b - 1 and

[formula]

where θ1 = 0 are applied. After that, the second Hadamard gate is applied on the control qubit and its state is measured in the computational basis {|0〉,|1〉}. This results in state

[formula]

whose measurement gives either 0 or 1, and is determined by the majority probability between |0〉 and |1〉. This measurement result consequently dictates the value of xb. The next iteration is performed with the c-U2b - k and [formula], where [formula] is calculated by the feed-forwarded measurement result of the prior iterations up to xb - k + 1. The algorithm is finished when the digit x1 is obtained.

The original IPEA has been used to determine only the phase parameter ωj of the eigenvalue [formula] of a unitary matrix U. In general, however, an eigenvalue of a non-unitary operator can be written as [formula]. The standard IPEA therefore cannot be applied without the knowledge of modulus |λj|.

Quantum Algorithm for Finding Complex Eigenvalues of General Matrices

Recently, Daskin et al. have introduced their technique to find the complex eigenvalues of general matrices[\cite=dask-qip-13-333]. In order to employ the IPEA on the non-unitary operators, first of all, the non-unitary operator O has to be controlled by a phase qubit and the c-U2b - k in Fig. [\ref=fig:1] is replaced by c-O2b - k.

In the scheme proposed by Daskin et al., the decomposition of the control gate of the non-unitary operator O of size N = 2m uses the programmable circuit design, which requires m + 1 ancillary qubits and m main qubits[\cite=dask-qip-13-333]. The operator O generally has a eigenvalue of the form [formula]. In case that [formula], an operation of c-O followed by the Hadamard gate gives an output state

[formula]

where p and m denote phase qubit and main qubits, respectively. As can be seen, the c-O2b - k can be realized by the decomposition proposed by Daskin et al. It is also possible to estimate its phase ωj via the IPEA from the probability shown in ([\ref=eq:findaskin]) in the same fashion as the phase estimation results determined by ([\ref=eq:ipeaprob]). However, the true novelty of the scheme is in the estimation of |λj|--taking the calculation to a complete eigenvalue estimation for any non-unitary matrix. Following the result shown in ([\ref=eq:findaskin]), the value of |λj| is related to the probability P0 or P1 of finding the phase qubit in states |0〉 or |1〉, respectively. Let P =  max {P0,P1}, so that we can estimate |λj| as

[formula]

where N is the dimension of matrix. In practice, |λj| is determined by the statistics of the measurement. We can also improve the accuracy of the estimation by using the statistics from other iterations. For the [formula] iteration after which c-O2b - k is operated followed by Z(θk) and the Hadamard gate, the relationship between P(k) and |λj| becomes

[formula]

Since we can estimate both |λj| and ωj, the complex eigenvalue λj can be determined.

Quantum Algorithm for Finding Polynomial Roots

Companion Matrix Approach

As the aim of this study is to find roots of a generic polynomial of degree n, we can formulate this problem as the eigenvalue problem of a non-unitary operator. First of all, consider

[formula]

it can be factorized into the form

[formula]

where [formula] are the roots of p(x). From general linear algebra[\cite=buchberger1985], the roots of polynomial p(x) are eigenvalues of its companion matrix defined as

[formula]

with respect to the basis [formula].

Daskin's algorithm requires that the absolute value of every coefficient ai must be less than or equal to 1, since rotation gates are used to simulate these coefficients. Therefore, we introduce a scaling method to meet this requirement. Let [formula] denote the greatest absolute value of [formula]. We choose a basis of circuit in the x-mode or (1 / x)-mode depending on whether |an| or |a0| is greater to maximize the success probability of the circuit scheme.

In case |an| > |a0|, the x-mode will be chosen, so the polynomial p(x) can be equivalently expressed in the form

[formula]

Let [formula] be a scaling factor. Then the corresponding eigenvalue equation is written as

[formula]

where [formula]. The eigenvalue of modified companion matrix is x / μ. On the other hand, if |a0| > |an|, the (1 / x)-mode will be used. Dividing the polynomial p(x) by [formula] leads to

[formula]

In this case, a scaling factor is [formula], and the corresponding eigenvalue equation is in the form

[formula]

where [formula] in this case. Note that the eigenvalue of the modified companion matrix is 1 / μx.

However, the traditional companion matrix as described in ([\ref=eq:cp]) has 1's in the upper diagonal entries but all of such entries of the modified companion matrices as shown in ([\ref=eq:scaling1]) and ([\ref=eq:scaling2]) have absolute values less than 1. To rectify this, we introduce a scaling gate Sm,μ which will be explained in details later; see Equation ([\ref=eq:Sgate]).

Quantum Circuit Design

Our design of the respective algorithm relies on Polynomial Representative Circuit (PRC), a circuit to represent this modified companion matrix as illustrated in Fig. [\ref=fig:2]. PRC requires m main qubits and 2 ancillary qubits where 2m = n is a degree of the polynomial. (Although it is inconvenient, the circuit is also applicable for n  ≠  2m simply by shifting the degree of polynomial up to the nearest power of 2.) First, let the main qubit be prepared in the initial state :

[formula]

and we define |β〉 as a result of Cp operating on |α〉; i.e.

[formula]

Multiplying |α〉 by the modified companion matrix from ([\ref=eq:scaling1]) or ([\ref=eq:scaling2]) gives |β〉 in the form:

[formula]

where [formula]. Similar to the circuit introduced by Daskin et al., our circuit consists of Input Modification Block, Formation Block, and Combination Block. The main ingredient of the Input Modification Block is a cyclic-swap gate Cs applied on the main qubits. The matrix representation of the gate is

[formula]

which can be implemented by the Toffoli gates as shown in Fig. [\ref=fig:3].

The aim of the operator Cs is to generate the matrix element of the companion matrix from row 1 to row n - 1. Since the operation is underpinned by the presences of the sequences of Toffoli gates, the algorithm will be plagued by the huge complexity. the complexity of the algorithm is quite large, and yet still smaller than that of Daskin's scheme, as their matrix elements are generated by the formation block which incurs more complexity. The formation block in our version plays a role of the controlled gate of an operator Fμ, which represents the components in the last row of the modified companion matrix Cp as in ([\ref=eq:scaling1]) or ([\ref=eq:scaling2]). The rotation gate Ri is represented by a matrix as follows:

[formula]

where [formula]. Accordingly, the array of Ri forms the block matrix Fμ as follows:

[formula]

The operation of Fμ can be simulated by a sequence of controlled-rotation gates as in Fig. [\ref=fig:4]. The operation of Fμ will be performed on main qubits and the second ancillary qubit in case that the state of first ancillary qubit is |1〉.

Next step, in the combination block, we define the operator C as follows:

[formula]

where "[formula]" represents the elements we can neglected because they will be filter out by post-selection at the final stage of the algorithm.

There are three sub-tasks to undertake in the combination block. First, a controlled-C gate with the operator C is operated on the main qubits conditioning to the state of the first ancillary qubit as |1〉 to create the [formula] component. As a result, the operation of Cs, Fμ, and C on main qubits and second ancillary qubit conditioning to the first ancillary state |1〉 give the following output:

[formula]

with the probability amplitude [formula]. This amplitude is required to be balanced with the case where the state of the first ancillary qubit is |0〉. At this stage of the algorithm, the scaling gate Sm,μ is introduced to balance this probability and generate 1 / μ in the upper diagonal entries of the modified companion matrix. It is defined as

[formula]

This gate is, in fact, a rotation gate Ry(θ), where [formula]. Scaling gate Sm,μ is to be operated on the second ancillary qubit in case that first ancillary qubit is in state |0〉. After the controlled-Sm,μ gate, the state is transformed into the following,

[formula]

However, referring to ([\ref=eq:afterscale]), the final state is not exactly |β〉. The last task is just to swap between the coefficient α0 and [formula] in ([\ref=eq:afterscale]) using the Toffoli gate in Fig. [\ref=fig:2], which results in

[formula]

where [formula] refers to the case that the ancillary qubits do not all give the result '0'. Finally, the post-selection only the results of both ancillary qubits gives '0', the output of the algorithm becomes |β〉 with the success probability of [formula].

Polynomial Root-finding by Eigenvalue Estimation Technique

In order to find roots of the polynomial, we will use the circuit shown in Fig. [\ref=fig:5]. A controlled operation of the PRC by the phase qubit is denoted by c-Cp in the figure. To describe the operation, we will firstly assume that the main qubits are initially prepared in an eigenstate |ψj〉 of the companion matrix. An expected state from the operation will be in the form

[formula]

Here we will assume that ωj has a binary expansion in the form [formula], where b is bit-precision. As in IPEA, the c-Cp will be operated 2b - k times in the [formula] iteration as illustrated in Fig. [\ref=fig:6]. The result of the first iteration is given by

[formula]

Similarly, for the [formula] iteration, we have

[formula]

After the operation of Z(θk) with θ1 = 0 and [formula] followed by the Hadamard gate, the phase qubit will be in the following state,

[formula]

The value of xb - k + 1 can be either 0 or 1. Therefore, the probabilities of finding the phase qubit in states |0〉 or |1〉 given that the both ancillary qubits give result 0 depend on the value of xb - k + 1; namely,

[formula]

Since xb - k + 1 can be either 0 or 1, the value of [formula] is either + 1 or - 1. In practice, xb can be obtained by comparing P0 and P1[\cite=gr-prl-76-3228], i.e., xb = 0 if and only if P0 > P1; and xb = 1 if and only if P0 < P1. In addition, the value of |λj| from the [formula] iteration can be calculated from the equation

[formula]

It should be emphasized that in later iterations, the parameter θk used in Z(θk) is constructed from xb - k + 1 from the prior iterations as in IPEA. Finally, an estimate of λj can now be obtained and the corresponding root of the polynomial can be calculated depending on which mode (x-mode or 1 / x-mode) is being used.

However, in general, the eigenstates of the companion matrix are unknown. The following approach is to estimate the greatest eigenvalue [formula]. Suppose that an initial state is prepared in a mixed state, the density operator can be expressed as

[formula]

where Aj is a probability of preparing the initial state in the eigenstate |ψj〉. The operation of c-Cp when the phase qubit is in state |1〉 transforms the density operator as

[formula]

For the [formula] iteration after which c-C2b - kp is operated and followed by Z(θk) and the Hadamard gate, the probabilities of finding phase qubit in states |0〉 or |1〉 given that both ancillary qubits give result 0 are

[formula]

where [formula]. In Equations ([\ref=eq:P0mix]) and ([\ref=eq:P1mix]), the terms with the largest eigenvalue [formula] will dominate if the number of iterations is large enough. Hence, the probabilities P0 and P1 will be reduced to the following forms:

[formula]

The value of xb - k + 1 can be found by comparing P0 and P1. Even without knowing the probability [formula], an estimate of [formula] can be obtained from

[formula]

After the largest root is found, it can be factorized from the polynomial, and the same technique and procedure can be repeated to calculate the other roots.

Discussions

In order to justify the efficiency of the quantum algorithm for finding roots of a polynomial, we have to compare it with the classical algorithm for solving the same problem. One of the most efficient classical algorithms for finding roots of a polynomial is created by Pan in 2002[\cite=pan-symbcomp-33-701]. We shall compare these two versions of the algorithm based on (i) resources required for calculation and (ii) algorithmic complexity.

We start by comparing the number of bits and qubits required by the computations. In order to find roots of an n degree polynomial, the quantum algorithm requires O( log n) qubits. In contrast, Pan's classical root-finding algorithm requires O(n) or O(n log n) bits. This makes it obvious that, for large n, the quantum algorithm requires many fewer bits than its classical counterpart. In this way, the quantum version of algorithm is capable for finding roots of a much higher order degree than the classical one.

Next, we will compare their algorithmic complexities. In Pan's algorithm, the number of operations required to find the roots is

[formula]

where b is the bit precision of the solutions. In contrast, since any m-qubit unitary gates can be simulated using only single-qubit gates and CNOT gates [\cite=ba-prsa-449-679], it is appropriate to compute the complexity of a quantum circuit in terms of the number of single-qubit gates and CNOT gates required to construct the circuit. From polynomial root-finding circuit, many unitary operations are controlled by several qubits. We will use the following corollary to calculate complexity of these gates (See Corollary 7.12 in Barenco et al.[\cite=ba-pra-52-3457]).

Corollary: For any unitary U, the corresponding c-U gate controlled by (m - 2)-qubit can be simulated by O(m) basic operations in m-qubit network, where the initial value of one qubit is fixed and incurs no net change.

In order to apply this corollary with the root-finding circuit, we need one more ancillary qubit and set its initial value to state |0〉. Note that this ancillary qubit can also be reused to simulate several controlled-unitary operations. In order to compute the overall complexity of the whole circuit, a complexity of each part may be found separately. The cyclic-swap gate can be simulated by m CNOT gates. Number of control qubits of each gate varies from 0 to m - 1. For other CNOT gates with multiple control qubits, its operation can be simulated by O(i + 2) operations where i > 1 is the number of control qubits. Therefore the overall complexity of the cyclic-swap gate is [formula]. The formation gate consists of 2m controlled rotation gates. Each gate, which is further controlled by m qubits, can be simulated by O(m + 2) basic operations. Hence the total complexity of the formation gate is O(2mm). The combination gate consists of m Hadamard gates and m NOT gates which brings its overall complexity to O(m). Finally, the complexity of the (m + 1)-qubit CNOT gate before the application of the last Hadamard gate can be readily computed by the corollary above, which amounts to O(m).

The total complexity of the complete circuit is the sum of complexity of each part as described above. However, in the complexity calculation, only the greatest term is kept. In the case of large n (where n is the degree of a polynomial), we can clearly see that the dominant term comes from the formation gate. Therefore, the complexity of the circuit in terms of the degree of a polynomial is

[formula]

for one iteration, or

[formula]

for k iterations. Compared with the classical case for b-bit precision, our approach needs k = 2b and the total complexity of the quantum version is

[formula]

Here, we can validate that the quantum version of the algorithm is less complex than the classical version in the case where the polynomial has a high degree and a small number bit precision is required. On the contrary, the quantum algorithm may be an overkill when finding the roots, with high-bit precision, of a low degree polynomial.

Conclusion

In summary, we have provided a quantum algorithm for finding roots of the [formula] degree polynomial partially based on Daskin et al.'s circuit for finding complex eigenvalues of a general matrix[\cite=dask-qip-13-333]. To make a comparison with classical version of the algorithm, resources and algorithmic complexities are considered. The quantum version requires fewer number of (quantum) bits than its classical counterpart for a high degree polynomial. In terms of algorithm complexities, the quantum algorithm also trumps the classical algorithms for a high degree polynomial, requiring low bit-precision solutions. The growth in complexity stems from a larger number of iterations needed to achieve the desired precision. Although our result clearly shows that finding the roots of polynomials using quantum information scheme is possible, the most important challenge, however, remains in strengthening the algorithm to overcome the classical algorithm both in the utilized resources and the chosen precisions. Another challenge lies of course in the practical issue of a working quantum computer. It is well known that the current quantum computer technology still falls short of the theoretical requirement of the algorithm, especially in terms of the number of entangled qubits and multiple-qubit quantum operations.

Acknowledgement

We would like to thank Assist. Prof. Dr. Kwan Arayathanitkul for helpful discussions. This work is a collaboration of Collaborative Research Unit on Quantum Information, Mahidol University and Optical and Quantum Communication (OQC) Laboratory, National Electronics and Computer Technology Center (NECTEC). Grant No. 035/2557 from the Development and Promotion of Science and Technology Talents project (DPST) scholarship, research fund for DPST graduate with first placement is acknowledged.