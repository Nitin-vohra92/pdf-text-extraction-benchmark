Notes on Geometric-Algebra Quantum-Like Algorithms

Introduction

Quantum algorithms are based on tensor products. Common wisdom states that tensor products are needed for entanglement. A similar situation was encountered in the early 1990s in connectionist systems, and led to the paradigm known as tensor product representations [\cite=Smolensky]. However, nowadays the cognitive science community seems to depert from tensor product representations in favor of their "compressed forms" such as Binary Spatter Codes (BSC) [\cite=Kanerva] or Holographic Reduced Representations (HRRs) [\cite=Plate].

The main reason why BSC and HRRs replace tensor product representations is that tensor multiplication expands dimensions of the associated liner spaces (tensor product of two n-tuples is an n2-tuple). HRRs, for example, replace tensor product with circular convolution, an operation that does not change the dimension (circular convolution of two n-tuples is again an n-tuple). Circular convolution is often referred to as a compressed form of the tensor product. Similarly, in BSC one replaces tensor products by XORs of binary strings. Quite recently, following the general program of investigating similarities and differences between AI, semantic analysis, and quantum information [\cite=AC], we have reformulated BSC in terms of Geometric Algebra (GA) [\cite=ACDM] [\cite=GA1] [\cite=GA2]. This reformulation was made possible by the observation that XOR has a natural representation at the level of geometric product.

In these notes we present a similar reformulation of the Deutsch-Jozsa algorithm [\cite=DJ]. As one can see, after minor modifications the GA algorithm works analogously to the quantum one. Accordingly, it is possible that GA algorithms can perform more general tasks until now reserved for quantum computation. The fact that it was easy to reformulate in a GA way the Deutsch-Jozsa problem is very encourageing.

Finally, let us mention that certain attempts of using GA for the purposes of quantum computation can be found in the literature [\cite=Somaroo] [\cite=BDM3] [\cite=HD]. Still, it seems that the approaches discussed so far reduce GA to the level of unitary operations or density matrices, i.e. objects that have a natural operator representation. In our approach, even "pure states" are represented by elements of GA. This is why we can perform operations on pure states that have no couterpart in standard quantum computation. In this sense our geometric algorithm may be regarded as something conceptually in-between quantum algorithms and HRRs or BSC.

Original Deutsch-Jozsa algorithm

We assume there exists an oracle performing

[formula]

where f(x)∈{0,1}. Now

[formula]

If f(x) = 0 then

[formula]

If f(x) = 1 then

[formula]

The two cases imply

[formula]

The Hadamard gate acts as follows

[formula]

Let

[formula]

Then

[formula]

If f(x) = f(0) for any x then

[formula]

If f is balanced then

[formula]

It is sufficient to look at the [formula] component to see if f is constant or balanced.

Geometric Algebra and its binary parametrization

Here and in the next section we repeat the presentation from [\cite=ACDM].

Euclidean-space GA is constructed as follows. One takes an n-dimensional linear space with orthonormal basis [formula]. Directed subspaces are then associated with the set

[formula]

Here 1 corresponds to scalars, i.e. a 0-dimensional space. Then we have vectors (oriented segments), bivectors (oriented parallelograms), and so on. There exists a natural parametrization: [formula], [formula], [formula], [formula], [formula], [formula], [formula], which shows that there is a one-to-one relation between an n-bit number and an element of GA. An element with k 1s and n - k 0s is called a k-blade.

A geometric product of k 1-blades is a k-blade. For example, e1248 = e1e2e4e8. Moreover, enem =  - emen, if m  ≠  n, and enen = 1, for any n. GA is a Clifford algebra [\cite=BT] enriched by certain geometric interpretations and operations.

Particularly interesting is the form of the geometric product that occurs in the binary parametrization. Let us work out a few examples:

[formula]

The number D is the number of times a 1 from the right string had to "jump" over a 1 from the left one during the process of shifting the right string to the left. Symbolically the operation can be represented as

[formula]

The above observations, generalized to arbitrary strings of bits, yield

[formula]

Indeed, for two arbitrary strings of bits we have

[formula]

where

[formula]

Cartan representation

In this section we give an explicit matrix representation of GA. We begin with Pauli's matrices

[formula]

GA of a plane is represented as follows: 1 = 2  ×  2 unit matrix, e1  =  σ1, e2  =  σ2, e12  =  σ1σ2 = iσ3. Alternatively, we can write e00 = 1, e10  =  σ1, e01  =  σ2, e11 = iσ3, and

[formula]

This is equivalent to encoding 22 = 4 real numbers into two complex numbers.

In 3-dimensional space we have 1 = 2  ×  2 unit matrix, e1  =  σ1, e2  =  σ2, e3  =  σ3, e12  =  σ1σ2 = iσ3, e13  =  σ1σ3 =  - iσ2, e23  =  σ2σ3 = iσ1, e123  =  σ1σ2σ3 = i.

Now the representation of

[formula]

is equivalent to encoding 23 = 8 real numbers into 4 complex numbers.

An arbitrary n-bit record can be encoded into the matrix algebra known as Cartan's representation of Clifford argebras [\cite=BT]:

[formula]

GA formulation of the Deutsch-Jozsa problem

Consider an (n + 1)-dimensional Euclidean space with orthonormal basis [formula], and its associated GA. The basis vector en + 1 in binary parametrization corresponds to [formula]. Recall that

[formula]

and, in particular,

[formula]

Consider

[formula]

The influence of En + 1 on [formula] is similar to ([\ref=1]):

[formula]

Now assume there exists an oracle Ef that performs

[formula]

Then

[formula]

In GA there exists an operation of reverse which reverses the order as follows: If [formula] then the reverse of X is

[formula]

By linearity we extend it to all multivectors. In binary parametrization the number k describes the number of 1s in [formula], i.e. [formula]. So consider

[formula]

Here [formula] since the last bit is 0. Now

[formula]

The dots denote all those term where the binary indices contain at least one 1. The two powers of - 1 have cancelled out since [formula]. Finally

[formula]

Now let Π project on [formula]. It follows that

[formula]

Here N =   Tr  1 is the dimension of the representation of GA. We have achieved the same goal as the quantum algorithm.

We have to point out at this moment a possible error one can make. Let us note that in the step

[formula]

we have Ef on the left and [formula] on the right. It might appear that it would be simpler and more natural to write Ef on the right as well. However, this would be misleading since

[formula]

Explicit examples

Two bits

GA of a plane consists of: 1 = 2  ×  2 unit matrix, e1  =  σ1, e2  =  σ2, e12  =  σ1σ2 = iσ3. Alternatively, we can write e00 = 1, e10  =  σ1, e01  =  σ2, e11 = iσ3.

[formula]

[formula]

[formula]

[formula]

[formula]

Case f(0) = f(1) = 0

[formula]

[formula]

[formula]

Case f(0) = f(1) = 1

[formula]

Since this is minus the result from the previus subsection, we immediately get

[formula]

Case f(0) = 0, f(1) = 1

[formula]

[formula]

[formula]

Alternatively

[formula]

Case f(0) = 1, f(1) = 0

[formula]

This is minus the result from the previou section and therefore   Tr  F2EfE2e10 = 0.

Summing up, constant functions were producing 2( - 1)f(0)21, and balanced functions implied 0, as it should be on general grounds.

Three bits

In 3-dimensional space we have 1 = 2  ×  2 unit matrix, e1  =  σ1, e2  =  σ2, e3  =  σ3, e12  =  σ1σ2 = iσ3, e13  =  σ1σ3 =  - iσ2, e23  =  σ2σ3 = iσ1, e123  =  σ1σ2σ3 = i. The operation   Tr  Π corresponds in this representation to taking the real part of trace (only e000 = 1 and e111 = i have nonzero trace).

Now the representation of a general element reads

[formula]

[formula]

[formula]

[formula]

[formula]

Case of constant f, f(00) = 0

[formula]

[formula]

[formula]

Case of constant f, f(00) = 1

[formula]

[formula]

Case of balanced f, f(00) = 0, f(10) = 0

[formula]

[formula]

[formula]

Final remarks

The above examples show that GA allows for a host of new mathematical tricks with respect to standard quantum computation. The representations of binary numbers are different. There is no distinction between "state vectors" and "operators". One can multiply "state vectors" without increasing the dimension. In the above examples both 2-bit and 3-bit problems were represented by 2  ×  2 matrices, a fact showing that one may expect GA to involve less redundancy than standard tensor representations. One can speak of entanglement in GA representations even though the "states" are not tensored with one another. Here again one finds close analogies to what is known from HRRs and BSC. And, last but not least, it seems there is no general difficulty with translating quantum operations into GA forms, and one can expect all quantum algorithms to have GA analogues.