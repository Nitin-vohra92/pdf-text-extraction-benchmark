Proposition Lemma Conjecture Definition Corollary

An alternative to Riemann-Siegel type formulas

Introduction

The Riemann zeta function is defined for s = σ + it by [formula], σ > 1. It can be analytically continued everywhere except for a simple pole at s = 1. The zeta function satisfies the functional equation ζ(s)  =  χ(s)ζ(1 - s) where χ(s): = πs - 1 / 2Γ((1 - s) / 2) / Γ(s / 2). One is usually interested in numerically evaluating ζ(σ + it) on the critical line σ  =  1 / 2 (e.g. to verify the Riemann hypothesis). However, one cannot use the Dirichlet series [formula] to numerically evaluate zeta when σ < 1 because the series diverges. Rather, one can use partial summation and integration by parts to analytically continue the series to σ > 0, obtaining

[formula]

where [formula] is the analytic conductor of zeta; see [\cite=iwaniec-kowalski]. The analytic conductor terminology was introduced by Iwaniec and Sarnak; see [\cite=iwaniec-sarnak] for example. This terminology will be useful when we generalize our formulas to Dirichlet L-functions, and it ensures that [formula]. We remark, though, that the precise definition of the analytic conductor does not affect the asymptotic content of the results, since [formula] needs only be of a comparable size to |s|.

Formula [\eqref=zeta_trunc] can be viewed as consisting of a main sum [formula], an extra term M- s / 2 + M1 - s / (s - 1), and a remainder RM(s). The main sum accounts for the bulk of the computational effort, the extra term can be computed easily, and the remainder can be controlled by choosing M accordingly. For example, one can ensure that |RM(s)| < ε on taking [formula]. So when σ  =  1 / 2, the main sum consists of [formula] terms, even if ε  =  1 say. Using a more careful analysis, however, one can show that RM(s)  ≪  M-  σ if [formula]. Alternatively, one can use the Euler-Maclaurin summation (see ) which allows for far more accuracy. In either case, though, the resulting main sum is of length [formula]. So these formulas are rather impractical for numerical computations on single processor when [formula], say, especially if high precision is sought. This is unfortunate since they are simple to derive and analyze, and have explicit error bounds. So, instead, one typically uses the Riemann-Siegel asymptotic formula which has a much shorter main sum of length [formula] (see ). The Riemann-Siegel formula was discovered around 1932 in Riemann's unpublished papers by C.L. Siegel. Some of its history is narrated in [\cite=edwards-zeta-book]. In lieu of the Riemann-Siegel formula, one can use the efficient smoothed formulas in [\cite=rubinstein-computational-methods].

We propose a new method for computing zeta based on slowly converging Dirichlet series such as [\eqref=zeta_trunc]. Then we generalize our method to Dirichlet L-functions to a power-full modulus. Interestingly, our results can be derived without knowing about the functional equation of the associated L-function, nor using analysis of similar strength, such as the Poisson summation. To state the results, we introduce some notation. Let

[formula]

where f(j)s(z) and g(j)K(z) denote the j-th derivative in z. We choose integers u0  ≥  1, v0  ≥  u0, and M  ≥  v0, and construct sequences Kr  =  ⌈vr / u0⌉ and vr + 1  =  vr  +  Kr for 0  ≤  r < R, where R: = R(v0,u0,M) is the largest integer such that vR  <  M. We define KR: =  min {⌈vR / u0⌉,M - vR}, so that vR + 1  =  M. Then we divide the main sum in [\eqref=zeta_trunc] into an initial sum of length v0, followed by R + 1 consecutive blocks where the r-th block starts at vr and has length Kr. The sequences Kr and vr are so defined in order to implement a more efficient version of dyadic subdivision of the main sum. There will be substantial flexibility in choosing them (need only Kr - 1  ≤  vr / u0, [formula]), but we do not exploit this here. We plan to approximate the r-th block [formula] by v- srBr(s,m) where

[formula]

which is a linear combination of a geometric sum and its derivatives. Also, we let

[formula]

[formula]

We prove the following theorem in .

Given s = σ + it with σ > 0, let u0 and v0 be any integers satisfying [formula]. Then for any integers M  ≥  v0 and m  ≥  0 we have where [formula]. We have R  <  2u0 log (M / v0) + 1.

We could have used the main sum from the Euler-Maclaurin formula, instead of the main sum in [\eqref=zeta_trunc], to derive Theorem [\ref=zeta_alg]. This permits one to choose M smaller. Indeed, replacing RM(s) by the Euler-Maclaurin correction terms, one can restrict [formula] while retaining high accuracy. In this case, Theorem [\ref=zeta_alg], applied with m = 0, leads to a simple proof of the bound [formula]; see corollary [\ref=zeta_bound] in . The truncation error TM,m in Theorem [\ref=zeta_alg] is bounded by εmBM, where, by lemma [\ref=Kr_bound], we have BM(s,u0,v0)  ≤  v-  σ0  +  (M1 - σ - v1 - σ0)(1 - σ)- 1 if σ  ≠  1, and BM(s,u0,v0)  ≤  v-  σ0  +   log (M / v0) if σ  =  1. This estimate is quite generous, however. It can be improved by computing BM(s,u0,v0) directly, which should yield a bound like u0 / (σvσ0). The said computation can be done in about R steps, and so it is subsumed by the computational effort for the main sum. In either case, the remainder term is clearly easy to control when [formula], due to the rapid decay of εm(s,u0) with m (decays like 1 / ⌊(m + 1) / 2⌋!).

The main sum in Theorem [\ref=zeta_alg] has v0  +  (m + 1)(R + 1) terms, where each term is, basically, a geometric sum. To ensure that |TM,m(s)|  +  |RM(s)|  <  ε for σ = 1 / 2, it suffices to take [formula] and [formula]. Since R  ≤  2u0 log (M / v0) + 1, this is of length [formula] terms. Choosing [formula], which is a typical choice, the main sum thus consists of [formula] terms. We show how to compute these terms (geometric sums) efficiently in , using [formula] precision. So, put together, the complexity of the formula in Theorem [\ref=zeta_alg] depends only logarithmically on M and the error tolerance ε. The formula enables square-root of the analytic conductor complexity, up to logarithmic loss, without using the functional equation, or the approximate functional equation. Also, the usual factor χ(s) does not appear, and the conditions on v0 and u0 imply that [formula]. Nevertheless, the idea behind the theorem is fairly simple. Writing n- s = e- s log n, we have [formula]. So if [formula], as we will have, then s log (1 + k / v)  =  sk / v  +  O(1). In particular, using Taylor expansions, we can approximate [formula] by a linear combination of the geometric sum gK( - s / v) and several of its derivatives. These geometric sums are easy to compute, which is the reason for the savings.

One can shorten the length of the main sum in Theorem [\ref=zeta_alg] to be roughly [formula]. But then instead of obtaining linear exponential sums, one obtains quadratic exponential sums. The length can be further shortened, leading to cubic and higher degree exponential sums. In view of this, Theorem [\ref=zeta_alg] belongs to the family of methods for computing zeta that were derived in [\cite=hiary-fast-methods]. And like these methods (see [\cite=hiary-char-sums]), Theorem [\ref=zeta_alg] can be generalized to Dirichlet L-functions L(s,χ), χ mod q, when q is power-full. To this end, define the analytic conductor for L(s,χ) by [formula]. If χ mod q is non-principal, then we have the trivial bound [formula]. Combined with partial summation we obtain, for σ > 0, that

[formula]

We will only consider the case q = pa for p prime. As in Theorem [\ref=zeta_alg], we divide the main sum in [\eqref=dirichlet_trunc] into an initial sum of length v0, followed by R + 1 consecutive blocks, where the r-th block starts at vr and has length Kr. Let [formula]. Then, in analogy with zeta, we approximate the r-th block [formula] by v- srBr(s,χ,m) where

[formula]

and g(j)K(z,χ,v) denotes the j-th derivative in z. The analogue of BM from Theorem [\ref=zeta_alg] is going to be more complicated to define. To this end, let b: = ⌈a / 2⌉ and, for 0  ≤  d < pb, let Hr,d: = ⌈(Kr - d) / pb⌉ and [formula] where L is as in lemma [\ref=gKr_lemma] and [formula] if gcd (vr + d,p) = 1. Then let

[formula]

In , we prove the following.

Given s = σ + it with σ > 0, a non-principal Dirichlet character χ mod pa with p a prime, let b = ⌈a / 2⌉, and let u0 and v0 be any integers satisfying [formula]. Then for any integers M  ≥  v0 and m  ≥  0 we have where [formula]. We have R  <  2u0 log (M / v0) + 1.

We use the Postnikov character formula in to show that gK(z,χ,v) can be written as a sum of pb geometric sums.

Given a Dirichlet character χ mod pa with p a prime, let b = ⌈a / 2⌉, and Hd: = ⌈(K - d) / pb⌉. Then [formula], where [formula] if (v + d,p) = 1, with [formula], otherwise wd: = 0. Here, L∈[null] and [formula] tends to sgn (t)π / 4 for large t. In explicit form, δ  =   exp (i sgn (t)(π / 4  -  θ)), where θ  =  π / 4 if |t|  ≤  2c / π, θ  =  c / |2t| if |t| > 2c / π, and c > 0 is a free parameter that we can optimize. In particular, δ- s is chosen to cancel out the exponential decay in Γ(s / 2) as t gets large on the l.h.s of [\eqref=smoothed_approx], ensuring that the l.h.s. is ≫  |s|(σ - 1) / 2|ζ(s)|e- c for large t. Although the series in [\eqref=smoothed_approx] are infinite, the weights G(z,w) decay exponentially fast when [formula]. Specifically, following [\cite=rubinstein-computational-methods], we have for [formula] and [formula] that [formula]. So, for |t|  >  2c / π and σ∈[0,1] say, we have [formula], where we used the inequality cos (π / 2 - x)  ≥  x / 2 for 0  ≤  x  ≤  1. Therefore, the series can be truncated after M terms with truncation error [formula]. So to ensure that the truncation error is <  ε, it certainly suffices to take [formula]. Once the series is truncated, it can be evaluated term by term to give a numerical approximation of ζ(σ + it) for |t| > 2c / π. The number of terms in the resulting main sum (i.e. truncated series) is roughly equal to [formula]. The terms in the main sum are more complicated than in the Riemann-Siegel formula since each term involves the smoothing function G(z,w).

In the case of Dirichlet L-functions, Davies [\cite=davies-dirichlet-l-functions], Deuring [\cite=deuring-dirichlet-l-functions], Lavrik [\cite=lavrik], and others had developed Riemann-Siegel type formulas for L(1 / 2 + it,χ), where χ is a primitive character mod q and t  ≫  1. Such formulas, whose general form was already considered by Siegel [\cite=siegel-dirichlet-l-functions], require the numerical evaluation of a main sum of length [formula] terms, where each term is of the form χ(n)n- 1 / 2 exp (it log n). Unfortunately, however, it does not seem that we have an analogue of Gabcke's explicit estimate for the remainder terms in such formulas. And it is not clear how to obtain a posteriori error estimate either. Therefore, we are not prepared to find the accuracy of the numerics resulting from these formulas explicitly. Still, if one is willing to live with a much longer main sum, consisting of about [formula] terms, then one can keep the simplicity of an unsmoothed main sum while having an explicit estimate for the remainder term. The basic idea is well-known, and was implemented carefully by Rumely [\cite=rumely-dirichlet-l-functions]. Essentially, one uses the periodicity of χ to write L(1 / 2 + it,χ) as a linear combination of about [formula] Hurwitz zeta functions, then one approximates each Hurwitz zeta function using the Euler-Maclaurin summation formula. However, since the Euler-Maclaurin formula requires a main sum of length about [formula], the cost of this method is prohibitive in comparison with a Riemann-Siegel approach with explicit remainder. In view of this, one typically uses a smoothing function to accelerate the convergence. Such formulae (see [\cite=rubinstein-computational-methods]) are applicable even for small t and have a main sum of length [formula] terms, where each term involves the computation of a smoothing function.

Proofs of Theorems [\ref=zeta_alg] & [\ref=dirichlet_alg]

We first prove Theorem [\ref=zeta_alg]. The proof of Theorem [\ref=dirichlet_alg] will be similar, but will additionally require a specialization of the Postnikov character formula, lemma [\ref=postnikov]. Recall that we choose integers u0  ≥  1, v0  ≥  u0, M  ≥  v0, and we construct the sequences Kr  =   min {⌈vr / u0⌉,M - vr} and vr + 1  =  vr  +  Kr for 0  ≤  r  ≤  R, where R: = R(v0,u0,M) is the smallest integer such that vR + 1  =  M.

R  =  R(v0,u0,M)  <  2u0 log (M / v0) + 1.

For r < R, we have vr + 1  =  vr  +  Kr  ≥  vr(1 + 1 / u0), and so by induction vr + 1  ≥  v0(1 + 1 / u0)r. If R > 0, then taking r = R - 1 and noting that vR  <  M, we obtain R  <   log (M / v0) /  log (1 + 1 / u0) + 1  ≤  2u0 log (M / v0) + 1, where we used the inequality log (1 + x)  ≥  x / 2 for 0  ≤  x < 1. If R = 0, then clearly the last bound still holds.

Let s = σ + it, σ  ≥  0. Using the same notation for Kr, vr, and R, we have

For k < v, we have [formula]. Thus, e-  σk / v  ≤  (1 + k / v)-  σ. Hence, [formula]. So [formula]. The lemma follows on evaluating the integral.

Let s = σ + it, σ  ≥  0. For any integers [formula], K  ≥  1, and m  ≥  0, such that (K - 1) / v  ≤  1 / u, we have

[formula]

[formula], |Em(s,v,K)|  ≤  εm(s,u) min {gK( - σ / v),| csc (t / (2v))|e-  σ(K - 1) / v}, and εm(s,u) is defined in [\eqref=eps_def].

We have e- s log (1 + k / v)  =  e- sk / vfs(k / v). The function fs(z) is analytic in |z| < 1. Taking the branch of the logarithm determined by fs(0) = 1, we have [formula] for |z| < 1. We expand fs(z) into a power series [formula]. By definition, we have [formula]. So, interchanging the order of summation in j and k, we obtain [formula]. We note that the function xje-  σx is increasing with x if 0  ≤  x < j / σ. So, if 0  ≤  k  <  jv / σ, then (k / v)je-  σk / v increases with k. This last condition, k < jv / σ, is satisfied because, by hypothesis, j > m  ≥  0, so j  ≥  1, and k / v  ≤  1 / u < 1 / σ. Thus, it follows by partial summation that

[formula]

Executing the summation in the geometric sum, we see that it is bounded by | csc (t / (2v))|. Also, by a trivial estimate, [formula]. Thus,

[formula]

We bound cj(s) by a standard application of Cauchy's theorem using a circle around the origin. We have [formula], c∈(0,1). If 0 < j  ≤  |s| / 4, let [formula]. So [formula], where [formula]. We conclude that |cj(s)|  ≤  |s|j / 2j- j / 2eαj for 0 < j  ≤  |s| / 4. Also, for any j  ≥  0, we may choose c = 1 / 2. So we have |cj(s)|  ≤  2jeα|s| / 4 for each j  ≥  0.

Since (K - 1) / v  ≤  1 / u, by hypothesis, we have by the estimate for cj(s), and assuming that m  ≤  |s| / 4, that

[formula]

If |s| / 4 is not an integer, then [formula], where we used [formula] and u  ≥  12. Since this is at most 0.2eα < 0.44 times the last term in first sum on the r.h.s. above, we obtain the estimate

[formula]

Now, for [formula], [formula]. Therefore,

[formula]

where we used [formula] and [formula], so (2.42)(1.44) < 3.5. If |s| / 4 is an integer, on the other hand, then the same bound holds (with an even better constant). It remains to consider the case when m > |s| / 4. Here, we have [formula]. Therefore, [formula]. Put together, we arrive at the claimed bound on Em(s,v,K). To complete the proof of the lemma, notice that

[formula]

So the formula [\eqref=geom_form] follows on interchanging the order of the double sum.

Let χ mod pa be a Dirichlet character, where p is a prime, and let b = ⌈a / 2⌉. Then there exists an integer L mod pa  -  b, depending on χ, p, a, and b only (so independent of x), such that χ(1 + pbx) = e2πiLx / pa - b for all [formula].

The proof is similar to that of [\cite=hiary-char-sums], but we still give it here for completeness. Let H be the subgroup in [formula] consisting of the residue classes congruent to 1 mod pb, so H has size |H| = pa - b. We identify the elements of H with the set of integers {1 + pbx  |  0  ≤  x < pa - b}. Consider the function [formula], defined by ψ(1 + pbx): = e2πix / pa - b By our choice of b = ⌈a / 2⌉, we have [formula]. Therefore, ψ((1 + pbx)(1 + pby)) = ψ(1 + pbx)ψ(1 + pby) for all [formula], meaning that ψ is multiplicative. Also, ψ is not identically zero; e.g. ψ(1)  =  1. Therefore, ψ is a character of H. Moreover, the values ψ(1 + pb)u  =  e2πiu / pa - b, 0  ≤  u  <  pa - b, are all distinct. In particular, ψ has order pa - b, which is the same as the order of H. So ψ generates the full character group of H. Since [formula] is a character of H, then [formula] for some L mod pa  -  b. To find L, we calculate χ(1 + pb), then use the relation χ(1 + pb) = e2πiL / pa - b.

We divide the main sum in [\eqref=zeta_trunc] according to the positions of vr as follows: [formula]. Note that Kr  =  ⌈vr / u0⌉  ≤  vr / u0 + 1 for r < R, and KR  ≤  vR / u0 + 1. So (Kr - 1) / vr  ≤  1 / u0 throughout 0  ≤  r  ≤  R. Thus, the conditions for lemma [\ref=h_sum] are satisfied and we can apply it to each block [formula]. This yields [formula]. And using the estimate for Em(s,v,K) in lemma [\ref=h_sum] yields the required bound on TM,m(s,u0,v0).

This follows from from the definitions and lemma [\ref=postnikov]:

[formula]

Given s = σ + it, σ  ≥  0, and a Dirichlet character χ mod pa with p a prime, let b = ⌈a / 2⌉. Then for any integers [formula], K  ≥  1, and m  ≥  0, such that (K - 1) / v  ≤  1 / u, we have

[formula]

where [formula], and, with Hd  =  ⌈(K - d) / pb⌉, we have

[formula]

The εm(s,u) is defined in [\eqref=eps_def].

Proceeding in the same way as in Theorem [\ref=zeta_alg] and lemma [\ref=gKr_lemma], we arrive at

[formula]

Therefore, using partial summation, as in the proof of lemma [\ref=h_sum], we obtain

[formula]

Combined with the trivial estimate, this yields the lemma.

We divide the main sum in [\eqref=dirichlet_trunc] according to the positions of vr as before: [formula]. We apply lemmas [\ref=h_chi_sum] and [\ref=gKr_lemma] to the sum over k. This yields the result with [formula]. By the estimate for Em(s,χ,v,K) in lemma [\ref=h_chi_sum] we obtain the desired bound on TM,m(s,χ,u0,v0).

Computing [formula] for 0  ≤  j  ≤  m

One can choose the parameters in Theorems [\ref=zeta_alg] & [\ref=dirichlet_alg] so that one can achieve moderate accuracy with m  ≤  8, say. So, in general, computing (f(j)s(0) / j!)(g(j)K(z) / vj) will be quite easy, and can be done using closed-form formulas to evaluate the geometric sum. The methods that we present below are intended for when j is large, but they can be used for any j  ≥  0. In our application (Theorems [\ref=zeta_alg] & [\ref=dirichlet_alg]), we have [formula], and [formula]. So we will assume that this holds throughout.

We recall that [formula] for |z| < 1. For example,

[formula]

To find f(j)s(0) in general, let [formula], so f(j)s(z)  =  Qs,j(z)esq(z) for some [formula] that satisfies the recursion Qs,0(z): = 1 and [formula]. Therefore, wj,0(s)  =  f(j)s(0), w0,0(s)  =  1, w0,l(s) = 0 for l > 0, and [formula]. Using this recursion, one can find all of f(j)s(0) = wj,0(s) for 0  ≤  j  ≤  m in about (m + 1)2 steps. In carrying out the recursion, one may treat s symbolically, so wj,0(s) is viewed as a polynomial in s and the recursion is finding the coefficients of this polynomial. In fact, it follows from the recursion that, more generally, wj,l(s) is a polynomial in s of degree ≤   min {(j + l) / 2,j}. So we may write [formula]. Also, β0,0,0  =  1, β0,0,η = 0 for η > 0, β0,l,η = 0 for l > 0, and we have [formula]. Therefore, using induction, we obtain the bound |βj,l,η|  ≤  (j + l)!2l + 1 / l!. In particular, |βj,0,η| / j!  ≤  2. Thus, the number of bits needed to represent |βj,0,η| / j!, and hence to compute f(j)s(0) / j! as a polynomial in s, to a given precision, is also well-controlled.

As for computing g(j)K(z), one can use the formula [formula], where w(z): = eKz - 1 and y(z): = (ez - 1)- 1. So for [formula] we have

[formula]

The factor 2- j is inserted inside the sum in [\eqref=fg_comp] in order to to control the size of the binomial coefficient [formula]. By hypothesis, [formula]. So, recalling that [formula], |βj,0,η|  ≤  2(j!), and [formula], we obtain |f(j)s(0)2j(K - 1)j| / (j!vj)  ≤  5. In particular, the number of bits needed to represent the outside factor in [\eqref=fg_comp] is well-controlled, and we may focus on computing the sum enclosed in parentheses.

To that end, we consider the computation of [formula] in [\eqref=fg_comp]. If [formula] is small, this can be done by directly differentiating y(z), but this is not a practical method if [formula] is large. Instead, we note that zy(z) = z / (ez - 1) is the exponential generating function for the Bernoulli numbers, specifically,

[formula]

Therefore, for [formula],

[formula]

Using the periodicity of ez, and our assumption on z, we can ensure that the argument given to g(j)K(z) satisfies |z|  <  3π / 2. Thus, the above formulas will suffice to compute [formula] provided that |z| is sufficiently bounded away from 0, say |z| > (m + 1) / (K - 1). For such z, and assuming that K > 2π(m + 1) (otherwise, we may compute g(j)K(z) by direct summation in ≪  m + 1 steps), we obtain that [formula] is bounded by a constant, and so its size is well-controlled. Thus, the only remaining case is when |z| < (m + 1) / (K - 1), with K > 2π(m + 1). In this case, we use the Euler-Maclaurin summation. To this end, let hj,z(x): = xjezx. Then [formula]. Note that, using the periodicity of ezk and conjugating if necessary, we may assume that [formula]. By the Euler-Maclaurin formula (see [\cite=rubinstein-computational-methods]), we have

[formula]

where [formula] is the [formula]-st derivative of hj,z(x) with respect to x, and the remainder term [formula], where B2L(x) is the 2L-th Bernoulli polynomial (e.g. B2(x)  =  x2 - x + 1 / 6), and {x} is the factional part of x. Now, [formula]. Thus, we have

[formula]

Also, from the Fourier expansion for B2L({x}) (see [\cite=rubinstein-computational-methods]), [formula]. Therefore, since [formula], we deduce that |EK,j,z,L| / (K - 1)j  ≤  4(K - 1)(2π)- 2L, which decays exponentially with L.

As for the main term [formula] in formula [\eqref=em_geometric], its computation does not present any difficulty since |z| < m / K (so z is small). For example, one can split the interval of integration into m + 1 consecutive subintervals of equal length, then, after a suitable change of variable, apply Taylor expansions to the integrand in each subinterval, which reduces the problem to integrating polynomials. Alternatively, one can use a numerical quadrature rule.

A convexity bound

We will use the following well-spacing lemma to prove corollary [\ref=zeta_bound].

Let [formula] be a set of real numbers. Suppose there exists a positive integer Q such that min n  ≠  n'|xn - xn'|  ≥  1 / (2Q). Then, for any y  ≥  x and any P  ≥  1, we have

[formula]

where A is any positive integer that satisfies A  ≤  Q / P.

Since |xn - xn'|  ≥  1 / (2Q) for n  ≠  n', then for any integer k we have [formula]. Using the inequality | sin (πα)|  ≥  2|α|, - 1 / 2  ≤  α  ≤  1 / 2, we obtain that [formula]. Combined with the inequality [formula], this gives *    ≤  2(A + 1)P + 2Q log (Q / A). Since the interval

[formula]

The bound that we obtain in corollary [\ref=zeta_bound] for zeta is, of course, superseded by the bound that one can obtain from the Riemann-Siegel formula. Nevertheless, it illustrates that Theorem [\ref=zeta_alg] yields a convexity bound of similar strength to the Riemann-Siegel formula, up to a constant factor, even though it is quite elementary.

[formula].

We will use Theorem [\ref=zeta_alg], but replacing RM(s) by the correction terms from the Euler-Maclaurin formula for ζ(s) (see the paragraph following the statement of the theorem). We take s = 1 / 2 + it, m = 0, [formula], M = 10⌈t⌉, and assume that t  ≥  36, as we may. Given our choice of M, it is not hard to show that the Euler-Maclaurin correction terms contribute ≪  1. And given our choice of u0, we have ε0(s,u0)  ≪  1. By routine calculations, [formula] and [formula]. Thus,

[formula]

It is helpful to recall that Kr  =  ⌈vr / u0⌉ for r < R, vr + 1 = vr + Kr, and [formula]. So, letting [formula], we see that if [formula], then [formula]. We let [formula] denote the interval containing M, so [formula]. Then, using simple estimates, we obtain

[formula]

Now, consider that for [formula], with r < R, we have

[formula]

where B is the smallest positive integer such that t / (2πu20)  ≥  1 / B. Note that, since [formula], then B  ≪  1. Also, as vr ranges over [formula], the argument t / (2πvr) moves by increments [formula], and it spans an interval of length [formula]. Therefore, applying lemma [\ref=csc_sum_lemma] to the set [formula] with [formula], A = B, and [formula], we obtain

[formula]

It follows that [formula]. So we conclude, [formula].

Parameter choices

Theorem [\ref=zeta_alg] offers a simple method for computing ζ(σ + it) with an explicit error bound. The control over the error term in the theorem goes beyond what the Riemann-Siegel asymptotic formula enables. Theorem [\ref=dirichlet_alg] achieves the same for L(σ + it,χ) when χ is power-full.

We implemented a basic version of Theorem [\ref=zeta_alg] in !Mathematica 9!, which is an application for computation, see . This was sufficient for our purposes as we were mainly interested in learning about reasonable choices of the parameters. This way, we could appraise the accuracy and running time in practice. The !Mathematica! notebook containing the implementation is available at .

Our computation relies on finite precision arithmetic, which introduces round-off errors. Such errors become significant for large t. This is primarily because the computation of t log n mod 2π will contain only a few correct digits for large t. In general, one cannot expect more than ±  εmach  t log n accuracy when computing eit log n, where εmach is the machine epsilon. So if t > 1 / εmach say, then, certainly, numerical results will not be meaningful. To overcome this problem, one could switch to an arithmetic system with a smaller machine epsilon (but having a slower performance). Assuming that round-off errors behave like independent random variables, which is a reasonable model, the accumulated round-off error in computing [formula] will be typically like [formula]. For double-precision arithmetic, εmach  =  2- 52  ≈  2  ×  10- 16. So, if we use double-precision arithmetic with t = 10d and M  ≈  10t, the accumulated round-off error will be like ±  10d - 16 log 103(d + 1) / 2.

With this in mind, we obtained marginally better control over the round-off errors by using the main sum from the Euler-Maclaurin formula with 6 correction terms, and with [formula], in particular we did not need to take M very large. We computed gK(z) using the formula (eKz - 1) / (ez - 1) when |z| > 10(m + 1) / (K - 1) (as is typically the case), and using the !Mathematica! built-in Euler-Maclaurin summation routine when |z| < 10(m + 1) / (K - 1). To check the accuracy of the results, we compared them with the outputs from !lcalc! and the !Mathematica! built-in zeta routine, leading to Table [\ref=compos]. We attempted to increase the accuracy by inputting t in !Mathematica! using a higher precision. However, it is likely that !Mathematica! still uses double-precision arithmetic in intermediate steps and some built-in routines. So the accuracy of many stages of the computation will be limited by the machine epsilon for double-precision numbers.

The error entries in Table [\ref=compos] are significantly smaller than the explicit bound for TM,m(s,u0,v0) given in Theorem [\ref=zeta_alg]. For example, when t = 1010 and m = 6, the explicit bound gives |TM,m(s,u0,v0)|  ≤  2.9  ×  10- 3 (here, we calculated BM(s,u0,v0) directly). This is significantly larger than the observed error 1.9  ×  10- 10 in Table [\ref=compos]. This is not surprising, and is due to the pseudo-random nature of round-off errors.

There was no attempt to optimize our implementation since, in any case, it is not competitive with an implementation directly in !C/C++!. With our parameter choices, and for large t, the implementation was slower by factor of about 2(m + 1)2 log t compared to computing the main sum in a Riemann-Siegel formula directly (in both cases we input t in higher precision than double-precision). The implementation was faster by a factor of about [formula] than computing [formula] directly (this is essentially the main sum in the Euler-Maclaurin formula). It might be possible to speed up the implementation by a factor of m + 1 if the derivatives g(j)K(z), 0  ≤  j  ≤  m, are computed simultaneously via a recursion. One can also save a factor of 2 by choosing [formula] instead of [formula], at the expense of a larger truncation error TM,m(s,u0,v0).