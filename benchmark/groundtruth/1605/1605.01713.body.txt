Introduction

As neural networks become increasingly popular, their "black box" reputation is a barrier to adoption when interpretability is paramount. Understanding the features that lead to a particular output builds trust with users and can lead to novel scientific discoveries. [\citet=Simonyan2013-hk] proposed using gradients to generate saliency maps and showed that this is closely related to the deconvolutional nets of [\citet=Zeiler2014-sk]. Guided backpropagation [\citep=Springenberg2014-gg] is another variant which only considers gradients that have positive error signal. As shown in Figure 2, saliency maps can be substantially improved by simply multiplying the gradient with the input signal, which corresponds to a first-order Taylor approximation of how the output would change if the input were set to zero; as we show, the layer-wise relevance propagation rules described in [\citet=Bach2015-pq] reduce to this approach, assuming bias terms are included in the denominators.

Gradient-based approaches are problematic because activation functions such as Rectified Linear Units (ReLUs) have a gradient of zero when they are not firing, and yet a ReLU that does not fire can still carry information (Figure 1). Similarly, sigmoid or tanh activations are popular choices for the activation functions of gates in memory units of recurrent neural networks such as GRUs and LSTMs [\citep=Chung2014-uj] [\citep=Hochreiter1997-yn], but these activations have a near-zero gradient at high or low inputs even though such inputs can be very significant.

We present DeepLIFT, a method for assigning feature importance that compares a neuron's activation to its 'reference', where the reference is the activation that the neuron has when the network is provided a 'reference input' (the reference input is defined according to what is appropriate for the task at hand). This addresses the limitation of gradient-based approaches because the difference from the reference may be non-zero even when the gradient is zero.

DeepLIFT Method

We denote the contribution of x to y as Cxy. Let the activation of a neuron n be denoted as An. Further, let the reference activation of neuron n be denoted A0n, and let the An  -  A0n be denoted as δn. We define our contributions Cxy to satisfy the following properties.

Summation to δ

For any set of neurons S whose activations are minimally sufficient to compute the activation of y (that is, if we know the activations of S, we can compute the activation of y, and there is no set S'  ⊂  S such that S' is sufficient to compute the activation of y - in layman's terms, S is a full set of non-redundant inputs to y), the following property holds:

[formula]

That is, the sum over all the contributions of neurons in S to y equals the difference-from-reference of y.

Linear composition

Let Ox represent the output neurons of x. The following property holds:

[formula]

In layman's terms, each neuron 'inherits' a contribution through its outputs in proportion to how much that neuron contributes to the difference-from-reference of the output.

Backpropagation Rules

We show that the contributions as defined above can be computed using the following rules (which can be implemented to run on a GPU). The computation is reminiscent of the chain rule used during gradient backpropagation, as equation 2 makes it possible to start with contribution scores of later layers and use them to find the contribution scores of preceding layers. To avoid issues of numerical stability when δn for a particular neuron is small, rather than computing the contribution scores explicitly, we instead compute multipliers mxy that, when multiplied with the difference-from-reference, give the contribution:

[formula]

Let t represent the target neuron that we intend to compute contributions to, and let Ox represent the set of outputs of x. We show that:

[formula]

The equation above follows from the linear composition property and the definition of the multipliers, as proved below:

[formula]

In the equations below, Iy denotes the set of inputs of y.

Affine functions

Let

[formula]

Then mxy  =  wxy

Proof. We show that [formula].

Using the fact that An  =  A0n  +  δn, we have:

[formula]

We also note that the reference activation A0y can be found as follows:

[formula]

Thus, canceling out A0y yields:

[formula]

Max operation

We consider the case of max operation such as a maxpool:

[formula]

Then we have:

[formula]

Where [formula] is the indicator function. If a symbolic computation package is used, then the gradient of y with respect to x can be used in place of [formula].

Proof.

[formula]

Maxout units

A maxout function has the form

[formula]

i.e. it is the max over n affine functions of the input vector [formula]. For a given vector of activations [formula] of the inputs, we split [formula] into segments such that over each segment s, a unique affine function dominates the maxout and the coefficient of an individual input x over that segment is w(s)xy. Let l(s) denote the fraction of [formula] in segment s. We have:

[formula]

Intuitively speaking, we simply split the piecewise-linear maxout function into regions where it is linear, and do a weighted sum of the coefficients of x in each region according to how much of [formula] falls in that region.

Other activations

The following choice for mxy, which is the same for all inputs to y, satisfies summation-to-delta:

[formula]

This rule may be used for nonlinearities like ReLUs, PReLUs, sigmoid and tanh (where y has only one input). Situations where the denominator is near zero can be handled by applying L'hopital's rule, because by definition:

[formula]

Element-wise products

Consider the function:

[formula]

We have:

[formula]

Thus, viable choices for the multipliers are mx1y  =  A0x2  +  0.5δx2 and mx2y  =  A0x1  +  0.5δx1

A note on final activation layers

Activation functions such as a softmax or a sigmoid have a maximum δ of 1.0. Due to the summation to δ property, the contribution scores for individual features are lower when there are several redundant features present. As an example, consider At  =  σ(Ay) (where sigma is the sigmoid transformation) and Ay  =  Ax1  +  Ax2. Let the default activations of the inputs be A0x1  =  A0x2  =  0. When x1  =  100 and x2  =  0, we have Cx1t  =  0.5. However, when both x1  =  100 and x2  =  100, we have Cx1t  =  Cx2t  =  0.25. To avoid this attenuation of contribution in the presence of redundant inputs, we can use the contributions to y rather than t; in both cases, Cx1y  =  100.

A note on Softmax activation

Let t1,t2...tn represent the output of a softmax transformation on the nodes y1,y2...yn, such that:

[formula]

Here, Ay1...Ayn are affine functions of their inputs. Let x represent a neuron that is an input to Ay1...Ayn, and let wxyi represent the coefficient of Ax in Ayi. Because Ay1...Ayn are followed by a softmax transformation, if wxyi is the same for all yi (that is, x contributes equally to all yi), then x effectively has zero contribution to Ati. This can be observed by substituting Ayi  =  wxyiAx  +  ryi in the expression for Ati and canceling out ewxyiAx (here, ryi is the sum of all the remaining terms in the affine expression for Ayi)

[formula]

As mentioned in the previous subsection, in order to avoid attenuation of signal for highly confident predictions, we should compute Cxyi rather than Cxti. One way to ensure that Cxyi is zero if wxyi is the same for all yi is to mean-normalized the weights as follows:

[formula]

This transformation will not affect the output of the softmax, but will ensure that the DeepLIFT scores are zero when a particular node contributes equally to all softmax classes.

Weight normalization for constrained inputs

Let y be a neuron with some subset of inputs Sy that are constrained such that [formula] (for example, one-hot encoded input satisfies the constraint [formula], and a convolutional neuron operating on one-hot encoded rows has one constraint per column that it sees). Let the weights from x to y be denoted wxy and let by be the bias of y. It is advisable to use normalized weights xy  =  wxy  -  μ and bias y  =  by  +  cμ, where μ is the mean over all wxy. We note that this maintains the output of the neural net because, for any constant μ:

[formula]

The normalization is desirable because, for affine functions, the multipliers mxy are equal to the weights wxy and are thus sensitive to μ. To take the example of a convolutional neuron operating on one-hot encoded rows: by mean-normalizing wxy for each column in the filter, one can ensure that the contributions Cxy from some columns are not systematically overestimated or underestimated relative to the contributions from other columns.

Results

Tiny ImageNet

A model with the VGG16 (Long et al., 2015) architecture was trained using the Keras framework [\citep=Chollet2015-ya] on a scaled-down version of the Imagenet dataset, dubbed 'Tiny Imagenet'. The images were 64  ×  64 in dimension and belonged to one of 200 output classes. Results shown in Figure 2; the reference input was an input of all zeros after preprocessing.

Genomics

We apply DeepLIFT to models trained on genomic sequence. The positive class requires that the DNA patterns 'GATA' and 'CAGATG' appear in the length-200 sequence together. The negative class has only one of the two patterns appearing once or twice. Outside the core patterns (which were sampled from a generative model) we randomly sample the four bases A, C, G and T. A CNN was trained using the Keras framework [\citep=Chollet2015-ya] on one-hot encoded sequences with 20 convolutional filters of length 15 and stride 1 and a max pool layer of width and stride 50, followed by two fully connected layers of size 200. PReLU nonlinearities were used for the hidden layers. This model performs well with auROC of 0.907. The misclassified examples primarily occur when one of the patterns erroneously arises in the randomly sampled background. We then run DeepLIFT to assign an importance score to each base in the correctly predicted sequences. The reference input is an input of all zeros post weight-normalization (see 2.6) of the first convolutional layer (after weight normalization, the linear activation of a convolutional neuron for an input of all zeros is the bias, which is the same as the average activation across all four bases at each position). We compared the results to the gradient*input (Figure 3).

Equivalence of gradient*input to Layer-wise Relevance Propagation

We show when all activations are piecewise linear and bias terms are included in the calculation, the Layer-wise Relevance Propagation (LRP) of Bach et al., reduces to gradient*input. We refer to Samek et al. (2015) for the concise description of LRP:

Unpooling: "The backwards signal is redirected proportionally onto the location for which the activation was recorded in the forward pass": This is trivially the same as gradient*input, because the gradient*input will be zero for all locations which do not activation the pooling layer, and equal to the output for the location that does.

Filtering: We consider the first rule described in Samek et al., where zij  =  a(l)iw(l,l + 1)ij is the weighted activation of neuron i onto neuron j in the next layer, and l is the index of the layer:

[formula]

The term involving ε is included to avoid issues of numerical instability when [formula] is near zero. The second rule described in Samek et al. is another variant designed to address the problem of numerical instability. We show that gradient*input gives the exact result as ε  →  0 (i.e. it solves the issue of numerical instability altogether).

Dropping the term for ε and substituting zij  =  a(l)iw(l,l + 1)ij, we have:

[formula]

Assuming the bias term is included (which would be necessary for the conservation property described in Bach et al. to hold), the denominator is simply the activation of neuron j, i.e.:

[formula]

Let us now consider what happens when there are two filtering operations applied sequentially. Let Rik denote the relevance inherited by neuron i in layer l from neuron k in layer l + 2, passing through the neurons in layer l + 1. We have:

[formula]

Thus, we see that denominator a(l + 1)j for the intermediate layer cancelled out, leaving us with a(l)iw(l,l + 1)ijw(l + 1,l + 2)jk, where w(l,l + 1)ijw(l + 1,l + 2)jk is the gradient of a(l + 1)k with respect to a(l)i. The only term left in the denominator is the activation of the last layer, a(l + 1)k; if we set the relevance of neurons in the final layer to be equal to their own activation, then R(l + 2)k (assuming k is the last layer) would cancel out a(l + 1)k in the denominator, leaving us with:

[formula]

Which is simply equal to the activation a(l)i multiplied by the gradient of ak with respect to a(l)i. In situations where the relevance of the last layer is not the same as its activation (which may happen if there is a nonlinear transformation such as a sigmoid, as a sigmoid output of 0.5 occurs when the input is 0), one can simply compute gradient*input with respect to the linear term before the final nonlinearity (which is what we did; for softmax layers, we apply the normalization described in 2.5).

Nonlinearity: "The backward signal is simply propagated onto the lower layer, ignoring the rectification operation": While this is not obviously the same as gradient*input, it should be noted that when a rectified linear unit is inactive, it has an activation of zero and the rule for filtering (described above) would assign it zero importance. Furthermore, when the rectified linear unit is active, its gradient is 1. Thus, when the unit is inactive, gradient*input is 0 and LRP assigns 0 signal; when a unit is active, gradient*input is equal to the output and LRP assigns all signal. The two approaches converge.

Discussion

Prevailing feature importance methods such as the saliency maps of Simonyan et al., the deconvolutional nets of Zeiler et al. and the guided backpropagation of Springenberg et al. are variants of computing gradients. As shown in Figure 1, this can give misleading results when the local gradient is zero. DeepLIFT instead considers the deviation from a neuron's reference activity. This makes it capable of handling RNN memory units gated by activations that have vanishing gradients (eg: sigmoid, tanh).

Layer-wise Relevance Propagation (LRP), proposed by Bach et al., does not obviously rely on gradients; however, as we show, if all activations are piecewise linear, LRP reduces to gradient*input (a first-order Taylor approximation of the change in output if the input is set to zero). If all reference activations are zero (as happens when all bias terms are zero and all reference input values are zero), DeepLIFT and LRP give similar results (except that by computing contributions using multipliers, DeepLIFT circumvents the numerical stability problems that LRP faces). In practice, biases are often non-zero, which is why DeepLIFT produces superior results (Figures 2 & 3).

Author contributions

AS & PG conceived of DeepLIFT. AS implemented DeepLIFT in software. PG led application to genomics. AYS led application to Tiny Imagenet. AK provided guidance and feedback. AS, PG, AYS & AK prepared the manuscript.