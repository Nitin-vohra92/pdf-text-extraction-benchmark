Estimating the number of receiving nodes in 802.11 networks via machine learning techniques

Introduction

Nowadays, more than two billions of smartphones are active in the global market [\cite=smartphone]. One of the most important features of a smartphone is to provide an Internet connection, allowing each user to access/share their data, e.g., e-mails, photos, videos, etc.

Two main factors usually affect a smartphone's capability to stay connected and exchange data: the battery life and the amount of data provided by the cellular carrier subscription. These can be addressed by exploiting heterogeneous wireless interface cards (WNICs) such as WiFi and Bluetooth, in order to simultaneously minimize the battery consumption and save a portion of the data transferred by the cellular network [\cite=d2dbattery]. However, this capability to automatically exploit heterogeneous WNICs is not yet supported by any smartphone service; indeed, if a user wants to connect her/his device to a WiFi connection, she/he has to manually set it up, provided that she/he either knows the SSID and the WiFi encryption parameters, or decides whether an open WiFi connection is worth trusting.

In the last few years, researchers in the Software Defined Networking (SDN) area have been focused on creating a software protocol suite that is decoupled from the underlying hardware. This entails the possibility to, e.g., prototype new protocols [\cite=mckeown2008openflow] and create network virtualization and traffic isolation (the reader can find a complete overview in [\cite=SDN_SURVEY]). The SDN paradigm goes in this direction by decoupling the network traffic into two planes: the control plane and the data plane. The control plane aims at monitoring routers, switches and Access Points (APs) to handle the network behavior and report any kind of useful information to a centralized unit, called controller. The controller can establish one or more data traffic flows among the network hosts by using the information gathered from the network status. These can be configured through some predefined Quality of Service network policies, such as offloading, number of hops between two users or energy consumption for the User Equipment (UE). Therefore, a controller can exchange information and manipulate the switch/router behavior by employing an ad hoc protocol like OpenSwitch [\cite=open_switch]. On the other hand, the data plane handles all the data traffic generated by the host, which is completely separated from the control plane.

A further step in this direction can be undertaken when the SDN concept is paired with wireless technologies, as explained in [\cite=openroads] [\cite=sdn_wifi_dense_2]. For the above-mentioned purpose, a number of real WiFi SDN testbed implementations have been presented, e.g., OpenRoads [\cite=openroads], Odin [\cite=odin], OFRewind [\cite=ofrewind] and CARMEN [\cite=carmen]. Among these testbeds, OpenRoads and CARMEN are the most promising: the former was the first testbed to exploit OpenSwitch and to give the possibility to use a WiFiMax connection to test traffic offloading between two heterogeneous wireless interfaces; the latter has 50 WiFi nodes in fixed positions deployed in a university campus area. Moreover, three features characterize CARMEN from the other testbeds: it is able to collect all network parameters from datalink layer to application layer, it can exploit Android smartphone devices for mobility analysis, and it provides each node with at least two IEEE 802.11 WNICs.

Finally, a further possibility is to integrate the device to device (D2D) communication into the SDN concept. D2D communication arises when two mobile nodes are able to communicate directly without traversing any infrastructure, i.e., a base station (more details regarding the D2D concept can be found in [\cite=asadi2014survey]). D2D can generally exploit cellular spectrum (i.e., inband) or unlicensed spectrum (i.e., outband). In a D2D architecture the device network interfaces are expected to be overseen/controlled by a central entity e.g., the SDN controller. Outband allows to eliminate the interference issues between D2D and cellular links, at the cost of an extra interface to be used, as it usually adopts other wireless technologies, such as WiFi, Bluetooth or IEEE 802.15.4. Therefore, the SDN paradigm applied to D2D makes it possible to dynamically switch between different interfaces during transmission, based on predefined policies, e.g., data offloading, traffic balance and battery energy consumption. Hence, it is possible to design and implement a heterogeneous network environment where the device can exploit both network interfaces through the D2D concept in an unlicensed band. The idea to couple SDN and D2D has already been studied in [\cite=cellular_offloading] [\cite=sdn_heterogenus1] [\cite=sdn_heterogenus2], as well as the exploitation of the WiFi-Direct paradigm to set up a D2D network [\cite=wifi_direct1] [\cite=wifi_direct2] with several devices.

In this work, we exploit CARMEN to generate an SDN scenario, where a D2D network is configured with WiFi Direct. The SDN controller, installed into the centralized radio access network (C-RAN), exploits an LTE connection to create a D2D network and to select its master node. The aim is to predict client-side information related to the nodes generating data traffic in the same D2D network. This procedure should: i) not interact with any SDN controller; ii) be completely transparent for the user; and iii) avoid to alter any network or SDN protocol (e.g., OpenSwitch/OpenFlow). In our previous work [\cite=deltesta_globecomm], we considered an SDN WiFi scenario with a node designated as the access point (i.e., master in case of a WiFi Direct scenario) and a varying number of nodes acting as clients. These nodes collected several network parameters in order to accurately predict an Estimated Time of Arrival (ETA). There, we used the number of simultaneously receiving nodes as an input datum, assuming that this information was available at each device. However, this assumption is unrealistic in practice, as the number of receiving nodes is only known to the transmitter (access point) which, in general, does not share this value unless a modification of the transmission protocol is introduced. Moreover, two reasons prevent the SDN controller from acknowledging how many nodes are actively involved in data reception inside the WiFi D2D network. First, the master is acting as D2D gateway, and the LTE C-RAN side is completely blind regarding who is generating the traffic data. Second, the slave nodes use their local OpenFlow table already configured for D2D, and do not report any information to the SDN controller through the LTE connection.

In this paper, we show how the number of the active UEs can be estimated accurately by the receiving nodes, by means of Machine Learning (ML) techniques and by taking as input only those network parameters available at the client side, in order to respect the requirement of not modifying any protocol. In order to accomplish this, we measure the amount of time needed for the transmission of the first fraction of a file from the AP to a receiving node, together with other information, e.g., the distance of each node to the AP and its transmission power.

The rest of the paper is organized as follows. In Section [\ref=sec:testbeddataset] we describe the testbed and the dataset employed in our experiments. In Section [\ref=sec:ml] we offer an overview on the ML techniques considered to estimate the number of active nodes. Section [\ref=sec:results] presents the experimental evaluation of the ML techniques used to predict the number of active nodes. Finally, Section [\ref=sec:conclusions] concludes the paper and proposes some future work.

Testbed and dataset

In this section, we describe how the data was collected and characterize the dataset in terms of dimensionality and network parameters.

WiFi Testbed

We conducted a thorough experimental data gathering to measure different network realizations and their related outputs. The data was collected using CARMEN [\cite=carmen], composed of 50 Alix miniPCs model 3d2 with WiFi driver ath9k and five Nexus 7 devices with the ath9k_htc WiFi driver. In order to minimize the setup time of a specific WiFi network and quickly collect its performance, this testbed was associated with a software able to automatically gather data and change the network configurations. This software can collect the TCP/IP stack parameters, starting from the MAC sublayer up to the Application layer, and to remotely set the WiFi transmission channel and power, as well as the distance among the Alix nodes and the transmitter (more details can be found in [\cite=carmen]). In addition, we exploited the GNU program cron to schedule all experiments at different times of the day, in order to automate the entire data collection phase. Being the data transmissions dependent on the channel status, several WiFi network setups were considered, by changing all possible parameters in order to modify the scenario and consequently the ETA measurements. Since the testbed is located inside our department, other WiFi nodes transmitting data can occupy the WiFi transmission channel, generating interference during the experiments. Our idea to mitigate this issue was to measure transmission data multiple times over different WiFi frequencies (channels) and times of the day (i.e., morning, afternoon and night).

Dataset characterization

The final dataset has been created by varying, for each time of the day, the following network and topology parameters: transmission power {0 dBm, 5 dBm, 10 dBm, 15 dBm, 20 dBm} , WiFi transmission channel {1, 6, 11}, number of nodes simultaneously receiving data from the transmitter N (from 1 to 4), and distance between the transmitter and the receivers {1 m, 5 m, 10 m}. For each configuration, we measured the transmission duration of a 100 MB file (the average size of a music video in full HD resolution). Each configuration of the network has been tested 10 times, and the experimental campaign lasted more than 45 days, for a total of M  =  5400 experiments. The network is deployed following a single-hop star topology, with a transmitting central node, called Access Point, and one or more nodes waiting for data reception.

The dataset has been divided into a training set [formula] and a test set [formula]: 80% of the data was assigned to the former, leaving the remaining 20% for performance testing, in order to take into account the trade-off between learning quality and classification accuracy. In particular, the classification performance was tested using four subsets of the network parameters as input features, in order to measure how a higher number n of known parameters could improve the final classification performance: the first subset contains only the ETA, whereas the others include either the ETA and the transmission power (PTx) or the ETA and the distance d, or all three features (ETA, PTx, d). All these network parameters are available at the receiving nodes, thus no modification of the standard signaling protocol is needed. Each value in either [formula] or [formula] is the number N of nodes actively receiving data from the AP, and is associated to its corresponding input feature vector in [formula] or [formula].

Finally, we tried to simulate a real case scenario, where we assess the classification performance in a more crowded environment, e.g., a domestic location, in which the distribution of simultaneously receiving nodes is shifted towards N  =  4 nodes. We introduced this case to study how the different classification algorithms are affected by this choice and whether a change in the parameters of the classification model leads to a better performance.

Overview of ML techniques

In this section, we first describe the structure of the dataset we used to collect data from the experiments and later introduce the classification techniques adopted to predict the number of users simultaneously receiving data from the AP.

Data structure

The dataset adopted in this work is composed by a matrix of input data [formula] and a vector of outputs [formula]. The i-th row in [formula] and the i-th element in [formula] define a pair [formula], for [formula], where [formula] is the input feature vector and y(i) is the label representing the value of N related to [formula] (i.e., the number of active nodes during that transmission). We used different supervised classification techniques to identify the model that best associates a given subset of the examples in [formula] to a set of labels, pairing each example [formula] to a class. We split the dataset into a training set [formula] used to train and optimize the learning algorithms, and a test set [formula], to evaluate the performance of each classifier.

Naive Bayes classifier

The Bayesian classifier [\cite=Duda] is a probability model that computes the posterior probability [formula] of a class given an input example [formula], for each of the k possible classes. Using Bayes' rule, this probability is computed as

[formula]

where the posterior probability is proportional to the likelihood [formula] and the prior p(yk). The object [formula] is classified under the class that holds the highest posterior probability:

[formula]

known as Maximum A Posteriori (MAP) formulation. The likelihood expresses how probable the input data [formula] is for a given class yk, whereas the prior captures the assumptions about the class, before observing the data, in the form of a prior probability distribution p(yk). If no prior knowledge about the class distribution is available, a uniform prior p(yk) = c is assumed and [\eqref=eq:MAP] turns into the Maximum Likelihood (ML) solution [formula]. The likelihood function can be modeled using different probability distribution functions (pdfs): in this paper we used both a Gaussian and a Poisson pdf, setting their parameters (mean and variance for the former, mean for the latter) according to the examples in the training set. In particular, we ran the classification algorithm with input examples [formula] of different dimensions, based on the number of features n involved: the idea behind this approach is to analyze how additional knowledge on an experiment impacts on the performance of the classifier. Therefore, the input vector contains either the ETA alone, or the pair (ETA, PTx) or (ETA, distance), or the triple (ETA, PTx, distance), and different pdfs are generated accordingly. For instance, for the second case (n = 2) with ETA and distance (d) as input features, [\eqref=eq:MAP] is reformulated as

[formula]

[formula] where p(d(i)|yk) = p(d(i)) for a homogeneous dataset.

Support Vector Machines

Support Vector Machines (SVMs) [\cite=Cortes1995] identify the hyperplane better separating the classes in a multi-dimensional feature space. A generic hyperplane can be written as the set of points [formula] satisfying [formula], where [formula] is the normal vector to the hyperplane and b represents the offset from the origin along [formula]. When the data points are linearly separable, it is possible to identify a pair of hyperplanes able to perfectly separate all the objects. By defining these hyperplanes as [formula], the margin, i.e., the region in-between, has length [formula], and the objective is to maximize [formula]. If we consider a binary classification problem, y(i)∈{ - 1,1}, the maximization of [formula] is equivalent to the minimization of [formula]; therefore the problem can be formulated as:

[formula]

where the constraint [formula] has been added to guarantee that all [formula]s lie outside the margin. Equation [\eqref=eq:SVM_optprob1] assumes that all training examples can be separated, which is not verified in general. As a result, [\eqref=eq:SVM_optprob1] can be modified to allow for some tolerance in the classification error. Therefore, for each training example [formula], there is an associated non-negative slack-variable ξi  ≥  0, [formula], allowing each example to lie on the other side of the hyperplane separating its class. The optimization problem then becomes:

[formula]

where the parameter C balances the trade-off between having a large margin and ensuring that most examples lie in the region associated to their class. The "dual" formulation of Eq. [\eqref=eq:SVM_optprob2] is

[formula]

where [formula] is the vector of Lagrange multipliers. It can be shown that

[formula]

by which it is possible to calculate the optimal weights in terms of the optimal values of [formula]. Now, a prediction for a new example input [formula] can be performed calculating [formula], and predicting y = 1 (or y =  - 1) if this quantity is bigger (or smaller) than zero. Hence, the prediction function can be written as

[formula]

which only depends on the inner product between the input vector [formula] and the subset of training vectors [formula] for which αi  ≠  0. Moreover, from [\eqref=eq:SVM_optprob3] it turns out that this subset only contains those training examples, known as Support Vectors (SVs), lying within the margin or in the region of the hyperspace belonging to the other class: as a consequence, the actual complexity of the prediction process only depends on the number of support vectors. The inner product [formula] in [\eqref=eq:SVM_predfunlin] can be replaced by particular non linear functions [formula], known as kernels, which correspond to scalar products between either linear or non linear transformations of [formula] and [formula]. Substituting [formula] in [\eqref=eq:SVM_optprob2] and [formula] in [\eqref=eq:SVM_predfunlin], we thus obtain the optimal prediction function in a non-linear feature space, rather than in input space:

[formula]

Finally, as the classification problem studied in this paper involves |C| = 4 classes, we adopted a generalization of the standard SVM known as multiclass SVM [\cite=Bishop2006], which works by reducing the multiclass problem into a number of binary problems. This generalization, known as one-vs-one classification, works by building a set of |C|(|C| - 1) / 2 binary classifiers, and then selecting the class that is assigned by the majority of the classifiers.

k-Nearest Neighbor

In k-Nearest Neighbor (k-NN), an example [formula] is classified under the most common class among its k nearest neighbors: k-NN is a type of lazy learning, since a learning phase is not needed at all. The neighbors are taken from a set of examples for which the class is known: this set can be thought of as the training set for the algorithm. In other words, the training phase of the algorithm simply consists in storing the training examples: once a test example is provided, the algorithm classifies it by assigning the most frequent class among its k nearest training examples. The parameter k is chosen so as to balance the trade-off between reducing the effect of noise (large k) and avoiding the creation of indistinct boundaries between the classes (low k).

Experimental Results

In this section, we present the classification results of the four algorithms: Naive Bayes (NB), linear Support Vector Machines (SVM-L), radial Support Vector Machines (SVM-R), k-Nearest Neighbor (kNN). The results are split into two parts: in the first part, we test the four classifiers on the whole dataset; in the second part, we train the classifiers on two subsets of data which mimic a more realistic scenario with unbalanced classes. In both cases (balanced and unbalanced training and test), we divide the dataset into 5 folds and train/test the classifiers 5 times, i.e., using 4 folds for training and the remaining fold for testing, every time. For the second part, we maintain the same 5 folds and sample a subset of the training and test data in order to produce an unbalanced dataset with more examples of transmission with multiple nodes (higher value of N). Two training/test subsets have been created with different proportion of examples per class, see Table [\ref=tab:dataset] for the details. For instance, subset "10-20-50-100" means that the first class (N = 1) is subsampled taking only 10% of the data, the second class (N = 2) maintains 20% of the data, etc.

Since we deal with a multi-class classification problem, we adopt the F1 score as a measure of performance for each class [\cite=DBLP:journals/ipm/SokolovaL09]:

[formula]

where P is the precision, i.e., the class agreement of the data labels with the positive labels given by the classifier, and R is the recall, that is the effectiveness of a classifier in identifying positive labels [\cite=han2011data]. In addition, we analyze the performance in terms of Receiver Operating Characteristic (ROC) curve which shows the fraction of true positive decisions of a classifier for a given rate of false positive decisions [\cite=Bradley19971145].

Full dataset

The classification performance for the full dataset is shown in Figure [\ref=fig:full]. For each class (number of nodes [formula]), we plot the average and the standard deviation of the F1 score of each classifier when all the features are used (ETA, PTx, and distance). In general, the performance is very high and it is possible to identify a common trend for all the classifiers: the 3-node class is harder to classify, mainly because the "tails" of this class overlap with the 2-node and 4-node classes. Table [\ref=tab:full] summarizes the performance for each class and the total average F1 score given a particular set of features. As we add more evidence (in terms of features), the performance of each classifier increases.

In  [\ref=fig:ROC], we show the analysis of the classification performance in terms of the ROC curve. This curve can be used to select the suitable operating point of the classifier; in particular, we see that at 20% rate of false positives, all the classifiers achieve an almost perfect performance (dashed line indicates 100% true positives). It is also worth noting that in the range 3% - 6% of false positive rate, all the classifiers are above the 95% true positive rate (dotted line). Table [\ref=tab:ROC] shows the cutoff points for the false positive rate that is required to achieve at least 95% of true positive rate.  [\ref=fig:ROC] and Table [\ref=tab:ROC] confirm that the NB approach is the slowest to reach the best performance.

Unbalanced dataset

In this subsection, we study the classification performance when classes are unbalanced and only one feature (the ETA) is available. In particular, we present the results of two subsamples of the classes with the following proportions (compared to the full dataset): i) 10%, 20%, 30%, 100%, ii) 20%, 30%, 50%, 100%, respectively for the 1-node, 2-node, 3-node, and 4-node classes. We tested the NB and SVM with two different approaches: one that incorporates the knowledge of the disproportion among classes, and another that does not take into account this information. For the NB, we trained NB with a uniform (NB uniform) distribution over the classes, so as to simulate a lack of knowledge about the unbalanced class distribution. We also trained a NB which computes the prior distribution p(yk) over the classes based on the relative frequency of class yk in the training set (NB prior). For the SVM, both the linear (SVM-L) and radial kernel (SVM-R) were used, training the algorithm either without modifying the weights of the classes (SVM no weight), or setting the values of the weights proportionally to the amount of training instances of each class in the training set (SVM weight), so that the C parameter in [\eqref=eq:SVM_optprob2] and [\eqref=eq:SVM_optprob3] takes into consideration the unbalanced data by setting the same sum of weights for each class. Finally, the k-NN algorithm was executed without any modification.

In Table [\ref=tab:ROC], we added the false positive rate cutoffs for each classifier. Since these two experiments, due to a reduced amount of training examples, constitute harder classification tasks with respect to the balanced-class setting, the values of the cutoff points are, in general, higher. This means that, in order to achieve a 95% true positive rate, it is at least needed to double the false positive error rate. It seems that SVM-L is much less prone to this type of performance decay. We will further investigate this particular behavior of the SVM with linear kernel. The results in Table [\ref=tab:10] and Table [\ref=tab:20] show that, in general, SVM-L, achieving the highest F1-score values in most classification tasks, seems to be preferable for the unbalanced datasets, whereas NB provides inferior results. In addition, kNN could be a good choice overall, as it attains good results at the lowest computational cost (as no training phase is needed).

Discussion and further analyses

The results of the experiments presented in this paper are very promising. The performance of the classifiers in all the considered configurations are high on average (F1 score above 0.89) if we consider that only three features were used (namely ETA, PTx, and d); moreover, the study of the ROC curve shows that a true positive rate equal to 95% can be achieved with a very small false positive rate (around 2-5%). We also observed a slight increment in performance when going from a single feature (ETA) to three features (ETA, PTx and d), but this increment in performance is not statistically significant. Instead, a substantial difference between the NB classifier and the SVM and k-NN classifiers has been observed. In the second part of the experimental analysis, we showed that the classification performance continues to be high even when classes are not balanced and the information about the skewness is not taken into account. Unexpectedly, weighted SVM performed worse than the unweighted (default) version. We are going to investigate further this problem in the future.

We claim that the exact number of users in the network is an important piece of information, as the predicted ETA is highly dependent on the value of N. To prove this, in Table [\ref=tab:ETA_pred] we show percentage mean prediction errors on the ETA, as a function of the number of users given as input, computed using the best-performing ML technique in [\cite=deltesta_globecomm]. In the table, we indicate with Nreal the actual number of active nodes during a given experiment, and with Npred the value of N given as input to the ETA predicted by the algorithm. The goal is to compare the ETA prediction errors when an erroneous number of nodes is used instead of the right one. For each experiment in the test set, the ETA has been predicted with a given value of Npred, and a percentage error has been computed with respect to the measured ETA value. The average of all the errors and standard deviations for a given (Nreal,Npred) pair is reported in Table [\ref=tab:ETA_pred]. Note that the errors on the diagonal are related to the predictions performed using the "right" value of N (Npred  =  Nreal); as expected, these values are the lowest for each class of experiments. The worst case is when the algorithm predicts a number of nodes greater than 1, Npred  >  1, when Nreal  =  1. In addition, when Nreal = 2 (or Nreal = 3), using the nearest value of N for the prediction, i.e., either Npred = 1 or Npred = 3 (or Npred = 2 or Npred = 4, respectively), gives approximately symmetric mean percentage errors. By computing the distribution [formula] with k,n∈[1,2,3,4], see Table [\ref=tab:prob_distr], it is possible to obtain the percentage weighted average prediction errors δi, i∈[1,2,3,4], for each value of users Nreal. For the aforementioned case, this computation gives [formula] which means that, on average, the percentage error is generally of the order of 10%, except when Nreal = 3, due to the overlap of the distribution of this class on the 2-node and 4-node ones, as already noted in Subsection [\ref=subsec:fulldataset].

Conclusions

In this paper, we studied how the number of active nodes N, an important SDN parameter, can effectively be inferred using only the data available at each node of a wireless network. We studied the distribution of the error on the ETA of a WiFi transmission given a wrong prediction of this parameter, and how the use of ML techniques is important to analyze the information derived from the first transmitted file chunk and return the value of N. Based on this work, a further step could be to predict the number of active nodes on-the-fly, as a function of the amount of data already received. This could allow to simultaneously update both the ETA estimation and the number of nodes during a transmission.