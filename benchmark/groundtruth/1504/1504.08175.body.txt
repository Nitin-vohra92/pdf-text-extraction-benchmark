Evaluation of recommender systems in streaming environments

Introduction

Usage-based algorithms for recommender systems rely on user-provided data. In a typical lab setting, this data has been previously collected from a system and consists of a finite set of user generated actions - typically item ratings. These datasets contain enough data to objectively apply well studied methodologies to evaluate recommendation algorithms in a laboratory setting. However, it is increasingly consensual that the accuracy obtained by algorithms in controlled environments does not translate directly into good performance or overall user-perceived quality in a real-world production environment.

We use the words "online" and "offline" to refer to the environment in which a system functions and/or is evaluated. Online systems run in production mode in a real-world setting - i.e. they provide or support an active online service to real users. Offline systems essentially run in laboratorial or controlled conditions mainly for development and/or systematic evaluation purposes.

In this paper, we propose the application of a prequential evaluation methodology [\cite=DBLP:conf/kdd/GamaSR09] for the evaluation of recommender systems. Prequential evaluation is primarily designed to evaluate algorithms that learn from continuous flows of data - data streams. If we look at user-generated data typically used by recommendation systems, we can safely state that this user feedback is generated online at unpredictable rates and ordering, and is potentially unbounded. This is the exact definition of a data stream [\cite=DBLP:conf/dmkd/DomingosH01]. On the one hand, this motivates the use of incremental algorithms, since batch rebuilding of predictive models may eventually become too expensive. On the other hand it also motivates a reflection on the applicability of classic evaluation methodologies to non-stationary models. This is because we are no longer trying to evaluate one model within a well delimited time frame, but rather a continuous and ever unfinished learning process. Prequential evaluation is especially adequate for this kind of setting. Nevertheless it is also applicable offline, with static datasets, as illustrated in this paper (Sec. [\ref=sec:exp]).

Holdout methods are widely used in the evaluation of recommender systems, however they are designed for batch algorithms and are not directly applicable in a non-stationary setting. Indeed, if data points are constantly being generated we can only take subsets of the available data and evaluate the algorithms on those subsets. Moreover, if we decide to implement an incremental algorithm, some issues on its evaluation, such as dataset ordering or recommendation bias, are not easy to circumvent (see Sec. [\ref=sec:classic_eval]).

Prequential evaluation does not require data pre-processing and is not restrictive in terms of evaluation criteria. It may include accuracy metrics typically used offline - e.g. precision/recall, RMSE -, but also allows online measurements of complex user interaction behavior or acceptance feedback, thereby including actual users in the evaluation process. By collecting diverse statistics, it is also possible to combine several important dimensions of the evaluation of recommender systems, such as novelty, serendipity, diversity, trust and coverage [\cite=DBLP:reference/rsh/ShaniG11], or to collect online A/B testing feedback data [\cite=DBLP:journals/datamine/KohaviLSH09]. We illustrate the use of prequential evaluation by observing a simple accuracy metric over time for the comparison of three algorithms, along with pairwise statistical significance tests.

To our knowledge, prequential evaluation has only been used for recommendation algorithms very recently in our work [\cite=DBLP:conf/um/VinagreJG14] and in [\cite=DBLP:conf/wims/SiddiquiTSSM14]. The first essentially uses the evaluation process described in this paper, and is a more direct application of the prequential methodology used in data stream mining. The second proposes a hybrid method that uses both holdouts and prequential evaluation in mini-batches. While in [\cite=DBLP:conf/um/VinagreJG14] our focus is essentially on the proposed algorithm, this paper focuses on the evaluation methodology itself with more detail, with the intent to raise discussion on the evaluation issues of incremental algorithms. We also illustrate the applicability of statistical significance tests to compare algorithms over time.

The remainder of this paper is structured as follows. In Sec. [\ref=sec:classic_eval] we describe the traditional batch evaluation methodologies. Prequential evaluation is described in Sec. [\ref=sec:prequential_eval]. We present an illustrative evaluation of three incremental recommendation algorithms in Sec. [\ref=sec:exp]. Finally we conclude in Sec. [\ref=sec:conclusions].

Evaluation methodologies

Traditionally, holdout methods are used in the batch evaluation of recommender systems. They begin by splitting the ratings dataset in two subsets - training set and testing set - randomly choosing data elements from the initial dataset. The training set is initially fed to the recommender algorithm to build a predictive model.

There is some variety of offline protocols to evaluate accuracy, however they are essentially variations of holdout strategies. Generally, these protocols "hide" a subset of ratings given by each user in the test set. These hidden interactions form a hidden set. Algorithms are evaluated by measuring the difference between predictions and the actual observations in the hidden set.

Issues with batch evaluation

Given the described offline evaluation methodology we identify the following issues:

Dataset ordering: randomly selecting data for training and test, as well as random hidden set selection, shuffles the natural sequence of the data. Algorithms designed to deal with naturally ordered data cannot be rigorously evaluated if datasets are shuffled. One straightforward solution is simply not to shuffle data. That is, to pick a moment in time or a number of ratings in the dataset as the split point. All ratings given before the split point are used to train the model and all subsequent ratings are used as testing data. One awkwardness with this approach is how to select the hidden set. In [\cite=DBLP:reference/rsh/ShaniG11] and [\cite=Lathia2010] the authors suggest that all ratings in the test set should be hidden;

Time awareness: shuffling data potentially breaks the logic of time-aware algorithms. For example, by using future ratings to predict past ratings. This issue may as well be solved by keeping the chronological order of data;

Incremental updates: incremental algorithms perform incremental updates of their models as new data points become available. This means that neither models or training and test data are static. Models are continuously being readjusted with new data. As far as we know to this date, the only contributions in the field of recommender systems that explicitly address this issue are [\cite=DBLP:conf/um/VinagreJG14]ï¿½and [\cite=DBLP:conf/wims/SiddiquiTSSM14]. This issue has already been addressed in the field of data stream mining [\cite=DBLP:conf/kdd/GamaSR09] [\cite=DBLP:journals/ml/GamaSR13];

Session grouping: most natural datasets, given their unpredictable ordering, require some pre-processing to group ratings either by user or user session in order to use offline protocols. As data points accumulate, it eventually may become too expensive to re-group them. This is true also for any other kind of data pre-processing task;

Recommendation bias: in online production systems, user behavior is - at least expectedly - influenced by recommendations themselves. It is reasonable to assume, for instance, that recommended items will be more likely followed than if they were not recommended. Simulating this offline usually requires complicated user behavior modeling which can be expensive and prone to systematic error. One way to evaluate the actual impact of a recommender system is to conduct user surveys and/or A/B testing [\cite=DBLP:journals/datamine/KohaviLSH09] [\cite=DBLP:journals/ijmir/DominguesGJLVLS13] [\cite=DBLP:journals/umuai/KnijnenburgWGSN12] [\cite=DBLP:journals/umuai/PuCH12].

The above limitations, along with other known issues [\cite=DBLP:reference/rsh/ShaniG11] [\cite=DBLP:conf/chi/McNeeRK06] [\cite=DBLP:journals/tois/HerlockerKTR04], weaken the assumption that user behavior can be accurately modeled or reproduced in offline experiments. From a business logic perspective [\cite=DBLP:conf/iccsa/FelixSJV14] offline evaluation may also not be timely enough to support decision making. These issues motivate the research of alternative or complementary evaluation methodologies.

Offline evaluation protocols and metrics

One important consideration about the evaluation of a recommendation algorithm is the type of problem or task being approached. When dealing with explicit numeric ratings, the first task of the algorithm is to accurately predict unknown ratings. This is usually referred to as a rating prediction task and is most naturally seen as a regression problem. One way to assess the accuracy of rating prediction algorithms is to measure the error of predicted ratings, given the true values in the hidden set [\cite=DBLP:conf/chi/ShardanandM95], using metrics such as Mean Absolute Error (MAE) and Root Mean Squared Error (RMSE). This protocol is in fact the most common approach, having been used in highly popularized competitions such as the Netflix prize [\cite=Bennett07thenetflix] and KDD-Cup 2011 [\cite=DBLP:journals/jmlr/DrorKKW12].

However, numeric ratings may not be available. In such cases, the data usually consists of a record of positive-only user-item interactions. The task is then to predict good items to recommend. This problem is usually referred to as item prediction. Item prediction problems can be evaluated both as classification and ranking problems. Accuracy is measured by matching recommendation lists to the true hidden items for each user. Typically, classification metrics such as Precision, Recall and F-measure or ranking metrics such as Mean Average Precision (MAP) [\cite=DBLP:conf/www/McFeeBEL12]ï¿½or Normalized Discounted Cumulative Gain (NDCG) [\cite=DBLP:conf/nips/WeimerKLS07] are used. The first protocols used for the evaluation of item recommendation problems are the ones known as All-but-N and Given-N [\cite=DBLP:conf/uai/BreeseHK98]. The All-but-N protocol hides exactly N items from each user in the test set. One popular sub-protocol is the All-but-One protocol, which hides exactly one item from each user in the test set. The Given-N protocol keeps exactly N items in the test set and hides all others.

Prequential evaluation

Given the problems listed in Section [\ref=subsec:issues_eval], we propose a prequential approach [\cite=DBLP:conf/kdd/GamaSR09], especially suited for the evaluation of algorithms in a non-stationary environment. Essentially, the prequential method consists of a test-then-learn procedure that runs for each new data point. Given a newly observed data point, a prediction is made and tested - e.g. measuring error. Then, the data point is used to update the model.

In this paper, we illustrate prequential evaluation with item prediction recommenders. The item prediction task consists of selecting good items for recommendation, which are typically presented to the user as a ranked list. In this task prequential evaluation consists of the folowing steps:

If u is a known user, use the current model to recommend N items to u, otherwise go to step 3;

Score the recommendation list given the true observed item i;

Update the model with the observed event;

Proceed to the next event in the dataset;

In its strict formulation, prequential evaluation does not require step 3. Indeed, one may not wish to update the model at every single observation, or ever. This allows the comparison between different types of algorithms, for example, incremental vs. batch algorithms.

This protocol provides several benefits:

It allows continuous monitoring of the system's performance over time;

Several metrics can be captured simultaneously;

If available, user feedback can be included in the loop;

Real-time statistics can be integrated in the algorithms' logic - e.g. automatic parameter adjustment, drift/shift detection, triggering batch retraining;

In ensembles, relative weights of individual algorithms can be adjusted;

The protocol is applicable to both item prediction and rating prediction;

By being applicable both online and offline, experiments are naturally reproducible if the same data sequence is available.

In an offline experimental setting, an overall average of individual scores can be computed at the end - because lab datasets are inevitably finite - and on different time horizons. For a recommender running in a production system, this process allows us to follow the evolution of the recommender by keeping online statistics of any number of chosen metrics. Thereby it is possible to depict how the algorithm's performance evolves over time. In Sec. [\ref=sec:exp] we present both the overall average score and complement it with plots of the evolving score using a simple moving average of an accuracy metric.

One challenging aspect of this method is that it only evaluates over a single item at each step, potentially failing to recognize other possible good recommendations. If item i is not recommended at the time the observation is made, the score will naturally be 0. However, other items within the N recommendations may occur in future observations for that user. In other words, the protocol exclusively evaluates how well the model predicts the next observation, ignoring all subsequent ones. Although this is a somewhat challengingly strict protocol, we have performed experiments by matching the recommended items with not just the current, but all future observations for each user - only possible offline -, and found that overall scores do not improve substantially. However, this strictness of the protocol may potentially have a higher impact with other metrics or data. One way to relax this, is to match the active observation not only with the current prediction, but also with a set of previous predictions. One other possible approach is to use a hybrid evaluation method such as in [\cite=DBLP:conf/wims/SiddiquiTSSM14].

Applying the methodology

To illustrate the usefulness of prequential evaluation in recommender systems, we perform a set of experiments using this protocol. We use three item recommendation algorithms that learn recommendation models incrementally as user feedback data becomes available. These algorithms are designed to process positive-only feedback - also known as binary feedback. However, we emphasize that this is not a restriction of the evaluation protocol, since it is possible to use the exact same methodology for rating prediction problems as well.

Datasets

We use four distinct datasets, described in Table [\ref=tab:datasets]. All datasets consist of a chronologically ordered set of pairs in the form < user,item > . Music-listen and Lastfm-600k consist of music listening events obtained from two distinct sources, where each tuple corresponds to a music track being played by a user. Music-playlist consists of a timestamped log of music track additions to personal playlists. MovieLens-1M is well known dataset consisting of timestamped movie ratings in a 1 to 5 rating scale. To use this dataset in an item prediction setting, since we intend to retain only positive feedback, movie ratings below the maximum rating 5 are excluded. Lastfm-600k consists of the first 8 months of activity observed in the Last.fm dataset originally used in [\cite=DBLP:books/daglib/0025137]. Both Music-listen and Music-playlist are extracted from the Palco Principal website, a social network dedicated to non-mainstream music enthusiasts and artists.

Algorithms used and overall accuracy

Using the prequential approach described in Sec. [\ref=sec:prequential_eval],ï¿½we compare the online accuracy of 3 incremental item recommendation algorithms: ISGD [\cite=DBLP:conf/um/VinagreJG14], BPRMF [\cite=DBLP:conf/uai/RendleFGS09] and a classic incremental user-based neighborhood algorithm [\cite=DBLP:conf/webi/MirandaJ08], all implemented in MyMediaLite [\cite=DBLP:conf/recsys/GantnerRFS11]. We measured accuracy with recall at cut-off 10 - denoted by recall@10.

Overall results with average update times are presented in Tab. [\ref=tab:results_overall]. These are possible to obtain in offline experiments, given that lab datasets are finite. However, in online production systems these results can only be interpreted as a snapshot of the algorithms' performance within a predefined time frame.

Accuracy over time

One valuable feature of our adopted evaluation protocol is that it allows the monitoring of the learning process as it evolves over time. To do that, we need to maintain statistics of the outcome of the predictions. We study how the algorithms' accuracy evolves over time by depicting in Fig. [\ref=fig:results_evolving] a moving average of the recall@10 metric. The moving average sizes are chosen to obtain clear lines in Fig. [\ref=fig:results_evolving], for illustrative purposes. We do not argue that these values are any better than others.

The plotted evolution of the algorithms with each dataset generally confirms overall results, however more details become available. For instance, although the overall averages of ISGD and UKNN are relatively close with the Music-playlist dataset, Fig. [\ref=fig:results_evolving] c) shows that these algorithms behave quite differently, starting with a very similar accuracy level and then diverging substantially. Although this kind of observation could be important for a rigorous evaluation, it is diluted in a single average in Table [\ref=tab:results_overall].

Statistical significance over time

We also depict in Fig. [\ref=fig:mcnemar] statistical significance tests using the signed McNemar test over sliding windows [\cite=DBLP:conf/kdd/GamaSR09] of the same size as the ones used for the moving averages used in Fig. [\ref=fig:results_evolving]. We set a significance level of 1%. Because McNemar is a pairwise test, a complete comparative assessment with four datasets and three algorithms would require 12 tests. However, to avoid multiple tests we can compare one proposed algorithm with existing ones. Alternatively we can use p-value corrections. In this illustrative experiment we compare the ISGD algorithm with the other two on the four datasets, which yields 8 tests. The main observation from Fig. [\ref=fig:mcnemar] is that the most of the apparent diferences in Fig. [\ref=fig:results_evolving] are statistically significant. However, the visualization of the McNemar test clarifies some comparisons.

The online monitoring of the learning process allows a more detailed evaluation of the algorithms' performance. Figure [\ref=fig:results_evolving] reveals phenomena that would otherwise be hidden in a typical batch evaluation. We consider that this finer grained evaluation process provides a deeper insight into the learning processes of predictive models.

Conclusions

In this paper, we propose a prequential evaluation framework to monitor evaluation metrics of recommender systems as they continuously learn from a data stream. To illustrate its applicability and appropriateness we use this framework to compare three incremental recommendation algorithms. We notice that our evaluation method allows a finer grained assessment of algorithms, by being able to continuously monitor the outcome of the learning process. Moreover, it is possible to integrate multiple measures simultaneously in the evaluation process, thereby evaluating multiple dimensions. We also show the applicability of statistical significance tests.

Acknowledgements

This work is partially funded by FCT/MEC through PIDDAC and ERDF/ON2 within project NORTE - 07 - 0124 - FEDER - 000059 and through the COMPETE Programme (operational programme for competitiveness) and by National Funds through the FCT - FundaÃ£o para a CiÃªncia e a Tecnologia (Portuguese Foundation for Science and Technology) within project FCOMP - 01 - 0124 - FEDER - 037281. The first author's work is funded by the FCT grant SFRH / BD / 77573 / 2011. The authors wish to thank Ubbin Labs, Lda. for kindly providing data from Palco Principal.