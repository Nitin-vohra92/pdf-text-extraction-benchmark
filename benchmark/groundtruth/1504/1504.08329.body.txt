FAST AND ACCURATE EVALUATION OF WIGNER 3-j, 6-j, and 9-j SYMBOLS USING PRIME FACTORISATION AND MULTI-WORD INTEGER ARITHMETIC

Fast and accurate evaluation of Wigner 3j, 6j, and 9j symbols using prime factorisation and multi-word integer arithmetic

Department of Fundamental Physics, Chalmers University of Technology, SE-412 96 Göteborg, Sweden Department of Physics and Astronomy, University of Tennessee, Knoxville, TN 37996, USA Physics Division, Oak Ridge National Laboratory, Oak Ridge, TN 37831, USA The research leading to these results has received funding from the European Research Council under the European Community's Seventh Framework Programme (FP7/2007-2013) / ERC grant agreement no. 240603, and the Swedish Foundation for International Cooperation in Research and Higher Education (STINT, IG2012-5158). This material is based upon work supported in parts by the U.S. Department of Energy under Contract No. DE-AC05-00OR22725 (Oak Ridge National Laboratory). The authors would like to acknowledge valuable comments on the manuscript and the computer code by B. D. Carlsson and K. Wendt.

Introduction

Wigner 3j, 6j, and 9j symbols (xj symbols) are used in physics and chemistry whenever one deals with angular momenta in quantum mechanical systems [\cite=varshalovich1988quantum] [\cite=brink1993angular]. These functions correspond to transformation coefficients between different spin representations. The input arguments are six or nine integers, or half integers, that represent different angular momenta j and projection quantum numbers |m|  ≤  j. Because of their frequent appearance in scientific computing, standard library functions that evaluate Wigner symbols are available in several mathematics software systems [\cite=sympy] [\cite=mathematica] [\cite=sage] and computational libraries [\cite=Galassi:2013wz]. In fact, the quantum spin properties of electrons, protons, neutrons and atoms imply that angular momentum recoupling is a general and important ingredient in the theoretical modeling of quantum many-body systems [\cite=fetter2003quantum]. Well known examples are found in quantum chemistry [\cite=atkins2011molecular], condensed matter [\cite=dickhoff2008many], atomic [\cite=lindgren2012atomic], and nuclear physics [\cite=suhonen2007nucleons]. More recently, the mathematical apparatus of quantum-mechanical angular momentum coupling has found a prominent role also in quantum gravity and quantum computing applications [\cite=Aquilanti2008].

In particular, the Wigner symbols enter at a critical stage in the computational chain of quantum many-body modeling; namely when calculating the strength of the interaction between pairs or triples of particles. The evaluation of these so called interaction matrix elements can involve intermediate angular-momentum sums that extend to very large values (j  ~  100). Eventually, a sum over all possible particle pairs or triples within the many-body system gives the total interaction energy. The continued efforts to improve both accurate calculations [\cite=Stone:1980bt] [\cite=Wei:1999hc] [\cite=Anderson2008], constructing recursive relations [\cite=schulten1975] [\cite=Luscombe:1998dr] [\cite=Tuzun:1998kk], and achieving fast look-up [\cite=Rasch:2003dr] show the central place of these symbols in computations.

Accurate evaluation of Wigner symbols with large j using floating-point arithmetic is difficult because of cancellation in sums of large alternating terms. The precision losses due to cancellations can be avoided by using integer arithmetic. However, this approach generally involves very large numbers due to factorials, thus requiring the use of multi-word integer representations in computer codes. Multi-word integers are multiple machine words used together to represent arbitrarily large numbers. A clever reduction of the huge integers, by expressing the terms as products of binomial coefficients, was demonstrated by L. Wei [\cite=Wei:1999hc]. In this context, one can also mention early efforts introducing prime factorisation [\cite=Dodds1972] [\cite=Stone:1980bt]. However, high-accuracy approaches are in general significantly slower than straight-forward floating-point implementations. As an example, the computation of 6j symbols for small angular momenta, max (j)  =  3, is already an order of magnitude slower when using the published code of Ref. [\cite=Wei:1999hc] as compared to a floating-point calculation with the popular GNU Scientific Library (GSL) [\cite=Galassi:2013wz]. This difference is growing with increasing j.

In this paper we present a new method in which the big-integer penalties are mitigated by making explicit use of prime-factorised factorials. In our tests this method executes considerably faster than previous high-accuracy approaches, provides a bounded and fixed relative accuracy, and extends to very large values of ingoing angular momenta.

Method

The implementation uses the fact that the xj symbols can be written on the form

[formula]

where n, s and q are integers. This general expression comes directly from the defining equations [\cite=varshalovich1988quantum]. E.g., for 6j symbols we have the Racah formula

[formula]

with

[formula]

and

[formula]

The summation index k is in the range max (α1,α2,α3,α4)  ≤  k  ≤   min (β1,β2,β3). As stated before, the input arguments a,b,c,d,e, and f are integers or half-integers. For a symbol not to be trivially zero, the sums αi must be integer and i must fulfill triangle conditions, e.g. for 1:

[formula]

The overall structure for 3j symbols is similar. Note how all expressions contain (factorials of) integers. While being possibly large, they can be evaluated exactly. By finding and using the least common denominator (LCD) of the sum, expression [\eqref=expr6j] can be brought to the form [\eqref=exprnsd].

Finding the LCD is straightforward by expressing each factorial as an explicit product of prime numbers, e.g. 7!  =  24  ×  32  ×  51  ×  71, treated as the tuple (4,2,1,1) in the calculations. The tuple representing each term is found by subtracting the exponents related to each prime number in all factors of the denominator from the ones representing the numerator. The LCD is then found by taking the minimum value for each exponent over all terms. In practice, the LCD is reduced considerably since the numerator is also included in this procedure. Factors common to all terms are then represented by positive exponents. As an explicit example we consider the computation of the 6j symbol [formula]. The sum that needs to be evaluated for this symbol includes three terms, see Table [\ref=tab:6jexample]. The final common factor of the sum (which includes the LCD) is found to have the tuple representation (1,2,1,1). The positive exponents are a consequence of the relatively large numerators appearing in the sum. The common factor is then subtracted from the exponent tuples of each term, giving pure numerators. In Table [\ref=tab:6jexample] this step corresponds to the second to last column. They are converted into exact integers using multi-word arithmetics. The sum is then easily accumulated, yielding one part of n in Eq. [\eqref=exprnsd].

The product of the Δ-factors is formed by summing the factorial prime exponent contributions. As it shall suffer a square root, one factor will be removed from each odd exponent to make sure that all remaining ones are even. The removed odd ones will build the term [formula] in Eq. [\eqref=exprnsd], while the remaining even ones will be divided by two, thereby evaluating the square root. In our example, the product under the square root becomes [formula] that is represented by the tuple (  -  1,  -  2,  -  1,  -  1)4  =  (  -  4,  -  8,  -  4,  -  4). All exponents are even so applying the square root simply gives [formula].

The common factor is then added, giving final exponents that are used to create q and the second part of n in Eq. [\eqref=exprnsd], by using the negative and positive exponents, respectively. In our example, the product of the Δ-factors is added to the common factor of Table [\ref=tab:6jexample] giving the final exponents ( - 1, - 2, - 1, - 1), which corresponds to 1 / 630. The two parts of n are combined using multi-word integer multiplication.

In the final step, the value of Wx in ([\ref=exprnsd]) can be evaluated using floating-point arithmetics with a limited loss in relative precision. In our example, this corresponds to the evaluation of [formula]. The three conversions from integer to floating point, together with one square root, one multiplication, and one division constitute six operations that each incur the loss of (at most) half a least significant bit in the floating-point representation used, commonly referred to as the machine epsilon, ε. For the 64-bit floating-point format of IEEE 758, which is usually used for the C type double, one has ε  =  1.11  ·  10- 16. This implies a maximum relative error of 6ε  =  6.66  ·  10- 16.

Wigner 9j

Wigner 9j symbols can be written as a sum of products of 6j symbols, see e.g. Ref. [\cite=varshalovich1988quantum]. It is not obvious from this direct formula for Wigner 9j symbols that they can be written on the form [\eqref=exprnsd] due to the square roots in the Δ prefactors of the 6j symbols. Nevertheless, a rearranged formula based on binomials was presented [\cite=Wei:1998hf] and used [\cite=Wei:1999hc] by L. Wei. This formula is also employed in the present implementation, with the small modification of expressing the binomials as factorials. In total, the 9j evaluation becomes a double sum where an overall LCD expressed on prime-exponent form can be extracted. The routine implementing the sum in the 6j formula is re-used for this purpose.

Results

Calculations using the wigxjpf routine presented in this work have been compared (in floating point) with the 369j code by Wei [\cite=Wei:1999hc] and with a simple implementation in which we use floating-point operations from precalculated factorial tables (see Sec. [\ref=sec:implementation]). The floating-point based routines of GSL (version 1.16) [\cite=Galassi:2013wz] have also been included in the measurements. The comparisons are both in terms of execution speed and accuracy. The benchmark calculations for measuring the accuracy are performed with our routine, wigxjpf, using extended precision computations (the 80 bit long double of the x87 floating-point unit, ε  =  5.42  ·  10- 20). This benchmark is reliable since only the last floating-point stage of the current routine introduces rounding errors.

Results are presented in Fig. [\ref=fig:3j] and Fig. [\ref=fig:6j9j] for 3j and (6j,9j) symbols, respectively. For reasonable maximum j, all symbols not trivially zero by triangle conditions have been calculated (solid lines), which provides an exhaustive measurement of the average evaluation speed and the maximum relative error. However, for larger symbols the measurement is approximative as we have restricted the computations to a random subset of non-trivially-zero symbols (dotted lines with markers).

In all measurements, the present work is slightly more accurate and up to an order of magnitude faster than 369j. The relative error never exceeded 6ε  ≈  6.66  ·  10- 16, which is our upper bound. The slightly larger accuracy loss in 369j is due to individual conversion of each prime power to floating point and subsequent multiplication. The execution time difference between our implementation and the fast floating-point based routines is less than an order of magnitude at low j, showing that the wigxjpf routines presented in this work are also very efficient. In comparison to GSL (version 1.16), wigxjpf is actually faster for 3j symbols up to max (j) = 60, while the difference in execution speed always remains smaller than a factor 4 up to max (j) = 20 (30) for 6j (9j) symbols. At large j the floating-point routines obviously suffer from an increasing loss of accuracy, thus making wigxjpf superior.

Explicit numerical values, execution times, and memory usage for a selected set of symbols are presented in Table [\ref=tab:values]. Note that we present results for extreme cases such as j = 50,000 and j = 2,000 for 6j and 9j symbols, respectively.

Implementation

Before the calculation of individual symbols, a table with precalculated factorisations of factorials is prepared. Table [\ref=tab:max] shows the maximum possible factorial that has to be computed for evaluation of different symbols. The time spent on this initialization stage is amortized for applications that make repeated use of the routines. The table also gives the maximum number of terms in the sum (inner sum for 9j symbols), for each of which temporary results (numerator-denominator exponent tuples) are stored during execution.

First, all prime numbers up to the largest factorial argument, p, are determined by the sieve of Eratosthenes. By simple enumeration of integer exponent combinations in the basis of prime numbers, the factorisation of all integers up to p are determined. Thus the factorisations are performed without any 'test' divisions, i.e., checks for remainder zero. Each factorisation is stored as an array of integers. The factorisation of factorials are constructed by cumulating the previous factorisations.

Multiplying (or dividing) two such factorisations is a matter of adding (or subtracting) each element of the arrays, giving a new array. Adding or subtracting two factorisations would be more complicated as the result, expressed as a factorisation, could be completely different, even requiring much larger prime factors. To avoid this, each term is converted from the prime-factor array representation to multi-word integer before addition or subtraction. No attempt is made to extract common factors between different multi-word integers, as this is expensive and would have no impact on accuracy.

The multi-word integers are just multiple machine words (32 or 64 bits) used to represent arbitrarily large numbers. The highest word is treated as having a sign bit, while all others are unsigned. Routines that perform addition, subtraction and multiplication are implemented. The main difficulty is to propagate overflow (i.e. carry) between the words. The execution times for addition and subtraction are linear in the number of words used, while multiplication is quadratic.

The conversion of a number in prime-factor form to multi-word integer form evaluates the contribution for each prime number separately, before multiplying them together. We utilize the fact that, for each exponent, each successively higher bit in its binary number representation corresponds to the square of the value represented by the previous bit. Therefore, two values are kept while iterating through the bits of each exponent: the repeatedly squared prime number and a cumulative product. While non-zero bits remain, the first number is squared each iteration, starting as the prime number for the first bit. For each bit set to one, the cumulative product is multiplied by the hitherto squared result. These intermediate results are treated as multi-word integers when necessary.

Conversion from multi-word integer to floating point in the final stages is done word by word, from lower to higher words. The contributions that cannot be represented (i.e. that are below the precision) in the resulting floating-point variable are therefore just lost/ignored.

Repeated similar calculations of factorial arguments can be avoided by noting that the factors (and denominators) of each successive term in the sum depend on the summation index k in such a way that they always change their argument by 1 for each iteration. Therefore, factorial arguments (table addresses) can be calculated before the sum loop. In the actual loop these addresses are then just moved up or down one step each iteration.

Symbols that are trivially zero can be identified using a single if-clause in combination with two's-complement arithmetics and bit manipulation. Only symbols passing this test are evaluated.

For the comparisons presented in Sec. [\ref=sec:results] we have also implemented simple floating-point routines. They use precalculated floating-point factorial values employing the same list-address technique for the sum as described above and thus become very fast. The factorials, stored as floating-point values, are calculated precisely using the multi-word integers. The accuracy loss is completely dominated by cancellation in the sums of large alternating terms.

Memory usage

The largest memory requirement of wigxjpf is associated with the tables of precalculated factorisations of numbers and factorials, see Table [\ref=tab:max]. The next largest use is the temporary arrays of prime factors of each term in the sum. Other variables that are used during computations, e.g. multi-word integers, are comparatively small in size.

Conclusions and Outlook

In conclusion, we have successfully implemented a computational method for fast and accurate evaluation of Wigner 3j, 6j, and 9j symbols using prime factorisation and multi-word integer arithmetics. The efficiency and accuracy of our approach has been validated via benchmark calculations and comparison with existing floating-point routines and with the 369j code by Wei [\cite=Wei:1999hc]. The latter algorithm is similar to our approach in the sense that it also uses prime-number factorisation and multi-word integer arithmetics. However, it employs recursive calculation of binomial coefficients while our implementation, with the precalculation of a table with prime-number factorisations, offers a code that is significantly faster; comparable in speed even to the floating-point routines. In addition, the precomputed factorisation table makes our approach particularly amenable to applications in which multiple evaluations of angular momentum coupling coefficients are needed.

Furthermore, our implementation produces results with a maximum relative error of only six times the machine epsilon for 3j, 6j, and 9j symbols, also for very large angular momenta. In comparison, the error in the evaluation of 6j symbols using GSL 1.16 is five orders of magnitude larger already for j = 15 and quickly grows with increasing values of the angular momenta.

A computer code with the routines presented in this work, wigxjpf, is available for download [\cite=chalmers:wigxjpf].

Acknowledgments

The research leading to these results has received funding from the European Research Council under the European Community's Seventh Framework Programme (FP7/2007-2013) / ERC grant agreement no. 240603, and the Swedish Foundation for International Cooperation in Research and Higher Education (STINT, IG2012-5158). This material is based upon work supported in parts by the U.S. Department of Energy under Contract No. DE-AC05-00OR22725 (Oak Ridge National Laboratory). The authors would like to acknowledge valuable comments on the manuscript and the computer code by B. D. Carlsson and K. Wendt.