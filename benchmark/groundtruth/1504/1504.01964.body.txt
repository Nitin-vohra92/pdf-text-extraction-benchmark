A Robust Approximation to a Lambert-Type Function ------------ Ken Roberts April 8, 2015

Introduction

The Lambert W function w  =  f(z) is the solution of w  ew  =  z, for complex w and z. It can be considered as the multi-branch inverse of the conformal map w  →  w  ew  =  z between the complex w-plane and the complex z-plane. When w and z are restricted to having real values, the graph of the Lambert W function is as shown in figure [\ref=fig-lamw-graph]. For further background regarding the Lambert W function, see [\cite=Corless-1996] [\cite=Valluri-2000].

Some problem situations, for instance the modeling of current and voltage in diodes or solar cells, reduce to an implicit equation which can be solved explicitly by means of the Lambert W function. As a simple example, consider the implicit equation

[formula]

where a,b are positive real numbers, parameters of the model, and U,V are real variables. The corresponding explicit solution for U as a function of V is

[formula]

Here [formula] denotes the principal branch of the natural logarithm function, and W() denotes the principal branch of the Lambert W function.

A typical task might be, given values of the model parameters, to draw a graph of U as a function of V. For that task, it is computationally efficient to have, instead of the implicit equation ([\ref=eqimplicit]), the explicit solution ([\ref=eqexplicit]) for U in terms of V and the model parameters.

Another task might be to estimate the model parameter values a,b which best fit experimental observations of U,V pairs. For that task, one wants to have an understanding of how varying the model parameters will affect the U-V curves.

Still another task might be to determine the relationships among the model parameters which correspond to having an extremum of a function of U or V. This task also requires an understanding of how varying the model parameters will affect the U-V curves, but it will also be helpful if the formula utilized has partial derivatives with respect to all the parameters.

The expression in equation ([\ref=eqexplicit]) is analytic, so is well-behaved with respect to its argument and the model parameters. It can be repeatedly differentiated, its extrema lie at stationary points, and so on. Because one is working with real values for U and V and the positive real model parameters, the argument for the Lambert W function evaluation in equation ([\ref=eqexplicit]) is positive, so the principal branch of the Lambert W function is being used. Moreover, one is using the principal branch of the natural logarithm function. Everything is single valued in this expression.

However, there can be a numerical difficulty in performing computations with equation ([\ref=eqexplicit]). Making the substitutions (coordinate changes) [formula] and [formula], the computations involve an evaluation of the function

[formula]

One difficulty which can arise, depending upon the computer programming language used, is numerical underflow or overflow, related to the evaluation of an exponential of x where x (negative or positive) has a large magnitude. The value of x must therefore be restricted to the set of logarithms of floating point numbers whose exponents can be accurately represented in the arithmetic facility of the computer language. A second difficulty which can arise is that the best computer programming language for the rest of one's problem solution may not have a built-in Lambert W function evaluator.

The purpose of this note is to address those two difficulties. We will describe a simple procedure, which can be implemented in any programming language with floating point arithmetic, for the robust calculation of the function [formula]. The procedure is valid for essentially any real value of x which is representable in the programming language.

Description of the Function [formula]

We may consider the function [formula] as a transformation of the Lambert W function, with a change of representation or coordinate space. For clarity, we will restrict to real arguments. We can think of W(u), the principal branch of the Lambert W function, as a mapping of the positive real line to itself. The function [formula] maps the whole real line to the positive real line, and its inverse [formula], the principal branch of the natural logarithm, maps the positive real line to the whole real line. In this interpretation, the function [formula] is the composition of functions [formula], and it maps the whole real line to the whole real line.

Suppose that [formula]. Taking exponentials (ie, applying the function h to both sides of the equation) gives That is, using the definition of the Lambert W function, or Taking logarithms (ie, applying the function h- 1 to both sides) gives

[formula]

Equation ([\ref=eqyey]) is a simple equation structure, as simple as the Lambert W defining equation structure

[formula]

In fact, equation ([\ref=eqyey]) is just equation ([\ref=eqwew]) in another coordinate system.

When we are evaluating [formula] as the solution to equation ([\ref=eqyey]), we are just evaluating the Lambert W function. There is an important difference, however: The evaluation of g(x) does not involve much risk of underflow or overflow in the numerical representation of the computer language.

Since y  =  g(x) satisfies g(x)  +  eg(x)  =  x, the first derivative of g(x) satisfies or

The second derivative of g(x) satisfies

Figure [\ref=fig-logwexp1] shows the function y  =  g(x) for moderate values of the argument x, that is, for - 4  <  x  <  4. Figure [\ref=fig-logwexp2] shows the same function for larger values of the argument x, that is, for - 1000  <  x  <  1000.

One can see from these graphs that the function g(x) behaves like x when x is much less than 0, and behaves like [formula] when x is much more than 0. For values of x around 0, there is a smooth blend between the two behaviors, with g(1)  =  0. The function g(x) is strictly monotonic increasing, as it has a positive first derivative. It curves downward, as it has a negative second derivative.

One can further see, from figure [\ref=fig-logwexp2], that when the range of the argument x is large, the graph of y  =  g(x) looks like it has a sharp corner at the origin. Actually, as figure [\ref=fig-logwexp1] illustrates, the graph does not really have a sharp corner. Nonetheless, at a suitable distance (large scale), one has in the function g a useful smooth function for representing a function which has a step in its derivative.

Algorithm for Calculating [formula]

In the terminology of H. Kuki ([\cite=Kuki-1966] page 23), the function g(x) is contracting. That is, |Δg(x)|  ≤  |Δx|, or |g'(x)|  ≤  1, for all x values in its argument domain. That means the task of finding an estimate for g(x) given x is relatively stable. A slight change in x (noise in the input) will produce only a slight change in g(x). The only challenges in developing a formula to estimate g(x), given x, are finding an appropriate algorithm, coding the sequence of calculations to avoid unwanted cancellation, and being reasonably efficient in the number of computations performed.

A suitable algorithm can be an initial estimate, followed by some number of iterations of a refinement. Halley's method is used to perform refinements because it has cubic convergence, and the derivatives involved can be calculated efficiently.

Given any fixed real number x, we wish to find a real number y such that is zero. The first and second derivatives of h(y) are needed for Halley's method. They are

[formula]

and hence are particularly easy to calculate. Once one has ey from the calculation of h(y), the derivatives are also at hand. It is also necessary, in order to use Halley's method, that the first derivative is non-zero; that is the case for h'(y)  =  1  +  ey.

As an initial estimate y0, we choose to use y0  =  x for x  ≤   - e, and [formula] for x  ≥  e. For - e  <  x  <  e, we linearly interpolate between the two values - e and 1. This is an extraordinarily crude initial estimate, but it is sufficient, since Halley's method is very robust and rapidly convergent in this application.

The general iteration formula for Halley's method is In this particular case h(y)  =  y  +  ey  -  x and the iteration formula becomes

[formula]

The details of coding depend upon the computer language. It will be efficient to evaluate eyn only once per iteration. All other computations are straightforward arithmetic. When evaluating the denominator of the adjustment in the iteration equation ([\ref=eqiter]), there is little risk of cancellation resulting from the subtraction, as the first term in the denominator is larger than the second term.

In practice, just a few iterations suffice to give a good result. For arguments in - 106  ≤  x  ≤  106, four iterations of Halley's method reduce the absolute error to less than 10- 80. The actual coding can use a convergence criterion, based upon the desired maximum error in the estimate of function value, to determine how many iterations to perform. Alternatively, if the precision is fixed by the computer language's arithmetic representation or by the needs of the application situation, then one can determine how many iterations of the refinement will suffice, and perform only that number, omitting the final redundant iteration which verifies the convergence. This technique, due to H. Kuki as seen in his algorithms for computing square root (see [\cite=Kuki-1966], pages 49-50 and 135-136), probably deserves a name. Perhaps it should be called "Kuki's convergence non-test".

Acknowledgments

The author had the good fortune and honor to work for Hirondo Kuki in 1968-69, and thanks him for his guidance, support and friendship. He also thanks S. R. Valluri for an introduction to the Lambert W function and the many interesting problems associated with its properties, and in particular for a stimulating discussion of the topic of this note. He thanks Mark Campanelli for suggesting Halley's method for iterative refinement in solar cell calculations.