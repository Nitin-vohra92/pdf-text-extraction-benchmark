ReOpt: an Algorithm with a Quality Guaranty for Solving the Static Relocation Problem

Introduction

Carsharing is a modern way of car rental, attractive to customers who make only occasional use of a car on demand. Carsharing contributes to sustainable transport as less car intensive means of urban transport, and an increasing number of cities all over the world establish(ed) such services. Hereby, a fleet of cars is distributed at specified stations in an urban area, customers can take a car at any time and station and return it at any time and station, provided that there is a car available at the start station and a free place at the final station. To ensure the latter, the stations have to keep a good ratio between the number of places and the number of cars in each station. This leads to the problem of balancing the load of the stations, called Relocation Problem: an operator has to monitor the load situations of the stations and to decide when and how to move cars from "overfull" stations to "underfull" ones.

Balancing problems of this type occur for any car- or bikesharing system, but the scale of the instances, the time delay for prebookings and the possibility to move one or more vehicles in balancing steps differ. We consider an innovative carsharing system, where the cars are partly autonomous, which allows to build wireless convoys of cars leaded by a special vehicle, such that the whole convoy is moved by only one driver (cf. [\cite=EDGC:2012:PCS]).

This setting is different from usual carsharing, but similar to bikesharing, where trucks can simultaneously load and move several bikes during the relocation process [\cite=Benchimol+etal:RAIRO] [\cite=do-cmc2013] [\cite=cirrelt-CMR-2012]. The main goal is to guarantee a balanced system during working hours (dynamic situation as in [\cite=cirrelt-CMR-2012] [\cite=HKQWW:2015:ODY] [\cite=HKQWW:LAGOS:2015] [\cite=KQWW:2014:LNCS] [\cite=LAGOS2013]) or to set up an appropriate initial state for the morning (static situation as in [\cite=do-cmc2013] [\cite=LAGOS2013]). Both, the dynamic and the static versions are known to be hard [\cite=Ball+etal:handbook:95a] [\cite=Ball+etal:handbook:95b] [\cite=do-cmc2013] [\cite=Nemhauser+etal:handbook:89], and different heuristic approaches have been developed, e.g., partitioning the problem into subproblems by discrete particle swarm optimization [\cite=CIE:GKA-2013], by reducing the search space [\cite=KQWW:2014:LNCS], using variable neighborhood search [\cite=EvoCOP:HPHR-2013], or partitioning the problem into subproblems with clustering techniques [\cite=SHH-2013].

In this paper, we address the static situation, where the system has to be set into a certain state [formula], outgoing from the current state [formula], within a given time horizon.

[formula]

Problem description and model

We model the Relocation Problem in the framework of a metric task system.

By [\cite=LAGOS2013], the studied carsharing system can be understood as a discrete event-based system, where the system components are the stations [formula], each having an individual capacity cap(vi), a system state [formula] specifies for each station vi the number of cars zti at a time point t  ≤  T within a time horizon

[formula]

.

In the static situation, we consider a start state [formula] and a destination state [formula]. Then the tasks are induced by the differences between these two states, i.e, for every station v∈V with z0v  ≠  zTv we have a task (v,z0v  -  zTv). A station vo with z0vo  -  zTvo  >  0 is called an overfull station, a station vu with z0vu  -  zTvu  >  0 is called an underfull station, and a station vb with z0vo  -  zTvu  =  0 is called an balanced station.

Since our considered carsharing system is located in an urban area, due to one-way streets, the distances between two stations v and v' may not be symmetric, i.e., the distance from v to v' may differ from that from v' to v. Furthermore, due to the traffic situation, the travel times also may vary. In order to represent the one-way streets (or different travel times) it is suitable to encode the urban area where the carsharing system is running as a (quasi) metric space M = (V,d) induced by a directed weighted graph [formula], where the nodes correspond to stations, arcs to their physical links in the urban area, node weights to the station's capacities, and the edge weights [formula] determine the distance d between two points v,v'∈V as length of a shortest directed path from v to v'.

All drivers begin and end their work at the same location, a so-called depot. A depot is represented in V by a distinguished origin vD∈V. In larger carsharing systems, there are usually several depots VD distributed within the urban area. Especially when a driver lives near a depot, he may prefer to start and end its tour in the same depot. Furthermore, this ensures that always the same number of trucks are located in the depots. However, in order to decrease the total distances traveled by the drivers, it may be suitable for the operators of the carsharing system that the drivers start and end their tours in different depots. The number of drivers starting in depot vD∈VD is represented by a natural number ZDvD; the total number of available drivers is denoted by [formula].

This together yields a (quasi) metric task system, a pair (M,T) where M  =  (V,d) is the above metric space and T a set of tasks, as suitable framework to embed the tours for the convoys. A driver able to lead a convoy plays the role of a server. Each server has capacity L, corresponding to the maximum possible number of cars per convoy; several servers are necessary to serve a task τ  =  (v,x) if [formula] holds.

More precisely, we define the following. An action for driver j is a 4-tuple [formula], where [formula] specifies the driver [formula] performing the action, [formula] specifies the station [formula], t∈[0,T] is the time t(a) when the action is performed, and [formula] the number of cars [formula] to be loaded (if x  >  0) or unloaded (if x  <  0). Hereby, the capacity of the convoy must not be exceeded, i.e., we have [formula]. We say that an action is performed (by a driver) if he loads (resp. unloads) [formula] cars at v. An action is called pickup action if x  >  0, drop action if x  <  0, and empty if x  =  0.

A move from one station to another is [formula], where [formula] specifies the driver [formula] that has to move from the origin station [formula] starting at time [formula] to destination station [formula] arriving at time [formula], and a load of [formula] cars. Hereby, we require that

[formula],

tv'  -  tv  =  d(v,v'), and

from [formula] follows [formula].

A move [formula] with v  =  w is called waiting move.

A tour is an alternating sequence [formula] of moves and actions with

[formula],

[formula],

[formula], and

[formula].

By [formula] we denote the sequence containing the actions of the tour [formula], i.e., [formula], and by [formula] we denote the sequence containing the moves of the tour [formula], i.e., [formula].

The length of a tour corresponds to the distance traveled by the driver. Several tours are composed to a transportation schedule. A collection of tours [formula] is a feasible transportation schedule S for [formula] if

every driver has exactly one tour,

each task [formula] is served (i.e., for every task τ  =  (v,x), the number of cars picked up (resp. dropped) at station v sum up to x),

all system states [formula] are feasible during the whole time horizon

[formula]

The total tour length of a transportation schedule is the sum of the lengths of its tours. Condition [\ref=def:_enum:_schedule:_3] requires that, besides the canonical precedences between a move [formula] and its successor move [formula] in the same tour [formula], also dependencies between tours are respected if preemption is used, i.e., if a car is transported in one convoy from its origin to an intermediate station, and from there by another convoy to its destination. This causes dependencies between tours, since some moves cannot be performed before others are done without leading to infeasible intermediate states (the reason why tours may contain waiting moves). More precisely, an action [formula] induces a precedence, avoiding a system state zt with ztv  <  0 (resp. cap(v)  <  ztv), if one of the following conditions is true:

[formula] drops cars at an overfull station,

[formula] picks up cars at an underfull station,

[formula] drops or picks up cars at a balanced station.

Note, it is possible that the action which is dependent on [formula] may not be uniquely determinable. Furthermore, an action with a dependency to [formula] does not necessarily fulfill any of the three conditions.

We call a transportation schedule non-preemptive if there are no precedences between moves of different tours, and preemptive otherwise. When every driver starts and ends its tour in the same depot, we say it is a transportation schedule with backhaul. Otherwise, we call it a transportation schedule without backhaul.

Our goal is to construct non-preemptive transportation schedules of minimal total tour length for the Relocation Problem in the static situation.

Given a (quasi) metric space [formula] induced by a (directed) weighted graph [formula], start state [formula], destination state [formula] with [formula] and time horizon

[formula]

Min-Cost Flows in Time-Expanded Network

In this section, we give an exact approach for the Static Relocation Problem [formula] without preemption by defining a time-expanded network with coupled flows: car and driver flows. Hereby, we firstly describe the approach for the Static Relocation Problem with backhaul (Sections [\ref=sec:_static:_min-cost_flows:_ten:_wo_pre_w_back]-[\ref=sec:_static:_min-cost_flows:_ilp:_wo_pre_w_back]). Afterwards, in Section [\ref=sec:_static:_min-cost_flows:_without_backhaul], we show how this approach can be modified in order to solve the Static Relocation Problem without backhaul.

We consider a (quasi) metric space [formula] induced by a (directed) weighted graph [formula] representing the set of stations V, a set of depots VD, the road (or logical) connections E between them, driving times [formula], and the (quasi) metric [formula] induced by the shortest path distances in G. In addition, there are per unit costs [formula] and [formula] for moving cars and drivers within G. The task set [formula] consists of the tasks τ  =  (v,z0v - zTv) for all v with z0v  ≠  zTv. The output is a preemptive transportation schedule for the metric task system [formula], the objective is to minimize its total tour length.

For that, we build a directed graph GT  =  (VT,AT), with [formula], as a time-expanded version of the original network G. For each 1  ≤  j  ≤  k, the drivers and their convoys will form flows [formula] and [formula] through GT which are coupled in the sense that on those arcs a∈AL used for moves of convoys, we have the condition [formula] reflecting the dependencies between the two flows.

Time-expanded network

We build a time-expanded version GT  =  (VT,AT) of the original network G.

The node set VT is constructed as follows: for each station and each depot v∈V and each time point t in the given time horizon

[formula]

Flows in

On the relocation arcs of GT, we define for each driver i a driver flow [formula] as well as a car flow [formula] which represents the convoy of this driver. On the holdover arcs of GT, we define a driver flow [formula] for each driver but only one car flow [formula]. We specify the capacities as well as the costs for each arc with respect to the different flows.

A flow on a relocation arc corresponds to a (sub)move in a tour, i.e., some cars are moved by drivers in a convoy from station v to another station v'. Hereby, the stations can be used to pick up or to drop cars, or simply to transit a node (when a driver/convoy passes the station(s) on its way to another station). A relocation arc from (v,t) to [formula] has capacity 1 for each of the driver flow [formula], 1  ≤  i  ≤  k. In order to ensure that cars are moved only by drivers and only in convoys of capacity [formula], we require that

[formula]

Thus, the capacities for the car flows [formula] on the relocation arcs are not given by constants but by a function. Note that due to these flow coupling constraints, the constraint matrix of the network is not totally unimodular (as in the case of uncoupled flows) and therefore solving such problems becomes hard. From Equation [\eqref=eq:_static:_min-cost_flows:_flows:_wo_pre_w_back:_1] it directly follows that [formula] holds for all relocation arcs a∈AL.

Since we consider transportation schedules without preemption, we must ensure that cars are not exchanged between convoys. Furthermore, we have to ensure that there is no "tour internal preemption", i.e., a tour drops a car at one station and later picks it up again. Inner preemption and preemption between tours can be avoided by ensuring that cars are only picked up at overfull stations and dropped at underfull stations. This means that there are more cars in a convoy leaving an overfull station than entering the station. Analogously, there are more cars in a convoy entering an underfull station than leaving the station, and in balanced stations the number of cars entering the station is equal to the number of cars leaving the station. Thus, one has to ensure that the following constraints hold for every 1  ≤  i  ≤  k

[formula]

where δ+L(v,t) denotes the set of incoming relocation arcs of (v,t), and δ-L(v,t) denotes the set of outgoing relocation arcs of (v,t). Note, that the sums in these equations are of a technical nature. In fact, in each of these equations there is at most one summand positive while all other are zero. However, since we do not know in advance which one is positive, we have to sum over all incoming resp. outgoing relocation arcs of a node.

The costs for the driver flows on a relocation arc a correspond to the distance traveled, i.e., if a corresponds to the edge (v,v')∈E the costs correspond to w(a): = w(v,v').

A flow on a holdover arc corresponds to cars/drivers remaining at the station in the time interval

[formula]

Integer linear program for Min-Cost-Flow in GT

To solve the Static Relocation Problem exactly, we aim at determining convoy tours with a minimal total tour length. For that, we summarize the previous sections by presenting an integer linear programming formulation for a min-cost flow problem in the time-expanded network GT  =  (VT,AT): where δ-(v,t) denotes the set of outgoing arcs of (v,t) (and δ-L(v,t) denotes the set of outgoing relocation arcs of (v,t)), and δ+(v,t) denotes the set of incoming arcs of (v,t) (and δ+L(v,t) denotes the set of incoming relocation arcs of (v,t)). The objective function [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_1] measures and minimizes the total tour length of the transportation schedule. The equalities [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_10] and [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_12] give the initial number of cars (resp. drivers) for each station (resp. for the depots). Conditions [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_14] and [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_15] are the flow conservation constraints for the flows [formula] and [formula], respectively. The conditions [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_11] and [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_13] ensure to reach the destination state and that every driver returns to its depot at the end of the time horizon. The conditions [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_16], [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_17] and [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_18] ensure that cars are only picked up at overfull stations, and dropped at underfull stations. Finally, the constraints [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_20] couple the flows [formula] and [formula] so that cars on relocation arcs cannot move without their driver. Furthermore, these constraints give the capacities for [formula] on relocation arcs.

Finally, the flows in the time-expanded network have to be interpreted as a transportation schedule. Hereby, car and driver flows on relocation arcs correspond to a move, differences in the car flow to actions. Note, one can easily compute a transportation schedule from the resulting flows. For that, positive flow [formula] on a relocation arc a  =  ((v,tv),(v',tv')) corresponds to a move [formula]. Actions are implied by differences of flow values between incoming and outgoing relocation arcs, i.e., if we have [formula] with a'  =  ((v',tv'),(v'',tv'')), and [formula] then the action [formula] is implied. This implies:

The optimal solution of system [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back] corresponds to a non-preemptive transportation schedule with minimal total tour length for the Static Relocation Problem with backhaul [formula] (Symmetric and Asymmetric).

Static Relocation Problem without backhaul

In this section, we consider the Static Relocation Problem without backhaul, and highlight the differences between the exact approach for solving the Static Relocation Problem with and without backhaul.

In the integer linear program stated in the previous section, the equations [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_13] ensure that every driver returns to its depot. Thus, it is sufficient to conveniently modify these equations.

For that, we replace the equations [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_13] by the following two constraints

[formula]

Hereby, [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_wo_back:_1] ensures that every driver can return to any depot and [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_wo_back:_2] ensures that the drivers do not end their tours in a station but only in a depot. Thus, we can compute non-preemptive transportation schedules with a minimal total tour length for the Symmetric (resp. Asymmetric) Static Relocation Problem without backhaul.

The combinatorial algorithm ReOpt

The computation times for computing an exact solution by solving the integer linear program [\eqref=eq:_static:_min-cost_flows:_ilp:_wo_pre_w_back:_10]-[\eqref=eq:_static:_min-cost_flows:_wo_pre_w_back:_ilp:_21] are extremely high even for small instances (see Table [\ref=tab:_computational_results]). This motivates the study of a combinatorial algorithm to solve the problem in reasonably short time. Therefore, we describe in detail the strategy ReOpt proposed in [\cite=LAGOS2013] to solve a Static Relocation Problem. The input of ReOpt is the Static Relocation Problem [formula]. Hereby, we consider a complete weighted graph [formula] induced by a (quasi) metric space M  =  (V,d), containing only the overfull stations VO  ⊆  V (with z0i  >  zTi), the underfull stations VU  ⊆  V (with z0i  <  zTi), and a set of depots VD, as well as all connections E between them and driving times [formula]. The task set T again consists of the tasks τ  =  (v,z0v  -  zTv) for all [formula]. The output of ReOpt is a non-preemptive transportation schedule for the (quasi) metric task system (M,T), the objective is to minimize its total tour length.

The ReOpt approach performs three steps. Firstly, we construct a weighted complete bipartite graph and find a matching between overfull and underfull stations with minimal edge weight. Each edge in this matching corresponds to a transport request between two stations. Secondly, tours for all convoys are constructed (using a heuristic insertion technique) serving each transport request. Since the transport requests stemming from the minimum matching do not necessarily lead to optimal convoy tours, the final step is to iteratively augment the tours by "rematching" certain origin/destination pairs, i.e., to reinsert accordingly adapted moves in such a way that the total tour length decreases.

First step: Compute transport requests

In the first step, we compute transport requests of the form (vo,vu,x), where vo is an overfull station, vu an underfull station and x is the number of cars to be transported from vo to vu. For that, we construct a weighted complete bipartite graph [formula] and consider a restricted vector [formula] of edge weights (reflecting the distance between the two adjacent stations) and a vector [formula] of node weights reflecting the number pv  =  |z0v - zTv| of cars which have to be moved in or out the corresponding station v.

Define a perfect p-matching in B to be a multiset [formula] of the edges such that for each node [formula], exactly pv incident edges are selected, counted with multiplicities xa. Note that by construction of [formula], the existence of such a perfect p-matching is ensured by [formula] since [formula]. The goal is to find a perfect p-matching x with minimal edge weight [formula], including multiplicities. The problem can be formulated by the following integer linear program Note that the constraint matrix is totally unimodular, and thus, problem can be solved efficiently [\cite=].

Each selected matching edge a  =  vovu, with vo∈VO and vu∈VU, corresponds to a transport request for xa cars from station vo to station vu. The set [formula] of all such transport requests provides the input for a Pickup and Delivery Problem (PDP) which has to be solved subsequently in order to construct tours for all convoys serving each transport request.

Second step: Serving the transport requests

In this section, we give an algorithm Pdp-Insert which solves the PDP using heuristic insertion techniques. The input for Pdp-Insert is the complete weighted graph [formula], the total number k of drivers, the convoy capacity [formula], and the set of transport requests [formula]. The output of Pdp-Insert is a non-preemptive transportation schedule for the drivers, which serves all transport requests in [formula] within the time horizon

[formula]

Third step: Reoptimization

The algorithm defined here involves the two previous steps: computation of transport requests and the algorithm Pdp-Insert. The input for the reoptimization step is a transportation schedule S serving all transport requests in [formula] and two natural numbers [formula]. The output is a transportation schedule having a total tour length less or equal to the total tour length of S. The algorithmic scheme of the reoptimization step is as follows:

From S we withdraw the N transport requests with highest marginal cost per load: [formula].

From the withdrawn transport requests we compute sets of over- and underfull stations, i.e., the set [formula], the set [formula] and the vector [formula] by xou  =   min {po,pu}, where [formula] and [formula].

For every pair (vo,vu)∈VO*  ×  VU* and every tour [formula] we compute the additional marginal cost [formula], where [formula] and [formula] is the tour after inserting a transport request (vo,vu,1). Let [formula] be the minimal additional marginal cost.

Next we generate a weighted complete bipartite graph [formula] and compute a minimal perfect p-matching (as in Step 1). From the minimal perfect p-matching, transport requests are generated, which serve as input for the algorithm Pdp-Insert (as in Step 2).

Redo these steps Δ times.

Finally, we return the best found transportation schedule, i.e., the one with the smallest total tour length.

Figure [\ref=fig:_reopt] shows an example for the reoptimization step improving a transportation schedule stemming from the minimal perfect p-matching of Step 1.

The algorithm ReOpt is summarized in Algorithm [\ref=alg:_static:_reopt].

Finally, we give some comments about the complexity of the algorithm ReOpt. The minimal perfect p-matching of Step 1 of the algorithm ReOpt (Section [\ref=sec:_static:_reopt:_first_step]), can be computed in polynomial time. Since constructing an optimal transportation schedule from the minimal perfect p-matching (Section [\ref=sec:_static:_reopt:_second_step]) results in a dial-a-ride problem, this step is at least hard. Thus, the second step cannot be solved in polynomial time unless P  =   holds. Therefore, the total complexity of ReOpt is at least in [formula].

Approximation factors

In this section, we consider several different situations and show that in most of these cases, the algorithm ReOpt achieves a finite approximation factor based on the capacity of the convoys. We consider the symmetric and asymmetric situations, when there is only one depot on the system and when there are multiple depots. In the case of multiple depots, we distinguish between tours with and without "backhaul", i.e., whether each driver has to return to its starting depot (with backhaul) or to any depot in the system (without backhaul). Obviously, in the case of only a single depot in the system, the Static Relocation Problem with backhaul and without backhaul coincide.

Firstly, we consider the case when there is only one depot in the system (Section [\ref=sec:_static:_reopt:_single_depot]). Hereby, we show that the approximation factor is equal in both cases, the symmetric and the asymmetric one. Secondly, we consider multiple depots in the system (Section [\ref=sec:_static:_reopt:_multiple_depot]). In this case, the symmetric and asymmetric situations become different, depending whether the transportation schedule contains only tours with or without backhaul.

Throughout this section, we assume that the time horizon is always large enough.

Single depot

In this section, we show that in the case when there is only one depot in the system, ReOpt achieves a finite approximation factor based on the capacity of the convoys.

For the Static Relocation Problem [formula] with one depot, the algorithm ReOpt achieves an approximation factor of [formula].

That ReOpt computes a non-preemptive transportation schedule for the Static Relocation Problem has already been observed in the previous section. In order to prove the approximation factor, we first introduce some definitions, as well as state and prove some lemmas.

Firstly, from a given tour, we construct a new tour where each action picks up (resp. drops) exactly one car. Considering such tours only simplifies several technical issues, like estimating the number of consecutive pickup actions. Secondly, we construct a new transportation schedule from an optimal transportation schedule and a minimal perfect p-matching. Finally, we compare the lengths of an optimal transportation schedule S*, a transportation schedule Sp derived from a minimal perfect p-matching, and the constructed transportation schedule St and show that

[formula]

holds, which proves the stated approximation factor. Hereby, we construct the transportation schedule Sp by taking moves and actions of the optimal transportation schedule S* and by constructing moves from the transport requests of the minimal perfect p-matching. Then, the approximation factor (L  +  1) emerges from the maximal number of moves corresponding to moves through the system in order to pickup cars and from moves which are serving a transport requests.

We start by showing how to construct a tour [formula] from a given tour [formula], where in each action exactly one car is picked up or dropped.

For every [formula] do

add move [formula] to [formula],

for every action [formula] where more than one car is picked up from a station v at time tv, we "replace" the action by actions each picking one car and waiting moves (with 0 waiting time) between these actions, i.e., if x  >  1 then add the following x actions and x - 1 moves [formula] are added to [formula],

for every action [formula] where more than one car is dropped at a station w at time tw, we "replace" the action by actions each picking one car and waiting moves (with 0 waiting time) between these actions, i.e., if x  <   - 1 then add the following x actions and x - 1 moves [formula] are added to [formula],

every action [formula] with - 1  ≤  x  ≤  1 is added unchanged to [formula].

The tour [formula] is called a uniform tour corresponding to [formula]. A transportation schedule containing only uniform tours is called uniform transportation schedule.

Note that a uniform tour is indeed a tour. Furthermore, note that there exists exactly one uniform tour corresponding to a tour (if no unnecessary empty actions and waiting moves are added), but from a uniform tour, one can generally derive several non-uniform tours.

In this section, we consider non-preemptive transportation schedules, i.e., there does not exist a tour depending on another tour. Therefore, empty actions can be safely removed from any tour in a transportation schedule (some moves may need to be adjusted accordingly). For the rest of this section, we assume that no action is empty.

Let us consider the graph and the dashed tour for driver 1 from the right side of Figure [\ref=fig:_reopt]. The tour is then given by

[formula]

and the corresponding uniform tour is then

[formula]

The "replaced" action is highlighted with bold fonts, all other actions [formula] have already the form [formula].

The following lemma is a direct conclusion from the construction of an uniform tour.

Let [formula] be a uniform tour for driver j. Then there are at most [formula] consecutive pickup (resp. drop) actions in the sequence [formula].

Next, we construct a graph G from a given tour, where the set of nodes corresponds to the actions, and the set of arcs to the moves of the tour. Afterwards, we combine this graph with transport requests (leading to a graph Gt), which then helps us to construct another tour (from this tour we finally gain the transportation schedule St). This constructed tour has some nice properties with respect to the number of traverses of each arc of Gt, which finally helps us to prove our main result (Theorem [\ref=thm:_static:_reopt:_approximation_factor]).

From a given tour [formula], we construct a directed weighted graph [formula], where

the set of nodes [formula] corresponds to the actions in [formula], V +  corresponds to the set of pickup actions, V -  to the set of drop actions, and V =  to an empty action at the depot vD, i.e., V =   =  {(  ·  ,vD,0)};

there is an arc from v∈V to v'∈V if [formula] and [formula] for a [formula], furthermore there is an arc from (  ·  ,vD,0) to [formula] and from [formula] to (  ·  ,vD,0);

the weight function w corresponds to the distances between the origin and destination stations of the corresponding moves, i.e., we set [formula].

We call such a graph a tour graph for [formula], the set A is called the set of tour arcs.

Note that one can assign to every arc a∈A of a tour graph a move [formula]. Then [formula] is called the corresponding move to a.

The tour graph for the tour [formula] from Example [\ref=ex:_static:_reopt:_uniform_tour] is illustrated in Figure [\ref=fig:_static:_reopt:_tour_1_action].

Analogously, to a uniform tour we now define a set of uniform transport requests. A transport request (vi,wi,xi) is called uniform if xi  =  1. Obviously, every set of transport requests can be transformed into a set of uniform transport requests by splitting every transport request (vi,wi,xi) into xi uniform transport requests. A set of transport requests [formula] is called set of uniform transport requests if every transport request [formula] is uniform.

To each uniform transport request [formula], we can now assign two actions for a driver j, one pickup (j,v,1) and one drop action (j,w, - 1). Hereby, every action is assigned to exactly one transport request.

Let G  =  (V,A,w) be a tour graph and let [formula] be a set of transport requests. Then we construct a directed weighted graph [formula], where At is the set of transport arcs, which consist of arcs corresponding to the transport requests in [formula], i.e., for a transport request [formula] there is an arc between v,v'∈V if v is the assigned pickup action of r and v' the assigned drop action of r. The weight of a transport arc is equal to the distance between the locations of the two assigned actions. The graph Gt is called a transport graph (see Figure [\ref=fig:_static:_reopt:_transport_graph] for an illustration).

Let G  =  (V,A,w) be a tour graph for a tour [formula] for driver j and let [formula] be a set of transport requests. From a transport graph [formula] for G and [formula], one can construct a new tour [formula] that serves all transport requests in [formula], as follows:

Start in the depot vD (resp. the node corresponding to the depot).

Consider the next tour arc a∈A or non-traversed transport arc at∈At.

If a tour arc a  =  (v,w) is selected, we add a corresponding move m to [formula] from [formula] to [formula] with [formula].

If necessary, add empty actions (or merge the moves).

If a transport arc at  =  (v,w) is selected, we add the pickup action v, a move [formula] and a drop action w to [formula].

When all transport requests are served, return to depot the by following tour arcs until the depot is reached.

The departure and arrival times of a move [formula] are directly induces by the departure and arrival times of the moves preceding [formula].

Note that following this construction, we always construct a tour. However, without further restrictions this easy construction does not ensure an upper bound on the number of traverses of an arc (later in Algorithm [\ref=alg:_static:_reopt:_construct_tour] we give a refined construction which ensures an upper bound on the number of traverses of an arc).

When we speak about a constructed tour (from a transport graph Gt and a set of transport requests TR), we mean a tour [formula] which is constructed using only the arcs from Gt and which serves all transport requests from [formula].

Let us consider the transport graph from Figure [\ref=fig:_static:_reopt:_transport_graph]. A possible new tour serving all transport requests [formula] constructed from the transport graph, is then given by (see Figure [\ref=fig:_static:_reopt:_tour_from_transport_graph] for an illustration)

[formula]

Hereby, the stations b1 and b2 both correspond to the station b. However, for the sake of readability, we use b1 and b2 instead of b.

Our goal is to construct a new tour from a transport graph, constructed from an optimal tour, and from a set of transport requests, which is generated from a minimal perfect p-matching. Then, we show that the approximation factors from Theorem [\ref=thm:_static:_reopt:_approximation_factor] hold for this constructed new tour. For that we define a function which returns for each arc of a transport graph the number of traverses of the arc during the construction of the tour.

Let [formula] be a uniform tour, [formula] be a set of transport requests and [formula] be a transport graph for [formula] and [formula]. Furthermore, let [formula] be a constructed tour from Gt and [formula]. Then, we consider a so-called traverse counter function, which is a function [formula] which reflects how often a tour arc a∈A is traversed during the construction of [formula].

With the function fa, we counts the traverses of the tour arcs only, while we the request arcs are handled later.

Let us consider the transport graph from Figure [\ref=fig:_static:_reopt:_transport_graph] and the tour [formula] from Example [\ref=ex:_static:_reopt:_tour_from_transport_graph]. The traverse counter function fa is then

[formula]

Note that there are two arcs in the transport graph from Figure [\ref=fig:_static:_reopt:_transport_graph] between b+2 and d-, one tour arc and one request arc. Hereby, the tour [formula] is constructed not by traversing the tour arc (b+2,d-) but instead by traversing the transport arc from b+2 to d- is traversed. Thus, we have fa(b+2,d-)  =  0.

Let [formula] be a uniform tour starting and ending in depot vD, [formula] a set of transport requests, and [formula] a transport graph for [formula] and [formula]. Furthermore, let [formula] be the constructed tour from Algorithm [\ref=alg:_static:_reopt:_construct_tour] and let fa be a traverse counter function for [formula]. Then [formula] holds for all tour arcs a∈A. More specifically, we have

[formula] holds for all tour arcs a  =  (v,w)∈A with v∈V - ,

[formula] holds for all tour arcs a'  =  (v',w')∈A with v'∈V + .

In the Example [\ref=ex:_static:_reopt:_traverse_counter_function], we can already make an important observation, namely, nodes corresponding to a pickup action increase the number of traverses, nodes corresponding to a drop action decrease the number of traverses. Next, we show that this observation is always true.

There are several consequences from this lemma. Firstly, we show in the next corollary that the difference of the number of traverses of two different tour arcs can be bounded from above. Secondly, we show a relation between the number of traverses of an arc and the number of cars that are transfered in the corresponding move within the constructed tour.

Next, we show that the maximum of a traverse counting function is always on the incoming and outgoing tour arcs of the depot.

In Algorithm [\ref=alg:_static:_reopt:_construct_tour] we describe a specific construction for new tours from a given tour and a given set of transport requests. For this new tour [formula] holds for all a∈A. This can be seen as follows.

It is fairly easy to see that Algorithm [\ref=alg:_static:_reopt:_construct_tour] follows basically the same steps as in Remark [\ref=rem:_static:_reopt:_construct_tour_from_transport_graph]. Furthermore, one can easily see that really a tour is constructed, serving all transport requests. In contrast to the construction in Remark [\ref=rem:_static:_reopt:_construct_tour_from_transport_graph], Algorithm [\ref=alg:_static:_reopt:_construct_tour] "follows" the given tour only until it arrives at a non-visited node corresponding to a pickup action and directly serve the transport request.

Since the constructed tour in Algorithm [\ref=alg:_static:_reopt:_construct_tour] "follows" the moves from [formula] until the next non-visited pickup action, it is ensured, that the number of traverses of an arc is not artificially increased. Thus, the result follows with the help of Lemma [\ref=lem:_static:_reopt:_max_consecutive_actions], Claim [\ref=lem:_static:_reopt:_abs_diff_1], Claim [\ref=cor:_static:_reopt:_leq_C] and Claim [\ref=cor:_static:_reopt:_f_geq_f_and_f_gt_f].

Although Algorithm [\ref=alg:_static:_reopt:_construct_tour] starts the construction of the tour from the depot, any arbitrary node could be used as a starting node. That could be done by removing line [\ref=alg:_static:_reopt:_construct_tour:_4] and giving currNode as a parameter. When the construction is started with another node, Lemma [\ref=lem:_static:_reopt:_f_leq_c_plus_1] still holds, and so does Lemma [\ref=cor:_static:_reopt:_existence_tour].

Let [formula] be a uniform tour, and let [formula] be a set of uniform transport requests so that [formula] serves all transport requests in [formula]. Furthermore, let [formula] be a transport graph for [formula] and [formula]. Since every transport request [formula] is served by [formula], there exists a path of tour arcs in Gt from the action [formula] corresponding to v to the action [formula] corresponding to v'. Let this path of tour arcs be [formula]. Due to the triangle inequality we can estimate the length [formula] of the transport arc by

[formula]

Therefore, the length of all transport arcs can be estimated by applying above formula iteratively on all transport arcs,

[formula]

where p(a) is the minimal path of tour arcs in Gt between the corresponding actions. Now we can consider a function [formula], called transport estimate function, where [formula] shows how often the tour arc a is used in the right hand side of Equation [\eqref=eq:_static:_reopt:_estimate_length_all_transport_arcs]. With [formula] can reformulate Equation [\eqref=eq:_static:_reopt:_estimate_length_all_transport_arcs] as

[formula]

It is easy to see, that the values of a transport estimate function depends on the choice of the set of transport requests [formula]. In order to prove the main theorem, we consider a specific set of transport requests. For that let [formula] be a uniform tour for a driver starting and ending in depot vD. A set of uniform transport requests [formula] so that

[formula] serves all transport requests in [formula],

for every transport request [formula] there are at most [formula] actions between two corresponding actions for r, and

there does not exist a transport request [formula] so that the minimal path from [formula] to [formula] of tour arcs traverses the tour arcs connecting the depot,

holds is called a set of close distance uniform transport requests for [formula].

In the next lemma, we show that for every uniform tour there exists a set of close distance uniform transport requests. Hereby, also the motivation for the choice of the name becomes clear as well.

Let [formula] be a uniform tour for a driver starting and ending in depot vD. Then there exists a set of close distance uniform transport requests for [formula].

Let [formula]. Since a tour starts and ends in the depot and there must be no car in the depot it follows that

[formula]

holds for every tour [formula]. Furthermore, if [formula] contains actions, it follows that the first action is a pickup action and the last action a drop action. Otherwise, there exists a move [formula] with x  <  0 or [formula] or the driver transfers vehicles into the depot, contradicting the definition of a tour.

We construct a set of transportation requests [formula] by assigning the station of the first pickup action in [formula] to the station of the first drop action in [formula], the station of the second pickup action in [formula] to the station of the second drop action in [formula], and so forth until all actions are assigned. Since the number of cars picked up or dropped in an action in [formula] is exactly one and due to Equation [\eqref=eq:_static:_reopt:_existence_tour:_zero_sum], there exists a pickup action for a drop action. Thus, it also follows that the number of actions is even in [formula].

Let [formula] be a transportation request and let [formula] be the corresponding pickup and [formula] the corresponding drop action for r. Using this construction, we show that there are at most [formula] actions between [formula] and [formula].

We prove the statement by induction over the number of actions [formula] in [formula]. For [formula] and [formula] there are [formula] actions between [formula] and [formula] proving the base case.

Let us assume that the induction hypothesis holds, i.e., there are at most [formula] actions between [formula] and [formula] for all tours with [formula] actions.

Next, we prove the inductive step. For that, let [formula] have [formula] actions.

We construct a sequence of [formula] actions and [formula] moves from [formula] by removing the first pickup and the first drop action from [formula]. Afterwards, we show that this sequence is a tour. Then the statement follows from the induction hypothesis.

Since every action is non-empty, [formula] is the first pickup action. Let [formula] be the first drop action. Furthermore, let [formula], [formula] and [formula], [formula].

First, let us consider the following new moves 1,2  =  (j,v1,tv1,w2,tw2,x1) and [formula] and let i  =  (j,vi,tvi,wi,twi,xi  -  1), for all [formula], be a move constructed from the move [formula]. Finally, let [formula] for all [formula].

Then [formula] is an alternative sequence of [formula] moves and [formula] actions. We show that [formula] is indeed a tour. It is sufficient to show for every move i  =  (j,  ·  ,  ·  ,  ·  ,  ·  ,xi) in [formula] that [formula] holds.

For that, we consider the number n+ of consecutive pickup actions before the move [formula] and number n- of consecutive drop actions directly after [formula] in [formula], as well as the number n̂+ of consecutive pickup actions before the move [formula] and number n̂- of consecutive drop actions directly after [formula] in [formula]. Since [formula] is a tour, it follows from Lemma [\ref=lem:_static:_reopt:_max_consecutive_actions] that [formula] holds. From the construction of [formula] it follows

[formula]

and, thus, we have [formula]. Furthermore, it follows that the number of cars in the convoy of driver j are equal in both sequences in and after the move [formula] and [formula], respectively, i.e., for every [formula] we have [formula], where xi is the number of cars in the move i.

Then, it follows for every move i  =  (j,  ·  ,  ·  ,  ·  ,  ·  ,xi) in [formula] that [formula] holds, and, thus, that [formula] is a tour with [formula] actions. Therefore, the induction hypothesis can be applied to [formula] and it follows that there are at most [formula] actions between the corresponding pickup and drop actions of a transportation request. Since there are at most [formula] consecutive pickup actions at the start of a tour (Lemma [\ref=lem:_static:_reopt:_max_consecutive_actions]), it follows that there are at most [formula] actions between the first pickup action and the first drop action. This proves the inductive step and the statement follows.

Since we assign a transport request to every pickup and drop action, the tour serves all transport requests in [formula].

Finally, it follows by construction that there does not exist a transport request [formula] so that the minimal path from [formula] to [formula] of tour arcs traverses the tour arcs connecting the depot.

Let [formula] be a uniform tour starting and ending in depot vD, and let G  =  (V,A,w) be a tour graph for [formula]. Furthermore, let [formula] be a function that returns the number of cars transfered in the corresponding moves in [formula], and let [formula] be a set of close distance uniform transport requests for [formula]. Then for a transport estimate function [formula] for [formula] it holds

[formula] for all a∈A, and

[formula] for all a,a'∈A.

Firstly, we show that for a transport graph [formula] for [formula] and [formula] and a transport estimate function [formula] for Gt

[formula] for all a  =  (v,w)∈A, a'  =  (w,u)∈A with w∈V - , and

[formula] for all a  =  (v,w)∈A, a'  =  (w,u)∈A with w∈V + ,

holds. Within the proof, we also show that [\ref=cor:_static:_reopt:_existence_tour:_1] holds. Secondly, the Statement [\ref=cor:_static:_reopt:_existence_tour:_2] follows from Claim [\ref=cor:_static:_reopt:_leq_C] [\ref=cor:_static:_reopt:_leq_C:_2].

To prove the third statement, we show that [formula], where [formula] is the move corresponding to the tour arc a  =  (v,w)∈A. This can be seen as follows. Since [formula] is a set of close distance transport requests, there does not exist a transport request [formula] so that the minimal path of tour arcs traverses the tour arcs connecting the depot. Thus, we have [formula] where a  =  (vD,v1)∈A and a'  =  (  ·  ,vD)∈A. Since [formula] is a tour, the node v∈V corresponds to a pickup action. Thus, for the move [formula] corresponding to the tour arc a1  =  (v1,v2), we have xa1  =  1. Furthermore, the tour arc a1 appears once on the right hand side of Equation [\eqref=eq:_static:_reopt:_estimate_length_all_transport_arcs], i.e., [formula].

If v2∈V +  corresponds to a pickup action then the number of cars transfered from v2 to the next station is increased by one. Since the destination of the transport request that started in v1 does not correspond to v2, the corresponding tour arc a2 appears twice on the right hand side of Equation [\eqref=eq:_static:_reopt:_estimate_length_all_transport_arcs]: once due to the transport request (v1,  ·  ,1) and once due to (v2,  ·  ,1).

Analogously, if v2∈V -  corresponds to a drop action, the number of cars transfered from v2 to the next station is decreased by one. Since the transport arc corresponding to the transport request (v1,v2,1) ends in v2, the number of appearances of the tour arc a2  =  (v2,  ·  )∈A on the right hand side of Equation [\eqref=eq:_static:_reopt:_estimate_length_all_transport_arcs] is decreased as well.

In the first case we have [formula] and in the second case [formula].

The above arguments can be applied iteratively to all nodes in [formula], showing that [\ref=lem:_static:_reopt:_existence_tour:_iii:_i] and [\ref=lem:_static:_reopt:_existence_tour:_iii:_ii] hold.

Since the values of the transport estimate function [formula] corresponds to the number of cars transfered in the corresponding move, the stament follows directly from Claim [\ref=cor:_static:_reopt:_leq_C] [\ref=cor:_static:_reopt:_leq_C:_2].

Finally, we prove the main theorem of this section.

For the Static Relocation Problem [formula] with one depot, the algorithm ReOpt achieves an approximation factor of [formula] for all [formula]. This approximation factor holds in the symmetric and in the asymmetric case.

We start by proving a special case when there is only one driver in the system. Afterwards, we generalize this special case to the general situation when there are k drivers in the system.

Let [formula] be an optimal tour for [formula]. Let [formula] be a set of transportation requests induced by a minimal perfect p-matching, and let [formula] an optimal tour serving all transport requests in [formula], i.e., a tour with a minimal total tour length serving all transport requests in [formula]. Finally, let [formula] be the constructed tour from Algorithm [\ref=alg:_static:_reopt:_construct_tour]. Then we have

[formula]

where [formula] is the total tour length of the tour [formula]. Thus, we only need to show that

[formula]

holds.

Let [formula] be a set of close distance uniform transport requests. Since [formula] is induced by a minimal perfect p-matching, it holds

[formula]

Let fa be a traverse counter function for [formula] and let [formula] be a transport estimate function. Let [formula] be a function that returns the number of cars transfered in the corresponding moves in [formula]. By definition, a convoy is empty at the beginning of a tour, and therefore, t(a0)  =  0 for a0  =  (vD,  ·  )∈A. Since we have [formula] for all a∈A (Lemma [\ref=cor:_static:_reopt:_existence_tour] [\ref=cor:_static:_reopt:_existence_tour:_1]), it follows [formula]. From Lemma [\ref=lem:_static:_reopt:_f_leq_c_plus_1] we know that [formula] for all a∈A, and thus, it follows from Lemma [\ref=cor:_static:_reopt:_existence_tour] [\ref=cor:_static:_reopt:_existence_tour:_2] that [formula] holds for all a∈A.

With above and Equation [\eqref=eq:_static:_reopt:_estimate_length_all_transport_arcs:_fTR] we can estimate the total tour length [formula] by

[formula]

proving the statement of the theorem if there is only one driver in the system.

Next we consider the general case, i.e., there are [formula] drivers. Since there is only one depot, and every tour starts and ends in the depot, all tours can be "merged" to one tour. For that let [formula] be a transportation schedule with k tours and with [formula]. Since by assumption T is large enough, we can construct a new tour [formula], where (except for the first and last tour) the moves to and from the depot are replaced by one move between the succeeding and preceding station, respectively (see Figure [\ref=fig:_static:_reopt:_k_tour_one_driver] for an illustration). Thus, all k tours are performed by only one driver. Due to the triangle inequality it follows that the length of the tour [formula] is at most the total tour length of the transportation schedule S. Therefore, we can generalize the statement when there are k drivers in the system.

Finally, note that we constructed a new tour by following either the tour arcs (induced by an optimal tour) or the transport request arcs (induced by the minimal perfect p-matching). Especially, no back arc is traversed. Thus, it follows that this approximation factor is also valid for the asymmetric case when there is only one depot.

Multiple depots

In the case that there is only one depot, the algorithm ReOpt has an approximation factor of [formula], independently from the number of drivers, or whether we have the symmetric or asymmetric case. In this section, we consider the case when there are multiple depots. Hereby, we can further distinguish between two situations: every tour must start and end in the same depot (Static Relocation Problem with multiple depots and with backhaul), and every tour can start and end in a different depot (Static Relocation Problem with multiple depots and without backhaul).

Firstly, we consider the situation where every tour can start and end in a different depot (i.e., tours without backhaul). We show that in the asymmetric case, the algorithm ReOpt generally does not have an approximation factor. However, we give for a special case an approximation factor of [formula], namely when in the optimal tour every driver returns to the depot from where its tour started. Note that this special case makes an assumption to the properties of an optimal tour, while the case when we have backhaul forces the tours to have certain properties in order to be a feasible solution for the Static Relocation Problem. In the symmetric case without backhaul, the approximation factor is [formula]. We gain the factor 2 since the algorithm ReOpt ensures that all drivers return to their starting depot.

Secondly, we consider the situation when every tour must end in its starting depot (i.e., tours with backhaul). In this situation, we can show that the algorithm ReOpt has an approximation factor of [formula] in the symmetric and asymmetric situation. We show this approximation factor, by applying nearly the same steps as we do in previous section, where we prove the approximation factor for the case when there is only a single depot. In fact, we mainly modify the construction of the transport graph (Definition [\ref=def:_static:_reopt:_multiple:_transport_graph]) and Algorithm [\ref=alg:_static:_reopt:_construct_tour], so that they are able to handle not only one tour but multiple tours (Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot]).

In order to show, that there does not exist an approximation factor for the algorithm ReOpt in the asymmetric case, even when there is only one driver, we consider the following example.

We consider the asymmetric situation with two depots v1D and v2D and four stations V  =  {a,b,c,d}. There is only one driver in the system, the convoy capacity is 1. In the stations a and c, one car has to be picked up, and at b and d one car has to be dropped. We consider the following distances

[formula]

and for all other pairs of stations v and w we set

[formula]

with x  ≫  2 arbitrary. An optimal tour [formula] serving all requests is induced by the path (v1D,a,b,c,d,v2D). The total tour length [formula].

A set of transport requests induced by a minimal perfect p-matching is given by [formula]. The total tour length [formula] for every tour, serving the transport requests in [formula], is at least x  +  4. Since x was arbitrarily selected, there cannot exist a constant [formula] so that

[formula]

holds.

The reason why we cannot give an approximation factor in the previous example is that we have to traverse at least once an arc that is not traversed by an optimal tour. Note that this example holds for all algorithms which compute tours using all arcs from a minimal perfect p-matching. An open question is whether there exists a deterministic algorithm for the Static Relocation Problem with multiple depots without backhaul with a constant approximation factor.

However, in order to prove an approximation factor for the a special case of the Asymmetric Static Relocation Problem with multiple depots without backhaul, where in the optimal transportation schedule every driver returns to its starting depot, and in order to prove the approximation factor for the Symmetric Static Relocation Problem with multiple depots without backhaul, we have to give some definitions and further results.

First, we define a graph similar to a transport graph, but in this case it is constructed from a transportation schedule instead of a tour. As in the transport graph, the nodes correspond to the actions, and the arcs correspond to moves.

From a given transportation schedule [formula], where [formula] we can construct a weighted graph [formula], with [formula], [formula], [formula] and [formula], where

the sets of nodes [formula] correspond to the actions in [formula]; the set of pickup nodes V + j corresponds to the set of pickup actions, the set of drop nodes V - j to the set of drop actions, the set of depot nodes V = j to the set containing empty actions at the depots, i.e., [formula];

there is an arc from v∈Vj to v'∈Vj if [formula] and [formula] for a [formula], furthermore there is an arc from (j,vjD,0) to [formula] and from [formula] to (j,vjD,0);

the weight function w corresponds to the distances between the origin and destination stations of the corresponding moves, i.e., we set [formula].

We call such a graph a schedule graph for S, the set A is called the set of schedule tour arcs.

Let [formula] be a set of transport requests. Then a graph [formula] is called transport schedule graph if [formula] is a schedule graph and the set At corresponds to the transport requests, i.e., to every transport request [formula] there is an arc [formula] assigned to r.

Let [formula] be a transportation schedule, let [formula] be a set of transport requests, and let [formula] be the corresponding transport schedule graph. Then we can construct a directed graph from a transport schedule graph, which has as nodes the tours and as arcs the transport requests between the tours. Laxly said, this graph "highlights" the transport requests which are between two different tours. This simplified version of a transport schedule graph enables us to prove some properties which we need in order to gain an approximation factor for ReOpt which is independent from the number of depots in the system. Formally, we define a directed graph Gs  =  (Vs,As), with

each node vs∈Vs corresponds to a tour [formula], and

every arc corresponds to a transport request [formula], where [formula] and [formula] are in different tours, i.e., [formula], [formula], with i  ≠  j.

We call the graph Gs a tour connection graph for Gtm (see Figure [\ref=fig:_static:_reopt:_multiple:_tour_connection_graph] for an illustration). Note, that a tour connection graph is loop free, but there can be multiple arcs between two nodes.

Let [formula] be a transportation schedule, let [formula] be a set of transport requests, and let [formula] be a corresponding transport schedule graph. Furthermore, let Gs be a tour connection graph for Gtm. Then it is true

every connected component in Gs is also strongly connected,

if every tour in S is a tour with backhaul, then every connected component in Gtm is also strongly connected.

"[\ref=lem:_static:_reopt:_multiple:_tour_connection_graph:_connected_thus_strongly:_1]": we prove that for every node vs∈Vs and for every outgoing arc as∈As of vs there exists an incoming arc as∈As of vs. Every transport arc at  =  (v,w)∈At connects exactly two actions. Whenever v corresponds to an action in one tour [formula] and w corresponds to an action in another tour [formula], there is an arc as∈As. Since every action in S is uniform, it follows that the number of non-empty actions in every tour is even. Therefore, there must exist a transport arc (v',w')∈At, with [formula] and [formula], i.e., there is an incoming arc in As. Thus, we have [formula] for all vs∈Vs.

From Euler's Theorem it now follows that in every connected component of Gs there exists an Eulerian walk. Especially, it follows that every connected component of Gs is also strongly connected.

"[\ref=lem:_static:_reopt:_multiple:_tour_connection_graph:_connected_thus_strongly:_2]": since S is a transportation schedule with backhaul, every tour of S is represented by a cycle of tour arcs in G and, thus, a strongly connected component. From the two statements above it follows that every connected component in Gtm is also strongly connected.

Note, in the asymmetric case without backhaul, connected components in Gtm are generally not strongly connected (e.g., see Example [\ref=ex:_static:_reopt:_multiple:_asymmetric_non_possible]). Furthermore, whenever we modify this graph so that every connected component becomes strongly connected, at least one arc cannot be estimated in general. Later we see that in the symmetric case, we can modify Gs so that every connected component in Gs is also strongly connected and every added arc can be estimated. This is achieved by connecting some actions with the "original" depot. In the symmetric case, an approximation factor can then still be computed since the distance from v to w is equal to the distance from w to v.

Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot] constructs a new transportation schedule with backhaul from a given uniform transportation schedule with backhaul, a set of depots and a set of uniform transport requests. Hereby, the algorithm always prioritizes following transport request arcs over following tour arcs. Similarly to the constructed tour from the previous section, we state and prove some properties of this transportation schedule.

It is easy to see that Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot] constructs a new transportation schedule. However, it is not obvious that in this transportation schedule all drivers return to their original depot, which we show in the next lemma.

Let S be a uniform transportation schedule with backhaul, let VD be a set of depots and let [formula] be a set of uniform transport requests. Then Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot] constructs a new transportation schedule with backhaul.

In Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot] we "follow" the tour arcs of a tour until we come to a pickup node that has not been visited before (lines [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot:_8] and [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot:_16]). If in the algorithm the current node is a non-visited pickup node, then the algorithm "follows" the transport (lines [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot:_9]-[\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot:_14]). From Lemma [\ref=lem:_static:_reopt:_multiple:_tour_connection_graph:_connected_thus_strongly] we know that every connected component in G is also strongly connected. Furthermore, the number of incoming and outgoing arcs for every node in Gs are equal and, thus, there exists an Eulerian walk in Gs. Therefore, it follows that the transportation schedule constructed in Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot] is a transportation schedule with backhaul.

Next, we show that the approximation factor [formula] holds even in the case of multiple depots.

For the Static Relocation Problem [formula] with multiple depots and with backhaul, and a complete graph G, the algorithm ReOpt computes a non-preemptive transportation schedule and achieves an approximation factor of [formula]. This approximation factor holds for the symmetric and asymmetric situation.

In order to prove this statement, we show how the results of the previous section can be applied to the case when there are multiple depots. For that we concentrate on an arbitrary tour from the optimal transportation schedule and show that we can apply the results from the previous section on this tour. Since the tour is arbitrarily selected, the statement then follows.

Let Gtm be a transport schedule graph for an optimal transportation schedule S and let [formula] be a set of transport requests computed from a minimal perfect p-matching. Let [formula] be an arbitrary tour. We say that there is a transport request between tours, if there exists a transport request arc (v,w) in Gtm so that v∈V + i and w∈V - j with i  ≠  j. In other words, if v corresponds to a pickup action in a tour [formula] and w corresponds to a drop action in tour [formula] with i  ≠  j.

As we did before, we construct tours [formula] from the optimal transportation schedule and the set of transport requests.

We consider two different cases for this tour, when there are no transport requests in [formula] between this tour and another tour, and when there are transport requests in [formula] between this tour and another tour.

Case 1 (there are no transport requests in [formula] between this tour and another tour): in this case, we can directly apply Theorem [\ref=thm:_static:_reopt:_approximation_factor] on [formula], showing the statement for this case.

Case 2 (there are transport requests in [formula] between this tour and another tour): in this case, we cannot directly apply Theorem [\ref=thm:_static:_reopt:_approximation_factor] as we did in the previous case. However, due to Remark [\ref=rem:_static:_reopt:_arbitrary_start_node], it is not necessary to start the construction of a new tour within the depot but it can be used any arbitrary node within a transport graph. Furthermore, all results from Section [\ref=sec:_static:_reopt:_single_depot] hold, when the construction has not been started in the depot.

From Lemma [\ref=lem:_static:_reopt:_multiple:_tour_connection_graph:_connected_thus_strongly] it follows that whenever Algorithm [\ref=alg:_static:_reopt:_multiple:_construct_tour_multiple_depot] "leaves" a tour at node [formula], it will eventually "return" to a node [formula]. Hereby, w is the first "entered" node after the tour has been changed.

From the point of view of the tour [formula], the path from v to w in Gtm is like a transport request from v to w. Thus, we replace this path by an artificial transport request arc (v,w). By repeating this procedure for all nodes which are start or end nodes of a transport request between [formula] and another tour, we receive a transport graph [formula]. On the constructed tour from [formula] and the transport requests we apply Theorem [\ref=thm:_static:_reopt:_approximation_factor]. Since the tour was arbitrarily selected, this proves the statement.

Finally, we consider the Symmetric Static Relocation Problem with multiple depots and without backhaul. For a first result, we show that the algorithm ReOpt achieves an approximation factor of at most [formula]. In order to prove this approximation factor, we construct in an intermediate step a transportation schedule with backhaul [formula] from the optimal transportation schedule S*. For every tour [formula] we construct a new tour [formula] by adding an arc from the last action of [formula] back to the "starting" depot (if they differ in the original tour). Since we consider the symmetric situation, this arc can be estimated by the total tour length of [formula]. Thus, the total tour length of this constructed transportation schedule is at most twice as large as the total tour length of the optimal transportation schedule. Applying Theorem [\ref=thm:_static:_reopt:_multiple:_with_backhaul:_C_plus_1] on [formula] then yields:

For the Symmetric Static Relocation Problem [formula] with multiple depots and without backhaul, and a complete graph G, the algorithm ReOpt computes a non-preemptive transportation schedule and achieves an approximation factor of [formula].

Computational Results

Both, the exact approach and the heuristic approach ReOpt, have been tested on randomly generated instances (with 20-80 over-/underfull stations, 50-100 stations in total, convoy capacities 5 and 10, and 10-30 drivers). The stations are randomly distributed on a plane and the distances between two closest stations (w.r.t. the Euclidean metric) are kept as rounded integers in the graph. Hereby, we ensure that the graph is connected. The time horizons are set to 100 in all test runs. Note that the size of these instances corresponds to small car- or bikesharing systems or to clusters of larger systems, as in [\cite=SHH-2013].

The algorithm ReOPT has been implemented in C++, and CPLEX v12.4 is used for solving ILPs. The operating system is Linux (CentOS with kernel version 2.6.32). The tests have been run on an Intel Xeon X5687 clocked at 3.60GHz, with 64 GB RAM.

For solving the integer linear program of the exact approach, we use Gurobi 5.6. The test have been run on a Linux server (CentOS with kernel version 2.6.32) with 160 Intel Xeon CPUs E7-8870 clocked at 2.40GHz, with 1 TB RAM. For the tests, we limited the number of threads to 32. Since we could not find any feasible solution for the first instance after 40 hours, we rerun the solver on this instance with an increased time-limit of 160 hours. After about 50 hours, a feasible solution has been found by Gurobi. However, even after 160 hours, the optimal solution could not be found. Due to the enormous runtime and the little to no gain, we did not rerun the solver with an increased time-limit on the remaining instances. The solution found by the ILP solver has a total tour length of 337 units and the lower bound found by Gurobi is 109 (thus, the duality gap is approximately 67.7%). Due to the enormous runtime of finding a solution with the exact approach, we did not continue with the other instances. Furthermore, one can see, that the improvements of the solution of the ILP solver are very little compared to the extra computational time spend.

In order to compute a preemptive transportation schedule, it is not necessary to distinguish between each of the drivers. Therefore, there are less variables within the integer linear program which models the preemptive situation than within the integer linear program which models a non-preemptive situation for the same instances. Since the total tour lengths of transportation schedules with preemption give lower bounds for the total tour lengths of non-preemptive transportation schedules, we state the lower bounds computed from non-preemptive transportation schedules. The lower bounds from Table [\ref=tab:_computational_results] are taken from feasible preemptive transportation schedules, and the duality gaps are computed from these lower bounds.

ReOPT computes solutions within a reasonable time (in average less than 1.5 minutes for the smaller instances with at most 40 imbalanced stations, less than 8 minutes for the middle sized instances with 60 imbalanced stations, and about 17 minutes for the bigger instances with 80 imbalanced stations, see Table [\ref=tab:_computational_results]).

Conclusion

In this paper, we considered the Static Relocation Problem [formula], where tours for k drivers have to be computed in a (quasi) metric space M, where the maximal length of the tours must be smaller or equal to a given time horizon T. Hereby, the drivers transfer cars between the stations by forming convoys of at most [formula] cars. In order to have an exact solution we construct a time-expanded network GT from the original network G and compute coupled flows (a car and a driver flow) on this network with an ILP. Due to the coupling constraints, the constraint matrix of the network is not totally unimodular (as in the case of uncoupled flows), reflecting that the problem is at least hard.

Thus, we presented a heuristic approach to solve the Static Relocation Problem: the algorithm ReOpt. The construction of the tours by ReOpt is as follows: firstly, transport requests between "overfull" and "underfull" stations are generated by a perfect p-matching. These transport requests serve as input for a Pickup and Delivery Problem, which is solved in the second step. Finally, the tours are iteratively augmented by "rematching" certain origin/destination pairs, i.e., to reinsert accordingly adapted moves in such a way that the total tour length decreases.

The algorithm ReOpt has an approximation factor based on the given convoy sizes for the Symmetric Static Relocation Problem with and without backhaul (Theorem [\ref=thm:_static:_reopt:_approximation_factor] and Theorem [\ref=thm:_static:_reopt:_approximation_factor:_symmetric_and_asymmetric]). In the asymmetric situation, the approach ReOpt can ensure a finite upper bound for the ratio of its solution to the optimal solution only for the Asymmetric Static Relocation Problem with backhaul (Example [\ref=ex:_static:_reopt:_multiple:_asymmetric_non_possible] and Theorem [\ref=thm:_static:_reopt:_multiple:_symmetric:_without_backhaul:_2_C_plus_1]). The approximation factors for ReOpt in the different situations are summarized in Table [\ref=tab:_conclusion:_summary:_approximation_factors].

Both approaches have been tested on randomly generated instances (with 20-80 over-/underfull stations, 50 and 100 stations in total, convoy capacities 5 and 10, and 10-30 drivers). The time horizon was set to 100 in all test runs. Note that the size of these instances corresponds to small car- or bikesharing systems or to clusters of larger systems, as in [\cite=SHH-2013]. While the optimal solution could not be found even after 160 hours, the algorithm ReOPT computes solutions within a reasonable time (in average less than 1.5 minutes for the smaller instances with at most 40 imbalanced stations, less than 8 minutes for the middle sized instances with 60 imbalanced stations, and about 17 minutes for the bigger instances with 80 imbalanced stations), and a reasonable gap to the solution computed by the ILP (see Table [\ref=tab:_computational_results]). In order to be able to give at least a meaningful duality gap, we compared the solution with some lower bounds for preemptive transportation schedules, which can be computed in a shorter time.

There are several practical and theoretical open questions according to the Static Relocation Problem. Improving the runtime and solutions of ReOPT is one goal. Usually, every driver used gives additional costs. Thus, it is desirable to know the minimal number of drivers needed in order to solve the Static Relocation Problem within the given time horizon. To the best of our knowledge this is still an open question. Due to the time horizon, it is possible that there does not exist a feasible solution for a given instance at all. Having feasibility conditions is useful in two directions: to save unnecessary computation time for an algorithm and to generate test instances which can give feasible solutions. Thus, finding feasibility conditions as well as lower bounds for the time horizon is another goal for the future.