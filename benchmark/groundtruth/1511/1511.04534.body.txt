Learning Fine-grained Features via a CNN Tree for Large-scale Classification

Introduction

Convolutional neural networks (CNN) [\cite=LeCun_back_1989] [\cite=lecun1998gradient] have recently demonstrated superior performance on many tasks such as image classification [\cite=Alex_imagenet_2012] [\cite=Zeiler_visual_2014] [\cite=He_delving_2015], object detection [\cite=Girshick_rich_2014] [\cite=Girshick_fast_2015] [\cite=Pierre_overfeat_2013] [\cite=ouyang2015deepid] [\cite=Szegedy_scalable_2014] [\cite=erhan2014scalable], object tracking [\cite=li2015robust] [\cite=wang2015video] [\cite=hong2015online], text detection [\cite=delakis2008text] [\cite=huang2014robust], text recognition [\cite=Goodfellow_2013_Multi] [\cite=jaderberg2014deep] [\cite=wang2012end], video classification [\cite=simonyan2014two] [\cite=karpathy2014large] [\cite=ng2015beyond], human pose estimation [\cite=toshev2014deeppose] [\cite=jain2013learning] [\cite=tompson2014joint], scene recognition [\cite=Gong_multi_2011] [\cite=Zhou_learn_2014] and scene labelling [\cite=shuai2015integrating] [\cite=farabet2013learning]. In the classical CNN framework  [\cite=Alex_imagenet_2012], CNN learns 7 shared feature layers (5 convolutional layers and 2 fully-connected layers) for all the categories, followed by the last fully-connected layer to distinguish among different classes based on the learned features. Such learned features encode discriminative visual patterns, which are useful for classification. However, for different subsets of categories, discriminative visual patterns should vary. For example, features used to distinguish cat and dog should be different from those used to distinguish grass and tree. In the current CNN model, we just simply "average" different types of discriminative features together in a single model for different subsets of categories. Then for a certain subset of classes, features learned to distinguish other classes might become noise. Hence, such a single CNN model is not ideal for classification, due to the lack of enough representation capacity.

In this paper, we present a novel approach to enhance the discriminability of CNN for large-scale multiclass classification. The key idea is to learn fine-grained features specifically for a subset of classes. Compared to features learned for all the categories, such fine-grained features are expected to better capture discriminative visual patterns of the subset of classes. Ideally, for a class ci, if we can identify the confusion set Si which contain all the possible classes whose testing examples might be classified as ci by the basic CNN model, then we can learn a specific CNN model for this confusion set Si only. Since Si contains fewer categories than the whole class set, the specific CNN model should encode discriminative visual patterns which are more useful for this confusion set. Then testing examples which are misclassified as ci by the basic CNN model might be corrected by the specific CNN model.

However, when there are a large number of categories (e.g, 1000), it is computationally expensive to learn a specific CNN model for each class. And worse, in this case, it might be difficult to cache all the CNN models in the memory in the testing procedure. Then the testing speed will be significantly decreased as we have to frequently load models from the hard disk. Hence we need to develop advanced methods to reduce the number of specific CNN models to train.

We observe that some classes share many common categories in their confusion sets. Then we can train a shared CNN model for these classes by merging their confusion sets. We may sacrifice accuracy because now our specific CNN model deals with more categories, but at the same time, we gain on reducing the number of specific CNN models to train. We can iteratively repeat this procedure: given the new CNN model, we re-estimate the confusion set for each class in that model, and train a specific CNN model for each confusion set respectively afterwards. At the end, we will build a tree of CNN models, each of which aims to learn discriminative features for a number of categories only.

When we merge the confusion sets, we should make a trade-off between efficiency and accuracy. We pose the optimization problem as minimizing the number of merged confusion sets while requiring the error rate of resulting CNN model to be below a certain threshold. This objective is intractable. Thus, we relax the constraint on accuracy by limiting the number of categories in each merged set. This assignment problem is similar to the virtual machine packing problem and is an NP-hard problem. And provably good polytime approximation algorithms may not exist [\cite=sindelar_sharing-aware_2011]. In this paper, a heuristic algorithm is then proposed based on the intuition that confusion sets with more overlap should be merged together in higher priority in order to optimize the benefits of inter-set category sharing.

To evaluate the proposed method, we use both the classical AlexNet [\cite=Alex_imagenet_2012] and the state-of-the-art GoogleNet [\cite=Christian_going] as our basic CNN models. Experiments on the ILSVRC 2014 dataset [\cite=ILSVRC_2014] show that our method could improve the performance of both models. This sufficiently demonstrates the effectiveness of the proposed method. Our method is quite general, hence it can potentially be used in combination with many other deep learning models.

The rest of the paper is organized as follows: Section [\ref=sec:related] gives an overview of related work. Section [\ref=sec:tree] introduces a novel CNN tree and section [\ref=sec:learning] gives a detailed description of the tree learning algorithm. The experimental evaluations are carried out in section [\ref=sec:exp] and finally we conclude the paper in section [\ref=sec:conclusion].

Related Work

Convolutional Neural Networks have a long history in computer vision. Since their introduction by LeCun et al [\cite=LeCun_back_1989], it has consistently been competitive with other methods for recognition tasks. Recently, with the advent of large-scale category-level training data, e.g ImageNet [\cite=deng_imagenet_2009], CNN exhibit superior performance in large-scale visual recognition. Most notably, Krizhevsky et al [\cite=Alex_imagenet_2012] proposed a classic CNN architecture which contains eight learned layers (5 convolutional layers and 3 fully-connected layers), and showed significant improvement upon previous methods on the image classification task.

Several techniques have been proposed to boost the performance of CNN in different aspects. Hinton et al [\cite=Hinton_dropout] proposed a method called Dropout to prevent complex co-adaptation on the training data. This method simply omit half of the feature detectors on each training case, so a hidden unit cannot rely on other hidden units being present.Wan et al [\cite=wan2013regularization] introduced DropConnect which is a generation of Dropout for regularizing large fully-connected layers within neural networks. Unlike Dropout, DropConnect sets a randomly selected subset of weights within the network to zero. Each unit thus receives input from a random subset of units in the previous layer. Ciresan et al [\cite=Ciresan_multi_column] proposed a multi-column CNN which improved the performance by combing several CNN columns together. Goodfellow et al [\cite=goodfellow2013maxout] proposed a new model called Maxout which aims to both facilitate optimization by Dropout and improve the accuracy of Dropout's fast approximate model average technique. Howard [\cite=Andrew_improve_2013] presented some new useful image transformation to increase the effective size of training set and generate more test predictions. They also showed an efficient way to train higher resolution models that generate useful complementary predictions. Wu et al [\cite=wu2015deep] also proposed more complex data augmentation techniques for model training. He et al [\cite=Kaiming_spatial] proposed a new network structure called SPP-net which equipped the CNN with a more principled pooling strategy, i.e "spatial pyramid pooling". The SPP-net can generate a fixed-length representation regardless of the image size. Also, it is robust to object deformations due to the use of pyramid pooling. Ioffe et al [\cite=ioffe2015batch]proposed a method called Batch Normalization which reduced the internal covariate shift by normalizing each training mini-batch. This method allows the training procedure to use much higher learning rate and be less careful about initialization, and in some cases eliminates the needs for Dropout. Zeiler and Fergus [\cite=Zeiler_visual] presented a novel visualization method that gives insight into the function of intermediate feature layers and the operation of the classifier, and showed how these visualization can be used into identify problems of the model and so obtain better performance. Simply by reduce the layer filter size and the stride of convolution, they significantly improved the performance. Simonyan and Zisserman [\cite=simonyan2014very] investigated the effect of CNN depth on its accuracy in large-scale image classification. They showed the the representation depth is beneficial for the classification accuracy. Szegedy et al [\cite=Christian_going] proposed a new CNN architecture which achieved the state-of-the-art performance by increasing the depth and width of the network. All of these methods learn generic features from the whole class set, which might not be discriminative for classes in a specific subset. Differently, Our method progressively learns fine-grained features for each class subset in the tree. These features should be more discriminative in distinguishing a specific class subset than the generic features learned on the whole class set.

Another kind of methods that is related to our work is the hierarchical classification. A number of papers have proposed to exploit the hierarchical structure between object classes. Griffin and Perona [\cite=griffin_learning_2008] propose an algorithm for automatically building classification trees. Deng et al [\cite=Deng_what_2010] and Torralba et al [\cite=Torralba_2008] propose to exploit semantic hierarchy from WordNet to improve classification. Bengio et al [\cite=bengio_label_2010] propose a label embedding tree for large-scale classification. It partitions categories into disjoint subsets recursively, and train one classifier for each subset. Deng et al [\cite=deng_fast_2011] improve the label tree by simultaneously determining the tree structure and learning the classifier for each node in the tree. They also allow overlaps among different subsets. The main purpose of these hierarchical method is to speed up the operation of testing. However, test examples that are misclassified at top layers can not be recovered later in their methods. In contrast, our method is able to recover test examples misclassified by the basic model as it can learn fine-grained features to distinguish the confusion set.

The Proposed CNN Tree

We are motivated by the observation that a class is usually confused by a few number of other classes in multiclass classification. In this paper, we refer to them as the confusion set of that class. Given the confusion set of one class, more discriminative features could be learned by a specific CNN to distinguish the classes only in this set. Based on this observation, we develop a method to progressively learn fine-grained features for different confusion sets.

Suppose [formula] is the whole class set of a multiclass classification task and [formula] is a basic CNN model learned on [formula]. The confusion set Si of a class ci is a set that contains ci and all other classes whose test examples are potential to be misclassified as ci by [formula]. With a large number of classes, we claim [formula] based on the intuition that a class should only be confused by a few similar classes in the whole class set. This exhibits valuable information for further improving the accuracy of [formula]. Specifically, we can train a specific CNN model to learn fine-grained features for each Si only. Since Si contains fewer classes, these fine-grained features should be more discriminative than the generic features learned by [formula] on the [formula]. When a test example is classified as ci by [formula], we can then use the specific CNN model trained on Si to refine its class label. It is hopeful that a test example that is misclassified by the basic CNN model might be correctly classified by the new specific CNN model.

However, when dealing with a large number of categories, learning a specific CNN model for each class separately is very computationally expensive. It is also difficult to cache all the CNN models in the memory in the testing procedure, leading to a significant decrease of testing speed. To alleviate this problem, we adopt a tree structure to progressively learn fine-grained features, namely the CNN tree.

Before we formally introduce the proposed CNN tree, we summarize the notations in Table [\ref=tb:notation] for clarity. Let T = (V,E) be a CNN tree. As shown in Fig. [\ref=fig:cnn_tree], for a node v∈V, we are given a class subset P(v)  ⊂  . We try to classify different classes in P(v) by learning a specific CNN model M(v) on P(v). If v is not a leaf node, we need to further enhance the discriminability of M(v). To this end, we re-estimate the confusion set Si of each ci∈P(v) based on M(v) using the method described in section [\ref=sec:confuse_estimation]. Based on the observation that some classes may share many common categories in their confusion sets, we can pack them into a confusion superset, i.e take the union of them, to reduce the number of CNNs to train. During the confusion set packing procedure, one confusion set could only be packed to one superset. Suppose we get N confusion supersets after merging, N children will be generated respectively. Let φ(v)  ⊂  V be the children set of node v. For a child uk∈φ(v), the confusion superset Qk is assigned to the class subset P(uk) for further learning specific CNN model on Qk.

To classify an input instance x with the constructed CNN tree, we start at the root node ṽ by predicting the class label cl of x with M(ṽ). Next we find the confusion superset Qk which the confusion set Sl is merged into. Then we traverse to the child uk∈φ(ṽ) that satisfies P(uk)  =  Qk. As the previous predicted result may be confused by classes in P(uk), we then use the specific CNN model M(uk) learned on P(uk) to refine the prediction. This process repeats until it reaches a leaf node. The class label predicted by the specific CNN model of this leaf node is regarded as the final result. The detailed prediction algorithms is shown in Algorithm [\ref=alg:cnn_tree_predict].

It is worth noting that the proposed method is quite different from the works on hierarchical classification [\cite=bengio_label_2010] [\cite=deng_fast_2011] [\cite=griffin_learning_2008]. The main purpose of hierarchical classification is to speed up the operation of testing. These methods partition categories into different subsets recursively, and train one classifier for each subset. However, test examples that are misclassified at top layers can not be recovered later in their methods. In contrast, our method refines the class labels predicted by the basic model via progressively learning more specific models on their confusion sets. As the specific model could learn fine-grained features to distinguish confused classes, it is capable of correcting test examples misclassified by the basic model.

Learning CNN Tree

Learning a CNN tree T = (V,E) refers to the learning of tree structure as well as the specific CNN model at each node. For each non-leaf node, we propose a softmax confusion matrix to robustly estimate the confusion sets of classes at this node and develop a heuristic algorithm to efficiently merge them into several confusion supersets. For each non-roof node, we show how to lean specific CNN model to distinguish the classes at this node.

Confusion Set Estimation

Given a non-leaf v of a CNN tree, we need to estimate the confusion set of each ci∈P(v). We perform the estimation based on confusion matrix. The confusion matrix is a common way to evaluate the performance of a multiclass classification algorithm , which plots the actual class label against the predicted class label. Specifically, the confusion matrix for an n-class problem is an n  ×  n matrix H, where the ijth entry hij represents the percentage of test instances of class ci that were predicted to belong to class cj. Some researchers have already proposed to explore the relationships among classes based on the confusion matrix  [\cite=godbole_scaling_2002] [\cite=godbole_discriminative_2004] [\cite=bengio_label_2010] [\cite=griffin_learning_2008]. The performance of their algorithms mainly depends on the accuracy of the confuse matrix computed by using a held-out validation dataset. However, for the large-scale multiclass classification problem, it is impractical to collect a large enough validation dataset to compute the confusion matrix for accurately measuring the inter-class relationships. For example, the ILSVRC2014 dataset [\cite=ILSVRC_2014] provides a validation dataset with only 50 samples for each class. As there are a total of 1000 different classes, the confusion matrix computed on such a small validation dataset cannot sufficiently capture the relationships among all these classes. For rich training data, it is not appropriate to use them to directly compute the confusion matrix based on the classification results since the model will fit the training data and can not produce a meaningfull confusion matrix on them.

To deal with the above problems, we propose a variant of confusion matrix which could take the advantage of rich training data. We observe that the output of the softmax layer in CNN represents the predicted confidence scores of the input instances against all the classes. Such scores indeed capture the confusion information between classes and are more robust to overfitting. Thus, by summing over the predicted confidence scores of all the training data, it is reasonable to obtain a robust estimation of the confusion information among all classes. We refer to such a variant as softmax confusion matrix.

For the non-leaf node v, suppose there are nv classes (i.e [formula]) and ti training examples for class ci. Let xik be the kth training example of ci and [formula] be nv-dimensional output vector of the softmax layer of current CNN model M(v) for xik. Then, the softmax confusion matrix H̃ can be computed as

[formula]

where

[formula]

With the above definition, the ijth entry h̃ij of H̃ measures how likely the examples of ci will be classified as cj on current model M(v). Considering the jth column [formula], it consists of all the scores that measuring how likely the examples of their corresponding classes will be classified as cj on M(v). Given an appropriate threshold α, a set Sj can be derived from [formula] by only reserving the class labels of entries that are larger than α. As Sj consists of classes that could be confused by cj, i.e the most possible classes that could be predicted as cj, we regard it as an estimation of the confusion set of cj. Fig. [\ref=fig:confusion_set] shows example images of some classes in the ILSVRC2014 training dataset [\cite=ILSVRC_2014] and their confusion sets estimated by using the softmax confusion matrix of the AlexNet [\cite=Alex_imagenet_2012]. It can be observed that each class has some similar aspects (e.g appearance, shape, size etc) with its confusion classes. More specific features are needed to distinguish them from their confusion classes.

Confusion Set Packing

Given a non-leaf node v and the confusion set for each class in P(v) estimated by using softmax confusion matrix of M(v), we will merge these confusion sets into several confusion supersets. We may sacrifice accuracy because now our specific CNN model deals with more categories, but at the same time, we gain on reducing the number of CNN models to train. We aim to have as few confusion supersets as possible, with the constraint that the error rate of each superset's CNN model should be low. However, we cannot try all the combinations to find the one which results in the smallest number of confusion supersets under this constraint. Instead, we change the constraint as limiting the number of classes in each confusion superset. It is based on the assumption that the performance of a CNN is highly relevant to the number of classes it aims to distinguish.

Let Q denote the confusion superset. At a given limit L of [formula], the optimal solution is the one that minimizes the number of generated Q. This problem is similar to the well-studied bin packing problem which aims to pack objects of different volumes into a finite number of bins with limit volume in a way that minimizes the number of bins used. Given n candidate supersets [formula] with the size limit [formula] and the confusion sets [formula] for all n classes, the confusion set packing problem can be formulated as:

Minimize

[formula]

subject to

[formula]

where

[formula]

Note that the first constraint in Eq. [\ref=eq:constraint] ensures the size limit of confusion supersets while the second one ensures that one confusion set can be packed into one confusion superset once and only once.

Given a solution of the problem, the N confusion supersets [formula] can be found by:

[formula]

Unlike the traditional bin packing problem, the cumulative size of several confusion sets can be smaller than the sum of individual confusion set sizes due to overlap, i.e [formula]. Actually, the confusion set packing problem is a virtual machine packing problem with general sharing model as described in  [\cite=sindelar_sharing-aware_2011] where the different virtual machines can share space when packed into a physical server. Finding an optimal solution of such a problem is very difficult since it has an NP-hard computational complexity.  [\cite=sindelar_sharing-aware_2011] shows that it is even infeasible to get a well approximated solution.

Here we propose a heuristic algorithm based on the intuition that confusion sets with more overlap should be packed together in higher priority in order to optimize the benefits of inter-sets sharing. The algorithm initializes n confusion supersets by allocating one confusion set to one superset respectively. At each step, the algorithm greedily searches the superset pair who has the maximal overlap among all possible superset pairs whose union set do not exceed the confusion superset size limit, and then merge them together. The detailed algorithm is described in Algorithm [\ref=alg:greedy].

Learning Specific CNN Model

Given a non-roof node v and a class subset P(v), we will learn a specific CNN model for this subset only.

Let v' be the parent of v, [formula]. We learn M(v) by fine-tuning the CNN model of v', i.e M(v'), on P(v). In this way, we can still leverage visual knowledge from a larger number of categories. Specifically, we follow the procedure described in [\cite=Girshick_rich_2014]. First, we remove the last fully-connected layer of M(v'). Next, we append a new randomly initialized fully-connected layer with nv output units. Then, we run stochastic gradient descent (SGD) to learn the new CNN model on training data of P(v). As CNN could simultaneously learn convolutional features and classification weights, the fine-tuning procedure should encode more discriminative visual patterns which are more powerful to distinguish classes in P(v).

Summary

We summarize the algorithm for learning the CNN tree in Algorithm [\ref=alg:cnn_tree_train]. The algorithm starts by initializing the root node ṽ with the whole class set [formula] and a given basic CNN model [formula]. Then a recursive procedure is performed to grow the tree in a top-down breath-first manner until it reaches a given maximal depth. With the growing of the tree, we can learn specific CNN models, each of which aims to learn fine-grained features for a number of categories only.

Experiments

Dataset and The Evaluation Criteria

We evaluate the proposed method on the image classification task with the ILSVRC2014 dataset [\cite=ILSVRC_2014]. This dataset contains 1000 leaf-node categories selected from the Imagenet hierarchy. There are about 1.2 million images for training and 50,000 images for validation, each of which is associated with a ground truth category. Following the previous papers, we test our method on the validation data. Two criteria are used to evaluate the algorithms: the top-1 error rate, which compares the first predicted class label against the ground truth, and the top-5 error rate, which checks whether the ground truth is among the top 5 predicted class labels.

We use both the classical AlexNet [\cite=Alex_imagenet_2012] and the state-of-the-art GoogleNet [\cite=Christian_going] as our basic CNN models. To make a fair comparison, we use the Caffe [\cite=jia2014caffe] implementation and download the pre-trained models for the ILSVRC2014 dataset .

The parameters for building a CNN tree are: (1) the maximal tree depth D, and (2) the size limit Ld of confusion superset at level [formula]. We tested the effects of using different parameters on AlexNet. For L1 with 50, 100, 150 and 200, the top-1(top-5) errors are shown in Table [\ref=tb:param_L1]. It can be found that different settings lead to similar performance. By setting L1 as 100, for L2 with 30, 50 and 70, the top-1(top-5) errors are shown in Table [\ref=tb:param_L2]. The performance also are similar. Actually, We do not optimize the parameters on the validation set. We empirically selected the parameters as shown in Table [\ref=tb:parameters] since they don't affect the performance much. Note that we select D as 2 and 1 for AlexNet and GoogleNet respectively since a deeper tree requires to train more CNNs but it only leads to a small increase in performance.

Results

We firstly compare our CNN tree at different depths with the basic CNN model. We use both AlexNet and GoogleNet as our basic models since they represent the classical CNN model and the state-of-the-art CNN model respectively. We denote the CNN tree with depth D as TD (Note that T0 is the basic CNN model). The results for AlexNet and GoogleNet on ILSVRC2014 are summarized in Table [\ref=tb:alex_net] and Table [\ref=tb:google_net] respectively (the column that the number of basic model is 1). For AlexNet, T1 decreases top-1 error rate by 2.41% and top-5 error rate by 1.43% when compared with T0. When we increase the depth to 2, T2 decreases top-1 error rate by 2.69% and top-5 error rate by 1.49%. For GoogleNet, T1 decreases the top-1 error rate by 4.38% and the top-5 error rate by 1.91%. The improvements are significant especially on GoogleNet since the task is to classify 50,000 examples into 1,000 different classes. The results demonstrate that the proposed CNN tree can enhance the discriminability of the basic CNN. The reason can be explained by the fact that the specific CNN models could learn more discriminative features to distinguish the confused classes. We also note that our method is better at improving the performance of a strong basic model, i.e GoogleNet. This may due to that the confusing sets estimated by a strong basic model are more accurate than those estimated by a weak basic model.

As the performance of a single model can always be improved by averaging multiple models, we then investigate whether the proposed method can also improve multiple basic models. We first train several basic CNN models by random initialization and then train a CNN tree for each basic model. The final prediction is obtained by averaging the predictions of CNN trees of different basic models. The results for AlexNet and GoogleNext are also shown in Table [\ref=tb:alex_net] and Table [\ref=tb:google_net] respectively. As can be observed, the performance could be further improved by applying CNN trees to multiple basic models.This may be because the confusion sets estimated by multiple basic models are more robust than those estimated by a single basic model, which helps to correct more misclassified samples. It also indicates that the proposed method provides values beyond model averaging. For example, averaging 6 basic models of AlexNet decreases top-1 (top-5) errors from 43.09% (20.04%) to 39.63% (17.43%) while applying our CNN trees on these 6 basic models further decreases the top-1 (top-5) errors to 37.19% (16.23%). On the other hand, averaging 6 basic models of GoogleNet decreases top-1 (top-5) errors from 32.75% (12.00%) to 29.56% (10.08%) while applying our CNN trees further decreases top-1 (top-5) errors to 25.15% (8.12%).

To show the limitation of model averaging, We present the error decrement with respect to the model number in model averaging in Fig [\ref=fig:average]. For AlexNet, averaging 16 models decreases top-1(top-5) errors to 39.15(%16.99%). For GoogleNet, averaging 12 models decreases top-1(top-5) errors to 29.29%(9.76%). But no further decrement can be obtained by using more models. As can be seen in Fig [\ref=fig:average], these results are much worse than our methods with 6 basic models.

We further conduct an experiment to show our method can learn more powerful feature representation at lower layers in the network. We try another learning strategy: For each class subset in the non-roof node, we fix the weights of all the layers except for the last fully-connected layer, and then fine-tune the CNN model for this class subset. With this setting, we actually train a multiclass logistic regression classifier for the class subset without learning features. We compare this learning strategy with T1. As shown in Table [\ref=tb:bp_test], for AlexNet, fine-tuning without feature learning decreases the top-1 error rate by 0.13% and even increases the top-5 error rate by 0.1%. For GoogleNet, fine-tuning without feature learning decreases the top-1 and top-5 error rate by 0.59% and 0.25% respectively. This strategy performs much worse than fine-tuning the specific CNN models with feature learning. This demonstrates that the proposed CNN tree enhances the discriminability by progressively learning fine-grained features for each class subset.

Fig. [\ref=fig:misclassify] gives the top-1 predictions of some categories on validation data by using AlexNet. Each image is marked with two labels, where the top label is predicted by the basic CNN model and the bottom label is predicted by using the proposed CNN tree. The red color denotes a right prediction while the green color denotes a wrong prediction. As can be seen, our method could correct the prediction of some examples that are misclassified by the basic CNN model. The reason is that our method could refine the class labels predicted by the basic model via progressively learning more specific models on their confusion sets.

Computational Complexity Analysis

With the parameter settings in Table [\ref=tb:parameters], for AlexNet, we actually fine-tune 55 specific CNN models at level 1, each of which contains no more than 100 classes, and 151 specific CNN models at level 2, each of which contains no more than 50 classes. For GoogleNet, we fine-tune 61 specific CNN models at level 1, each of which also contains no more than 100 classes

To fine-tune these models, we start SGD from a learning rate of 0.001 (1/10 of the initial pre-training rate) and decrease the learning rate by a factor of 10 when the accuracy on validation data stops improving. For AlexNet, the learning is stopped after about 15,000 iterations for each CNN model in level 1 and about 5,000 iterations in level 2. Thus, learning such a CNN tree requires a total of about 1.5 million iterations, which is 5 times of learning the basic model (310k iterations). In experiments, we train the proposed CNN tree in parallel on 12 Tesla K40 GPUs. It takes about 1.5 days to finish the training procedure. For testing, our method increases the time by 2 times as each test examples need to be evaluated by 3 CNNs. For GoogleNet, the learning is stopped after about 80,000 iterations for each CNN model in level 1. Thus it requires a total of about 4.8 million iterations, which is 2 times of learning the basic model (2.4 million iterations). It takes about 2 days to finish the training procedure on the same platform. The testing time is increased by 1 time as the tree depth is 1.

Conclusion

In this paper, a CNN tree is proposed to progressively learn fine-grained features to distinguish a subset of classes which are confused by the basic CNN model. Such features are expected to be more discriminative, compared to features learned for all the classes. Thus, test examples that are misclassified by the basic CNN model might be correctly classified by the specific CNN model in the bottom layer. To learn the tree structure as well as the fine-grained features, a new learning algorithm is proposed to grow the tree in a top-down breadth-first manner. Experiments on large-scale image classification tasks by using both AlexNet and GoogleNet demonstrate that our method could enhance the discriminability of given basic CNN models. The proposed method is fairly generic, hence it can potentially be used in combination with many other deep learning models.