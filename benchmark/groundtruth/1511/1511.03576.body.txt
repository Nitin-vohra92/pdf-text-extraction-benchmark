DataGrinder: Fast, Accurate, Fully non-Parametric Classification Approach Using 2D Convex Hulls

Introduction

Data mining topics such as classification [\cite=AutoAtt:11] [\cite=SVMInd:11] [\cite=FineClassification:13] [\cite=GAIA:10] [\cite=Raymond:12] [\cite=SMCC:12] [\cite=Intrusion:10] [\cite=DiscriminantClassifier:07], clustering [\cite=BIRCH:96] [\cite=DDFactors:11] [\cite=DCInference:12] [\cite=ClusterForest:13] [\cite=SMCC:12] [\cite=AdvancedClust:11] [\cite=ArrayStore:11] [\cite=LatentOlap:11] [\cite=SparseGraph:11], frequent pattern mining [\cite=ARM2:00] [\cite=ARM1:94] [\cite=MaxFreq:13], frequent sub-structure mining [\cite=MaxFreq:13] [\cite=SMCC:12], regression [\cite=Bilal:11] [\cite=Ashraf:11], data cleaning [\cite=ERACER:10] [\cite=AdvancedClust:11] [\cite=AutoAtt:11], ranking [\cite=PageRank:11], data warehousing [\cite=LatentOlap:11], recommender systems [\cite=TopRecs:11] [\cite=Recsplorer:10] [\cite=Package:12], bio-informatics [\cite=Raymond:12], outlier detection [\cite=BSkyTree:10] [\cite=IOSky:13] [\cite=efficientSkyline:11], nearest neighbors [\cite=FuzzyNN:10] [\cite=NN:12] and social networks [\cite=SN1] [\cite=SN2], have been widely discussed in data management and prediction. There has been plenty of work on classification as one of the main techniques for supervised learning. Figure [\ref=fig:classificationexp], shows a small example where we have sets of points in a plane, each of which belonging to one category, demonstrated by different shapes. A classifier model, is given data vectors in 2 dimensional space (2D), with labels (i.e. training), and is expected to predict, and assign new objects with missing labels to their correct categories(i.e. testing).

There exist a variety of classification algorithms in machine learning and data mining. Most popular classifiers are known as discriminant classifiers. Discriminant classifiers aim at statistical or probabilistic modeling in order to find an objective function. Then, optimization and numerical methods are used in order to find optimal parameter values. Having found these optimal values, we can find the decision boundaries that divide the space into regions that separate objects from different categories. It is often the case that data is not linearly separable. This leads to misclassification errors most of the times. In order to minimize misclassification error, people use methods such as regularization, kernel transformations, feature extraction and feature selection [\cite=BishopML]. Examples of discriminant classifiers include Support Vector Machines and Logistic Regression [\cite=SVMInd:11] [\cite=DiscriminantClassifier:07].

Other types of classifiers are Decision Trees, Rule-based [\cite=RuleClass1] [\cite=RuleClass2] [\cite=RuleClass3] methods and Nearest Neighbor methods. Most of these methods have practical shortcomings. Discriminant classifiers need to optimize their objective function and this may not be feasible in reasonable time for big data. Besides, it is a challenge to find straight forward parallel implementations of these optimization algorithms. In web-based scenarios, data changes very frequently [\cite=SMCC:12]. This requires either algorithms with highly scalable training phase, or models we can sequentially update. Although time always plays a key role and sometimes sequential update may not be optimal [\cite=RecSys]. Decision Trees and Rule-based classifiers also suffer from the same shortcoming in practical scenarios. In many cases, the theoretical problem defined to solve the classification problem is NP-hard. Nearest Neighbor methods are efficiently applicable if data is stored in data structures such as kd-trees for nearest neighbor search. Despite their efficiency in execution, they lack accuracy even for slightly challenging inputs. We demonstrate this with experiments in Section [\ref=sec:expn], and briefly explain how each classification algorithm works.

In this paper, rather than solving optimization problem, we use Computational Geometry, in order to build an accurate classifier. We use 2D convex hulls, using all possible 2 dimensional projections (i.e. all possible pairs of columns regardless of order). Figure [\ref=fig:convex1], shows an example of the convex hull of a point set P. In order to build classifiers, we project the input dataset with d dimensions to all possible [formula] planes. In each plane, having partitioned the training data into different classes, we find the 2D convex hull for each class (Select-Project-ConvexHull). This results in [formula] convex hulls, where C is the number of classes. Given a new testing instance with d feature values, we check for all existing [formula] convex hulls, whether they contain the corresponding 2 dimensional projection(Ï€). We find the class cmax, that scores highest (i.e. its boundaries contain the point in more 2D projections) and assign the class label. Since d is typically a small constant in practice, we are not worried about the testing time. Besides, using parallelization, testing time is negligible. We also propose a filtering approach to choose only the most discriminant features in Section [\ref=sec:expn], that results in accuracy improvements as well. We explain our classification algorithm in more detail in Section [\ref=sec:classificationAlgo], after providing the necessary computational geometry background. We make the following contributions in this paper:

We explain the Convex Hull problem from Computational Geometry [\cite=ComputationalGeometryBook]. We provide algorithmic background in terms of the running time, and propose an algorithm with O(n) expected running time. We also prove its correctness. Besides, we calculate the "constant" through probabilistic analysis, and our experiments show our calculated constant is reliable for different sizes of data. Database community has shown tremendous interest in solving problems formulated similar to convex hulls such as designing algorithms for finding Skylines [\cite=BSkyTree:10] [\cite=IOSky:13] [\cite=efficientSkyline:11].

We propose and explain our classification algorithm, DataGrinder(DGR), using 2D convex hulls. We also propose tricks for tuning the classifier by filtering weak features that results in considerable accuracy improvement, in the case of one dataset.

We propose parallel algorithms for implementing DataGrinder at different levels including data partitioning as well as parallel convex hull algorithms, using the divide and conquer method.

We propose a method for random data generation and testing classifiers. Our proposed testing methodology controls the hardness of classification using two parameters. We conduct a comprehensive set of experiments on randomly generated and real datasets. Our experiments show DataGrinder is competitive against the most widely known commercial classifiers in accuracy, while being extremely scalable.

Convex Hull Background

Convex Hull of a point set in 2D, CH(P), is a set of points such that every point in P can be computed as a positive linear combination (all the weights are positive), of the points in CH(P). For this reason, it is important in applications where we are interested in finding mixtures using some baseline prototype vectors. In a sense, convex hull of a point set is a small subset of the points that wraps around a point set, and can represent any point in the point set with a positive linear combination. We can represent convex hull as a polygon, that contains every other point in P, within its boundaries. This polygon that wraps around all points can be extremely useful for applications in Machine Learning when we want to define the boundaries of a group of points (class). It also has the base ingredients to represent any point in that class. For instance, we can use convex hull along with radial basis or any other sort of function in order to construct a kernel and represent every point in a new feature space.

Moreover, in Computational Geometry, problems such as finding half space intersection can be reduced to finding convex hull and this highlights the importance of exploring more computationally efficient algorithms. In many real life applications we deal with datasets with thousands or millions of data points, and existing O(nlog(n)) algorithms fail to find convex hull in a timely manner. Other than problems we can directly model with convex hull, there are many other domains such as web mining where we deal with large graphs. We can also use properties of these domains such as link structure in order to define entities such as web pages in a multidimensional Euclidean space, and use convex hull for modeling [\cite=SMCC:12].

We only focus on the 2D case but our heuristics and ideas are generalizable to higher dimensions. We use 2D for simplicity because it is more intuitive for problem solving and leave generalized version to our future work. Moreover, in our present application of convex hulls (i.e. classification), we are seeking data boundaries as tight as possible while still maintaining properties of binary feature correlations. This, kind of resembles entries of a covariance matrix, in Multivariate Gaussian Distributions that can be used for Principle Component Analysis as well.

It is provable that the best possible worse case running time for this problem is O(nlog(n)), since sorting can be reduced to the convex hull problem [\cite=ComputationalGeometryBook]. In fact, the most efficient classic convex hull algorithms use sorting. First, we sort all the points in a dataset according to one coordinate. Then, using a left to right scan of the sorted list, we iterate over other points and remove any points that do not belong to the convex hull, in linear time. In order to do so, they use geometric properties of the points on convex hull and line segments between them. Figure [\ref=fig:convex1] shows a point set along with a polygon that wraps around it. If we extend each line segment in both ends, we obtain a line such that every other point in P, is located on one side (i.e. half space).

We devise an algorithm, that despite its O(n2) worst case running time, achieves O(n) expected running time if P is distributed uniformly, and dimensions are independent. We also prove for independent Normal distributions. Previous work in Computational Geometry also approves the possibility of O(n) expected running time, if the algorithm is designed within the given framework [\cite=Convex:81]. Here, we thoroughly describe the algorithm and provide pseudo code as well as average case analysis for computing the constant. Regardless of the data instance, we can always devise strategies to avoid the worst case through smart query optimization, and use of empirical algorithms.

Our 2D convex hull algorithm avoids paying the initial nlogn sorting time. Instead, in every iteration our new algorithm finds the next minimum of the list in O(|candidates|), and using the new point, it uses a heuristic to remove other points from the candidate set, that do not qualify to be on convex hull. This is what we refer to as Candidate Elimination process. Once we process all the candidates and remain with an empty candidate set, we have found the convex hull. Our theoretical analysis as well as our quantitative experimental results, suggest that repeating this process results in O(n) expected running time, for finding 2D convex hull. This iterative candidate elimination process enables us to find the convex hull of up to 1000000 points in less than 20 seconds while the existing classic algorithm fails to terminate in in a timely manner (after 8 hours). It is worth highlighting again that although the classic algorithm has a better worst case running time, it fails in practice. In the rest of this section, we formally define the convex hull problem and discuss naive and classic solutions. In the subsequent subsections, we discuss a new algorithm based on candidate elimination, and discuss its expected running time. Eventually, we show with experiments that the improvement achieved using this pruning heuristic is indeed considerable, and indeed it results in linear expected running time.

Convex Hull Problem Definition

Convex Hull of a point set P  =  {p1,p2,...,pn}, is best defined intuitively as a polygon that wraps around all the points in P. We can formally define this polygon as follows.

Naive algorithm for finding CH(P) is as follows:

Produce every pair of points pi and pj: O(n2)

Find the line segment between pi and pj in constant time.

Check if every other point belongs to either negative or positive half space. If yes, add the line segment to CH(P) otherwise discard: O(n).

Figure [\ref=fig:convex2], shows examples of both types of line segments. Overall running time of the naive algorithm is O(n3), since it scans P once for every pair of points. This results in a process that takes minimal usage of geometric properties and is extremely inefficient. Using geometric properties, we can aim at designing a more targeted process. Next, we describe O(nlog(n)) algorithm that first sorts all the points by their x-coordinate.

Background of Algorithms (nlogn algorithm)

Rather than arbitrarily exploring the search space, first we sort the point set based on one coordinate (typically x). Points in P, start from Xmin and end at Xmax after sorting.

Figure [\ref=fig:UpperLowerHulls], splits the convex hull into two parts, both from Xmin to Xmax. We use Upper Hull (UH), in order to refer to the part above the line segment between Xmin and Xmax; we use Lower Hull (LH), in order to refer to the lower part. Classic algorithm for finding convex hull invokes FindUpperHull(P) and FindLowerHull(P) functions, in order to find the convex hull of P, each in O(n). Therefore, the total execution time is O(nlog(n)). Finding upper and lower hulls separately are two symmetric procedures with respect to each other. Here, we only present for upper hull. Algorithm [\ref=algo:findUpper], computes the upper hull of the sorted point set by scanning from Xmin to Xmax. It is intuitive that we visit all the points in UH(P) in sequence, once we do scanning from left to right, although with the rest of the points in between. The idea is to: 1) perform this scanning; 2) identify and maintain points that belong to UH(P), and 3) discard all the other points. We change i from 1 to n, and start the ith iteration having computed the correct upper hull of the points {p1...pi - 1}. We add pi to UH(P), because we know it belongs to the upper hull of {p1...pi}, with the largest x - coordinate value so far. We read UH(P) in reverse order and remove any points that do not belong to the convex hull of {p1...pi}, until we stop.

After appending pi to UH, we check for the last 3 points in UH, if they belong to the correct convex hull or not. In order to do so, [formula] returns true if [formula] is above the line segment from [formula] to [formula]. This means [formula] belongs to UHi. Otherwise, it is removed and we repeat this process until UHCheck returns true, and obtain the correct upper hull of p1 to pi. Equation [\ref=eq:checkUp], computes a sign variable. If sign is a non-negative number, UHCheck returns true.

[formula]

Figure [\ref=fig:classicAlgoEx], shows a snapshot during the execution, where two middle points need to be removed after adding p5. It also shows the correct upper hull after we exit the while loop. We exit the while loop when for the first time we find a middle point which passes the convex test (Equation [\ref=eq:checkUp]). When this happens, it is guaranteed that UH5(P) is convex since the last step is convex and also we know the rest is constructed convex starting from p1  =  Xmin. We exit the while loop also when only 2 points are left, in which case there is no middle point and UHi(P) is always convex.

It is worth noting, it can happen that two points appear in sorted P next to each other with the same value for x - coordinate. In this situation, we order all the points with the same x - value based on their y - coordinate to preserve the correctness of Algorithm [\ref=algo:findUpper]. If two points are exactly the same, one can be removed without hurting the correctness of the convex hull algorithm.

Finding Convex Hull by Candidate Elimination

Classic convex hull algorithm presented so far needs to perform an initial sorting with cost O(nlog(n)). We know we can not do better in the worst case for finding convex hull. Despite O(nlog(n)) worst case running time, in many cases we may be able to use heuristics in order to make the problem size smaller and achieve better Expected running time. In this section, we describe a process called "Candidate Elimination", that we use, instead of sorting. We use candidate elimination along with existing FindUpperHull procedure, in order to solve the problem. The idea is to avoid sorting, maintain candidate lists of points for different parts of the convex hull, and find the next minimum value from a smaller candidate list, rather than paying O(nlog(n)) for sorting in the beginning.

Figure [\ref=fig:CandidateElimination1], divides the plane as well as the convex hull of the point set into 4 quarters, using minimum and maximum x and y values in the point set. We use UpperLeftHull, UpperRightHull, LowerLeftHull and LowerRightHull, in order to refer to these 4 quarters.

We know the upper left hull starts at Xmin and ends at Ymax. We also know that the upper left hull is convex. Therefore, none of the points on it can be below the line.

Lemma [\ref=lemma:candidate], provides an opportunity for candidate elimination in the beginning. We can draw a line from Xmin to Ymax, and remove any points below the line, to obtain a list of UpperLeftHull candidates. Using symmetry, we can find a candidate list for UpperRightHull by choosing all the points above the line that goes through Ymax and Xmax. Lower left candidates are those on or below the line from Xmin to Ymin, and lower right candidates are on or below the line from Ymin to Xmax. Finding minimum and maximum x and y coordinate values can be done in O(n). Therefore, by paying O(n), we can discard many points and continue with smaller input size and this obviously can considerably improve the performance. We use Candidate Elimination, to refer to this process that makes more targeted use of both x and y coordinates. Figure [\ref=fig:CandidateArea], shows a minimal box that contains all of the points in P, using Xmin, Xmax, Ymin and Ymax. Inside this box, we separate 4 triangles in 4 corners. These are the only areas where convex hull candidates can appear. We use Candidate Area in order to refer to any area inside the box, where convex hull candidates can appear. In Figure [\ref=fig:CandidateArea], four triangles form the candidate area.

We assume points are distributed uniformly in the plane. We also assume that x and y coordinates are uniform and independent. Given these assumptions, we define zi to be a random variable. We assign zi  =  1, if the ith point in P is in the candidate area. We know P(zi  =  1)  =  (CandidateArea / BoxArea)  =  1 / 2; therefore, E(zi)  =  1 / 2. There are n such points in the dataset, and we can use [formula] while Z is a random variable that takes values in {1...n}, that indicates the number of candidate points all together after the first candidate elimination. Expected value of Z is n times expected value of zi, equal to n / 2, using linearity of expected value.

Convex Hull Algorithm

The first candidate elimination step reduces the expected number of candidates to half. Although this is a good heuristic, we still need to eliminate more candidates, and find the correct convex hull. As described earlier, we do this in 4 smaller steps for UpperLeftHull, UpperRightHull, LowerLeftHull, and LowerRightHull, separately. Here, we only describe the process for UpperLeftHull, and we know the rest is symmetric for the three other quarters of the convex hull. Algorithm [\ref=algo:findUpperLeft], takes as input the list of upper left candidates after the initial candidate elimination, that are on or above the line from Xmin to Ymax. Please note, that the list is not sorted by x - coordinate anymore. The idea is to avoid sorting the candidate list. Instead, we keep finding the next smallest x, NextX, and repeat candidate elimination using NextX. The justification behind replacing sorting with this operation, is the fact that candidate list keeps getting smaller and smaller after performing candidate eliminations in sequence. This makes the cost of finding the next minimum negligible, even for large n.

Rather than reading the next point from sorted P, in order to find upper left hull, Algorithm [\ref=algo:findUpperLeft], finds NextX in line 3 and removes it from the list of upper left candidates. We pay O(|ULCandidates|) cost to find NextX. In line 4, eliminateCandidates repeats the same candidate elimination task using NextX. In order to do so, we draw a line from NextX to Ymax, and remove any candidates below the line. In the rest of Algorithm [\ref=algo:findUpperLeft], we pretend NextX is read from a sorted list and repeat the same process in order to fix UpperHull that Algorithm [\ref=algo:findUpper] does, already presented in Section [\ref=sec:classicAlgo].

Running Time Analysis

Worst Case Running Time

There are three main steps in each iteration of finding convex hull by candidate elimination:

Finding NextX, overall O(|candidates|)

Candidate elimination, O(|candidates|)

Fixing upper hull, C (constant)

It is possible in the worst case, that all of the points in P belong to the convex hull. In this case, candidate elimination results in removing no candidates and repeating a O(n) process n times, resulting in O(n2) worst case running time. For the current classification problem, worst case scenario rarely happens.

Expected Running Time

Since there are 4 quarters and the expected number of candidates is n / 2 after the initial candidate elimination, there is an expected number of n / 8 candidates in each triangle. It is worth noting, we can use the product of expected values of two random variables as the expected value of their product, because all the random variables are independent . This, is a natural assumption, used widely in Machine Learning [\cite=BishopML]. We define Î±0  =  1 / 8 to be the elimination ratio, indicating the expected cost of finding NextX, after the initial candidate elimination in each quarter. We present using LowerRightHull, to have more variety in our examples. Subsequently, we can define, 0  <  Î±1  <  1, as elimination ratio in iteration 1 and, 0  <  Î±2  <  1, as elimination ratio in iteration 2. The expected size of LRCandidates after iteration 2 is (Î±0Î±1Î±2)  Ã—  n.

We know Î±0 is the initial elimination ratio that reduces the number of lower right candidates to n / 8. Therefore, this is the expected size, we start with. In each iteration, we pay the cost O(|LRCandidates|). The number of LRCandidates after iteration 2, is Î±1Î±2  Ã—  n / 8. Similarly, the number of candidates after the ith iteration is [formula]. Therefore, we pay [formula] cost, which is the expected size of LRCandidates. Adding up for a maximum of n / 8 iterations we get [formula], the total expected cost of finding LowerRightHull. Although we write the sum for n / 8 iterations, it is quite likely that in the end the expected cost is 0 or close to 0. This is because an exponentially smaller coefficient is multiplied by n / 8. This is because all Î±1...Î±n / 8 are smaller than 1.

Suppose at some iteration we have found NextX and we perform candidate elimination. Figure [\ref=fig:CandidateArea2], compares candidate area to eliminated area. Candidate area is shown below the line from NextX to Xmax. Eliminated area is a triangle with area  =  ac / 2. Total area is bc / 2  +  ac  +  ac / 2. Therefore, Î±  =  (bc / 2  +  ac) / (bc / 2  +  ac  +  ac / 2)  =  (2a + b) / (3a + b). As we get closer to Xmax, b gets closer to a and the value of Î± decreases to 3a / 4a  =  3 / 4.

Using lemma [\ref=lemma:candidate2], we know [formula] is a product that decreases with i. Since Î± is smaller than 1 all the time, and Î± is a decreasing function. We can "assume" [formula] exponentially decreases with i and we can bound the expected running time using the sum of a geometric series as follows: [formula]. Since [formula] is a constant between 0 and 1, we know the sum of the geometric series is constant and so is the expected running time. We know minimum value for Î± is 3 / 4 and Î±  <  1. Using average value of 3 / 4 and 1, we can approximate   =  7 / 8, resulting in O(n) points accessed during the execution of the convex hull algorithm for each corner. Finally, we can approximate 4n as the total number of points accessed during the execution for finding the convex hull of 4 quarters. Next, we aim at calculating a constant upper bound for the expected cost, in order to prove the expected cost is linear, when convex hull is found by candidate elimination, instead of using [formula] which is only raw approximation!

In order to choose NextX, we need to draw a point from the uniform distribution specified by the triangle in Figure [\ref=fig:CandidateArea2]. The three corners of the triangle have these coordinates:(Ymin.x,Ymin.y), (Xmax.x,Ymin.y), (Xmax.x,Xmax.y). We are interested in finding the expected position of NextX on x - axis. Since the distribution is uniform and we are interested in expected NextX.x, we need to find the point on x - axis, such that if we split the triangle using a vertical line, candidate areas inside the triangle on both sides of the vertical line are equal. We assume the perpendicular sides of the triangle have equal expected length. One is equal to L1  =  Xmax.x  -  Ymin.x, and the other equal to L2  =  Xmax.y  -  Ymin.y. L1 and L2 are two random variables. E(L1 / L2) depends on the range of values of x and y coordinates in the point set. It is usually the case that these coordinates are either in the same range or we can perform normalization and make expected values of L1 and L2 both equal to a value L. Thus, without loss of generality we calculate (L - c)2 / 2 as the triangle area on the left side of NextX. We also compute (2L - c)  Ã—  c / 2, the area inside the triangle on the right side of NextX. Therefore, we need to find the value of c in terms of L in the following equation:

[formula]

.

We get [formula], by solving the above equation. After drawing a large enough (constant) number of points from the distribution, we can assume the expected value is reached in any instance of the problem. If we rewrite Î±  =  (2a + b) / (3a + b) that we computed earlier in the proof of lemma [\ref=lemma:candidate2], in terms of L and c, and replace c  =  0.3L, we get a  â‰ˆ  0.35L, b  â‰ˆ  0.65L and Î±  =  0.79. Therefore, we can bound expected running time by (1 / (1 - 0.8))  Ã—  n  =  5n. We need to do an initial scanning of the list in the first candidate elimination and read n points. Therefore, we compute 6n as an upper bound for the expected number of points read during the execution.

Regardless of the exact running time, by proving Theorem [\ref=theo:linearProof], we have shown the expected running time of the algorithm is O(n). In the next section, in our experiments we use counters for the number of points read until we find the convex hull for each experiment. In all of our experiments, we read almost 4n points during execution. This emphasises, the importance and reliability of our theoretical analysis for computing the expected running time in this section.

We have already done the proof for Uniform distribution. We know Normal distribution is more centered around its mean and further from its boundaries. It is obvious that this results in more probability mass in eliminated areas in all of the proofs regarding the expected running time analysis. We can say the expected running time when P is Uniform is an upper bound for the expected running time when P is Normal.

ConvexHull Running Time: Experimental Analysis

We performed 6 experiments for different number of points in P. The number of points grows exponentially. In all cases, we generate the point set randomly from uniform distribution. We use ClassicAlg for the classic algorithm and NewAlg for our new algorithm based on candidate elimination. We use QuickSort with expected O(nlog(n)) time for sorting in the implementation of classic algorithm which is typically one of the most efficient in practice. In all cases, except for n  =  10, our running time is almost 4n. In the case of n = 10, we perform 68 point reads which is more than 40. Although the difference is negligible, we relate the additional cost paid to the overhead of finding four quarters of the convex hull separately. There exists a negligible amount of overhead because Xmin, Xmax, Ymin and Ymax belong to candidate sets in more than 1 quarters.

The remarkable results we observe in the above table are: 1) Linear number of point reads compared to the input size for our new algorithm; 2) Finding 2 - D convex hull of up to 106 points while the classic algorithm fails to do so. We also notice we pay a lot less cost in order to find the convex hull of 106 points than the classic algorithm pays to find the convex hull of 105 points.

Classification Algorithm

Figure [\ref=fig:classificationexp1], shows the same distribution of data in classes as Figure [\ref=fig:classificationexp]. It also shows how classes are separated using their 2-dimensional (2D) convex hulls. Any new sample with missing label is checked against these three convex hulls. It is classified in that class if it is inside the corresponding convex hull. As shown in the figure, these classes overlap in the areas they cover and misclassification is always possible. It is also the case that if we try to separate these classes using other decision boundaries we face the same problem. Since convex hull tightly wraps around the points from each class, it reduces the chances of misclassification using its tight boundaries. There can be instances where the point falls outside all convex hulls. In such cases, we can assign a point to a class using it's proximity in Euclidean space. In the rest of this paper, we only deal with classification problems where there are typically d  >  2 features. In this case, since there are more than 2 dimensions, for each class we produce 2D convex hulls for every permutation of 2 features resulting in [formula] convex hulls for d features. We define the notion of 2DAspect as follows:

In order to check whether a point is covered by a 2DAspect, we check if it is below all the lines on the UpperHull and above all the lines on the LowerHull. Our convex hull based classifier, is composed of [formula] 2DAspect's, while C is the number of classes. Algorithm [\ref=algo:train], provides the pseudo-code for training a DataGrinder using 2D convex hulls.

In Algorithm [\ref=algo:train], for each class label (Ci), and pair of columns (features f1, f2), we select all rows of X corresponding to Ci, then project to columns f1 and f2. Both selection and projection are standard Relational Algebraic operations and thus we can even implement DataGrinder inside a database engine. We find upper and lower hulls of the point set, P, in the (f1,f2) plane. Having found the convex hull, we create a new 2DAspect structure using Ci, f1, f2, UH and LH. We repeat the process and construct all [formula] 2DAspects.

Testing for a new sample without label is done as follows:

Iterate over all 2DAspects.

Project the input x' vector to the corresponding (f1,f2) for each 2DAspect.

Check if the 2DAspect contains Ï€f1,f2(x').

Increment the score for the corresponding class label Ci.

Find the class cmax with the highest score and classify x' to cmax.

Testing is simpler than training and all we need to do is check for all 2DAspects, if they contain the new data row x', inside their convex hull. Having done this, we keep track of a count for each class, Ci, in how many 2DAspects it covers x'. We choose the class with the highest score and assign the appropriate class label according to DataGrinder.

Parallelization for Training and Testing

We can achieve parallelization for both training and testing phases easily by partitioning according to either classes or 2DAspects. This can be done in a straight forward way following a divide and conquer approach. For instance we can partition data into different classes or partition according to indices of (f1,f2) combinations. Since this is trivial, we only describe a simple divide and conquer algorithm for finding the 2D convex hull of a point set P, to conclude this section. It is worth to highlight that in Section [\ref=sec:expectedTime], we already showed both theoretically and empirically that our convex hull algorithm reads only O(n) expected number of points during its execution. Parallelization of the same algorithm using divide and conquer strategy obviously does not increase the running time. In fact, there may be no reason for parallelization in many scenarios. In cases where we want to build classifiers on demand for millions of points, it is practical to use parallelization. Algorithm [\ref=algo:parallelConvexHull] provides the pseudo code.

We use CH(P) to denote the convex hull of P. As described earlier, it is composed of to halves or four quarters each of which is an ordered set of points by x, (f1), coordinate. The idea is simple, first we partition P, until the size of each Pi is small enough. Typical running times can be estimated according to a simple cost-based analysis, and computing power/trafic available. We find the convex hull of each Pi, resulting in only a few remaining points on CH(Pi), typically constant. Having done this, we merge all CH(Pi)'s. It is guaranteed that we end up with a super set of the points required for the correct answer of CH(P). We find the convex hull of P' trivially in a final step.

Proof is already explained since

[formula]

.

Experimental Analysis

We have already shown how our convex hull algorithm achieves expected O(n) point reads. In this section, we already report our results regarding accuracy in different cases. First, we propose a random class generation approach, through which we can control the difficulty of the classification problem instance. We generate data only using the Uniform distribution. It is known that we can convert other distributions to Uniform as well before classification, using Normalization [\cite=BishopML]. Here, our focus is mainly on designing DataGrinder and efficient algorithms. We report our raw results using only the algorithms described and avoid any pre/post processing to leave more room for the future work, and study the key factors involved in classification accuracy of DataGrinder, in its standard and straight forward case. We will show shortly, how DataGrinder (DGR) achieves high accuracy even in its simplest form, as described in this paper. This increases our hopes for designing highly scalable Data Mining and Machine Learning algorithms, in the Database community. Our data generation aapproach works as follows. Feature values of class C (last class label), are generated as: C  +  Î»  Ã—  Uniform(0,1). This results in producing uniformly distributed random values for all features of class Ci, in the range

[formula]

Existing Classification Datasets

We use two standard datasets also used as examples in Machine Learning textbooks for the classification problem, Iris and Wine. We obtain these datasets from the UCI data mining repository . Both datasets have less than 1000 samples and 3 classes. We use 10-fold cross validation for training and testing, meaning we divide the dataset into 10 partitions, and use the average of 10 experiments. In each experiment, we use 9 partitions for training and 1 for testing. All algorithms reach acceptable accuracy on Iris dataset > 90%, and close to 1 (Figure [\ref=fig:classificationexpIrisWine]). In the case of Wine dataset, DiscriminantClassifier performs slightly superior compared to DataGrinder and DecisionTree. NearestNeighbor method is significantly outperformed by all the other algorithms. Since DiscriminantClassifier uses many parameters to achieve this, we also decide to add only 1 hyper-parameter namely Filtering Ratio (0  â‰¤  Î¸ < 1) to DataGrinder. In order to do this, we add an additional variable to each 2DAspect, Classification Accuracy. It refers to the number of training samples that correctly fall inside a 2DAspect (i.e. 2DAspect and data labels match), over the total number of all samples. Any 2DAspects that largely overlap with other classes resulting in classification accuracy less than Î¸, are removed from DataGrinder. We vary Î¸ using a 0.01 step size from 0 to 1 over the training dataset and record the best testing accuracy. We also show in Figure [\ref=fig:classificationexpIrisWine], the best DataGrinder accuracy after filtering using a solid bar. As it is notable, DataGrinder accuracy increases after filtering, resulting in less classification errors. This also adds another dimension to our future research in order to target adding few meaningful parameters or hyper-parameter to the model that increase accuracy. The remarkable fact to highlight about the filtering technique presented is that we can achieve higher accuracy using tuning techniques and this leaves the door open for future research on DataGrinder. Figure [\ref=fig:RatioExp], shows how DataGrinder accuracy changes on these datasets with varying Î¸. For Î¸ = 0, i.e. Raw DataGrinder, no 2DAspects are filtered. When Î¸ = 1, all 2DAspects are filtered and all samples are assigned to the default class 0. In both cases we get the best accuracy around Î¸  =  0.5. This is logical, because any features whose classification rate is more than misclassification rate can be useful for discriminating between classes. When a large enough number of such features are combined, we can achieve high overall accuracy.

Related work

In this section, we review the recent works in literature that discuss scalable data mining algorithms and frameworks similar to DataGrinder, in motivation and technical contribution.

In [\cite=SVMInd:11], authors propose an "Exact Indexing" approach for Support Vector Machines. They propose indexing strategies in the Kernel space, iKernel, that is used for exact top-k query processing when SVM is used for ranking. Given a SVM model, authors use properties of the Kernel space such as ranking instability and ordering stability. They provide an excellent background of support vector machines, and their relevance to databases, top-k query processing and ranking. They only focus on prediction (i.e. testing), and do not aim at designing parallel SVM algorithms. DataGrinder, provides a highly scalable algorithmic framework for both training, model updating and testing that achieves high accuracy. We might be able to focus on future work leveraging convex hulls for constructing kernels as well as ranking. Although this requires leveraging more geometric properties of the data, in order to be able to achieve accuracy as high as Support Vector Machines. Support Vector Machine is a well researched problem with a complex structure. In contrary, DataGrinder aims at building simpler discrete models with high accuracy and our initial experimental results are promising. SVM also has applications in bioinformatics, where there are thousands of features and we need to improve DataGrinder in order to be able to deal with these applications. Biological datasets are typically more complex. Regardless of the model structure, they focus on ranking and top-k query processing while we focus on convex hulls and classification. ArrayStore [\cite=ArrayStore:11], is a storage manager for complex array processing. Authors process datasets as big as 80GB, using parallel data mining algorithms. They provide a multi-dimensional array model, suitable for our classification scenario. They also discuss data access issues. Our Select-Project-ConvexHull series of operations completely fits within their storage framework. Thus, we do not worry about scalability of DataGrinder at all. Rather than focus on storage, in this paper we discuss a new discrete classification algorithm, that can work on the top of ArrayStore. Authors already discuss two types of clustering algorithms, but they did not provide any examples on the classic classification problem. We provide a divide and conquer algorithm that makes DataGrinder compatible with ArrayStore. ERACER [\cite=ERACER:10], provides an iterative statistical framework for filling in missing data, as well as data cleaning and fixing corrupted values using conventional statistical methods. DataGrinder can solve their problem in a special case. Extensions of DataGrinder can also solve the same exact problem. We use Computational Geometry, and theoretical analysis for a O(n) expected running time algorithm while maintaining accuracy. DataGrinder can as well fit inside a DBMS engine using Select-Project-ConvexHull. We can implement ConvexHull as an operation using Table Functions. DataGrinder is fully non-Parametric, meaning that it is easy to use, and needs no parameter tuning. DataGrinder is completely discrete and we can also count on divide and conquer solutions for intense scalability. DataGrinder is easy to implement, thus suitable for the industry. DataGrinder achieves high accuracy in classification. We also show with experiments how we can improve accuracy by Filtering(Î¸). All in all, we find DataGrinder a more suitable solution for the database community, due to its strong and fundamental theoretical contributions. Spanners [\cite=Spanners:13], is an interesting theoretical contribution, and a formal framework for information extraction. We believe DataGrinder has a similar flavour in its contribution to Spanners. We also aim at designing operations for processing multidimensional data and knowledge discovery. Spanners is focused on Information Extraction and using Regular Expressions for Text Mining using predefined operations. Several other previous works have also tried to achieve the same goal such as [\cite=TopRecs:11]. Another interesting direction to achieve parallel statistical and data mining algorithms is through Sampling [\cite=DCInference:12]. In this approach, we make BigData assumption and use parallelization for processing. We build many small models and using statistical inference, we combine these models to guarantee reliability and accuracy. The size of input data and distribution(s) of data are examples of key parameters we need to take into account. Naturally, we need to focus on how to sample and pay attention to things such as the number of samples, the size of each sample as well as how to effectively combine the models built using different samplings of the data. This can be done for Big Data, regardless of the data mining task discussed. Examples of such methods include [\cite=ClusterForest:13] [\cite=DDFactors:11]. Rule-based classifiers are other examples of discrete classification algorithms, discussed in the data mining literature [\cite=RuleClass1] [\cite=RuleClass2] [\cite=RuleClass3]. They use frequent patterns and association rules mining in order to find rules with high support and confidence. They typically achieve reliable accuracy. They need a rather costly parameter tuning step to construct the best classifier. They need the exact solution of a NP-hard theoretical problem compared to O(n) expected running time of DataGrinder. There have been some attempts for parallel frequent pattern mining algorithms which is outside the context of this paper.

Convex Hull problem has a long history in Computational Geometry [\cite=ComputationalGeometryBook]. It is significantly important, because many other important problems in Computational Geometry can be reduced to this problem. Many efforts have been devoted to improving the worst case running time and output sensitive algorithms. We find average case analysis more suitable to the database community, due to its similarity to cost-based query optimization. In [\cite=Convex:81], there is a proposal for expected O(n) algorithms along with theoretical analysis to prove its possibility. In this paper, we provide an algorithm with pseudo code and calculate a exact costant, to serve as an upper-bound for the expected running time. Our experimental evaluation backs up all of our arguments, regardless of the running time and programming languages used.

Conclusions and Future Work

In this paper, we revisited the important problem of finding 2D convex hulls. We propose an algorithm based on a well-known historical algorithm, with O(n) expected running time. We propose a simpler and shorter proof compared to the previous work, and also calculate a constant that serves as an upper-bound for the expected linear running time. We conduct experiments to back up all of our arguments. We perform several experiments and show DataGrinder is comparable to the most reliable commercial classification packages in MATLAB and outperforms many, while maintaining its extreme provable scalability. We show how to achieve several levels of parallelization, while keeping the correctness of our classification algorithm. We intend to focus on more detailed Geometrical study of the problem, in order to partition the data more accurately. Specially, remove sparse areas. We also intend to test for more classification scenarios as well as adding meaningful parameters and hyper-parameters to DataGrinder. We would also like to take DataGrinder to the cloud for classification of enormous datasets.