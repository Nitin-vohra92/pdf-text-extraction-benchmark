Lemma Definition Remark

Randomized Incremental Construction of Compressed Quadtrees

Introduction

In this note, we point out that compressed quadtrees can be built via randomized incremental construction. Compressed quadtrees are simple geometric data-structure. Despite their simplicity, they are surprisingly useful for carrying out various geometric tasks, see [\cite=h-gaa-08].

The first randomized algorithm for building compressed quadtrees is due to Clarkson [\cite=c-faann-83]. Eppstein et al. [\cite=egs-sqsdd-05] suggested building compressed quadtrees by using hierarchical random sampling in a style similar to skip-lists. If one allows bitwise operations (in particular, interleaving the bits of two integers in constant time) one can build compressed quadtrees using z-order [\cite=g-ewrq-82] [\cite=h-gaa-08] by a relatively simple algorithm, but the task is more challenging if such operations are not allowed.

The new algorithm we describe seems to be quite simple, and can be interpreted as a variant of the skip quadtree of Eppstein et al. [\cite=egs-sqsdd-05].

Preliminaries

For a real positive number z and a point p  =  (x,y) in [formula], define [formula] to be the grid point [formula]. Observe that [formula] partitions the plane into square regions, which we call grid . Formally, for any [formula], the intersection of the half-planes x  ≥  zi, x  <  z(i + 1), y  ≥  zj and y  <  z(j + 1) is said to be a grid .

A square is a , if it is contained inside the unit square, it is a cell in a grid [formula], and r is a power of two.

Given a set [formula] of n points in the unit square, a quadtree [formula] is built as follows: The root corresponds to the unit square. Every node [formula] corresponds to a cell [formula] (i.e., a square), and it has four children. The four children correspond to the four squares formed by splitting [formula] into four equal size squares, by horizontal and vertical cuts. The construction is recursive, and we start from [formula]. As long as the current node contains more than, say, two points of [formula], we create its children, and continue recursively the construction in each child. We stop when each leaf of this tree contains a single point of [formula].

By compressing paths (in this tree) of nodes that all have a single child, we get a compressed quadtree of size O(n). Let [formula] denote the (uniquely defined) of [formula].

A leaf in this quadtree corresponds to a canonical square, and a compressed edge (or more precisely the top vertex of this edge) corresponds to an annulus formed by the set difference of two canonical squares. We will refer to such region as a , see Figure [\ref=fig:tile]; that is, a tile is either a square (corresponding to a leaf of the compressed quadtree) or an annulus (corresponding to a compressed edge). As such, a compressed quadtree induces a partition of the unit square into these tiles. We denote the planar map induced by these tiles of the compressed quadtree of [formula] by [formula].

Algorithm and analysis

The algorithm

Pick a random permutation [formula] of the points of [formula]. Let [formula] be the compressed quadtree of [formula]. In any node of [formula] that corresponds to a tile f of [formula], we store a list, denoted by [formula], of all the points of [formula] that lie inside f. As such, any point of [formula] is stored exactly once somewhere in [formula]. We will refer to [formula] as the of f. We also store for every point of [formula] a pointer to the node of [formula] that contains it.

In the ith iteration, we find the node vi of [formula] that stores [formula], and we insert [formula] into this node. This insertion might result in at most a constant number (i.e., three) of new nodes being created. The resulting tree [formula] is the compressed quadtree of [formula]. Now, we need to move all the points stored in vi to their new proper place in [formula]. Thus, for every point stored in vi, we check if it has to now be stored in one of the new nodes, and if so we move it to this new node. If there are k points in the conflict list of vi then this iteration takes O(1  +  k) time.

The compressed quadtree [formula] is the required tree.

The analysis

Let Y be an arbitrary subset of [formula], and consider a tile f∈(Y). A set X  ⊆  Y is a for f, if f∈(X) and it is a minimal set with this property (i.e., no proper subset of X has f as a tile).

The following is proved by a tedious but easy case analysis.

If X is a defining set of a tile [formula] then [formula].

Unlike "traditional" randomized incremental construction, the defining set is not unique in this case.

Consider a tile [formula]. The probability that f was created in the ith iteration is ≤  4 / i. Formally, we claim that

[formula]

Let [formula] be all the different defining sets of f. Consider the set [formula].

Observe that f was created in the ith iteration only if [formula]. Indeed, if [formula], then there exists a defining set Dt of f such that [formula]. But then, f is also a tile of [formula] as [formula], and the probability of this tile to be created in the ith iteration is zero.

Now, by Lemma [\ref=lemma:tedious], all the defining sets have cardinality at most four, and [formula]. As such, the required probability is bounded by the probability that [formula] is in Z. We bound this probability by backward analysis. Indeed, fix the set [formula] and consider all possible permutations of this set. The probability that one of the (at most) four points of Z is the last point in this permutation (of i elements) is at most 4 / i.

Observe that the probability of a tile f to be created (according to Lemma [\ref=lemma:backward]) is independent of the size of its conflict list.

The expected amount of work in the ith iteration is O(1  +  n / i).

Consider a tile [formula]. The amount of work spent on it, if it was created in the ith iteration, is proportional to the size of its conflict list [formula]. Let Xi be the random variable which is the amount of work spend by the algorithm in the ith iteration. Since the total size of the conflict lists of [formula] is n, we get by Lemma [\ref=lemma:backward] that the expected work in the ith iteration is bounded by

[formula]

(Again, the expectation here is over all possible permutations of [formula].) Now, we have that [formula].

Given a point set [formula] of n points in the plane contained inside the unit square, one can build a compressed quadtree for [formula] in O(n log n) expected time.

By Lemma [\ref=lemma:iteration], the total expected work of the above algorithm is [formula].

The algorithm can also be analyzed using the results from Clarkson et al. [\cite=cms-frric-93].

Discussion and conclusions

The algorithm presented for building quadtrees works also for points in higher dimensions.

It is natural to compare our algorithm to Eppstein et al. [\cite=egs-sqsdd-05]. They get a slightly more complicated algorithm, but they support both insertions and deletions, while our algorithm can only build the quadtree. In light of our approach, it is natural to interpret the algorithm of Eppstein et al. [\cite=egs-sqsdd-05] as a lazy randomized incremental algorithm for building quadtrees [\cite=bds-lric-95].

The author believes that this is a neat example of backward analysis. The reader naturally has the right to disagree.

Acknowledgments

The author thanks Ken Clarkson and David Eppstein for useful discussions on the problem studied in this note.