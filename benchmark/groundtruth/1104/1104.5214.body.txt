Linear-Space Approximate Distance Oracles for Planar, Bounded-Genus, and Minor-Free Graphs

An extended abstract is to appear in the Proceedings of the 38th International Colloquium on Automata, Languages and Programming (ICALP 2011)

Introduction

A (1 + ε)-approximate distance oracle for a graph is a data structure that supports point-to-point approximate distance queries. A distance-oracle construction for a family of graphs has three complexity measures:

preprocessing time: time to build the data structure,

space: how much space is occupied by the data structure, and

query time: how long does it take for a query to be answered.

Each of these quantities might depend on the stretch parameter 1 + ε (which is defined as the maximum ratio over all pairs of nodes of the query output divided by the length of a shortest path) as well as the size of the graph.

General graphs

For general graphs, for stretch less than 2, no approximate distance oracle is known that achieves subquadratic space and sublinear query time. (In Section [\ref=sec:general-graphs], we briefly survey work on general graphs.)

Restricted graph families

The only known constructions that achieve (1 + ε) stretch are for restricted families of graphs: planar graphs [\cite=ThorupJACM04], minor-excluded graphs [\cite=AbrahamG06], and graphs of low doubling dimension [\cite=conf/stoc/Talwar04] [\cite=MendelHarPeled] [\cite=SlivkinsPODC05JournalVersion] [\cite=journals/corr/abs-1008-1480]. (In Section [\ref=sec:previous-work], we survey previously known results in this area.)

Fortunately, such graphs arise in applications, e.g. relating to road maps. Distance oracles can be used in finding nearby points of interest, in navigation and route-planning, and in algorithms for solving other optimization problems such as vehicle routing.

Space requirements

One obstacle to the widespread adoption of this technique may have been the space requirements of known distance oracles. Even the most compact distance oracle of Thorup [\cite=ThorupJACM04] requires Ω(ε- 1nlgn) space for n-node graphs. Even though the constant is quite modest, the storage required is rather large [\cite=distance-oracle-experiment].

Since modern computer architectures involve hierarchical memory (caches, primary memory, secondary memory), a high memory requirement in effect may greatly increase the actual query time. If the distance oracle could fit in cache, the query time could be much faster than if secondary or primary memory must be accessed. For smaller, less powerful mobile devices such as handhelds, the problem is exacerbated.

Our contribution

In this paper, for every family of graphs for which a nontrivial (1 + ε)-approximate distance oracle is known (planar, bounded genus, H-minor-free, bounded doubling dimension), we give such a distance oracle that in addition requires only linear space. In fact, for any δ > 0, there is such a distance oracle whose space requirement is only 1 + δ times the space required just to store the graph itself; thus the overhead due to the distance oracle is in essence negligible.

We achieve this while increasing the query time by a factor that is almost proportional to the decrease in space. For planar graphs, the query time of our oracle is O(ε- 2lg2n). Although the query time for our constructions is slower than that for the superlinear-space constructions, the increase may be partly made up for by the decrease in actual time due to better memory performance (because of the memory hierarchy). The space/query-time tradeoff is tunable, so the construction can be adapted to a particular architecture.

The preprocessing time is also faster for our schemes than for the superlinear-space constructions.

Bounded-genus graphs

For bounded-genus graphs, there was previously no distance-oracle construction known other than that implied by the minor-excluded construction, for which the constant is enormous and the preprocessing time is a high-degree polynomial. We give a more efficient construction tailored to graphs of genus g. For our linear-space oracle, the query time is O(ε- 2(lgn  +  g)2) and the preprocessing time is O(n(lgn)(g3  +  lgn)). (There is also an alternative construction with preprocessing time O(n(lgn)(g / ε  +  lgn)).) We also provide an approximate distance oracle using space O(nε- 1(lgn + g)) but having faster query time O(g / ε) (Theorem [\ref=thm:genusfastquerythm]).

Bounded-doubling-dimension graphs

We also provide a linear-space approximate distance oracle for unit-length graphs with bounded doubling dimension (Theorem [\ref=thm:doublingthm]) using an approach that does not require separators. The query time of our construction is ε- O(α2)  ·  (lgn)O(α).

Summary of our results

A summary of our results is given in Table [\ref=tab:our-results].

Previous work on approximate distance oracles

General and sparse graphs

Thorup and Zwick [\cite=ThorupZwick2005] gave asymptotically almost optimal trade-offs for distance oracles for general undirected graphs, proving that for any graph and for any integer k there is a (2k - 1)-approximate distance oracle using space O(kn1 + 1 / k) and query time O(k). They also prove that, if stretch strictly less than 2k + 1 is desired, then Ω(n1 + 1 / k) bits of space are necessary. A slightly weaker lower bound holds for sparse graphs: Sommer, Verbin, and Yu [\cite=SparseDO] prove that a distance oracle with stretch k and query time t requires space n1 + Ω(1 / (kt)) (up to poly-logarithmic factors). Tight with respect to this bound, the distance oracle of Mendel and Naor [\cite=MendelN07] has query time O(1) and stretch O(k) using space O(n1 + 1 / k). The oracle with the best stretch factor is by P atra scu and Roditty [\cite=PatrascuRoditty], who recently gave a 2-approximate distance oracle using space O(n5 / 3) on sparse graphs. Distance oracles with stretch strictly less than 2 have not been achieved for general graphs.

Restricted graph classes: planar, excluded-minor, and bounded-doubling-dimension graphs

For restricted classes of graphs, better distance oracles are known and stretch 1 + ε can be achieved.

Planar graphs

Thorup [\cite=ThorupJACM04] presents efficient (1 + ε)-approximate distance oracles for planar digraphs. (There is a slight improvement [\cite=conf/soda/Klein05] to the preprocessing time for one case.) Table [\ref=tab:planardoresults] lists these results.

There are also many results on exact distance oracles for planar graphs. The best is that of Fakcharoenphol and Rao [\cite=journals/jcss/FakcharoenpholR06] and its subsequent improvements [\cite=conf/soda/Klein05] [\cite=journals/talg/KleinMW10] [\cite=esa/MozesW10] and variants [\cite=journals/corr/abs-1011-5549] [\cite=Nussbaum10]. Faster per-query time can be achieved by using more space [\cite=conf/soda/Cabello06] [\cite=journals/corr/abs-1011-5549]. However, all these results require polynomial (but sublinear) query time. There are also results on special cases of planar graphs and special kinds of queries [\cite=conf/stacs/DjidjevPZ95] [\cite=journals/algorithmica/DjidjevPZ00] [\cite=conf/icalp/DjidjevPZ91] [\cite=stoc/ChenX00] [\cite=journals/talg/KowalikK06].

Excluded-minor graphs

Abraham and Gavoille [\cite=AbrahamG06] extend Thorup's result to minor-free graphs. After a polynomial-time preprocessing step, point-to-point queries can be answered in time O(ε- 1lgn) using a data structure of size O(nε- 1lgn).

Bounded-tree-width graphs

For digraphs with tree-width w, Chaudhuri and Zaroliagis [\cite=journals/algorithmica/ChaudhuriZ00] give a O(w3n)-time algorithm to compute a distance oracle with query time O(w3α(n)), where α(n) denotes the inverse Ackermann function. Gavoille et al. [\cite=journals/jal/GavoillePPR04] provide a distance oracle with space O(n  ·  wlg2n) and query time O(lgn).

Graphs of bounded doubling dimension

Let Δ denote the aspect ratio (diameter divided by minimum distance) and let α  =  lg2λ denote the doubling dimension. Har-Peled and Mendel [\cite=MendelHarPeled], improving upon earlier results by Talwar [\cite=conf/stoc/Talwar04] and Slivkins [\cite=SlivkinsPODC05JournalVersion], provide a (1 + ε)-approximate distance oracle (they term it compact representation scheme) using space (1 / ε)O(α)n with query time O(α). Bartal et al. [\cite=journals/corr/abs-1008-1480], extending [\cite=MendelHarPeled], recently gave a distance oracle with constant query time, at the cost of increasing the space consumption. We shift the trade-off in the reverse direction, increasing the query time while reducing the space requirement to linear (see Section [\ref=sec:doubling] in the appendix for details).

Linear-space approximate distance oracle for planar graphs

We prove our main theorem. The description of the improved preprocessing algorithm can be found in its own section (Section [\ref=sec:planar:prepro]).

For any undirected planar graph G with non-negative edge weights there exists a (1 + ε)-approximate distance oracle with query time O(ε- 2lg2n), linear space, and preprocessing time O(nlg2n).

Review of Thorup's distance oracle

We briefly review a variant of Thorup's distance oracle for undirected graphs (using somewhat different terminology).

There are two core ideas. The first is approximately representing shortest paths that intersect a shortest path. Let P be a shortest path in a graph G. A pair (p,v) of nodes where p is in P and v is in G is a connection for v with respect to P. A set C of such connections covers v in G with respect to P if, for every node p of P, there is a connection (p',v) in C such that

[formula]

Let u,v be nodes of the input graph. Let Q be the shortest u-to-v path that intersects P. Suppose C is a set of connections that covers u and v with respect to P. Then it contains connections (p,u),(p',v) such that

[formula]

Thorup gives an algorithm that, given a (mostly) planar graph G and a shortest path P, computes a set C of connections that covers all nodes of G and that has O(ε- 1) connections per node v. In Section [\ref=sec:planar:prepro], we give an algorithm that achieves a faster running time by covering only a subset of the nodes of G. The distance oracle involves storing with each node v the connections that cover v with respect to several shortest paths (and the distances associated with these connections). The storage required for v thus has size O(ε- 1) times the number of such paths.

The second idea is recursively decomposing a planar graph with shortest-path separators. This idea is based on a lemma in [\cite=LT79] stating that, for any spanning tree T in a planar graph in which every face is a triangle, there is a nontree edge e such that the unique simple cycle in [formula] is a balanced separator. The nodes of this separator comprise two paths in T.

The distance-oracle construction uses this lemma with T being a shortest-path tree to recursively decompose the input graph. The recursive decomposition defines a binary decomposition tree in which each node x is labeled by (i) a subgraph G(x) of the input graph and (ii) the separator S(x) used to decompose G(x), if x is not a leaf. If x is the root, G(x) is the input graph. If x has children y and z, removing the separator S(x) from G(x) results in two separated subgraphs, G(y) and G(z). If x is a leaf, G(x) consists of one node.

Each input-graph node v is associated with some decomposition-tree node, namely, the leafmost node x whose subgraph includes v. We say that the ancestors of x are relevant to v. Thus each input-graph node v has O(lgn) relevant tree-nodes. The distance oracle assigns a label to v that consists of a set of connections; for each tree-node x relevant to v, for each of the two paths P comprising the separator S(x), the distance oracle stores a set of connections that cover v in G(x) with respect to P. It follows that the label of v has size O(ε- 1lgn).

Next we show that these labels suffice to estimate point-to-point distances. We say that a tree-node x is relevant to a path Q if S(x) contains a node of Q, and is the most relevant if x is the rootmost relevant tree node.

If x is the tree-node most relevant to Q then G(x) contains Q.

Let u,v be any pair of input-graph nodes, and let Q be the shortest u-to-v path. Let x be the tree-node most relevant to Q. Then G(x) contains Q, and at least one of the paths comprising the separator S(x), say P, intersects Q. It follows from ([\ref=eq:connections-and-shortest-path]) that the u-to-v distance is approximately

[formula]

for two nodes p,p' on P. To estimate the u-to-v distance, therefore, the following procedure suffices: for every tree-node x that is relevant to u and v, compute the minimum of ([\ref=eq:dist-est]) over connections (p,u) and connections (p',v) where p and p' belong to one of the two paths comprising S(x). This takes time proportional to the number of such connections. We review this process in Section [\ref=sec:planar:query] since in our case the situation is slightly more complicated.

Our compact distance oracle

Our linear-space construction draws on another kind of recursive decomposition using separators.

A division of a graph G is a partition of the edges of G into edge-induced subgraphs. A node of G is a boundary node of the partition if it belongs to more than one subgraph. An r-division of an n-node planar graph G is a division of G into O(n / r) subgraphs, called regions, with the following properties: (i) Each region contains O(r) edges, and (ii) the number of boundary nodes in each region is at most [formula].

Note that there are [formula] boundary nodes in total.

A planar graph on n vertices can be divided into an r-division in O(nlgn) time.

Using an r-division to obtain linear space

Before carrying out the recursive decomposition with shortest-path separators, our preprocessing algorithm computes an r-division for [formula] (where [formula] is a parameter). Subsequently, connections (v,w) are only stored for those nodes v that are boundary nodes of the r-division. Since there are [formula] boundary nodes, the connections and associated distances require storage [formula]. We choose [formula] so the total storage is O(n).

An s-to-t query is handled as follows. First, compute shortest-path distances from s to all the nodes in s's region Rs. This takes [formula] time [\cite=journals/jcss/HenzingerKRS97]. At this point, the query algorithm has distances in the subgraph Rs from s to all the boundary nodes of Rs (and to t, if t is in Rs). There are [formula] such boundary nodes. Similarly, compute shortest-path distances to t from all the nodes in t's region Rt, obtaining distances in the subgraph Rt to t from all the boundary nodes of Rt.

Let A,B be, respectively, the set of connections for boundary nodes of Rs,Rt. For each separator path P that has connections in A and B, the procedure described in Section [\ref=sec:planar:query] finds the shortest s-to-t path that enters P via a connection of A and leaves P via a connection of B. The time is linear in the number of such connections (see also [\cite=ThorupJACM04] and [\cite=ThorupJACM04]). Since each of the [formula] boundary nodes of Rs and Rt has O(ε- 1lgn) connections, the total time for these computations is [formula].

Finally, return the minimum overall path-length (including the s-to-t distance within Rs, if t belongs to Rs). The total time for handling the query is [formula].

Details of the query algorithm

We now explain how we find the shortest s-to-t path that enters P via a connection of A and leaves P via a connection of B. The method is a generalization of that in [\cite=ThorupJACM04].

For each connection (b,p) in A, b is a boundary node of Rs and we have [formula]. For each connection (b,p) in B, b is a boundary node of Rt and we have [formula]. Let C be the sequence of all connections (s,p) and (t,p) in [formula], sorted according to the position of p on P. We use the following procedure. initialize ms,mt,d: =   ∞   initialize p̂:  =  p0 for each connection (p,b) in C in order,   [formula] [formula] p̂: = p if b is a boundary node of Rs,   [formula] if b is a boundary node of Rt [formula] d: =  min {d,ms + mt} return d The procedure requires time [formula]. The procedure maintains the invariant that, after a node p̂ of P has been considered in the loop, ms is the length of the shortest s-to-p̂ path of the form that goes via a boundary node b of Rs and a connection (b,p) and then travels along P from p to p̂, where p appears before p̂ on P. A similar statement holds for mt. It follows that the value d returned by the procedure is the length of the shortest s-to-t path that travels in Rs to a boundary node b of Rs, then goes to P via a connection for b, then travels along P then leaves P via a connection for a boundary node b' of Rt then travels to t within Rt.

Extensions: distance oracles for planar digraphs and reachability oracles

Similar techniques (i.e. storing the connections for a subset of the nodes only) apply to more of Thorup's results based on shortest path separators [\cite=ThorupJACM04]. Instead of using a more sophisticated preprocessing algorithm that computes only the connections for the boundary nodes, we may compute the connections for all the nodes (using Thorup's preprocessing algorithms as black boxes) and then store only those for boundary nodes. By doing so, we obtain the following linear-space oracles. For directed planar graphs, there is a (1 + ε)-approximate distance oracle with query time O((ε- 1(lgn)(lg(nN)))2), where N denotes the largest integer weight. Furthermore, there is a reachability oracle with query time O(lg2n) (using [\cite=ThorupJACM04]).

We exploit a similar black-box construction for minor-free graphs in Section [\ref=sec:minorfr].

Preprocessing algorithm for linear-space approximate distance oracle for planar graphs

Thorup's preprocessing algorithm for his undirected construction takes time O(nε- 2lg3n) (as stated in [\cite=ThorupJACM04]). We give a preprocessing scheme for our construction that takes time O(nlg2n), independent of ε. We give details later, but here we observe that the factor O(ε- 2lgn) speedup has three sources. (This explanation is aimed at readers familiar with Thorup's paper.)

First, since we are not aiming for a query time of O(ε- 1), we can use a simpler preprocessing approach than the one underlying [\cite=ThorupJACM04]; we use the approach that for directed graphs underlies [\cite=ThorupJACM04]. The corresponding bound for undirected graphs is listed in Table [\ref=tab:planardoresults] as "implicit."

Second, we only need to compute connections for a small subset of the nodes (the boundary nodes of the r-division). That in itself does not seem to permit an additional speedup using Thorup's method since his algorithm depends not on the number of connections stored but on the sizes of the graphs searched. Therefore, third, in addition we use another approach to finding connections, one based on the multiple-source shortest-path (MSSP) algorithm of Klein [\cite=conf/soda/Klein05] or that of Cabello and Chambers [\cite=conf/soda/CabelloC07].

Preprocess(G0)   let B0 be the set of boundary nodes of an r-division [\cite=journals/siamcomp/Frederickson87] let T be a shortest-path tree compute recursive decomposition based on cycle separators of the form [formula] for each nonroot node x of recursive-decomposition tree,   for each path Pi (i = 1,2) comprising S(x),   compute connections for nodes of B0 in G(x) with respect to Pi

The last step, computing the connections for nodes of B0 in G(x) with respect to Pi, works on a graph G'(x) obtained from G(x) by cutting along Pi, duplicating the nodes and edges of Pi and creating a new face whose boundary consists of the two copies of Pi. This modification destroys paths that cross Pi but such paths are not needed since Pi is a shortest path. It has the advantage that, for each copy P of Pi, in G'(x) all nodes of P lie on a common face.

For each copy P, there is a computation that selects connections (p,v) for specified nodes v with respect to that copy. The computation uses an algorithm called Path(G,B,P) that takes time [formula] and selects O(ε- 1) connections per node v∈B. Since there are two copies of two paths comprising S(x), the last step of Preprocess selects O(ε- 1) connections per node of B0 in G(x). Therefore the total number of connections for B0 is O(ε- 1lgn), and the total time is [formula], which is O(nlg2n).

Now we describe Path(G,B,P). Let the nodes of P be [formula]. First the algorithm computes [formula] and [formula]. These can be computed using a single-source shortest-path computation in the graph obtained by zeroing out the lengths of the edges of P.

For [formula], let Ti denote the shortest-path tree rooted at pi. For i > 0, let Ti' be the tree obtained from Ti - 1 by removing the parent edge of pi and adding the edge pipi - 1, obtaining a pi-rooted tree (not a shortest-path tree). For i > 0, let σi denote a sequence of edges whose insertion into T'i (followed by the ejection of each corresponding parent edge) result in Ti. Klein [\cite=conf/soda/Klein05] shows that each edge is inserted at most once, and gives an [formula] algorithm (the multiple-source shortest-path algorithm) to compute these sequences. For each such inserted edge uv, the algorithm also computes the resulting change Δuv in the length of the root-to-v path in the tree. Cabello and Chambers [\cite=conf/soda/CabelloC07] give a simplification of the multiple-source shortest-path algorithm and generalize it to bounded-genus in [formula] time. The algorithm Path uses one of these algorithms to compute the sequences σi and the corresponding length changes Δuv.

The two phases

The remainder of Path consists of two phases, Forward and Backward. A connection (pi,v) might be added by Forward if i > i(x) and by Backward if i  <  i(x). We describe Forward. Backward is symmetric.

The Forward phase

The algorithm Forward iterates through the nodes [formula] of P, maintaining a tree T that is, in turn, [formula]. The tree T is represented using a dynamic-tree data structure [\cite=ABHVW04] [\cite=AHLT05] [\cite=Frederickson97] [\cite=ST83] [\cite=TW05]. A node-labeling is maintained: μ(v) is a quantity (discussed later) that is used to decide whether v needs a new connection. This labeling is represented implicitly, as is typical in dynamic trees, so as to support bulk updates. In this case (somewhat atypically), an update takes the form "add a quantity Δ to the label of every tree in the subtree rooted at u." Each update takes O(lgn) amortized time. In addition, searching for a node v that has μ(v)  ≤  0 takes O(lgn) time.

Forward(G,B,P):   initialize T: = T0 for every node v, initialize μ(v): =   ∞   for [formula]:   comment: T is rooted at pi [formula] for each node v∈B such that either i(v) = i or μ(v)  ≤  0 ,   create a connection (pi,v) set μ(v): = ε  dv if i < s, comment: now change the root... remove parent edge of pi + 1 and add edge pi + 1pi comment: now make the tree a shortest-path tree [formula] for each edge uv in the sequence σi + 1,   remove the current parent edge of v in T, and add uv [formula] for every active node w in the v-rooted subtree of T, μ(w): = μ(w)  +  Δuv

The overall number of iterations of the loop in Step [formula] is the number of connections added. The overall number of iterations of the loop in Step [formula] is at most the number of edges, which is [formula]. Step [formula] can be done using a single bulk update in [formula] time. Consequently, the algorithm runs in time [formula].

Now we show that the algorithm selects a covering set of connections (and that the set is small). At each moment in the execution of the algorithm, for each node v such that μ(v) is finite, let [formula] denote the node p of P such that (p,v) was the most recently selected connection for v.

The μ invariant is: for every node v for which μ(v) is finite,

[formula]

Note that [formula] is the length of the path that goes from the current root pi to v via [formula]. When this length becomes significantly longer than [formula] (longer by εdv), μ(v)  ≤  0 so the node v is included in the loop in Step [formula], so the connection (pi,v) is added. This shows that the connections added by Forward and Backward cover each node v∈B.

To bound the number of connections, we follow Thorup in using the potential function [formula]. Suppose that, at some execution of Step [formula], μ(v)  ≤  0, so [formula]. When a connection (pi,v) is then added, [formula] becomes pi, so the potential function Φv is reduced by at least εdv.

Initially [formula]. Throughout the phase, by the triangle inequality , [formula]. Again using the triangle inequality (and the fact that the graph is undirected), [formula], so [formula]. Thus the total amount of reduction in Φv is at most [formula]. Since each reduction is by at least [formula], the total number of reductions (number of connections added by Forward after the initial one) is at most ⌈2ε- 1⌉.

Approximate distance oracles for genus g graphs

For any undirected graph G embedded in a surface of Euler genus g, there exists a (1 + ε)-approximate distance oracle with query time O(ε- 2(lgn  +  g)2), linear space, and preprocessing time O(n(lgn)(g3  +  lgn)). The oracle can also be constructed in time O(n(lgn)(g / ε  +  lgn)).

Our distance oracle for genus g graphs is based on separating shortest paths, as for planar graphs (see Section [\ref=sec:planar:overview]). Thorup [\cite=ThorupJACM04] proves that any planar graph can be recursively separated by three shortest paths. Abraham and Gavoille [\cite=AbrahamG06] extend his result to minor-closed families, proving that any minor-free graph can be recursively separated by O(1) shortest paths. Since bounded-genus graphs exclude minors, we could use their result to obtain a linear-space distance oracle. The constant in [\cite=AbrahamG06] however depends on the size of the minor in an unspecified way. In the following, we prove that genus g graphs can be recursively separated using at most O(g) shortest paths. In fact, only the first separator consists of at most 2g paths, while lower levels can be separated using 3 paths. These smaller separators allow us to derive approximate oracles and labeling schemes with a dependency on g that is much lower than the corresponding dependency in the more general construction by Abraham and Gavoille [\cite=AbrahamG06]. More formally, we also prove the following.

For any undirected graph G embedded in a surface of Euler genus g, there exists a (1 + ε)-approximate distance oracle with query time O(g / ε), space O(n(g + lgn) / ε), and preprocessing time O(n(lgn)3ε- 2 + n(lgn)g / ε). The oracle can be distributed as a labeling scheme using O((g + lgn) / ε) bits per node.

In the following, we assume that G is embedded.

Overview

In the first step, we "cut" the genus g graph into planar subgraphs using the tree-cotree decomposition of Eppstein [\cite=conf/soda/Eppstein03], which decomposes a graph of genus g into planar graphs, separated by 2g paths from a tree T. We choose T to be a shortest-path tree.

Any graph G of genus g on n nodes and m edges can be divided into planar subgraphs by a separator that consists of at most 2g shortest paths. Furthermore, these paths can be computed using a single-source shortest-path search in G plus O(gm) time.

The existence of these paths is due to Eppstein's tree-cotree decomposition (T,C,X) of G, where T is a SSSP tree (any spanning tree works), C is its cotree, and X is the set of remaining edges of size at most 2g [\cite=conf/soda/Eppstein03].

Starting at an arbitrary node u, we compute a single-source shortest path tree T and its dual C. The separator consists of at most 2g tree paths from u to vi for each of the remaining edges (v0,v1)∈X, and of the edges in X.

At a high level, the theorems follow by combining Eppstein's lemma with the distance oracles for planar graphs (Thorup [\cite=ThorupJACM04] and Sections [\ref=sec:planar] and [\ref=sec:planar:prepro]). Within the planar subgraphs, we use the distance oracles for planar graphs. In addition to computing the connections to the separator paths within each planar subgraph, we also need to compute the connections to the O(g) tree-cotree decomposition paths. Note that the latter set of connections consists of paths that may pass through non-planar parts. To compute these, we may use either [\cite=conf/soda/CabelloC07] or [\cite=ThorupJACM04], depending on the values of g and ε.

Preprocessing algorithm

Within planar subgraphs

To obtain the preprocessing and space bounds in Theorem [\ref=thm:genusthm], we use the preprocessing algorithm described in Section [\ref=sec:planar:prepro] with [formula], where [formula]. Since the number of connections per node is proportional to [formula] and since a [formula]-fraction of the nodes per subgraph lies on the boundary, the overall space consumption is linear. To obtain the preprocessing and space bounds in Theorem [\ref=thm:genusfastquerythm], we use Thorup's algorithm [\cite=ThorupJACM04] for O(1 / ε) query time.

Connections to tree-cotree separator

There are two options to compute these connections: (1) We may use [\cite=ThorupJACM04] (which internally uses Thorup's O(m) SSSP algorithm [\cite=journals/jacm/Thorup99] [\cite=journals/jal/Thorup00]). The lemma states that, for a path Q, we can compute an ε-covering set C(v,Q) for all nodes v in time O(ε- 1n(lgn)). (2) We may use the MSSP data structure for genus g graphs by Cabello and Chambers [\cite=conf/soda/CabelloC07], which requires O(g2nlgn) preprocessing and then answers queries in time O(lgn). See planar preprocessing (Section [\ref=sec:planar:prepro]) for details. The time required is [formula]. We apply either lemma for the at most 2g paths of the tree-cotree decomposition. (For Theorem [\ref=thm:genusfastquerythm], the first option gives faster asymptotic preprocessing time; for Theorem [\ref=thm:genusthm], the optimal choice depends on ε and g.)

Query algorithm

At query time, we can essentially use the same algorithm as for the planar case (Section [\ref=sec:planar:query] and [\cite=ThorupJACM04]). The only difference to the planar case is that we also need to include the at most 2g paths separating the genus graph into planar subgraphs. To obtain the bound on the query time in Theorem [\ref=thm:genusthm], note that computing connections through these [formula] separating paths can be done in time [formula] and that exploring both regions took time [formula] (where [formula]).

Linear-space approximate distance oracle for H-minor-free graphs

For any minor H there is an integer h = h(H) such that for any undirected H-minor-free graph G with n nodes and m edges there exists a (1 + ε)-approximate distance oracle with query time O(hε- 2lg2n), space O(m), and polynomial preprocessing time.

The proof of Theorem [\ref=thm:minorthm] is structurally the same as for the planar case. We again use r-divisions [\cite=journals/siamcomp/Frederickson87], this time tailored to minor-free graphs using a separator algorithm by Kawarabayashi and Reed [\cite=conf/focs/KawarabayashiR10].

An r-division of an H-minor-free graph is a division into Θ(n / r) regions of O(r) vertices each and [formula] boundary vertices each. (Note that the boundary is larger by a factor [formula] compared to the boundary in the planar case.)

An H-minor-free graph on n vertices can be divided into an r-division in O(n2lgn) time.

The proof is a combination of three techniques: (i) Lemma [\ref=lemma:minordivision], (ii) shortest path separators in minor-free graphs by Abraham and Gavoille [\cite=AbrahamG06], and (iii) Thorup's ε-covers (as described in Section [\ref=sec:planar:overview]).

Abraham and Gavoille [\cite=AbrahamG06] prove that any H-minor-free graph can be recursively separated by k(H) shortest paths and that these paths can be found in polynomial time. We first compute these separator paths. We then compute an r-division for [formula] as in Lemma [\ref=lemma:minordivision]. For all the nodes on the boundary, we compute connections to these shortest paths [\cite=ThorupJACM04] (as in Section [\ref=sec:genus:prepro]). We store [formula] connections per node (where [formula] depends on [formula] in an unspecified way) for [formula] nodes. The total space requirement is thus O(m) (without further dependencies on H).

At query time, given a pair (s,t), we first explore both regions Rs and Rt, respectively, using an SSSP search [\cite=journals/dam/TazariM09] until all the boundary nodes of these two regions have been found. This step requires time [formula] (hiding further dependencies on H stemming from [\cite=journals/dam/TazariM09]). As described in Section [\ref=sec:planar:query], we can then merge clean and ordered covers in linear time [\cite=ThorupJACM04].

Linear-space approximate distance oracle for unit-length graphs with bounded doubling dimension

The distance oracles for planar, bounded-genus, and minor-free graphs heavily used the notion of separators. In the following, we show that separators are not the only way to obtain linear-space approximate distance oracles. Our linear-space approximate distance oracle for bounded-doubling-dimension graphs exploits the bounded-growth property.

The aspect ratio (also known as spread) of P  ⊆  V, denoted by Δ(P), is the ratio of the diameter of P and the distance between the closest pair of nodes in P. It is well known that for any λ-doubling metric M, any set of points P  ⊂  M with aspect ratio at most D  ≥  Δ(P) satisfies [formula].

We use this fact to obtain the following.

For any unit-length graph G = (V,E) on [formula] nodes and [formula] edges with doubling dimension α and diameter Δ, and for any ε  >  0 there exists a (1  +  ε)-approximate distance oracle using space O(m) and query time (lgΔ)O(α)  ·  (1 / ε)O(α2).

Note that (1) for unit-length graphs Δ = O(n) and thus the query time for constant α is O(poly(lgn,1 / ε)) and (2) our result also holds for unweighted geometric graphs such as those considered in [\cite=GudmundssonLevcopoulosNarasimhanSmid]. Our approach extends to graphs with moderate edge lengths; the dependency on the largest weight is however polynomial and not logarithmic.

In our proof we use the following approximate distance labeling scheme.

For a metric with doubling dimension α and aspect ratio Δ  =  Δ(V) and for any ε  >  0, there exists a (1  +  ε)-approximate distance labeling scheme with label length (1 / ε)O(α)lgΔ bits per node and query time 2O(α).

Let δ  <  n be an integer. A δ-dominating set of a graph G  =  (V,E) is a subset L  ⊆  V of nodes such that for each v∈V there is a node l∈L at distance at most δ. It is well-known that there is a δ-dominating set L of size at most [formula] and that such a set L can be found efficiently [\cite=KP98].

Let G = (V,E) be a graph that allows for a (1 + ε)-approximate distance labeling scheme with label length [formula] (Lemma [\ref=lemma:doublinglabel]). We store the distance labels for the nodes of an [formula]-dominating set, which requires total space O(n). For each unlabeled node v, we also store its nearest labeled node l(v).

At query time, given s,t∈V, we distinguish between "close" pairs (distance at most [formula]) and "far" pairs (otherwise). For "close" pairs, we explore (using BFS) the ball B(s) of radius [formula] around s. If t∈B(s), the exact distance can be returned (a "close" pair). Recall that for any λ-doubling metric M, any set of points P  ⊂  M with aspect ratio at most D  ≥  Δ(P) satisfies [formula]. For a unit-length graph G = (V,E) with doubling dimension α  =  lg2λ, for any node v∈V the number of nodes within distance d satisfies The number of edges within B(s) is at most quadratic in the number of nodes. Exploring B(s) using BFS thus requires time proportional to λO(lgd). For "far" pairs, we triangulate using l(s) and l(t), returning an approximate distance: The algorithm returns d̃(u,v)  =  dG(u,l(u))  +  D(L(l(u)),L(l(v)))  +  dG(l(v),v), where L(w) denotes the label of w and D(  ·  ,  ·  ) denotes the decoding function of the labeling scheme. A simple calculation (using the triangle inequality and the fact that the distance d(u,v) is at least [formula]) yields that the query result d̃(u,v) satisfies d̃(u,v)  ≤  (1 + 7ε)d(u,v) (for any ε∈(0,1]).