Auto-Stabilisation et Confinement de Fautes Malicieuses : Optimalit� du Protocole min + 1

Motivations et Définitions

Le développement des systèmes distribués à large échelle a démontré que la tolérance aux différents types de fautes doit être incluse dans les premières étapes du développement d'un tel système. L'auto-stabilisation permet de tolérer des fautes transitoires tandis que la tolérance aux fautes traditionnelle permet de masquer l'effet de fautes permanentes. Il est alors naturel de s'intéresser à des systèmes qui regrouperaient ces deux formes de tolérance. Cet article s'inscrit dans cette voie de recherche.

Auto-stabilisation

Dans cet article, nous considérons un système distribué asynchrone anonyme, i.e. un graphe non orienté connexe G où les sommets représentent les processus et les arêtes représentent les liens de communication. Deux processus u et v sont voisins si l'arête (u,v) existe dans G. Les variables d'un processus définissent son état. L'ensemble des états des processus du système à un instant donné forme la configuration du système. Nous souhaitons résoudre une classe particulière de problèmes sur ce système : les problèmes statiques (i.e. les probl�mes où le système doit atteindre un état donné et y rester). Par exemple, la construction d'arbre couvrant est un problème statique. De plus, nous consid�rons des problèmes pouvant être spécifiés de manière locale (i.e. il existe, pour chaque processus v, un prédicat spec(v) qui est vrai si et seulement si la configuration est conforme au problème). Les variables apparaissant dans spec(v) sont appelées variables de sortie ou S-variables.

Un système auto-stabilisant [\cite=D74] est un système atteignant en un temps fini une configuration légitime (i.e. spec(v) est vraie pour tout v) ind�pendament de la configuration initiale (propriété de convergence). Une fois cette configuration l�gitime atteinte, tout processus v vérifie spec(v) pour le restant de l'exécution et, dans le cas d'un problème statique, le système ne modifie plus ses S-variables (propriété de clôture). Par définition, un tel système peut tolérer un nombre arbitraire de fautes transitoires, i.e. de fautes de durée finie (la configuration initiale arbitraire modélisant le résultat de ces fautes). Cependant, la stabilisation du système n'est en g�n�ral garantie que si tous les processus exécutent correctement leur protocole.

Stabilisation stricte et forte

Si certains processus exhibent un comportement Byzantin (i.e. ont un comportement arbitraire, et donc potentiellement malicieux), ils peuvent perturber le système au point que certains processus corrects ne vérifient jamais spec(v). Pour gérer ce type de fautes, [\cite=NA02] définit un protocole strictement stabilisant comme un protocole auto-stabilisant tolérant des fautes Byzantines permanentes. Plus précisèment, étant donné c (appelé rayon de confinement), [\cite=NA02] d�finit une configuration c-confinée comme une configuration dans laquelle tout processus v à une distance supérieure à c de tout processus Byzantin vérifie spec(v). Un protocole strictement stabilisant est alors d�fini comme un protocole satisfaisant les propriétés de convergence et de clôture par rapport à l'ensemble des configurations c-confinées (et non plus l'ensemble des configurations légitimes comme en auto-stabilisation). Cela permet d'assurer que seuls les processus dans le c-voisinage (i.e. à distance inférieure ou égale à c) d'un processus Byzantin peuvent ne pas vérifier infiniment souvent la spécification. Cependant, [\cite=NA02] fournit une série de résultats d'impossibilité. Intuitivement, il n'existe pas de solution strictement stabilisante (pour tout rayon de confinement inférieur au diamètre) pour tout problème global (constructions d'arbre couvrant,...).

Pour contourner de tels résultats d'impossibilité, [\cite=MT06] définit un modèle de tolérance plus faible : la stabilisation forte. Intuitivement, il s'agit d'affaiblir les contraintes relatives au rayon de confinement. En effet, certains processus à l'extérieur de ce rayon sont autorisés à ne pas respecter la spécification en raison des Byzantins. Cependant, ces perturbations (i.e. périodes d'exécution durant laquelle des processus en dehors du rayon de confinement ne vérifient plus la spécification) sont limitées dans le temps : les processus ne peuvent être perturbés par les Byzantins qu'un nombre fini de fois et toujours pendant un temps limité même si les Byzantins agissent infiniment longtemps. La mesure d'efficacité principale de ce type de protocole est leur nombre de pertubations, i.e. le nombre maximal de perturbations possibles dans une exécution. Dans ce modèle de tolérance, nous avons montré [\cite=DMT10] qu'il est possible de résoudre le problème de construction d'arbre couvrant, ce qui illustre le fait que la stabilisation forte permet de résoudre plus de problèmes que la stabilisation stricte (en contrepartie, les propriétés assurées sont plus faibles).

Construction d'arbre couvrant en largeur

Dans cet article, nous nous int�ressons au problème de la construction d'arbre couvrant en largeur. Un processus du réseau est désigné a priori comme étant la racine (notée r) du système. Nous supposons que cette racine n'est jamais Byzantine. Une configuration satisfait la spécification du problème lorsqu'il existe un arbre couvrant le système enraciné en r vérifiant la propriété suivante : pour tout processus, la distance entre v et r dans l'arbre couvrant est égale � celle dans le système initial. Il s'agit d'un problème fondamental car il permet de mettre en œ uvre de nombreux protocoles de communication (par exemple, diffusion, routage par les plus courts chemins, etc.). Ce problème a été largement étudié dans le domaine de l'auto-stabilisation (voir par exemple [\cite=G03] [\cite=DT01]).

Lorsque le système contient des processus Byzantins, notons B l'ensemble de ces Byzantins. Dans ces conditions, il est impossible, pour un processus correct, de distinguer la racine réelle r d'un Byzantin se comportant comme une racine. Nous devons donc autoriser le système à construire une forêt couvrante du système (donc un ensemble d'arbres couvrant le système) dans laquelle chaque racine est soit r soit un Byzantin. Plus précisèment, chaque processus v a deux S-variables : un pointeur sur son parent Pv et une hauteur Hv. Un chemin [formula] (k  ≥  1) est un chemin correct s'il vérifie (i) [formula], Hv0 = 0 et [formula], (ii) [formula] et Hvi = Hvi - 1 + 1 et (iii) [formula]. Nous pouvons à présent donner la spécification locale de notre problème. [formula] Il est possible de remarquer que, dans le cas où aucun processus n'est Byzantin et où tout processus v vérifie spec(v), il existe un arbre couvrant du système au sens "classique". Cette spécification implique le théorème d'impossibilité suivant :

Il n'existe pas de solution strictement stabilisante ou fortement stabilisante pour la construction d'arbre en largeur pour tout rayon de confinement et tout nombre de perturbations.

L'impossibilité de la stabilisation stricte est dûe à [\cite=NA02] tandis que celle de la stabilisation forte provient du fait que tout processus Byzantin peut perturber infiniment souvent la moitié des processus sur le chemin qui le sépare de la racine (rendant donc impossible la majoration de cette distance par une constante).

Stabilisation stricte et forte topologiquement dépendante

Afin de contourner les résultats d'impossibilité du Théorème 1, nous introduisons ici une nouvelle idée dans le domaine de l'auto-stabilisation confinant les fautes permanentes. Nous relâchons la contrainte sur le rayon de confinement. Pour cela, nous assurons que l'ensemble des processus infiniment souvent perturbés par les Byzantins n'est plus l'union des c-voisinages des processus Byzantins mais un ensemble de processus d�pendant du graphe de communication et de la position des processus Byzantins. C'est pourquoi nous avons nomm� ce concept stabilisation stricte (respectivement forte) topologiquement dépendante (abrégé TD dans la suite). Pour en donner une définition formelle (dans le cas des problèmes statiques), nous devons introduire quelques définitions.

Nous prenons comme modèle de calcul le modèle à états : Les variables des processus sont partagées : chaque processus a un accès direct en lecture aux variables de ses voisins. En une étape atomique, chaque processus peut lire son état et ceux de ses voisins et modifier son propre état. Un protocole est constitué d'un ensemble de règles de la forme < garde >   →   < action > . La garde est un prédicat sur l'état du processus et de ses voisins tandis que l'action est une séquence d'instructions modifiant l'état du processus. A chaque étape, chaque processus évalue ses gardes. Il est dit activable si l'une d'elles est vraie. Il est alors autorisé à exécuter son action correspondante (en cas d'exécution simultannée, tous les processeurs activés prennent en compte l'état du système du début de l'étape). Les exécutions du système (séquences d'étapes) sont gérées par un ordonnanceur : à chaque étape, il sélectionne au moins un processus activable pour que celui-ci exécute sa règle. Cet ordonnanceur permet de modéliser l'asynchronisme du système. La seule hypothèse que nous faisons sur l'ordonnancement est qu'il est fortement équitable, i.e. qu'aucun processus ne peut être infiniment souvent activable sans être choisi par l'ordonnanceur (cette hypothèse est nécessaire pour borner le nombre de perturbations de notre protocole). Nous considérons un ensemble SB de processus corrects déterminé par l'ensemble B des processus Byzantins et la topologie du système. Intuitivement, SB regroupe les processus qui peuvent être infiniment souvent pertubés par les processus Byzantins. Il est appelé zone de confinement. Nous introduisons ici quelques notations. Un processus correct est SB-correct s'il n'appartient pas à SB. Une configuration est SB-légitime pour spec si tout processus SB-correct v vérifie spec(v). Une configuration est SB-stable si tout processus SB-correct ne modifie pas ses S-variables tant que les Byzantins n'effectuent aucune action. A présent, nous définissons la stabilisation stricte (respectivement forte) topologiquement dépendante (Définition 2, respectivement Définition 5).

Une configuration ρ est (SB,f)-TD contenue pour spec si, étant donné au plus f Byzantins, toute exécution issue de ρ ne contient que des configurations SB-légitimes et que tout processus SB-correct ne modifie pas ses S-variables.

Un protocole est (SB,f)-TD strictement stabilisant pour spec si, étant donné au plus f Byzantins, toute exécution (issue d'une configuration arbitraire) contient une configuration (SB,f)-TD contenue pour spec.

Une portion d'exécution [formula] (t > 1) est une SB-TD perturbation si : (1) e est finie, (2) e contient au moins une action d'un processus SB-correct modifiant une S-variable, (3) ρ0 est SB-légitime pour spec et SB-stable, et (4) ρt est la premi�re configuration SB-légitime pour spec et SB-stable après ρ0.

Une configuration ρ0 est (t,k,SB,f)-TD temporellement contenue pour spec si, étant donné au plus f Byzantins : (1) ρ0 est SB-légitime pour spec et SB-stable, (2) toute exécution issue de ρ0 contient une configuration SB-légitime pour spec après laquelle les S-variables de tout processus SB-correct ne sont pas modifiées (même si les Byzantins exécutent une infinité d'actions), (3) toute exécution issue de ρ0 contient au plus t SB-TD perturbations, et (4) toute exécution issue de ρ0 contient au plus k modifications des S-variables de chaque processus SB-correct.

Un protocole P est (t,SB,f)-TD fortement stabilisant pour spec si, étant donné au plus f Byzantins, toute exécution (issue d'une configuration arbitraire) contient une configuration (t,k,SB,f)-TD temporellement contenue pour spec.

Par définition, un protocole TD strictement stabilisant (respectivement TD fortement stabilisant) est plus faible qu'un protocole strictement stabilisant (respectivement fortement stabilisant). Cependant, il est plus puissant qu'un protocole auto-stabilisant (qui peut ne jamais stabiliser en présence de Byzantins).

Construction d'Arbre Couvrant en Largeur

Zones de confinement optimales

Nous définissons les zones de confinement suivantes : SB  =  {v∈V|min{d(v,b)|b∈B}  ≤  d(r,v)} et S*B  =  {v∈V|min{d(v,b)|b∈B}  <  d(r,v)}. Intuitivement, SB regroupe l'ensemble des processus situ�s plus pr�s (ou à égale distance) du plus proche des Byzantins que de la racine tandis que S*B regroupe l'ensemble des processus situ�s strictement plus pr�s du plus proche des Byzantins que de la racine. Il est alors possible de prouver le résultat suivant.

Il n'existe pas de protocole (AB,1)-TD strictement stabilisant ou (t,A*B,1)-TD fortement stabilisant pour la construction d'arbre en largeur avec [formula] et [formula] (pour tout t).

Solution optimale

Il existe un protocole auto-stabilisant simple pour construire un arbre couvrant en largeur (voir [\cite=G03] [\cite=DT01]). Celui-ci est connu sous le nom de min + 1 en raison de sa règle principale. Tout processus (différent de la racine) teste si la hauteur de son père actuel est minimale parmi celles de ses voisins et si sa hauteur et �gale à celle de son père plus un. Si ce n'est pas le cas, le processus est alors activable pour choisir comme père son voisin ayant la hauteur minimale (règle min ) et calculer sa nouvelle hauteur en fonction (règle + 1). L'algorithme [formula] présenté en Algorithme 1 suit ce principe à l'exception suivante près : si plusieurs voisins présentent une hauteur minimale, alors le processus choisi le plus petit qui est supérieur au père actuel (selon un ordre circulaire défini sur les voisins).

Il est alors possible de montrer que l'ensemble des processus strictement plus près de la racine que d'un processus Byzantin agiront exactement comme si aucun Byzantin n'était présent (étant donné qu'ils sont suffisament proches de la racine pour que sa hauteur soit considérée comme minimale). Il est également possible de montrer que les processus à égale distance de la racine et d'un processus Byzantin peuvent être perturbés par les processus Byzantins. En revanche, nous pouvons borner ce nombre de perturbations. En d'autres termes, nous obtenons le résultat suivant :

[formula] est un protocole (SB,n - 1)-TD strictement stabilisant et (nΔ,S*B,n - 1)-TD fortement stabilisant pour spec (avec n nombre de processus et Δ degré maximal du système).

Conclusion

Dans cet article, nous nous sommes intéressés aux protocoles auto-stabilisants confinant de plus l'effet de fautes Byzantines permanentes. Nous avons montré que le protocole min + 1 connu pour construire un arbre couvrant en largeur de manière auto-stabilisante fournit de plus un confinement Byzantin optimal. L'ensemble de ces résultats ont été publiés dans [\cite=DMT10a].

En utilisant les résultats de [\cite=DT01] sur les r-opérateurs, nous pouvons facilement étendre les résultats obtenus à d'autres métriques. Il est alors naturel de se demander si ce nouveau concept de confinement Byzantin topologiquement dépendant peut être étendu � d'autres problèmes, statiques ou non.