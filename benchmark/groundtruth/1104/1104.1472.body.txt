Gaussian Affine Feature Detector

Introduction

Detecting two dimension signals is more difficult than one dimension ones and many heuristic algorithms are proposed to deal with it. However, following appearance of scale space theory [\cite=IEEEhowto:SS] [\cite=IEEEhowto:koe84], many effective feature detectors come into being [\cite=IEEEhowto:Lin].

Originally, scale space theory is proposed by physicists, and developed by computer scientists. It is studied thoroughly from view point of vision and mathematics, and a consistent way to find new detector had been built [\cite=IEEEhowto:Romeny]. Many successful feature detectors are built upon scale space, including [\cite=IEEEhowto:lowe04] [\cite=IEEEhowto:lowe99].

An additional dimension is introduced in scale space, namely scale dimension. In order to get image's information, such as affine shape parameters, some methods [\cite=IEEEhowto:compare_feat] [\cite=IEEEhowto:Eval_Feat] [\cite=IEEEhowto:Mikolajczyk_IJCV] iteratively search in scale dimension. They are based on fix point theory: they will finally get a solution if there is one. In practice, however, these methods have several drawbacks, including,

waste lots of candidate features;

very slow;

get abundant duplicated or false features.

To overcome these drawbacks, we propose a new method based on analytic solution. It achieves or outperforms iterative methods with much less computation resources.

Some feature detectors [\cite=IEEEhowto:MSer] [\cite=IEEEhowto:ibr_ebr] are ideal for noise free images, but are incapable of blurred or noisy images. The proposed detector is more robust with similar performance.

Features' position, orientation, background luminance, contrast, area and aspect ratio can also be extracted from images. Until recently, information such as background luminance contrast are not commonly used in feature extraction. Others including area, orientation and aspect ratio are studied extensively, but with a limited accuracy.

In this paper, a feature model is proposed, and the above mentioned parameters will be calculated.

Gaussian Affine Shape

In this section, firstly a feature model is proposed, and then analytic result is derived based on the model to get various parameters.

Feature Model

From a view point of systematology, images, feature extractor and features correspond to input, system, and output. We need build a system that can transform input to output. In another words, image is system input and feature parameters are output. In order to study behavior of the system, we need define input signals. As it is not possible to build an all-purpose feature extractor, we will concentrate on some specific image signals. Since (two dimensional) Gaussian has nice analytic properties and simple form, it is chosen as input signal. As to be shown later, Gaussian based model will filter out high frequency signal, hence ideal for noisy images.

Based on above mentioned idea, image surface is modeled as Gaussian function, as shown in Fig. [\ref=fig:gaussIn]. In this way, image feature parameters are related to Gaussian parameters, including orientation, long and short radii, baseline height and contrast. Traditionally, baseline height and contrast are not considered in feature extraction, they are included for completeness. The signal can be defined as Equ. [\ref=equ:gaussIn]. Parameters and model variables are listed in Tab. [\ref=tab:model_factor].

[formula]

Before continuing, it is helpful to clarify a fact, that is, rotating an image will not affect our discussion. This fact greatly simplifies our deduction. It is proved in Appendix. [\ref=proof].

Known the fact, two-dimensional axis-aligned Gaussian will be used as input signal, as shown in Equ. [\ref=equ:sigin]. For this function, we need get value of α, β, c and d.

[formula]

Feature Detection

Before computing parameters, we need detect feature's position. There exists many feature detectors, we need choose the one that has good performance and solid mathematical foundation. It will be chosen from rotation invariant differential operator family. As defined in Equ. [\ref=equ:LoG], LoG detector is a good candidate, it is very stable, has fast implementation, and is Gaussian based. The last one is the most important reason, because input signal is also a Gaussian, and they may have close relation.

[formula]

[formula]

Using Equ. [\ref=equ:laplacelr], which is based on Equ. [\ref=equ:convlrd], we can define LoG operation on image function, as shown in Equ. [\ref=equ:lagconv].

[formula]

[formula]

As shown in Equ. [\ref=equ:convGI], convolving I with G is another Gaussian, which is called (Gaussian) scale space. For zero shifted I, its Laplacian will get extreme at origin. Normalizing this value will get normalized Laplacian of Gaussian operation upon I, which is basis of some feature extractors.

[formula]

Applying LoG to image to get extreme points, and with information provided by G * I, we need get radii (standard deviations) of original input (Gaussian) function I.

Parameters Calculation

As shown before, image I can be considered as a surface in three-dimensional space. From differential geometry, we know its hessian matrix directly relates to principal curvatures and principal directions, and for Gaussian function, principal curvatures connect with its standard deviations. In one word, eigenvalues of hessian matrix relate to radii and eigenvectors relate to directions. We also know that two principal directions are perpendicular to one another. Based on these facts, we will derive formulas for parameters.

Obviously, convolving I with isotropic Gaussian will not change principal direction. For extreme point, we can use G * I's principal direction as I's principal direction. For the case of axis-aligned Gaussian, we already know principal directions, otherwise, compute eigenvectors.

Remaining question is, giving information of G * I , how to get I's radii α and β, its contrast c and baseline height d.

Here, we will exploit a fact, that LoG can detect Gaussian at one and only one scale. In another word, every α and β pair must produce one and only one σ, as shown in Equ. [\ref=equ:constrain]. If analytic form of f is determined, we can recover α and β from σ.

[formula]

For any input image, [formula] is fixed. LoG will detect extreme point in a fixed scale σ. Let us denote [formula], and [formula].

Apply normalized LoG operator to I, and substitute β  =  αk and α  =  σh, and let x = 0, y = 0, we get Equ. [\ref=equ:LoGMax].

[formula]

Let c be constance 1 and draw this expression in Fig. [\ref=fig:ridge]. It is clearly shown that for k > 1, extreme of LoG * I is located on a smooth ridge.

For a fixed k, at extreme point, the formula's one order derivative will be zero. After some calculation, we can get Equ. [\ref=equ:LoGMaxDeriv].

[formula]

To solve this equation, let k2 = K and h2 = H, and we get two order equation Equ. [\ref=equ:twoorderequ].

[formula]

It is easy to solve, as Equ. [\ref=equ:sol].

[formula]

Known constraint of K and H, we need more information to get their values. As mentioned above, eigenvalues of hessian matrix relate to radii closely. We calculate hessian matrix over scale space, as shown in Equ. [\ref=equ:hessscale].

[formula]

As before, we calculate eigenvalues of this matrix, and let x = 0, y = 0. Since our discuss based Gaussian, we can get analytic solution of two eigenvalues, shown in Equ. [\ref=equ:eig].

[formula]

These two eigenvalues have complicated form, but their ratio is simpler, shown in Equ. [\ref=equ:eigratio].

[formula]

From Equ. [\ref=equ:eigratio], we can solve for K, shown in Equ. [\ref=equ:KR].

[formula]

Combined Equ. [\ref=equ:sol] and Equ. [\ref=equ:KR], we can solve for H, result is Equ. [\ref=equ:Hres].

[formula]

We draw this relation in Fig. [\ref=fig:Hr], which shows detecting scale tends to be constancy as shape gets elongate. Simply put, elongating a shape contributes little to its detecting scale.

Got H, k, h, α and β will be solved directly.

c and d can also be solved in analytic form. Equ. [\ref=equ:LoGMax] is used to get c. Because d is constant component of scale space, it will disappear by differential operation; therefore can only be solved in scale space itself. Let x = 0 and y = 0 in G * I, we will get Equ. [\ref=equ:scalemax], so d can be solved upon extreme point of scale space.

[formula]

Until now, we have calculated all parameters of the zero shifted and axis aligned Gaussian. Because axis can be shifted or rotated, our discussion will be applied to Gaussian of any position or rotation. We will summary the steps of our algorithm.

Detect extreme point in normalized LoG space, and get its σ.

compute hessian matrix of extreme point in corresponding scale space

compute eigenvectors as principal directions of the point.

compute eigenvalues, let absolute larger one divide smaller one, and represented as r

use Equ. [\ref=equ:Hres] to compute H, Equ. [\ref=equ:KR] to compute K, and use [formula] to compute other parameters, use Equ. [\ref=equ:LoGMax] and Equ. [\ref=equ:scalemax] to solve for contrast and baseline height.

Data Transformation

Until now, signal's radii and angle are extracted. In order to comparing with other methods' results, we depend on some publicly available tools. Therefore radii and angle need to be transformed to a common form, such as symmetric positive definite matrix, as shown in Equ. [\ref=equ:symmat].

[formula]

If let θ be signal's orientation, and t  =   arctan (θ), in a similar way as before, we get Equ. [\ref=equ:xyzs].

[formula]

Implementation Details

In this section, some important implementation details are outlined.

Approximation and Adjustment

As shown in Equ. [\ref=equ:lowequ], LoG can be implemented by DoG, and together with pyramid algorithm, which makes proposed method ready for application. We use similar DoG pyramid as Lowe's. Extremum of DoG should be adjusted by a constant multiplier, for its value is used to compute c and d.

[formula]

Removal of False Features

Tested with synthesized data, we found one common problem among several (affine) feature detectors, that is, for a single Gaussian signal, often there are several features detected out. Some of them have similar radii and orientations, located around true position, as shown in Fig. [\ref=fig:compare_circle] and Fig. [\ref=fig:noise_localvar]. Others are false features arisen from noise, as shown in Fig. [\ref=fig:noise_localvar] and Fig. [\ref=fig:compare_dist_noisy].

In practice, we found a large part of false features coming from sampling and digitization process, that is to say, they are small sized, low contrast features. True features seldom have such properties. Therefore features with small value of c, α and β are considered as noises.

Detector Threshold

Like SIFT, we uses ratio of principal curvatures (ratio of hessian's eigenvalues, or r in our method) to remove points on valley or ridge. To accept more features, the ratio needs to be refined. Combining Equ. [\ref=equ:Hres] and Equ. [\ref=equ:KR], with K  =  k2, we have Equ. [\ref=equ:kr-relation].

[formula]

We have drawn relation of k and r in Fig. [\ref=fig:kr-relation]. For aspect ratio k to be as high as 40, r need at least to be 535 theoretically. The r in Equ. [\ref=equ:throsh] is threshold of features.

[formula]

Experiments

In order to evaluate performance of our method, we firstly test it with synthesized data. In this way, we will know true parameters and therefor can compare them with calculated ones. We will compare results of our method and others, including Harris-Affine, Hessian-Affine and Mser. Only common parameters such as orientation, long and short scale can be compared, because contrast and base height are unique provided by our method. Nevertheless, we will show the results alone.

Gaussian will be used as test image. Image size is 256x256, and gray scale level is 256. Our method can detect a large range of parameters, and Tab. [\ref=tab:param] lists parameters used in experiments.

Results of ideal signals

As demostrated in Fig. [\ref=fig:compare_circle], Hessian-Affine and Harris-Affine tend to detect duplicated features. Fig. [\ref=fig:compare_dist] and Fig. [\ref=fig:aspect_ratio_nonoise] show, for noise free Gaussian signal, Mser has highest accuracy for detecting position and aspect ratio. Our method achieves similar results as MSer. Compared with Harris-Affine, Hessian-Affine gets better results. Both Mser and our method can detect signals of high aspect ratio, but Hessian-Affine and Harris-Affine are limited to low aspect ratio signals.

Our method is to compute original parameters from blurred output image. For very long and thin shapes, our method may slightly underestimate true aspect ratio, as shown in Fig .[\ref=fig:aspect_ratio_nonoise].

As shown in Fig. [\ref=fig:compare_short_scale], our method and Mser achieve highest accuracy for detecting short radii. However, in addition to true signals, Mser often finds small concentric signals.

In conclusion, for ideal noise free Gaussian, Mser get best results, and ours is similar to that of Mser. Hessian-Affine and Harris-Affine are not as stable as Mser and ours.

Results of noisy signals

Fig. [\ref=fig:noise_localvar] is a typical noisy image, and Mser is the most sensitive to noise. Even a small amount of noise can impact Mser seriously. Fig. [\ref=fig:compare_dist_noisy] is distance of true and detected points. It is difficult for Mser to differentiate noises from true signals. Therefore we only compare Hessian-Affine, Harris-Affine and ours for noisy images.

As shown in Fig. [\ref=fig:compare_dist_noisy], Fig. [\ref=fig:aspect_ratio_noisy], Fig. [\ref=fig:aspect_ratio_noisy], our method performs well when other methods reach their limits.

Using Mikolajczyk's evaluation images and toolbox, we get repeatability in Fig. [\ref=fig:rep]. For these noisy free images, Mser get highest accuracy, and Hessian-Affine, Harris-Affine and our methods have similar results. Our 1 and 2 are results of different thresholds.

Fig. [\ref=fig:compare_wall] is detecting results of graffiti under different view angle. Compared with Hessian-Affine and Harris-Affine, Mser and ours detect fewer features. It seems that the former two detect many redundant features. Compared with ours, Mser tends to detect many small features.

Conclusion

In this paper, we have proposed a new feature detector. Compared with other methods, it is very stable, accurate and quick. Tested with Gaussian, for ideal noisy free signal, our method produces one of the best results, and for noisy signal, it outperforms others significantly. The proposed method can also extracts parameters unavailable for other methods, such as contrast and baseline height.

Test with benchmark images, the method get similar repeatability as Harris-Affine and Hessian-Affine.

Proof of Rotation Invariant for Image Surface

Let F be Fourier operator, and f be an input function; Fourier transform is shown in Equ. [\ref=equ:fourtran].

[formula]

If input function rotates in x space, and let , its Fourier transform will also rotate same angle, as shown in Equ. [\ref=equ:fourtranrot].

[formula]

Convolution in space domain can be implemented by multiplication in ξ domain, as shown in Equ. [\ref=equ:convfour].

[formula]

[formula]

Using Equ. [\ref=equ:fourtran], Equ. [\ref=equ:fourtranrot] and Equ. [\ref=equ:convfour], we can get Equ. [\ref=equ:convfourrot]. It means if input and system are rotated with same angle, the output will also rotate the same angle. In one word, output's geometrical property will not change on rotating input and system.

Acknowledgments

Acknowledgment

The authors would like to thank PhD. Andrea Vedaldi for his excellent open sourced code, and professor Bart ter Haar Romeny for his free distributed electronic book.