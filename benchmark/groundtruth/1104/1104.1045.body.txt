Main Theorem Lemma Proposition Corollary Fact Question Problem Conjecture Example

Definition Notation Remark

Tractable Set Constraints

École Polytechnique, LIX (UMR 7161 du CNRS), 91128 Palaiseau, France Martin Hils Institut de Mathématiques de Jussieu (UMR 7586 du CNRS), Université Paris Diderot Paris 7, UFR de Mathématiques, 75205 Paris Cedex 13, France

An extended abstract of the content of this article appeared in the proceedings of IJCAI'11 [\cite=BodHilsKrim].

Introduction

Constraint satisfaction problems are computational problems where, informally, the input consists of a finite set of variables and a finite set of constraints imposed on those variables; the task is to decide whether there is an assignment of values to the variables such that all the constraints are simultaneously satisfied. Set constraint satisfaction problems are special constraint satisfaction problems where the values are sets, and the constraints might, for instance, force that one set y includes another set x, or that one set x is disjoint to another set y. The constraints might also be ternary, such as the constraint that the intersection of two sets x and y is contained in z, in symbols [formula].

To systematically study the computational complexity of constraint satisfaction problems, it has turned out to be a fruitful approach to consider constraint satisfaction problems [formula] where the set of allowed constraints is formed from a fixed set Γ of relations R  ⊆  Dk over a common domain D. This way of parametrizing the constraint satisfaction problem by a constraint language Γ has led to many strong algorithmic results [\cite=Maltsev] [\cite=IMMVW] [\cite=BoundedWidth] [\cite=BodirskyKutzAI] [\cite=tcsps-journal], and to many powerful hardness conditions for large classes of constraint satisfaction problems [\cite=Schaefer] [\cite=JBK] [\cite=conservative] [\cite=Bulatov] [\cite=tcsps-journal].

A set constraint language Γ is a set of relations [formula] where the common domain [formula] is the set of all subsets of the natural numbers; moreover, we require that each relation R can be defined by a Boolean combination of equations over the signature [formula], [formula], c, [formula], and [formula], which are function symbols for intersection, union, complementation, the empty and full set, respectively. Details of the formal definition and many examples of set constraint languages can be found in Section [\ref=sect:setcsps]. The choice of [formula] is just for notational convenience; as we will see, we could have selected any infinite set for our purposes. In the following, a set constraint satisfaction problem (set CSP) is a problem of the form [formula] for a set constraint language Γ. It has been shown by Marriott and Odersky [\cite=MarriottOdersky] that all set CSPs are contained in NP; they also showed that the largest set constraint language, which consists of all relations that can be defined as described above, has an NP-hard set CSP.

Drakengren and Jonsson [\cite=DrakengrenJonssonSets] initiated the search for set CSPs that can be solved in polynomial time. They showed that [formula] can be solved in polynomial time, where

x  ⊆  y holds iff x is a subset of or equal to y;

[formula] holds iff x and y are disjoint sets; and

x  ≠  y holds iff x and y are distinct sets.

They also showed that [formula] can be solved in polynomial time if all relations in Γ can be defined by formulas of the form

[formula]

or of the form

[formula]

where [formula] are not necessarily distinct variables. We will call the set of all relations that can be defined in this way Drakengren and Jonsson's set constraint language. It is easy to see that the algorithm they present runs in time quadratic in the size of the input.

On the other hand, Drakengren and Jonsson [\cite=DrakengrenJonssonSets] show that if Γ contains the relations defined by formulas of the form

[formula]

the problem [formula] is NP-hard.

Contributions and Outline.

We present a significant extension of Drakengren and Jonsson's set constraint language (Section [\ref=sect:setcsps]) whose CSP can still be solved in quadratic time in the input size (Section [\ref=sect:algorithm]); we call this set constraint language [formula]. Unlike Drakengren and Jonsson's set constraint language, our language also contains the ternary relation defined by [formula], which is a relation that is of particular interest in description logics - we will discuss this below. Moreover, we show that any further extension of [formula] contains a finite sublanguage with an NP-hard set CSP (Section [\ref=sect:maximal]), using concepts from model theory and universal algebra. In this sense, we present a maximal tractable class of set constraint satisfaction problems.

Our algorithm is based on the concept of independence in constraint languages which was discovered several times independently in the 90's [\cite=Koubarakis] [\cite=JonssonBaeckstroem] [\cite=MarriottOdersky] - see also [\cite=BroxvallJonssonRenz] [\cite=Disj]; however, we apply this concept twice in a novel, nested way, which leads to a two level resolution procedure that can be implemented to run in quadratic time. The technique we use to prove the correctness of the algorithm is also an important contribution of our paper, and we believe that a similar approach can be applied in many other contexts; our technique is inspired by the already mentioned connection to universal algebra.

Application Areas and Related Literature

Set Constraints for Programming Languages.

Set constraints find applications in program analysis; here, a set constraint is of the form X  ⊆  Y, where X and Y are set expressions. Examples of set expressions are [formula] (denoting the empty set), set-valued variables, and union and intersection of sets, but also expressions of the form f(Z1,Z2) where f is a function symbol and Z1,Z2 are again set expressions. Unfortunately, the worst-case complexity of most of the reasoning tasks considered in this setting is very high, often EXPTIME-hard; see [\cite=Aiken94] for a survey. More recently, it has been shown that the quantifier-free combination of set constraints (without function symbols) and cardinality constraints (quantifier-free Pressburger arithmetic) has a satisfiability problem in NP [\cite=KuncakRinard]. This logic (called QFBAPA) is interesting for program verification [\cite=KuncakNguyenRinard].

Tractable Description Logics.

Description logics are a family of knowledge representation formalisms that can be used to formalize and reason with concept definitions. The computational complexity of most of the computational tasks that have been studied for the various formalisms is usually quite high. However, in the last years a series of description logics (for example [formula], +  +, Horn-FL0, and various extensions and fragments [\cite=KuestersMolitor] [\cite=BaaderEL] [\cite=BaaderBrandtLutz] [\cite=KroetzschRudolphHitzler]) has been discovered where crucial tasks such as e.g.  entailment, concept satisfiability and knowledge base satisfiability can be decided in polynomial time.

Two of the basic assertions that can be made in +  + and Horn-FL0 are C1||C2 (there is no C1 that is also C2) and [formula] (every C1 that is C2 is also C3), for concept names C1,C2,C3. These are [formula] set constraints, and the latter has not been treated in the framework of Drakengren and Jonsson. None of the description logics with a tractable knowledge base satisfiability problem contains all [formula] set constraints.

Spatial Reasoning.

Several spatial reasoning formalisms (like RCC-5 and RCC-8) are closely related to set constraint satisfaction problems. These formalisms allow to reason about relations between regions; in the fundamental formalism RCC-5 (see e.g. [\cite=RCC5JD]), one can think of a region as a non-empty set, and possible (binary) relationships are containment, disjointness, equality, overlap, and disjunctive combinations thereof. Thus, the exclusion of the empty set is the most prominent difference between the set constraint languages studied by Drakengren and Jonsson in [\cite=DrakengrenJonssonSets] (which are contained in the class of set constraint languages considered here), and RCC-5 and its fragments.

Constraint Satisfaction Problems

To use existing terminology in logic and model theory, it will be convenient to formalize constraint languages as (relational) structures (see e.g. [\cite=HodgesLong]). A structure Γ is a tuple [formula] where D is a set (the domain of Γ), each fΓi is a function from Dki  →  D (where ki is called the arity of fΓi), and each RΓi is a relation over D, i.e., a subset of Dli (where li is called the arity of RΓi). For each function fΓi we assume that there is a function symbol which we denote by fi, and for each relation RΓi we have a relation symbol which we denote by Ri. Constant symbols will be treated as 0-ary function symbols. The set τ of all relation and function symbols for some structure Γ is called the signature of Γ, and we also say that Γ is a τ-structure. If the signature of Γ only contains relation symbols and no function symbols, we also say that Γ is a relational structure. In the context of constraint satisfaction, relational structures Γ are also called constraint languages, and a constraint language Γ' is called a sublanguage (or reduct) of a constraint language Γ if the relations in Γ' are a subset of the relations in Γ (and Γ is called an expansion of Γ').

Let Γ be a relational structure with domain D and a finite signature τ. The constraint satisfaction problem for Γ is the following computational problem, also denoted by [formula]: given a finite set of variables V and a conjunction Φ of atomic formulas of the form [formula], where [formula] and R∈τ, does there exists an assignment s:V  →  D such that for every constraint [formula] in the input we have that [formula]?

The mapping s is also called a solution to the instance Φ of [formula], and the conjuncts of Φ are called constraints. Note that we only introduce constraint satisfaction problems [formula] for finite constraint languages, i.e., relational structures Γ with a finite relational signature.

Set Constraint Languages

In this section, we give formal definitions of set constraint languages. Let [formula] be the structure with domain [formula], the set of all subsets of natural numbers, and with signature [formula], where

[formula] is a binary function symbol that denotes intersection, i.e., [formula];

[formula] is a binary function symbol for union, i.e., [formula];

c is a unary function symbol for complementation, i.e., [formula] is the function that maps [formula] to [formula];

[formula] and [formula] are constants (treated as 0-ary function symbols) denoting the empty set [formula] and the full set [formula], respectively.

Sometimes, we simply write [formula] for the function [formula] and [formula] for the function [formula], i.e., we do not distinguish between a function symbol and the respective function. We use the symbols [formula] and not the symbols [formula] to prevent confusion with meta-mathematical usages of [formula] and [formula] in the text.

A set constraint language is a relational structure with a set of relations with a quantifier-free first-order definition in [formula]. We always allow equality in first-order formulas, and the equality symbol =   is always interpreted to be the true equality relation on the domain of the structure.

The ternary relation [formula] has the quantifier-free first-order definition [formula] over [formula].

Let Γ be a set constraint language with a finite signature. Then [formula] is in NP.

It is well-known that the structure [formula] is a Boolean algebra, with

[formula] playing the role of false, and [formula] playing the role of true;

c playing the role of [formula];

[formula] and [formula] playing the role of [formula] and [formula], respectively.

To not confuse logical connectives with the connectives of Boolean algebras, we always use the symbols [formula], [formula], and c instead of the usual function symbols [formula], [formula], and [formula] in Boolean algebras. To facilitate the notation, we also write x̄ instead of c(x), and x  ≠  y instead of [formula].

We assume that all terms t over the functional signature [formula] are written in (inner) conjunctive normal form (CNF), i.e., as [formula] where lij is either of the form x̄ or of the form x for a variable x (every term over [formula] can be re-written into an equivalent term of this form, using the usual laws of Boolean algebras [\cite=Boole]). We allow the special case n = 0 (in which case t becomes [formula]), and the special case ni = 0 (in which case [formula] becomes [formula]). We refer to ci: = {lij  |  1  ≤  j  ≤  ni} as an (inner) clause of t, and to lij as an (inner) literal of ci. We say that a set of inner clauses is satisfiable if there exists an assignment from [formula] such that for all inner clauses, the union of the evaluation of all literals equals [formula] (this is the case if and only if the formula [formula] has a satisfying assignment).

We assume that all quantifier-free first-order formulas φ over the signature [formula] are written in (outer) conjunctive normal form (CNF), i.e., as [formula] where Lij is either of the form [formula] (a positive (outer) literal) or of the form [formula] (a negative (outer) literal). Again, it is well-known and easy to see that we can for every quantifier-free formula find a formula in this form which is equivalent to it in every Boolean algebra. We refer to Ci: = {Lij  |  1  ≤  j  ≤  mi} as an (outer) clause of φ, and to Lij as an (outer) literal of Ci. Whenever convenient, we identify φ with its set of clauses.

EI Set Constraints

To define [formula] set constraints, we need to introduce a series of important functions defined on the set of subsets of natural numbers.

Let

[formula] be the function that maps (S1,S2) to the set [formula];

F be the function that maps [formula] to the set of finite non-empty subsets of S;

[formula] be a bijection between [formula] and the set of finite non-empty subsets of [formula] (since both sets are countable, such a bijection exists);

[formula] be defined by

[formula]

ei be the function defined by ei(x,y)  ↦  e(i(x,y)).

Let [formula] be a function, and [formula] be a relation. Then we say that f preserves R if the following holds: for all [formula] we have that [formula] if ai∈R for all i  ≤  k. If f does not preserve R, we also say that f violates R. We say that f strongly preserves R if for all [formula] we have that [formula] if and only if ai∈R for all i  ≤  k. If φ is a first-order formula that defines a relation R over [formula], and f preserves (strongly preserves) R, then we also say that f preserves (strongly preserves) φ. Finally, if [formula] is a function, we say that f preserves (strongly preserves) g if it preserves (strongly preserves) the graph of g, i.e., the relation [formula].

Note that if an injective function f preserves a function g, then it must also strongly preserve g.

The set of all relations with a quantifier-free first-order definition over [formula] that are preserved by the operation ei is denoted by [formula].

Remark. We will see later (Proposition [\ref=prop:e-atomless-correct] and Proposition [\ref=prop:ei-atomless-correct]) that the class [formula] is independent from the precise choice of the operations e and i.

Proposition [\ref=prop:syntax] shows that [formula] has a large subclass, called Horn-Horn, which has an intuitive syntactic description. In Section [\ref=sect:horn-horn] we also present many examples of relations that are from [formula] and of relations that are not from [formula]. Before, we will establish some properties of the functions i and e.

The mapping i is an isomorphism between [formula] and [formula].

The mapping i can be inverted by the mapping that sends [formula] to [formula]. It is straightforward to verify that i strongly preserves [formula], [formula], c, [formula], [formula].

We write [formula] as an abbreviation for [formula].

The function e has the following properties.

e is injective,

e strongly preserves [formula], [formula], and [formula], and

for [formula] such that [formula], not [formula], and not [formula], we have that [formula].

We verify the properties one by one. Since G is bijective, e(x) = e(y) if and only if x and y have the same finite subsets. This is the case if and only if x = y, and hence e is injective. Thus, to prove that e strongly preserves [formula], [formula], and [formula], it suffices to check that e preserves [formula], [formula], and [formula].

Since G is bijective, we have that [formula] equals the set of all finite subsets of [formula], and hence [formula], which shows that e preserves [formula]. We also compute [formula].

Next, we verify that for all [formula] we have [formula]. Let [formula] be arbitrary. We have [formula] if and only if [formula]. By definition of F and since G(a) is a finite subset of [formula], this is the case if and only if [formula]. This is the case if and only if [formula], which concludes the proof that e preserves [formula].

We verify that if [formula], not [formula], and not [formula], then [formula]. First observe that for all [formula] with [formula] we have [formula] since e preserves [formula]. This implies that [formula]. Since [formula] and [formula], there are a,b such that a∈x, a∉y, b∈y, b∉x. Then we have that {a,b}∈F(z), but [formula]. Hence, G- 1({a,b})∈e(z), but [formula]. This shows that [formula].

Note that in particular e preserves [formula], [formula], and ||. Moreover, [formula]: this follows from preservation of ||, since x||c(x), and therefore e(x)||e(c(x)), which is equivalent to the inclusion above. Both e and i strongly preserve [formula], [formula], and [formula], and therefore also ei strongly preserves [formula], [formula], and [formula].

Horn-Horn Set Constraints

A large and important subclass of EI set constraints is the class of Horn-Horn set constraints.

A quantifier-free first-order formula is called Horn-Horn if

every outer clause is outer Horn, i.e., contains at most one positive outer literal, and

every inner clause of positive outer literals is inner Horn, i.e., contains at most one positive inner literal.

A relation [formula] is called

outer Horn if it can be defined over [formula] by a conjunction of outer Horn clauses;

inner Horn if it can be defined over [formula] by a formula of the form [formula] where each ci is inner Horn;

Horn-Horn if it can be defined by a Horn-Horn formula over [formula].

The following is a direct consequence of the fact that isomorphisms between Γk and Γ preserve Horn formulas over Γ; since the simple proof is instructive for what follows, we give it here for the special case that is relevant here.

Outer Horn relations are preserved by i.

Let φ be a conjunction of outer Horn clauses with variables V. Let [formula] be an outer clause of φ. Let [formula] be two assignments that satisfy this clause. Let [formula] be given by x  ↦  i(u(x),v(x)). Suppose that w satisfies [formula] for all 1  ≤  j  ≤  k. Since i is injective we must have that tj  =   for both u and v for 1  ≤  j  ≤  k, and therefore neither assignment satisfies the negative literals. Hence, u and v must satisfy [formula]. Since i is an isomorphism between [formula] and [formula], it preserves in particular [formula], and hence w also satisfies [formula].

Inner Horn relations are strongly preserved by e.

Observe that [formula] is equivalent to [formula], which is strongly preserved by e since e strongly preserves [formula]. This clearly implies the statement.

Note that Fact [\ref=fact:outer-horn] and Proposition [\ref=prop:inner-horn] imply that ei strongly preserves inner Horn relations. We later also need the following.

Let [formula], where [formula]. Then the following are equivalent.

[formula].

there exists an i  ≤  k such that [formula].

there exists an i  ≤  k such that [formula].

For k = 0, we have that [formula] if and only if [formula].

For the implication from (1) to (2), suppose that there is for every i  ≤  k an [formula] such that [formula]. Let c be [formula]. Then for each i  ≤  k, we have that [formula]. To see this, first observe that [formula]. Therefore, [formula] for all i  ≤  k. We conclude that [formula].

The implication (2)  ⇒  (3) follows directly from Proposition [\ref=prop:inner-horn]. The implication (3)  ⇒  (1) is trivial. The second statement is a direct consequence of Proposition [\ref=prop:inner-horn].

Every Horn-Horn relation is preserved by e and i; in particular, it is from EI.

Suppose that R has a Horn-Horn definition φ over [formula] with variables V. Since R is in particular outer Horn, it is preserved by i by Fact [\ref=fact:outer-horn].

Now we verify that R is preserved by e. Let [formula] be an assignment that satisfies φ. That is, u satisfies at least one literal in each outer clause of φ. It suffices to show that the assignment [formula] defined by x  ↦  e(u(x)) satisfies the same outer literal. Suppose first that the outer literal is positive; because φ is Horn-Horn, it is of the form [formula] or of the form [formula], which is preserved by e by Lemma [\ref=lem:e].

Now, suppose that the outer literal is negative, that is, of the form [formula] for some k  ≥  0. We will treat the case k  ≥  1, the other case being similar. Suppose for contradiction that [formula]. By Lemma [\ref=lem:e], there exists an i  ≤  k such that [formula]. But then we have in particular that [formula], in contradiction to the assumption that u satisfies φ.

Examples.

The disjointness relation || is Horn-Horn: it has the definition [formula].

The inequality relation ≠   is inner Horn: it has the definition [formula].

Using the previous example, the relation [formula] can easily be seen to be Horn-Horn.

The ternary relation [formula], which we have encountered above, has the Horn-Horn definition [formula].

Examples of relations that are clearly not Horn-Horn: [formula] is violated by e, and [formula] is violated by i.

The formula

[formula]

is clearly not Horn-Horn. However, the relation defined by the formula is from EI: if (x1,y1,u1,u2) und (x2,y2,u2,v2) are from that relation, then neither [formula] nor [formula]. By Proposition [\ref=prop:nat-core], (ei(x1,x2),ei(y1,y1),ei(u1,u2),ei(v1,v2)) satisfies the formula.

There is no equivalent Horn-Horn formula, since the formula is not preserved by i.

The formula [formula] is not Horn-Horn. However, it is preserved by e and by i: the reason is that one of its clauses has the negative literal [formula], and the conjuncts [formula] and [formula]. Therefore, for every tuple t∈R the tuple e(t) satisfies [formula] and is in R as well. By Fact [\ref=fact:outer-horn], R is preserved by i.

In this case, the authors suspect that there is no equivalent Horn-Horn formula. More generally, it is an open problem whether there exist formulas that are preserved by e and i, but that are not equivalent to a Horn-Horn formula.

Drakengren and Jonsson's set constraint language only contains Horn-Horn relations.

For inclusion x  ⊆  y, disjointness ||, and inequality ≠   this has been discussed in the examples. Horn-Horn is preserved under adding additional outer disequality literals to the outer clauses, so all relations considered in Drakengren and Jonsson's language are Horn-Horn.

We prepare now some results that can be viewed as a partial converse of Proposition [\ref=prop:syntax].

A quantifier-free first-order formula φ (in the syntactic form described at the end of Section [\ref=sect:setcsps]) is called reduced if if every formula obtained from φ by removing an outer literal is not equivalent to φ over [formula].

Every quantifier-free formula is over [formula] equivalent to a reduced formula.

It is clear that every quantifier-free formula can be written as a formula φ in CNF and in the form as we have discussed it after Theorem [\ref=thm:np]. We now remove successively outer literals as long as this results in an equivalent formula.

We first prove the converse of Fact [\ref=fact:outer-horn].

Let φ be a reduced formula that is preserved by i. Then each outer clause of φ is Horn.

Let V be the set of variables of φ. Assume for contradiction that φ contains an outer clause with two positive literals, [formula] and [formula]. If we remove the literal [formula] from its clause C, the resulting formula is inequivalent to φ, and hence there is an assignment [formula] that satisfies none of the literals of C except for [formula]. Similarly, there is an assignment [formula] that satisfies none of the literals of C except for [formula]. By injectivity of i, and since i strongly preserves [formula], and [formula], the assignment [formula] defined by x  ↦  i(s1(x),s2(x)) does not satisfy the two literals [formula] and [formula]. Since i strongly preserves c, [formula], [formula], none of the other literals in C is satisfied by those mappings as well, in contradiction to the assumption that φ is preserved by i.

Let V be a set of variables, and [formula] be a mapping. Then a function from [formula] of the form x  ↦  e(s(x)) is called a core assignment.

For every quantifier-free formula φ there exists a formula ψ such that all inner clauses are inner Horn, and such that φ and ψ have the same satisfying core assignments. If φ is preserved by ei, then the set of all satisfying core assignments of ψ is closed under ei.

Suppose that φ has an outer clause C with a positive outer literal [formula] such that t contains an inner clause [formula] that is not Horn, i.e., k  ≥  2. Then we replace the outer literal [formula] in φ by k literals [formula] where ti is obtained from t by replacing c by [formula].

We claim that the resulting formula φ' has the same set of satisfying core assignments. Observe that [formula], and hence [formula] implies [formula]. An arbitrary satisfying assignment of φ' satisfies either one of the positive outer literals [formula], in which case that observation shows that it also satisfies φ, or it satisfies one of the other outer literals of C, in which case it also satisfies this literal in φ. Hence, φ' implies φ. Conversely, let s be a satisfying core assignment of φ. If s satisfies a literal from C other than [formula], then it also satisfies this literal in φ', and s satisfies φ'. Otherwise, s must satisfy [formula], and hence [formula]. Since s is a core assignment, Lemma [\ref=lem:e] implies that there exists an i  ≤  k such that [formula]. So s satisfies φ'.

Suppose that φ has an outer clause C with a negative outer literal [formula] such that t contains an inner clause [formula] that is not Horn, i.e., k  ≥  2. Then we replace the clause C in φ by k clauses C1, , Ck where Ck is obtained from C by replacing c with [formula].

We claim that the resulting formula φ' has the same set of satisfying core assignments. Observe that [formula] implies that [formula], for every i  ≤  k. The observation shows that an arbitrary assignment of φ is also an assignment of φ'. Conversely, let s be a satisfying core assignment of φ'. If s satisfies one of the other literals of C other than [formula], then s satisfies φ. Otherwise, s must satisfy [formula] for all i  ≤  k, and by Lemma [\ref=lem:e] we have that s also satisfies [formula].

We perform these replacements until we obtain a formula φ' where all inner clauses are Horn; this formula satisfies the requirements of the first statement of the lemma.

To prove the second statement, let [formula] be two satisfying core assignments of φ'. Since φ' and φ have the same satisfying core assignments, u and v also satisfy φ. Then the mapping [formula] given by x  ↦  ei(u(x),v(x)) is a core assignment, and because ei preserves φ, the mapping w satisfies φ. Since φ and φ' have the same core assignments, w is also a satisfying assignment of φ', which proves the statement.

A quantifier-free first-order formula φ (in the syntactic form described at the end of Section [\ref=sect:setcsps]) is called strongly reduced if every formula obtained from φ by removing an outer literal does not have the same set of satisfying core assignments over [formula].

Let φ be a strongly reduced formula all of whose inner clauses are Horn. If the set of satisfying core assignments of φ is closed under ei, then φ is Horn-Horn.

Let V be the set of variables of φ. It suffices to show that all clauses of φ are outer Horn. Assume for contradiction that φ contains an outer clause with two positive literals, [formula] and [formula]. If we remove the literal [formula] from its clause C, the resulting formula has strictly less satisfying core assignments; this shows the existence of a core assignment [formula] that satisfies none of the literals of C except for [formula]. Similarly, there exists a core assignment [formula] that satisfies none of the literals of C except for [formula]. By assumption, the inner clauses of t1 and t2 are Horn. We claim that the assignment [formula] defined by x  ↦  ei(s1(x),s2(x)) does not satisfy the clause C. Since ei strongly preserves inner Horn clauses, we have that s does not satisfy [formula]. For the same reasons s does not satisfy any other literals in C; this contradicts the assumption that the satisfying core assignments for φ are preserved by ei.

Let Γ be a finite set constraint language from EI. Then [formula] can be reduced in linear time to the problem to find a satisfying assignment for a given set of Horn-Horn clauses.

Let Φ be an instance of [formula], and let V be the set of variables that appear in Φ. For each constraint [formula] from Φ, let φR be the definition of R over [formula]. By Lemma [\ref=lem:strongly-reduced], there exists a formula ψR that has the same satisfying core assignments as φR and where all inner clauses are Horn; moreover, since φR is preserved by ei, the lemma asserts that the set of all satisfying core assignments of ψR is preserved by ei. We can assume without loss of generality that ψR is strongly reduced; this can be seen similarly to Lemma [\ref=lem:reduced]. By Proposition [\ref=prop:core-horn-horn], the formula ψR is Horn-Horn.

Let Ψ be the set of all Horn-Horn clauses of formulas [formula] obtained from constraints [formula] in Φ in the described manner. We claim that Φ is a satisfiable instance of [formula] if and only if Ψ is satisfiable. This follows from the fact that for each constraint [formula] in Φ, the formulas φR and ψR have the same satisfying core assignments, and that both φR and ψR are preserved by ei (for ψR this follows from Proposition [\ref=prop:syntax]), so in particular by the function x  ↦  ei(x,x).

Note that in Proposition [\ref=prop:core-reduction] we reduce satisfiability for EI to satisfiability for a proper subclass of Horn-Horn set constraints: while for general Horn-Horn set constraints we allow that inner clauses of negative outer literals are not Horn, the reduction only produces Horn-Horn clauses where all inner clauses are Horn.

Algorithm for Horn-Horn Set Constraints

We present an algorithm that takes as input a set Φ of Horn-Horn clauses and decides satisfiability of Φ over [formula] in time quadratic to the length of the input. By Proposition [\ref=prop:core-reduction], this section will therefore conclude the proof that [formula] is tractable when all relations in Γ are from EI.

We first discuss an important sub-routine of our algorithm, which we call the inner resolution algorithm. As in the case of Boolean positive unit resolution [\cite=horn-linear] one can implement the procedure Inner-Res such that it runs in linear time in the input size.

Let Φ be a finite set of inner Horn clauses. Then the following are equivalent.

[formula] is satisfiable over [formula].

Inner-Res(Φ) from Figure [\ref=fig:inner] accepts.

[formula] has a solution whose image is contained in [formula].

It is obvious that [formula] is unsatisfiable when Inner-Res(Φ) rejects; in fact, for all inner clauses c derived by Inner-Res from Φ, the formula [formula] is logically implied by [formula]. Conversely, if the algorithm accepts then we can set all eliminated variables to [formula] and all remaining variables to [formula], which satisfies all clauses: in the removed clauses the positive literal is satisfied, and in the remaining clauses we have at least one negative literal at the final stage of the algorithm, and all clauses with negative literals at the final stage of the algorithm are satisfied.

The proof of the previous lemma shows that [formula] is satisfiable over [formula] if and only if [formula] is satisfiable over the two-element Boolean algebra. As we will see in the following, this holds more generally (and not only for inner Horn clauses). The following should be well-known, and can be shown with the same proof as given in [\cite=KoppelbergBoolenAlgebras] for the weaker Proposition 2.19 there. We repeat the proof here for the convenience of the reader (for definitions of the notions appearing in the proof, however, we refer to [\cite=KoppelbergBoolenAlgebras]).

Let t1,t2 be terms over [formula]. Then the following are equivalent:

[formula] is satisfiable over the two-element Boolean algebra;

[formula] is satisfiable over all Boolean algebras;

[formula] is satisfiable in a Boolean algebra.

Obviously, 1 implies 2, and 2 implies 3. For 3 implies 1, assume that [formula] has a satisfying assignment in some Boolean algebra [formula]. Let c be the element denoted by t2 in [formula] under this assignment. It is well-known that every element [formula] of a Boolean algebra is contained in an ultrafilter (see e.g. Corollary 2.17 in [\cite=KoppelbergBoolenAlgebras]). So let U be an ultrafilter of [formula] that contains [formula], and let [formula] be the characteristic function of U. Then f is a homomorphism from [formula] to the two-element Boolean algebra that maps c to [formula]; thus [formula] is satisfiable over [formula].

The same statement for [formula] instead of [formula] is Proposition 2.19. in [\cite=KoppelbergBoolenAlgebras]. Fact [\ref=fact:ba] has the following consequence that is crucial for the way how we use the inner resolution procedure in our algorithm.

Let Ψ be a finite set of inner Horn clauses. Then Inner-Res[formula] rejects if and only if [formula] implies that [formula] over [formula].

[formula] implies that [formula] if and only if [formula] is unsatisfiable over [formula]. By Fact [\ref=fact:ba], this is the case if and only if [formula] is unsatisfiable over the 2-element Boolean algebra, which is the case if and only if [formula] is unsatisfiable over the two-element Boolean algebra. As we have seen in Lemma [\ref=lem:pre-inner-res], this is turn holds if and only if Inner-Res[formula] rejects.

The algorithm 'Outer-Res' in Figure [\ref=fig:outer] decides satisfiability for sets of Horn-Horn clauses in quadratic time.

We first argue that if the algorithm rejects Φ, then Φ has indeed no solution. First note that during the whole argument, the set of clauses Φ has the same satisfying tuples (i.e. the corresponding formulas are equivalent): Observe that only negative literals get removed from clauses, and that a negative literal [formula] only gets removed from a clause when Inner-Res rejects [formula] for each inner clause [formula] of t. By Lemma [\ref=lem:inner-res], if Inner-Res rejects [formula] then Ψ implies that [formula]. Hence, the positive unit clauses imply that [formula] and therefore the literal [formula] can be removed from the clause without changing the set of satisfying tuples. Now the algorithm rejects if either Inner-Res rejects Ψ or if it derives the empty clause. In both cases it is clear that Φ is not satisfiable.

Thus, it suffices to construct a solution when the algorithm accepts. Let Ψ be the set of all inner clauses of terms from positive unit clauses at the final stage, when the algorithm accepts. For each remaining negative outer literal [formula] and each remaining inner clause [formula] of t there exists an assignment αD from [formula] that satisfies [formula]: otherwise, by Lemma [\ref=lem:inner-res], the inner resolution algorithm would have rejected [formula], and would have removed the inner clause D from t. Let [formula] be an enumeration of all remaining inner clauses D that appear in all remaining negative outer literals.

Write is for the s-ary operation defined by [formula] (where i is as in Fact [\ref=fact:nat-iso]). We claim that [formula] given by

[formula]

satisfies all clauses in Φ. Let C be a clause from Φ. By assumption, at the final stage of the algorithm, the clause C is still non-empty. Also note that since all formulas in the input were Horn-Horn, they contain at most one positive literal. This holds in particular for C, and we therefore only have to distinguish the following cases:

At the final state of the algorithm, C still contains a negative literal [formula]. Since [formula] has not been removed, there must be a remaining inner clause [formula] of t. Observe that [formula] if and only if [formula] for all 1  ≤  j  ≤  s. Hence, and since [formula], s satisfies [formula]. This shows that s satisfies C.

All negative literals have been removed from C during the algorithm. The positive literal [formula] of C is such that the inner clauses of t0 are Horn. They will be part of Ψ, and therefore [formula] is satisfied by s. Indeed, by assumption the assignments αDj satisfy Ψ, and Ψ is preserved by i.

We conclude that s is a solution to Φ. The inner resolution algorithm has a linear time complexity; the outer resolution algorithm performs at most a linear number of calls to the inner resolution algorithm, and it is straightforward to implement all necessary data structures for outer resolution to obtain a running time that is quadratic in the input size.

Combining Proposition [\ref=prop:core-reduction] with Theorem [\ref=thm:outer-res], we obtain the following.

Let Γ be a finite set constraint language from EI. Then [formula] can be solved in quadratic time.

Maximality

In this section we show that the class EI is a maximal tractable set constraint language. More specifically, let Γ be a set constraint language that strictly contains all EI relations. We then show that Γ contains a finite set of relations Γ' such that already the problem [formula] is NP-hard (Theorem [\ref=thm:set-maximal]).

In our proof we use the so-called universal-algebraic approach to the complexity of constraint satisfaction problems, which requires that we re-formulate set CSPs as constraint satisfaction problems for ω-categorical structures. For a more detailed introduction to the universal-algebraic approach for ω-categorical structures, see [\cite=Bodirsky-HDR]. A structure Γ with a countable domain is called ω-categorical if all countable structures that satisfy the same first-order sentences as Γ are isomorphic to Γ (see e.g. [\cite=HodgesLong]). By the theorem of Ryll-Nardzewski, and for countable signatures, this is equivalent to requiring that every relation that is preserved by the automorphisms of Γ is first-order definable in Γ (see e.g. [\cite=HodgesLong]). The set of all automorphisms of Γ is denoted by [formula].

It is well-known that all countable atomless Boolean algebras are isomorphic (Corollary 5.16 in [\cite=KoppelbergBoolenAlgebras]; also see Example 4 on page 100 in [\cite=HodgesLong]); let [formula] denote such a countable atomless Boolean algebra. Let [formula] denote the domain of [formula]. Again, we use [formula] and [formula] to denote join and meet in [formula], respectively. Since the axioms of Boolean algebras and the property of not having atoms can all be written as first-order sentences, it follows that [formula] is ω-categorical. A structure [formula] has quantifier elimination if every first-order formula is over [formula] equivalent to a quantifier-free formula. It is well-known that [formula] has quantifier elimination (see Exercise 17 on Page 391 in [\cite=HodgesLong]). We will also make use of the following.

A quantifier-free formula is satisfiable in some infinite Boolean algebra if and only if it is satisfiable in all infinite Boolean algebras.

A fundamental concept in the complexity theory of constraint satisfaction problems is the notion of primitive positive definitions. A first-order formula is called primitive positive (pp) if it is of the form

[formula]

where for each i  ≤  m the formula ψi is of the form [formula] or of the form y1  =  y2, and where R is a relation symbol and [formula] are either free variables or from [formula]. We say that a k-ary relation R  ⊆  Dk is primitive positive definable (pp definable) over a τ-structure Γ with domain D iff there exists a primitive positive formula [formula] with the k free variables [formula] such that a tuple [formula] is in R if and only if [formula] is true in Γ.

Example. The relation [formula] is pp definable in [formula] where [formula]. The pp definition is [formula] (the definition is even quantifier-free).

Example. The relation [formula] is pp definable in [formula] where [formula]. The pp definition is [formula].

When every relation of a structure Γ is preserved by an operation f, then f is called a polymorphism of Γ. Note that polymorphisms of Γ also preserve all relations that have a pp definition in Γ. The following has been shown for finite domain constraint satisfaction in [\cite=JBK]; the easy proof also works for infinite domain constraint satisfaction.

Let R be a relation with a primitive positive definition in a structure Γ. Then [formula] and the CSP for the expansion of Γ by the relation R are polynomial-time equivalent.

The following theorem is one of the reasons why it is useful to work with ω-categorical templates (when this is possible).

Let Γ be an ω-categorical structure. Then R is primitive positive definable in Γ if and only if R is preserved by all polymorphisms of Γ.

The previous and the next result together can be used to translate questions about primitive positive definability into purely operational questions. Let D be a set, let O(n) be Dn  →  D, and let O be [formula] the set of operations on D of finite arity. An operation π∈O(n) is called a projection if for some fixed [formula] and for all n-tuples [formula] we have the identity [formula]. The composition of a k-ary operation f and k operations [formula] of arity n is the n-ary operation defined by

[formula]

We say that F  ⊆  O locally generates f:Dn  →  D if for every finite subset A of Dn there is an operation g:Dn  →  D that can be obtained from the operations in F and projection maps by composition such that f(a) = g(a) for all a∈A.

Let F  ⊆  O be a set of operations with domain D. Then an operation f:Dk  →  D preserves all finitary relations that are preserved by all operations in F if and only if F locally generates f.

In the following, we always consider sets of operations F that contain [formula], and therefore make the following convention. For F  ⊆  O, we say that F generates f∈O if [formula] locally generates f. We now define analogs of the operations e and i, defined on [formula] instead of [formula].

There is an isomorphism ĩ between [formula] and [formula].

It is straightforward to verify that [formula] is again a countable atomless Boolean algebra.

Motivated by the properties of e described in Lemma [\ref=lem:e], we make the following definition.

Let [formula] and [formula] be two arbitrary Boolean algebras with domains B and B', respectively, and let g:B  →  B' be a function that strongly preserves [formula], [formula], and [formula]. We say that g forgets unions if for all k  ≥  1, l  ≥  0, and [formula] we have

[formula]

if and only if there exists an i  ≤  k such that [formula].

There exists an injection [formula] that strongly preserves [formula], [formula], and [formula] in [formula], and that forgets unions.

The construction of ẽ is by a standard application of König's tree lemma for ω-categorical structures (see e.g. [\cite=Bodirsky-HDR]); it suffices to show that there is an injection f from every finite induced substructure [formula] of [formula] to [formula] such that f strongly preserves [formula], [formula], and [formula], and forgets unions.

So let [formula] be such a finite substructure of [formula], and let B be the domain of [formula]. Let [formula] be the Boolean algebra of the subsets of B. We claim that g:B  →  P(B) given by [formula] and [formula] for [formula]

preserves [formula] and [formula]: this is by definition;

preserves [formula]: for x,y∈B (including the case that [formula] or [formula]) we have

[formula]

is injective: if x,y∈B such that g(x) = g(y), then [formula] and [formula], and hence x = y;

strongly preserves [formula]: this follows from the previous two items;

forgets unions: This can be shown analogously to the proof of Lemma [\ref=lem:e].

Clearly, there is an embedding h from [formula] into [formula]. Then f: = h(g) is a homomorphism from [formula] to [formula] that forgets unions.

Let φ be a quantifier-free first-order formula over the signature [formula]. Then e preserves φ over [formula] if and only if ẽ preserves φ over [formula]. Moreover, every operation from [formula] that strongly preserves [formula], [formula], and [formula] and forgets unions generates ẽ, and is generated by ẽ.

Let ā be a tuple of elements from [formula]. Clearly, there exists a tuple [formula] of elements from [formula] such that ā and [formula] satisfy the same set ψ of quantifier-free first-order formulas; this follows from the fact that every finite Boolean algebra is the Boolean algebra of subsets of a finite set. Now observe that whether or not the tuple e() satisfies a quantifier-free first-order formula φ only depends on ψ, by Lemma [\ref=lem:e]. Since ẽ strongly preserves [formula], [formula], and [formula], and forgets unions, the same is true for the quantifier-free first-order formulas that hold on ẽ(ā). Hence, ẽ preserves φ over [formula] if and only if e preserves φ over [formula].

To prove the second part of the statement, we use Theorem [\ref=thm:loc-clos]. Suppose that [formula] and [formula] are tuples of elements from [formula] that satisfy the same quantifier-free first-order formulas. By the equivalent characterization of ω-categoricity mentioned above, and the fact that [formula] has quantifier-elimination, there exists an automorphism α of [formula] that maps [formula] to [formula]. By the above observations and Theorem [\ref=thm:loc-clos], this implies that all operations that strongly preserve [formula], [formula], and [formula], and forget unions generate each other.

Let [formula] be the operation (x,y)  ↦  ẽ(ĩ(x,y)). The following can be shown similarly to Proposition [\ref=prop:e-atomless-correct].

Let φ be a quantifier-free first-order formula over the signature [formula]. Then ei preserves φ over [formula] if and only if [formula] preserves φ over [formula]. Moreover, every binary operation g that strongly preserves [formula], [formula], and [formula], and forgets unions generates [formula], and is generated by [formula].

We now give the central argument for the maximal tractability of EI, stated in universal-algebraic language. We say that an operation from [formula] depends on the argument [formula] if there is no (k  -  1)-ary operation f' such that for all [formula]

[formula]

We can equivalently characterize k-ary operations that depend on the i-th argument by requiring that there are [formula] and [formula] such that

[formula]

Let f be an operation generated by [formula]. Then either {f} generates [formula], or f is generated by {ẽ}.

To show the statement of the theorem, let f be a k-ary operation generated by [formula]. For the sake of notation, let [formula] be the arguments on which f depends, for l  ≤  k. Let [formula] be the operation given by [formula]. Clearly, f' must be injective (since it is generated from an injective operation and depends on all arguments). Since f' is generated by [formula] it preserves [formula], [formula], [formula], and since f' is injective, it also strongly preserves those functions.

Consider first the case that l = 1, i.e., f' is unary. If for all finite subsets of [formula], the operation f' equals an automorphism of [formula], then f is generated by [formula] and there is nothing to show. So assume otherwise; that is, assume that there is a finite set [formula] such that there is no [formula] with f'(x)  =  a(x) for all x∈S. We claim that f' forgets unions. To see this, let [formula] be from [formula] such that [formula]. Since f' is generated by {}, there is a term composed from automorphisms of [formula] and [formula] such that f'(x)  =  T(x) for all [formula]. By the choice of S, this term cannot be composed of automorphisms alone, and hence there must be [formula] and operational terms T1,T2 composed from automorphisms of [formula] and [formula] such that [formula] for all x∈S. As [formula] forgets unions, there exists an i  ≤  k such that [formula]. Since T1 strongly preserves [formula] we conclude that there exists an i such that [formula] (see the proof of Proposition [\ref=prop:inner-horn]), which is what we wanted to show. By Proposition [\ref=prop:e-atomless-correct] it follows that f' is generated by ẽ. But then f is generated by ẽ as well.

Next, consider the case that l > 1. Let g be the binary operation defined by [formula]; since f' is injective, the operation g will also be injective, and in particular depends on both arguments, and strongly preserves [formula], [formula], and [formula]. We claim that g forgets unions. Let [formula] be from [formula] such that [formula]. Since g is generated by [formula] and cannot be generated by the automorphisms of [formula] alone, there is a term of the form [formula] where

[formula],

T1 and T2 are operational terms composed from automorphisms of [formula] and [formula],

g(x,y)  =  T(x,y) for all [formula].

Since [formula] forgets unions, there exists an i  ≤  k such that [formula] and [formula]. Suppose first that T1 depends on both arguments. Then T1 defines an injective operation and strongly preserves [formula]. It follows that [formula] in [formula] since these equations are inner Horn. We can argue similarly if T2 depends on both arguments, and in those cases we have established that g forgets unions. Suppose now that each of T1 and T2 does not depend on both arguments. Consider first the case that T1 only depends on the first argument. Then the function x  ↦  T1(x,x) is injective and strongly preserves [formula], and from [formula] we derive as above that [formula] holds in [formula]. In this case, T2 must depend on the second argument, since T depends on both arguments. We therefore also have that [formula] holds in [formula]. The situation that T1 only depends on the second argument and T2 only depends on the first argument is analogous. So g forgets unions. By Proposition [\ref=prop:ei-atomless-correct], g generates [formula]. Consequently, also f generates [formula].

Let [formula] be the following relations

[formula]

Note that both U and I are preserved by ĩ. The following demonstrates that when Γ has the polymorphism ĩ, this does not suffice for tractability of [formula].

Let Γ be the structure with domain [formula] and three relations U, I, and ≠  . Then [formula] is NP-hard.

The proof is by reduction from 3SAT. We compute from a given 3SAT instance Φ with variable set V an instance Ψ of [formula] (in polynomial time) as follows. There are distinguished variables t and f in Ψ. For each variable x of Φ there are two variables xt and xf in Ψ. For a clause C: = {l1,l2,l3} of Φ (with literals li either of the form x or of the form [formula]) we create a fresh variable uC, and add the constraints U(v1,v2,uC) and U(uC,v3,t) where vi: = xf if [formula], and vi: = xt if li  =  x. Moreover, we add for each variable x∈V the constraints U(xt,xf,t) and I(xt,xf,f). Finally, add the constraint t  ≠  f and I(t,f,f).

It is clear that if Φ has the satisfying assignment α:V  →  {0,1} then the following assignment β satisfies all constraints in Ψ. Choose [formula] arbitrarily. Then β maps t to St and f to Sf, it maps xt∈V to St if α(x)  =  1 and to Sf otherwise, it maps xf∈V to Sf if α(x)  =  1 and to St otherwise, and for every clause C = {l1,l2,l3} of Φ it maps uC to St if α(l1) = 1 or α(l2) = 1, and to Sf otherwise.

Conversely, suppose that β maps the variables of Ψ to the elements of Γ satisfying all constraints of Ψ. Let [formula] be the finite Boolean algebra that is generated by β(V) in Γ. Since [formula], we have that β(t) is non-empty. Select an arbitrary atom a of [formula] that is contained in β(t). Then we set α(x) for x∈V to 1 if a  ⊆  β(xt) and to 0 otherwise. In this way all clauses {l1,l2,l3} of Φ are satisfied. To see this, assume for simplicity of presentation that [formula] is negative and l2  =  y and l3  =  z are positive; the general case is analogous. Since we have the constraints U(xf,yt,uC) and U(uC,zt,t), and since a is an atom of [formula], one of β(xf),β(yt),β(zt) must contain a. If a is in β(yt) or β(zt) then α(y) or α(z) is set to 1. If a is in β(xf), then the clause I(xt,xf,f) forces that a is not in β(xt), and hence α(x) is set to 0. Thus, α sets at least one of [formula] to 1, and the clause C is satisfied.

Let Γ be a set constraint language. Suppose that Γ contains all relations from EI, and also contains a relation that is not from EI. Then there is a finite sublanguage Γ' of Γ such that [formula] is NP-hard.

When [formula] are the relations of Γ, let [formula] be quantifier-free first-order formulas that define [formula] over [formula]. Let [formula] be the relations defined by [formula] over [formula], and let Δ be the relational structure with domain [formula] and exactly those relations. By Proposition [\ref=prop:ei-atomless-correct], Δ contains a relation that is not preserved by [formula], and contains all relations that are preserved by [formula]. Consider the set F of all polymorphisms of Δ.

The set F does not contain [formula], since this would contradict by Theorem [\ref=thm:loc-clos] the fact that Δ contains a relation that is not preserved by [formula]. Since F is locally closed, it follows from Theorem [\ref=thm:minimal] that all operations f∈F are generated by ẽ. But then the relation [formula] is preserved by all operations in F, and hence pp definable in Γ by Theorem [\ref=thm:pp-pres]. This relation has an NP-complete CSP [\cite=ecsps]. Let Δ' be the reduct of Δ that contains exactly the relations that appear in those pp definitions. Clearly, there are finitely many such relations; we denote the corresponding relation symbols by τ'  ⊂  τ. By Lemma [\ref=lem:pp-reduce], [formula] is NP-hard.

This establishes also the hardness of [formula]: let Γ' be the τ'-reduct of Γ. We claim that [formula] and [formula] are the same computational problem. We have to show that a conjunction of atomic τ'-formulas Φ is satisfiable in Γ' if and only if it is true in Δ'. Replacing each atomic τ'-formula in Φ by its quantifier-free first-order definition, this follows from Theorem [\ref=thm:mo].

Concluding Remarks

We have introduced the powerful set constraint language of EI set constraints, which in particular contains all Horn-Horn set constraints and all previously studied tractable set constraint languages. Constraint satisfaction problems over EI can be solved in polynomial - even quadratic - time. Our tractability result is complemented by a complexity result which shows that tractability of EI set constraints is best-possible within a large class of set constraint languages.

It is not hard to see from the properties we prove for EI set constraints that there is an algorithm to test whether a given finite set constraint language (where relations in the language are given by quantifier-free formulas over the signature [formula]) is contained in EI. This means that the so-called meta-problem for EI set constraints can be decided effectively.

We would also like to remark that one can analogously obtain tractability for the class of constraints where the inner clauses of the positive outer literals are dual Horn (i.e., have at most one negative literal).

Acknowledgements

We want to thank Franois Bossière who pointed out mistakes in the conference version of the paper.