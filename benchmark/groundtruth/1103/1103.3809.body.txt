= 5mu plus 1mu minus 2mu

=9000 =9999

A new approach to nonrepetitive sequences

Introduction

A repetition of size h in a sequence S is a subsequence of consecutive terms of S consisting of two identical blocks [formula]. A sequence is nonrepetitive if it does not contain a repetition of any size [formula]. For instance, the sequence 1232312 contains a repetition 2323 of size two, while 123132123 is nonrepetitive.

It is easy to see that each binary sequence of length at least four contains a repetition. In 1906 Thue [\cite=Thu06] proved that 3 symbols are sufficient to produce arbitrarily long nonrepetitive sequences (see [\cite=Ber95]). His method is constructive and uses substitutions over a given set of symbols. For instance, the substitution

[formula]

preserves the property of nonrepetitiveness on the set of finite sequences over {1,2,3}. This means that replacing all symbols in a nonrepetitive sequence by the assigned blocks results in a sequence that still does not contain repetitions. Sequences generated by substitutions have found many unexpected applications in such diverse areas as group theory, universal algebra, number theory, ergodic theory, and formal language theory. The work of Thue inspired a stream of research leading to emergence of new branches of mathematics with a variety of challenging open problems (see [\cite=AS03] [\cite=BEM79] [\cite=Cur05] [\cite=Gry08] [\cite=Lot83]).

In this paper we present a different approach to creating long nonrepetitive sequences. Consider the following naive procedure: generate consecutive terms of a sequence by choosing symbols at random (uniformly and independently) and every time a repetition occurs, erase the repeated block and continue. For instance, if the generated sequence is 12323, we must cancel the last two symbols, which brings us back to 123.

We prove by a simple counting that with positive probability the length of a constructed sequence exceeds any finite bound, provided the number of symbols is at least 4. This is slightly weaker than Thue's result, but our argument remains valid in more general settings, in which the method of substitutions does not seem to work.

One particular example of such a setting is the list-version of nonrepetitive sequences - an analog of the classical graph choosability introduced by Vizing [\cite=Viz76] and independently by Erds, Rubin, and Taylor [\cite=ERT80]. Suppose we are given a collection of lists (sets of symbols) [formula]. A sequence [formula] is chosen from lists [formula] if si∈Li for all [formula]. The following list-version of Thue's theorem seems plausible.

For every [formula] and a sequence of sets [formula], each of size 3, there is a nonrepetitive sequence chosen from [formula].

Notice that the statement of the conjecture is not obvious, even for lists of any given size. However, a rather straightforward touch of the Lovász local lemma assures that the conjecture is true for sufficiently large lists (for a careful introduction to the local lemma and the probabilistic method in general we send the reader to [\cite=AS08]). In fact, the bound 64 comes as a special case of a result on nonrepetitive colorings of bounded degree graphs (Alon et al. [\cite=AGHR02]; see also [\cite=Gry07]). Recently Grytczuk, Przybył o and Zhu [\cite=GPZ] proved that lists of sizes at least 4 suffice. They achieve this almost tight bound applying an enhanced version of the local lemma due to Pegden [\cite=Peg11]. In Section [\ref=sec:list-Thue] we give a simple argument for the same bound.

This research would not emerge without a contribution of Moser on his way to an algorithmic proof of Lovász local lemma [\cite=MT10]: his entropy compression argument. This was widely discussed in the combinatorics community and we send the reader to great expositions of the topic by Tao [\cite=TaoBlog] and Fortnow [\cite=ForBlog].

In this paper we make use of the above-mentioned approach to games involving nonrepetitve sequences.

The nonrepetitive game over a symbol set S is played by two players in the following way. The players collectively build a sequence choosing from S, one by one, consecutive terms of the sequence. The first player, Ann, is trying to avoid repetitions, while the second player, Ben, does not necessarily cooperate. Of course, just by mimicking Ann's moves Ben can force a lot of repetitions of size 1. It turns out however that for large enough S he cannot force any larger repetition at all! Pegden [\cite=Peg11], using his extension of the Lovász local lemma, proved that Ann has a strategy in the nonrepetitive game to build an arbitrarily long sequence with no repetition of size greater than 1 over symbol set of size at least 37 (no matter how perfidiously Ben is playing). In this paper we prove (Theorem [\ref=thm:Pegdens-game]) that Ann can do the same on every set of symbols of size at least 6. On the other hand, Ben can easily force nontrivial repetitions in a game on just 3 symbols (see [\cite=Peg11]). Thus, the minimum size of a set of symbols required to ensure Ann's strategy is 4, 5 or 6.

The erase-repetition game over a set of symbols S is also a two-player game between Ann and Ben. As before they build a sequence picking symbols alternately from S and appending them to the end of the sequence built so far. But this time whenever a repetition occurs the second instance of the repeated block is immediately erased and the next player continues extending the remaining prefix of the sequence. We prove (Theorem [\ref=thm:erase-repetition-game]) that there is a strategy for Ann in this game to build an arbitrarily long nonrepetitive sequence over at least 8 symbols.

The paper is organized as follows. Section [\ref=sec:list-Thue] contains the generic argument proving that from any sequence of lists, each of size 4, one can choose a nonrepetitive sequence. Section [\ref=sec:preliminaries] introduce a bit of generating functions theory used in counting arguments. Sections [\ref=sec:erase-repetition-game] and [\ref=sec:nonrepetitive-game] are devoted to erase repetiton game and nonrepetitive game, respectively.

The algorithm

Consider the following randomized algorithm. The input is a sequence of lists [formula]. Random elements are chosen independently with uniform distribution.

The general idea is that if Algorithm [\ref=alg-choosing-from-lists] works long enough for all evaluations of the random experiments, then a lot of repetitions occur, based on which we can compress a random string to a better extent than is actually possible.

For every [formula] and a sequence of sets [formula], each of size 4, there is a nonrepetitive sequence chosen from [formula].

Suppose for a contradiction that it is not possible to choose a nonrepetitive sequence from [formula]. This means that Algorithm 1 does not terminate on this sequence. In the following, by the j-th step of the algorithm, we mean the j-th iteration of the while loop. Set M to be a sufficiently large integer. We are going to record, in two different ways, the possible scenarios of what algorithm does in the first M steps.

Order arbitrarily the elements of each Li. In each step the algorithm picks a random element from a list of size 4. Let rj ([formula]) be the position of the chosen element in the appropriate list. Clearly, [formula] is a sequence of random variables with 4M possible evaluations. When we fix evaluations of [formula] we make Algorithm [\ref=alg-choosing-from-lists] deterministic.

For fixed evaluations of [formula], let d1 = 1 and dj ([formula]) be the difference between the values of variable i after jth and (j - 1)th steps of the algorithm. The important properties are: A pair (D,S) is a log if there is an evaluation of [formula] such that D is the corresponding sequence of differences and S is the final sequence produced after M steps of the algorithm. The key point is that a log encodes all values of [formula] in a lossless fashion.

Every log corresponds to a unique evaluation of [formula].

Given a log [formula] with [formula] we are going to decode the evaluation of rM (the last random choice taken) and SM - 1 - the sequence constructed after M - 1 steps. Then by simple iteration one can extract all the remaining values of [formula].

If dM = 1 then, the element generated in the Mth step is appended to the end of SM. Thus the value of rM is simply the position of sl in Ll. Moreover, no repetition occurred after the Mth step and therefore [formula].

If [formula] then some symbols were erased after the Mth step. But, since we know the size of the repeated sequence, namely h = |dM| + 1, and only one part of it was erased, we can read and copy the appropriate block to restore the sequence before the erasure [formula]. Then we read the value of rM as a position of sl in Ll + h, and SM - 1 as [formula] (in case of h = 0 we put [formula]).

Let TM be the number of sequences [formula] satisfying [\ref=item-dj<=1], [\ref=item-sum-of-the-prefix>=1] and additionally [formula]. Such sequences are in close relation to plane trees, and are known to be enumerated by Catalan numbers, i.e., [formula]. Note that every feasible sequence of differences in a log has total sum less than n (as Algorithm [\ref=alg-choosing-from-lists] never terminates). The number of sequences satisfying [\ref=item-dj<=1], [\ref=item-sum-of-the-prefix>=1] but with total sum equal k (fixed [formula]) is at most TM. Thus, we conclude that the number of all feasible difference sequences of size M is at most n  ·  TM. Clearly, for every feasible sequence of differences D the number of sequences which can occur in log with D is at most 4n. Since the number of logs is exactly 4M we get

[formula]

which is a contadiction for large enough M. This means that the number of realizations which do not generate a nonrepetitive sequence of length n is smaller than the number of all realizations.

Preliminaries

We make some use of generating functions theory. We consider only algebraic functions. A generating function [formula] with positive radius of convergence is algebraic if there exists a nonconstant polynomial [formula] (defining polynomial) such that P(z,t(z)) is constantly zero within the disc of convergence of t(z). It is a well known fact that, if the radius of convergence of [formula] is strictly greater than α, then Tn  =  o(α- n). The following observation is fundamental in analysis of algebraic generating functions, the thorough study of which can be found in [\cite=FS09] (chapter VII.7).

The coefficients of the functions we use are nonnegative integers. In such cases it is easy to see that the radius of convergence is not greater than 1, whenever a function has infinite number of nonzero coefficients. In order to bound the growth of the sequence of coefficients of such a function, we calculate the discriminant of its defining polynomial P(z,t) with respect to the variable t, and look for its positive real root in the interval (0,1]. If there is only one such root, it must be the radius of convergence of the function.

The erase-repetition game

In the erase-repetition game over a symbol set of size 8, there exists a strategy for Ann to build an arbitrarily long nonrepetitive sequence.

We fix n and prove that Ann has a strategy to build a nonrepetitive sequence of size n. In fact, the strategy for Ann will be randomized and we will show that for every strategy of Ben there is an evaluation of random experiments leading to the sequence of size n against that strategy. The fact that for every strategy of Ben there is a strategy for Ann to build a sequence of size n implies that Ann simply has a strategy to build such a sequence. Let C be the size of a symbol set. The argument to be presented turns out to work for [formula]. The strategy for Ann is the following: choose a random element distinct from the last three symbols in the sequence constructed so far. In this setting, Ann does not generate repetitions of size 1, 2 and 3. Obviously, Ben can cause many repetitions of size 1 but repetitions of size 2 and 3 are not possible. Indeed, in order to get a repetition of the form 'abcabc' the last three symbols must be generated by Ben. Consider Ann's move just before Ben puts 'b' in the repeated block. As she could not play preceding symbol 'a' she must have invoked a repetition. But all her repetitions are of size at least 4 and therefore the repeated block must have ended with 'abca'. This would mean that she played 'a' which is not possible as this symbol is not distinct from the last three in the current sequence at that step. Analogous argument proves that repetitions of size 2 are also impossible.

Fix n and a strategy of Ben. Take M sufficiently large and consider possible scenarios of the first 2M moves of the game against that fixed Ben's strategy. Suppose, for a contradiction, that the size of a sequence after 2M moves is always (for any evaluation of Ann's choices) less than n. Ann generates exactly M elements. Let rj ([formula]) be the jth symbol generated by Ann. Clearly, [formula] is a sequence of random variables with at least (C - 3)M possible evaluations. When we fix an evaluation of [formula] the course of the whole game is determined.

Let hj ([formula]) be the length of the sequence generated after j moves (including possible erasure invoked by the jth move) and let [formula] be the sequence of differences: d1 = 1, dj = hj - hj - 1 for [formula]. Note that dj = 1 means that there is no erasure after jth move and dj < 1 indicates that repeated block of size |dj| + 1 was removed. A pair (D,S) is a game log and D is feasible if there is an evaluation of [formula] such that D is the sequence of differences and S is the final sequence produced after 2M moves. A pair (D,S) is a reduced game log if it is a log but with all zeros in D erased. Note that any sequence of differences [formula] in a reduced log satisfies:

Every reduced log corresponds to a unique evaluation of [formula].

Given a reduced log [formula] with [formula], we decode all random choices taken by Ann in two steps. First we reconstruct the sequence [formula] of all symbols introduced in the game except those (of Ben) generating repetitions of size 1. The introduced symbols generating repetitions of size 1 are called bad, other symbols are good. The move is good (bad) if a good (bad) symbol is introduced. The number of good moves played is exactly the size of the difference sequence in the reduced log, namely m. Note that Sm is the sequence formed after the mth good move (even if a bad move is played afterwards, it does not change the sequence).

We reconstruct the sequence of good symbols backwards, i.e., we first decode xm, which is the last good symbol introduced, and the sequence Sm - 1 constructed after m - 1 good moves. Then, by simple iteration, we extract all the remaining good symbols [formula].

If dm = 1, then the mth good symbol introduced did not invoke a repetition. Thus, the last good symbol introduced is the last symbol of the final sequence, i.e. xm = sl and [formula].

If [formula], then some symbols were erased after the mth good move. But since we know the size of the repetition, namely h = |dm| + 1, and only one half of it was erased, we can read and copy the first part of the repeated block to restore [formula] and xm = sl.

Once we get all [formula], we read the sequence from the beginning and check whether the symbols agree with the strategy of Ben we fixed. The difference appears only where Ben introduces a bad symbol. There we extend the sequence with this symbol and continue. This way we reconstruct the sequence of all symbols introduced in the game and clearly every second symbol is chosen by Ann.

By a game walk we mean a sequence [formula] satisfying [\ref=item-erase-repetition-dj<=1], [\ref=item-erase-repetition-sum-of-the-prefix>=1] and additionally [formula]. Let Tm be the number of gamewalks of length m. By our assumption that Ann never wins, every feasible sequence of differences in a reduced log sums up to a number smaller than n. The number of sequences of size m satisfying [\ref=item-erase-repetition-dj<=1], [\ref=item-erase-repetition-sum-of-the-prefix>=1] but with a total sum k (for fixed [formula]) is bounded by Tm + 3 (just append two '1's and '- (k + 1)' to the end). Note also that [formula] for m > 1. Indeed, for a given sequence [formula] let i be the least index with di < 0 (there must be such provided m > 1). Then [formula] is a sequence counted by Tm + 1 and this extension is injective. Finally, all feasible sequences of differences are of size at most 2M. All this yields that the number of feasible difference sequences in a reduced log is at most 2M  ·  n  ·  T2M + 3. For a given feasible sequence of differences D, the number of final sequences which can occur with D in a reduced log is bounded by Cn. Thus, the number of reduced logs is bounded by

[formula]

We turn to the approximation of T2M. Every game walk [formula] is either a single step up (i.e., m = 1, d1 = 1), or it can be uniquely decomposed into |dm| + 1 subsequent game walks of total length m - 1. The jth component of the decomposition is the substring between the last visit of height j - 1 and the last visit of height j (i.e. between the last k such that [formula] and last l such that [formula]). This description together with the fact that if m > 1, then [formula], certify that the generating function [formula] satisfies the following functional equation:

[formula]

where the right hand side is [formula] From this equation we extract a polynomial

[formula]

that defines t(z). In the standard way we calculate the discriminant polynomial obtaining:

[formula]

This polynomial has only one positive real root equal to [formula]. Pick any α with ρ- 2  <  α < 5. Then T2M = o(αM).

By the claim the number of realizations is exactly the number of reduced logs. That gives

[formula]

Thus for [formula] and sufficiently large M we obtain a contradiction.

The nonrepetitive game

In the nonrepetitive game over a symbol set of size 6, there is a strategy for Ann to build an arbitrarily long sequence with no repetitions of size greater than 1.

We fix n and prove that Ann has a strategy to build a sequence of size n without repetitions of size greater than 1. As before we consider randomized Ann's strategy and we show that for every strategy of Ben there is an evaluation of random experiments leading to the generation of a nonrepetitive sequence of size n. This means that Ben cannot have winning strategy. Therefore, there exists a winning strategy for Ann. In this proof, by a repetition we mean a repetition of size greater than 1.

Let [formula] be the sequence already generated in the game and suppose that it is Ann's turn (m is odd). The strategy for Ann goes as follows: choose any symbol at random, but

This stategy explicitly ensures that no repetitions of size 2 and 3 occur in the game. It turns out that also repetitions of size 4 are avoided. Suppose for a contradiction that at some point in the game a sequence with a suffix of the form x1x2x3x4x1x2x3x4 is produced. Suppose also that Ann introduces the last symbol, namely x4. As she did not prevent a repetition of size 4, the rule [\ref=item:_excluding_repetitions_of_size_4] of the strategy did not exclude a symbol and therefore rule [\ref=item:_excluding_repetitions_of_size_3] must have been invoked. In particular, x3 = x4. But this means that in the previous move of Ann (when she introduced x2 in the repeated block) the symbols excluded by [\ref=item:_excluding_repetitions_of_size_2] and [\ref=item:_excluding_repetitions_of_size_3] were the same, so, rule [\ref=item:_excluding_repetitions_of_size_4] must have been applied. But that rule excludes x2, a contradiction. Analogous reasoning works for the case when Ben finishes a repetition of size 4.

Fix a strategy for Ben. We simulate the play between randomized Ann and this fixed strategy, and whenever a repetition of size h occurs in the mth move (of the real game), we backtrack to the move m - h + 1. This means that we remove the whole repeated segment and continue the simulation starting from the move m - h + 1 again (with independent random experiments).

A search sequence is the sequence of consecutive symbols chosen by players in the simulation. Note that it is not possible for Ben to introduce three symbols in a row in the search sequence. Indeed, if he introduces two symbols in a row, then there must have been a repetition (of odd size) after the first symbol. Thus, the second one is the same as the symbol just erased at this position (as Ben's strategy is fixed in the simulation). This means that the second symbol could not generate repetition and therefore Ann is next to play in the simulation.

The weight of a search sequence is the number of symbols chosen by Ann in the sequence. Fix M large enough. We are going to show that there is a scenario of the first M random experiments (first M moves of Ann) leading the simulation to an outcome sequence of size n. This will prove that Ann has a strategy to build a sequence of size n against the fixed strategy of Ben. For a contradiction we suppose that all outcome sequences generated after M moves of Ann in the simulation are of length less than n for all possible evaluations of random experiments.

Clearly, a search sequence of weight M is uniquely determined by the sequence of M Ann's choices. Let [formula] be the symbols chosen by Ann. As she always chooses one symbol out of at least C - 2 symbols, the sequence [formula] has at least (C - 2)M possible evaluations. A search sequence induced by an evaluation of [formula] is called a realization of this evaluation.

Let hj be the length of the current sequence just before the jth step (move) of the simulation. The sequence (hj) is called a height sequence. If Ann introduces a symbol in the jth step, then her next move is in step k∈{j + 1,j + 2,j + 3} (as Ben never plays three times in a row). There are only few possible extensions of the height sequence from hj up to hk: We want to get rid of some redundancy in the height sequence. More precisely, we encode the sequence of heights into its subsequence consisting of hj's corresponding to Ann's moves with a little extra information. Let hj,hk be again the heights of the current sequence right before any two consecutive moves of Ann. Note that

If hk > hj, then the sequence of heights between hj and hk is of type [\ref=item:type0].

If hk = hj - 2, then the sequence of heights between hj and hk is of type [\ref=item:type4].

If [formula], then the sequence of heights between hj and hk is of type [\ref=item:type1], [\ref=item:type2],[\ref=item:type3] or [\ref=item:type4].

Therefore, in order to record the whole height sequence it is enough to remember the subsequence [formula] of heights corresponding to Ann's moves and additionally, if [formula], to record [formula], which is the type of the original height sequence between symbols corresponding to h'j and h'j + 1.

Finally, note that all the h'j's are even (as the current sequence before Ann's move contains an even number of symbols). The reduced sequence of differences is: d1 = 1, dj + 1 = (h'j + 1 - h'j) / 2 for [formula], and the type function [formula], provided the latter is defined. Note that

A pair [formula] is a search log if there is an evaluation of [formula] such that D is the reduced sequence of differences in the realization of [formula], [formula] is a type function of D, and S is the final sequence produced after M steps of Ann in this realization of the search procedure.

Every search log corresponds to a unique evaluation of [formula].

Given a search log [formula] where [formula] we decode the evaluation of [formula] in a few steps. First we extract the height sequence [formula] from [formula] and put additionally hm + 1  =  |S|. Now, we are going to describe how to reconstruct the sequence [formula] of all symbols introduced in the simulation. This is done in backward direction, i.e., we decode first xm and the sequence Sm - 1 constructed after m - 1 steps of the simulation. Then by simple iteration we extract all the remaining symbols [formula].

If hm + 1 - hm = 1, then the introduction of xm did not invoke a repetition. Thus, xm is the last symbol in the final sequence S, i.e., xm = sl and [formula].

If [formula], then some symbols were erased after the introduction of xm. But we know the size of the repetition, namely h = |hm  +  1  -  hm| + 1, and since only one half of it was erased, we can copy the appropriate block to restore [formula] and xm = sl.

Once we get all [formula] we read the sequence from the beginning and track the current sequence in the simulation. Every time the current sequence is of even length the next symbol is introduced by Ann.

By a typed search walk we mean a pair [formula] satisfying [\ref=item-nonrepetitive-dj<=1], [\ref=item-nonrepetitive-sum-of-the-prefix>=1], [\ref=item-types] and additionally [formula]. Let TM be the number of typed search walks of length M (i.e., D is of length M). By our assumption that Ann never wins, every feasible sequence of differences in a typed search walk sums up to less than n. The number of typed search walks of length M satisfying [\ref=item-nonrepetitive-dj<=1], [\ref=item-nonrepetitive-sum-of-the-prefix>=1], [\ref=item-types] with total sum k (fixed [formula]) is at most TM + 1 (just append - (k - 1) to the end and pick arbitrary type, if necessary). Furthermore, [formula] for m > 1. All this implies that the number of feasible typed search walks is n  ·  TM + 1. For a given feasible typed search walk [formula] the number of final sequences which can occur with [formula] in a search log is bounded by Cn. Thus, the number of reduced logs is bounded by

[formula]

We turn to the approximation of Tm. Every typed search walk [formula] is either a single step up (i.e., m = 1, d1 = 1), or it can be uniquely decomposed into |dm| + 1 subsequent search walks of total length m - 1 and additionally into the type of dm if it is defined (i.e., if [formula]). This decomposition (analogous as in the proof of Theorem [\ref=thm:Pegdens-game]) gives the following functional equation for the generating function t(z):

[formula]

where z stands for a trivial one-step-up walk, zt2(z) stands for the case dm =  - 1 in which dm has no type, and the last term stands for the case [formula]. The right hand side of the equation is in fact equal to [formula]. From that form we derive the defining polynomial for t(z):

[formula]

In the standard way we calculate the discriminant polynomial obtaining:

[formula]

The radius of convergence of t(z) is one of the roots of the above polynomial. This polynomial has only one positive real root in ρ = 0.2537.. > 4- 1. Therefore TM  =  o(4M).

By the claim, the number of realizations is exactly the number of search logs. That gives

[formula]

Therefore for [formula] and sufficiently large M we obtain a contradiction.

Final remarks

The expected running time of the algorithm is linear in n for lists of size at least 4. It is immediate for lists of size 5, and needs a little effort for size 4. The computational experiments suggests different behaviour for size 3. This somehow explains the difficulty of Conjecture [\ref=conj]. It might be also the case that the list version of Thue's theorem does not hold, as it goes with the list version of the Four Color Theorem, although every planar graph is colorable from lists of size 5 [\cite=Tho94].

It is natural to try a similar approach for other Thue-type problems, especially for those in which the Lovász local lemma has been previously successfully applied. One such topic concerns graph-theoretic analogues of nonrepetitive sequences. A coloring of the vertices of a graph G is nonrepetitive if sequences of colors on all simple paths of G are nonrepetitive. The minimum number of colors needed is denoted by π(G). This parameter is bounded for graphs with bounded degree [\cite=AGHR02], as well as for graphs with bounded treewidth [\cite=BV07], [\cite=KP08]. A major challenge of this area is to settle whether π(G) is bounded by a constant for all planar G.

The ideas behind the erase-repetition algorithm already led to the proof [\cite=KM] that for every tree and lists of size 4 one can choose a coloring with no three consecutive identical blocks on any simple path. This fits to the recent construction from [\cite=FOOZ11] proving that no constant-size of lists guarantees a nonrepetitive coloring of a tree chosen from these lists.

Another direction is to look for stronger versions of nonrepetitive sequences. Here is an interesting variation due to Erds [\cite=Erd61]. A sequence S is strongly nonrepetitive if no two adjacent blocks of S are permutations one of another. It is known that there are arbitrarily long strongly nonrepetitive sequences over four symbols [\cite=Ker92]. But is it true that one can choose strongly nonrepetitive sequences from any collection of lists of sufficiently large size?