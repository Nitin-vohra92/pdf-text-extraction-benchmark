Lemma Claim Corollary

Tight Lower Bounds on Envy-Free Makespan Approximation

Introduction

Consider the scenario in which there is a set of tasks and a workforce that is commissioned to complete it. The tasks we are interested in are indivisible, that is, we can assign more than one job to each worker but two workers cannot both work on the same task. One goal is to complete all the tasks in the shortest period of time. However, each worker is specialized in his own way and ranks the difficulty of performing each task differently from his colleagues. We would also like to allocate the tasks in such a way that no worker would prefer to complete the workload of a colleague over his own. This problem is the focus of this paper.

Determining fair division is at the heart of a large body of research in computer science. One of its earliest occurrences in literature was in 1947 when Neyman, Steinhaus, Banach and Bronislaw modeled it as the problem of how to find a fair partitioning of cake ([\cite=steinhaus1], [\cite=steinhaus2]). Since then, several books including [\cite=barbanel], [\cite=bt1], [\cite=bt2], [\cite=meertens], [\cite=hougaard], [\cite=moulin] have been dedicated to the subject. The problem is generally described as a way of assigning n jobs to be processed by m machines or agents in a fair manner. One of the reasons that this area of research is so rich is that there are multiple ways to characterize a fair allocation. One way to do so is to consider the division that preserves envy-freeness, the notion that no agent would be better off if he were assigned the set of jobs given to another ([\cite=ds], [\cite=foley]). In the scenario where jobs can be divided among more than one machine, one solution would be to divide all jobs equally among all agents (although depending on the set-up of the problem this division might be ill-defined, i.e. if one agent takes an infinitely long time to process a specific job).

Determining a fair allocation when jobs are not divisible is less straightforward. In order to furnish a solution we must define a mechanism that determines an allocation as well as payments either to or from the agents, or between agents and the mechanism or agents among themselves. We consider the utility of each agent to be quasi-linear, i.e. the difference between the payment he receives and the cost to process his assignment of jobs.

When determining an optimal envy-free solution other goals can be considered such as revenue optimization or economic efficiency. The additional goal we described in our earlier example was makespan minimization, or the intention to minimize the longest processing time of jobs on any one machine. In their paper [\cite=himsz], Hartline et. al. considers a task schedule for m machines in which the minimum makespan for any indivisible allocation is 1. They then go on to show that no mechanism exists that can provide an envy-free indivisible allocation of with a makespan of less than 2 - 1 / m. In addition they provide an algorithm to find an envy-free indivisible allocation that upper bounds the makespan by (m + 1) / 2. Two years later, Cohen et. al. generalized and tightened the bounds on makespan approximation [\cite=cffko]. In there paper, they show that there does not exist a mechanism that provides on envy-free division with a makespan of less than O( log m /  log  log m) times the optimal, and produce a polynomial time algorithm that finds an envy-free scheduling that approximates the minimal makespan by a factor of O( log m).

Our contribution is to tighten the lower bound on makespan approximation to the upper bound. Specifically, we show that no mechanism exists that can guarantee an envy-free allocation of jobs to m machines with a makespan of less than a factor of O( log m) of the minimal makespan. This result definitively proves that the optimal algorithm for obtaining a minimal makespan for any envy-free division can at best approximate the makespan to a factor of O( log m).

Preliminaries

The scheduling problem that we are interested in is the following: We have n indivisible jobs and m machines. We are given a cost matrix (ci,j)1  ≤  i  ≤  m,1  ≤  j  ≤  n where ci,j is the cost of running job j on machine i. The allocation matrix (ai,j)1  ≤  i  ≤  m,1  ≤  j  ≤  n specifies which jobs are assigned to run on which machines, so that ai,j  =  1 if we run job j on the ith machine and ai,j  =  0 otherwise. Since our focus is on indivisible jobs, if ai,j  =  1, then ai',j  =  0 for all i'  ≠  i. In the case where jobs are divisible ai,j∈[0,1]. In both the divisible and indivisible job cases, [formula], i.e. we always find an allocation of jobs to machines where every job is processed in its entirety.

Let [formula] denote the ith row of the cost matrix (ci,j) and let [formula] denote the ith row of the allocation matrix (ai,j). Then the load on machine i, or the cost running the jobs assigned to machine i is [formula]. The makespan of an assignment is the maximum load on any machine, or max 1  ≤  i  ≤  mi  ·  āi.

We can formulate the problem of finding the minimum makespan for indivisible jobs as an integer programming problem and for divisible jobs as a linear programming problem. In 1990, Lenstra, et. al. introduced a 2-approximation algorithm for finding the minimum makespan for indivisible jobs, and showed that there does not exist a ρ-approximation algorithm for finding the minimum makespan for ρ < 3 / 2 unless P = NP [\cite=lst].

In this formulation we consider each of the m machines as a selfish agent. An allocation function a is mapped to the m  ×  n cost matrix c so that a(c)  =  (ai,j). As before let [formula] and [formula] denote the ith row of (ci,j) and a(c), respectively. Let p denote a payment function that is a mapping from c to [formula], and let p(c)i denote the ith coordinate of p(c).

We define a mechanism as a pair of functions, M =  < a,p >  where a is the allocation function and p is the payment function. Given a mechanism < a,p >  with a cost function (ci,j), the utility of agent i is p(c)i  -  i  ·  āi. A mechanism is considered envy-free if no agent can increase his utility by trading his job allocation and payment with another player. More formally, a mechanism is envy-free if, for all j∈1..n,

[formula]

We call an allocation function envy-free implementable (EF-implementable) if there exists a payment function p such that mechanism < a,p >  is envy-free.

An allocation function is locally-efficient if for all cost matrices c and permutations π of [formula], we have

[formula]

Hartline, et. al. introduced the following useful theorem [\cite=himsz].

An allocation is EF-implementable if and only if it is locally-efficient.

Main Result: Lower Bound on Envy-Free Makespan Approximation

We give a lower bound of Ω( log m) on the makespan achievable by any envy-free allocation of jobs.

Let [formula] be the number of jobs for some [formula]. The number of machines is m = n + l where 2l  =   log ñ. Let c denote a cost matrix where ci,j gives the cost of running job j on machine i. For this cost matrix, we have

[formula]

Each row i for 1  ≤  i  ≤  n + l gives the costs for the ith machine and each entry ci,j in the matrix denotes the cost of running job j on machine i. The horizontal line lies between machines n and n + 1. For 1  ≤  i  ≤  n, the cost of running job j on machine i is given by

[formula]

Note that for 1  ≤  i < n and i > j, we have [formula]. For n < i  ≤  n + l, the cost to process any job on machine i is 2i - n.

For 1  ≤  i  ≤  n + l and 1  ≤  j  ≤  n, we have ci,j  >  1 / 2.

The lemma statement is trivially true for i  ≤  j or n < i  ≤  n + l. Therefore, we need only consider the cases where j < i < n. Consider the function [formula] where 1  ≤  x  ≤  ñ  /   log ñ and 1  ≤  y  ≤  x - 1. Since the function is linear, it's critical points will be where the boundaries of the domain intersect. The three boundaries are at y = 1, x = ñ  /   log ñ, and y = x - 1, and so the points of intersection are (2,1), (ñ  /   log ñ,1), and (ñ  /   log ñ,ñ  /   log ñ - 1). We have f(2,1)  =  1 -  log ñ / (2ñ), f(ñ  /   log ñ,1)  =  1  -  (ñ  /   log ñ) log ñ / (2ñ) and f(ñ  /   log ñ,ñ  /   log ñ - 1) = 1 -  log ñ / (2(ñ  -  ñ  /   log ñ)) all of which are in the range of (1 / 2,1).

For this cost matrix, the optimal makespan is 1. We reach this makespan when i = j. Since the cost of running any job on any machine is strictly greater than 1 / 2, if more than one job is run per machine the makespan will be more than 1. Any other permutation of jobs would require at least one job j to be run on some machine i for i < j or for n < i  ≤  n + l. Either of these scenarios would give us a makespan of at least 2.

We show that any envy-free makespan for this cost matrix is lower bounded by log n. More specifically, we show that no matter how we partition the n jobs into n + l bundles, any locally-efficient assignment of the bundles has a makespan of at least log n. This establishes that there does not exist an algorithm that can always find a makespan of less than log n.

For any partition of n jobs into bundles, the makespan for every locally efficient assignment of bundles is at least 2l  =   log ñ.

Before we prove this theorem, we introduce the following useful lemma.

For the cost matrix (ci,j) defined, and makespan of less than 2l  =   log ñ has the following properties:

Fewer than 2l + 1 jobs run on each machine.

Fewer than 2l / 2i - n jobs run on each machine n + i for n < i  ≤  n + l.

The total number of jobs running on machines [formula] is fewer than 2l.

Property (1) follows directly from Lemma [\ref=lem:cost1/2]; Property (2) holds since ci,j  =  2i - n for n < i  ≤  n + l; and (3) follows from (2) because [formula].

Consider an arbitrary partition of the n jobs into n + l bundles with a makespan of less than 2l. Suppose that this assignment is locally-efficient. In order to prove this theorem by contradiction, we must provide a permutation of the assignment that decreases that total cost over all jobs. Since the cost of running a job on machine n + l is 2l, there are no jobs assigned to run on machine n + l. Therefore, the permutation we will provide is the one in which each bundle of jobs assigned to machine i is moved to machine i + 1.

By Lemma [\ref=lem:2^l] (1), less than 2l + 1 jobs run on machine n, so the increase of cost from moving the bundle of jobs from machine n to machine n + 1 is less than 2l + 1(2 - 1 / 2)  =  3  ·  2l. For n < i < n + l, we have ci + 1,j = 2ci,j, and so moving each bundle from machine i to i + 1 in this range increases the cost by a factor of 2. By Lemma [\ref=lem:2^l] (3), fewer than 2l jobs run on this set of l machines, and so moving each bundle to the next machine would increase the total cost by less than [formula]. Therefore, moving each bundle assigned to machine i to machine i + 1 for n  ≤  i < n + l increases the cost of the assignment by less than (l + 3)2l  =  ( log  log ñ + 3) log ñ.

By Lemma [\ref=lem:2^l] (3), there are fewer than 2l jobs running on machines [formula], which implies that the total number of jobs running on machines [formula] is greater than n - 2l. Pairing this with Lemma [\ref=lem:2^l] (1), we know that the total number of jobs running on machines [formula] is greater than n - 2l - 2l + 1 = n - 3  ·  2l. As noted earlier, moving any job j from machine i to machine i + 1 in this range decrease the cost of the job by [formula]. Therefore, the total cost from moving all the bundles on machines [formula] decreases by at least [formula], where Hk is the kth harmonic number.

The decrease of cost from the first n - 1 machines is larger than the increase of cost from the last l + 1 machines and so the makespan for any locally efficient assignment must be greater than 2l.

For any partition of n jobs into bundles, the makespan for every envy-free assignment of bundles is Ω( log m).

By Theorem [\ref=thm:makespan], every locally efficient partition has a makespan of at least log ñ  =   log ((n - 1) log ñ)  ≥   log n. Since m = n + l = O(n) for the cost matrix defined, it holds that it is an Ω( log m) approximation.