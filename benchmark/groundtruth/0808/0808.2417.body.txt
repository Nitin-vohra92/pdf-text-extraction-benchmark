Corollary Lemma

On NFAs Where All States are Final, Initial, or Both

Introduction

Nondeterministic finite automata (NFAs) differ from deterministic finite automata (DFA) in at least two important ways. First, they can be exponentially more concise in expressing certain languages, as it is known that there exist NFAs on n states for which the smallest equivalent DFA has 2n states [\cite=Ershov:1962] [\cite=Moore:1971] [\cite=Meyer&Fischer:1971]. Second, while it is possible to test inequivalence and nonuniversality for DFAs in polynomial-time, the corresponding problems for NFAs are PSPACE-complete [\cite=Meyer&Stockmeyer:1972].

In this paper, we consider NFAs with certain natural restrictions, such as having all states final, all states initial, or all states both initial and final. Although imposing these conditions significantly narrows the class of languages accepted (see § [\ref=charac]), we show that there is still an exponential blow-up in converting to an equivalent DFA, and the corresponding decision problems are still PSPACE-complete. Furthermore, these restricted NFAs are intimately related to languages that are prefix-closed, suffix-closed, or factor-closed (see § [\ref=charac] and [\cite=Brzozowski:2008]), and have close connections with certain decision questions on infinite words and a decision problem on Boolean matrices [\cite=Rampersad:2009].

Here is a brief outline of the paper. In Section [\ref=notation], we give some basic definitions and notation. In Sections [\ref=hardness], [\ref=hardnessi], and [\ref=hardnessif], we prove an assortment of hardness results on NFAs with various restrictions on their initial and final states. In Section [\ref=charac], we give a simple characterization of the languages accepted by NFAs with these restrictions. In Sections [\ref=statecomp] and [\ref=statecomp2], we give our main results, on state complexity. We end with Sections [\ref=complement] and [\ref=shortest], where we discuss the complexity of complement and the length of the shortest word not accepted.

Definitions and notation

We recall some basic definitions. For further details, see [\cite=Hopcroft&Ullman:1979]. A non-deterministic finite automaton (NFA) M is a quintuple M  =  (Q,Σ,δ,I,F), where Q is a finite set of states; Σ is a finite alphabet; δ  :  Q  ×  Σ  →  2Q is the transition function, which we extend to Q  ×  Σ* in the natural way; I  ⊆  Q is the set of initial states; and F  ⊆  Q is the set of final states. An NFA M accepts a word w∈Σ* if [formula]. The language of all words accepted by M is denoted L(M).

A deterministic finite automaton (DFA) M is defined as an NFA above, with the following restrictions: M has only one initial state q0, and |δ(q,a)|  =  1 for all q∈Q and a∈Σ.

The state complexity of a regular language L is the number of states in the minimal DFA accepting L. Given an operation on regular languages, we also define the state complexity of that operation to be the number of states that are both sufficient and necessary in the worst-case for a DFA to accept the resulting language.

Hardness results

First, we discuss the case of NFAs with a single initial state, and where all states are final.

Consider the following decision problem

NFA-INEQUIVALENCE-ASF(k): Given two NFAs M1 and M2, over an alphabet with k letters, each having the property that all states are final states, is [formula]?

We will prove the following theorem.

NFA-INEQUIVALENCE-ASF (k) is PSPACE-complete for k  ≥  2, but solvable in polynomial time for k  =  1.

First, let us consider the case where k  =  1. Let M be a unary NFA (over the alphabet Σ  =  {a}) with all states final. Then L(M) is either finite or Σ*, depending on whether there is a cycle in the directed graph G given by the transitions of M. Furthermore, if M has n states, then an∈L(M) iff G has a cycle reachable from q0. Therefore, we can determine L(M) efficiently by checking first if an is accepted. If it isn't, we then successively check whether an - 1, [formula] are accepted. If the first string in this list that is accepted is ai, then [formula]. Thus we can check whether [formula] efficiently.

The NFA-INEQUIVALENCE-ASF problem is in PSPACE, since the more general NFA-INEQUIVALENCE problem (problem AL1 in Garey and Johnson [\cite=Garey&Johnson:1979]) is well-known to be in PSPACE. A proof of this result can be found in Sipser [\cite=Sipser:1996].

Now we need to see that NFA-INEQUIVALENCE-ASF is PSPACE-hard. To do so, we consider the specialization NFA-NONUNIVERSALITY-ASF:

NFA-NONUNIVERSALITY-ASF(k): Given an NFA M over an alphabet Σ with k letters, having the property that all states are final states, is L(M)  ≠  Σ*?

Clearly, if we prove the stronger result that NFA-NONUNIVERSALITY-ASF(k) is PSPACE-hard, then it will follow that NFA-INEQUIVALENCE-ASF(k) is PSPACE-hard, by choosing one of the NFAs to be the one-state NFA with a loop back to the single state on every input symbol. So it will suffice to prove the following lemma:

NFA-NONUNIVERSALITY-ASF(k) is PSPACE-hard for k  ≥  2.

First, let us consider the case where k  ≥  3. We reduce from the following decision problem, which is well-known to be PSPACE-complete [\cite=Garey&Johnson:1979] for k  ≥  2:

NFA-NONUNIVERSALITY(k): Given an NFA M over an alphabet Σ with k letters, is [formula]?

Here are the details of the reduction.

Given an NFA M over an alphabet of size k, we transform it to an NFA M' with all states final, over an alphabet of size k + 1, as follows: M' is identical to M, except that we add a transition from each final state of M to the initial state q0 on a new symbol, say #  , and then we change all states to be final states. This construction is illustrated below in Figure [\ref=nfa4].

Let [formula].

We now claim that [formula] iff [formula], or, equivalently, L(M)  =  Σ* iff L(M')  =  Δ*.

Suppose L(M)  =  Σ*. Then for each string w∈Σ*, there exists a final state p(w) of M such that p∈δ(q0,w). Let x∈Δ*. If x∈Σ*, the result is clear. Otherwise write [formula], where each xi∈Σ*. Now there exists an accepting computation for x in M', which starts in q0, follows x1 to the state p(x1), then follows the transition on #   back to q0 of M', then follows x2 to p(x2), etc. Thus L(M')  =  Δ*.

Now suppose L(M')  =  Δ*. Then, in particular, M' accepts all strings of the form w  #   where w∈Σ*. In order for M' to accept w  #  , it must be the case that there is a transition from a state p∈δ(q0,w) on #   in M'. But then this state is final in M, by construction, so w is accepted by M. Thus L(M)  =  Σ*.

This completes the reduction. Note that our construction increases the size of the alphabet by 1, so that we have shown that

NFA-NONUNIVERSALITY(k) reduces to NFA-NONUNIVERSALITY-ASF(k + 1).

Since NFA-NONUNIVERSALITY is PSPACE-hard for k  ≥  2, we have proved the lemma for k  ≥  3.

It remains to show NFA-NONUNIVERSALITY-ASF(2) is PSPACE-hard. To do this, we show by recoding that NFA-NONUNIVERSALITY-ASF(4) reduces to NFA-NONUNIVERSALITY-ASF(2).

Here are the details. Given a machine M over the input alphabet Σ  =  {0,1,2,3} with all states final, we create a new machine M' over the input alphabet Δ  =  {0,1}. Each transition out of a state A is recoded, and two new final states are introduced, so that

a transition on 0 is replaced by a transition on 0 followed by 0

a transition on 1 is replaced by a transition on 0 followed by 1

a transition on 2 is replaced by a transition on 1 followed by 0

a transition on 3 is replaced by a transition on 1 followed by 1

See Figure [\ref=nfa5].

We claim that L(M)  =  Σ* iff L(M')  =  Δ*.

This completes the proof of Theorem [\ref=first].

Minimizing an NFA with all states final, over an alphabet of size ≥  2, is PSPACE-hard.

If we could minimize an NFA with all states final, we could also solve the nonuniversality problem [formula] as follows: first we minimize the NFA. If it has ≥  2 states, we say "yes". Otherwise we inspect the transitions (if any) of the minimized NFA, and check if the single state is final and that there is a loop on every element of the alphabet. If so, we say "no"; otherwise, we say "yes".

Generalized NFA with all states initial

Now we consider a variant of the problems considered in Section [\ref=hardness]. These variants concern generalized NFAs with multiple initial states allowed, in which all states are initial states and there is only one final state. We consider the following decision problems:

NFA-INEQUIVALENCE-ASI(k): Given two NFAs M1 and M2, over an alphabet with k letters, each having the property that all states are initial states and only one state is final, is [formula]?

NFA-NONUNIVERSALITY-ASI(k): Given an NFA M over an alphabet Σ with k letters, having the property that all states are initial states and only one state is final, is L(M)  ≠  Σ*?

We prove the following theorem.

Both NFA-INEQUIVALENCE-ASI(k) and NFA-NONUNIVERSALITY-ASI(k) are PSPACE-complete for alphabet size k  ≥  2, but solvable in polynomial time for k  =  1. Furthermore, minimizing an NFA with all states initial and one state final is PSPACE-hard for k  ≥  2.

These results follow trivially from the results in the previous section by observing that L is accepted by an NFA M with a single initial state and all states final iff LR (the language formed by reversing all the strings of L) is accepted by MR, the generalized NFA formed by reversing all the transitions of M, and changing initial states into final and vice versa.

All states both initial and final

Our original motivation in Section [\ref=intro] involved generalized NFAs where all states are both initial and final. Consider the following decision problem:

NFA-INEQUIVALENCE-ASIF(k): Given two NFAs M1 and M2, over an alphabet with k letters, each having the property that all states are both initial and final, is [formula]?

NFA-INEQUIVALENCE-ASIF (k) is PSPACE-complete for k  ≥  2, but solvable in polynomial time for k  =  1.

The idea is similar to that in the proof of Theorem [\ref=first]. We only indicate what needs to be changed.

Once again, we work with the "easier" problem

NFA-NONUNIVERSALITY-ASIF(k): Given an NFA M over an alphabet with k letters, having the property that all states are both initial and final, is L(M)  ≠  Σ* ?

We can show that NFA-NONUNIVERSALITY(k) reduces to NFA-NONUNIVERSALITY-ASIF(k + 1) using a simple variant of our previous proof. Given M, an NFA over an alphabet Σ of k symbols, we modify it to obtain M', an NFA over an alphabet [formula] of k + 1 symbols, as follows. First, we delete all states of M not reachable from q0, the start state. Next, we introduce a new symbol #   and transitions on #   from each of the final states of M to q0. Finally, we change all states to be both initial and final. We claim that L(M)  =  Σ* iff L(M')  =  Δ*.

The direction [formula] is exactly as before. For the other direction, suppose L(M')  =  Δ*. Then, in particular, for all x∈Σ*, the string #  x  #   is accepted by M'. Consider an accepting path for this string in M'. It starts at some state (since all states are initial) and then follows a transition on #   to q0. The machine M' now processes x and arrives at some state q. In order for M' to reach a final state on the last symbol, #  , there must be a transition on #   from q to q0. But this can only be the case if q was final in M. Thus we have found an accepting path for x in M, and so L(M)  =  Σ*.

Thus we have shown NFA-NONUNIVERSALITY-ASIF(k) is PSPACE-complete for k  ≥  3, and thus, that NFA-INEQUIVALENCE-ASIF(k) is PSPACE-complete for k  ≥  3.

To complete the proof of the theorem, we prove the following lemma.

NFA-NONUNIVERSALITY-ASIF(2) is PSPACE-complete.

It is enough to show that NFA-NONUNIVERSALITY-ASF(3) reduces to NFA-NONUNIVERSALITY-ASIF(2). The reduction has several steps, but the basic idea is simply to recode the 3-letter alphabet {0,1,2} into strings over a 2-letter alphabet {1,10,100}.

Given an NFA M with input alphabet Σ  =  {0,1,2}, a single initial state q0, and all states final, we first modify M to enforce the condition that there be no transitions entering the initial state. To do this, we double the initial state, adding a new state p0 with the same outgoing transitions as q0, and make any transitions formerly entering q0 to enter p0 instead.

Second, we enforce the condition that the labels of all transitions entering a particular state be the same. To do this, we triple each state except the initial state (which, by construction, now has no incoming transitions), copying the outgoing transitions, and assigning an incoming transition of each element of Σ to one of the three states, appropriately.

Third, we recode the transitions of the NFA, as follows:

[formula]

Of course, this recoding necessitates introducing intermediate states for transitions on 1 and 2. We call these intermediate states "new" and all other states "old".

The incoming transitions of each old state have the same labels, which are either 1, 10, or 100. In our fourth step, we add additional outgoing transitions, and states, as depicted in Figure [\ref=transf]. The dotted transitions indicate transitions that include some nondepicted states, and the dashed circles indicate the additional states added. The effect of these additional transitions is to allow, from each old state with an incoming arrow, a path labeled by 1 and then 3 or more zeroes that returns to q0.

Finally, we make all states both initial and final. Call the resulting generalized NFA M'. We claim M accepts Σ* iff M' accepts Δ*, where Δ  =  {0,1}. Define the morphism h by 0  →  1, 1  →  10, and 2  →  100.

Suppose M accepts Σ*. We need to show that every s∈Δ* is accepted by M'. Let us identify the maximal blocks of 3 or more zeroes in s, if they exist. These blocks either mark the beginning or end of s, or else are bounded on the left by a string specified by (ε  +  0  +  00)(1  +  10  +  100)*1, and on the right by a string specified by (1 + 10 + 100)+. Thus every string in Δ* has one of the following forms:

y

yw

(zx)*z

yx(zx)*z

(zx)*zw

yx(zx)*zw

where y  =  {ε,0,00}, x  =  {1,10,100}*1, z  =  {000}{0}*, and w  =  {1,10,100}+. For forms (a)-(f), we argue that each string s specified is accepted by M'. We do this only for part (f), as the others are similar.

Let s∈Δ*. We show how to construct an accepting path for s in M', where s is of the form yx(zx)*zw. Write [formula], where y' is a string of y, each xi is a string of x, each zi is a string of z, and w' is a string of w.

First, consider an accepting path for 2h- 1(x0) in M. This path corresponds to a path in M' starting at q0 and visiting a sequence of old states in turn. In particular, the path for the prefix 2 corresponds in M' to a sequence of transitions on (successively) 1,0,0, leading to an old state. Call the sequence of states encountered q1, q2, q3. Since every state of M' is initial, we can choose to start at our accepting path at

q1 (if the string s we are trying to accept starts with 001);

q2 (if the string s we are trying to accept starts with 01);

q3 (if the string s we are trying to accept starts with 1).

Thus there is a path in M' starting at either q1, q2, or q3, processing y'x0, and ending in an old state. At this point we can read z0, which leads back to q0. It now remains to construct a path for [formula]. Again, there is path from q0 in M on h- 1(x1), and this corresponds to a path in M' leading to an old state. We can now process the symbols of z1, leading back to q0. This process continues until after reading zn we have returned once more to q0. At this point we can process the symbols of w', and we are in an accepting state. Thus M' accepts s.

For the other direction, assume M' accepts Δ*. We must show M accepts Σ*. Clearly M accepts ε, since M has an initial state and all states are final. Now let s∈Σ+, and consider the string 1000h(s)1 in Δ*. This string is accepted, and so there is an accepting path starting in some state (not necessarily q0) for it in M'. By our construction, after reading 1000, we are either in q0 or in some new state. If we are in a new state, however, there is no possible transition on 1, so we must be in q0 after reading 000. Now an acceptance path for h(s)1 from q0 corresponds to an acceptance path for s0, and hence s, in M. (We require the final 1 because otherwise if s ends in 0, we could be in a new state of M' which would not map back to a path in M.)

This completes the proof of Theorem [\ref=asif].

Minimizing an NFA with all states both initial and final is PSPACE-hard.

Characterization of the languages accepted by special NFAs

In this section we observe that the languages accepted by the kinds of NFAs we have been discussing have a simple characterization.

We define [formula] to be the language of all prefixes of strings of L, [formula] to be the language of all suffixes of strings of L, and [formula] to be the language of all factors (aka "subwords") of strings of L. A language L is prefix-closed if [formula], suffix-closed if [formula], and factorial if [formula].

The results summarized in the following theorem are easy to prove. Part (b) was noted by Gill and Kou [\cite=Gill&Kou:1974].

A nonempty regular language is prefix-closed if and only if it is accepted by some NFA with all states final;

A nonempty regular language is suffix-closed if and only if it is accepted by some generalized NFA with all states initial and one final state.

A nonempty regular language is factorial if and only if it is accepted by some generalized NFA with all states both initial and final.

It is natural to consider the complexity of testing whether a given regular language is prefix-closed, suffix-closed, or factorial. We will see below that the answer depends on whether the input is given as an NFA or a DFA.

The following problems are PSPACE-complete: given an NFA M, decide if L(M) is not prefix-closed (resp. suffix-closed, factorial).

To show that determining if L(M) is not prefix-closed is in PSPACE, we first give a non-deterministic algorithm. The desired result will then follow by Savitch's Theorem. Let n be the number of states of M. If L(M) is not prefix-closed, there exists a string w∈L(M) such that some prefix w' of w is not in L(M). We guess such a w of length <  2n + 1 one input symbol at a time and verify that w is accepted by M but some prefix w' is not. The space required is that for the current set of states of M and for an n + 1 bit counter, which is clearly polynomial. It remains to show that if such a w exists, we may choose w to have length <  2n + 1. Suppose the shortest such w has length ≥  2n + 1. Let w' be the prefix of w not accepted by M. During the computation of M on the first 2n symbols of w, M must repeat a set of states, and similarly for its computation on the second 2n symbols of w. If w' has length >  2n, then omitting the portion of the computation between the repeated set of states in the first half of w yields a new, shorter string accepted by M with a prefix not accepted by M, contradicting the minimality of w. If w' has length ≤  2n, then omitting the portion of the computation between the repeated set of states in the second half of w gives the same result. We conclude that a shortest such w has length <  2n + 1.

A similar argument shows that determining if L(M) is not suffix-closed is also in PSPACE. Noting that [formula], one concludes that determining if L(M) is factorial is also in PSPACE.

To show PSPACE-hardness we use the reduction from the acceptance problem for polynomial-space bounded Turing machines to NFA-NONUNIVERSALITY given by Aho, Hopcroft, and Ullman [\cite=Aho&Hopcroft&Ullman:1974]. Given a deterministic Turing machine T and an input w, Aho, Hopcroft, and Ullman [\cite=Aho&Hopcroft&Ullman:1974] showed how to construct a regular expression E specifying all strings that do not represent an accepting computation of T on w. From E we can construct an NFA M for L(E) in polynomial space using the standard constructions. Thus if T does not accept w, the NFA M accepts all strings over its input alphabet Σ. If T does accept w, then M accepts all strings except the one string x that represents the accepting computation of T on w. But now if L(M)  =  Σ*, then L(M) is clearly prefix-closed, suffix-closed, and factorial. If [formula], then L(M) is not prefix-closed, suffix-closed, or factorial. Thus L(M)  =  Σ* iff L(M) is prefix-closed (resp. suffix-closed, factorial). Since the problem of deciding if L(M)  ≠  Σ* is PSPACE-complete, we conclude that deciding if L(M) is not prefix-closed (resp. suffix-closed, factorial) is PSPACE-complete.

The following problems can be solved in polynomial time: given a DFA M, decide if L(M) is not prefix-closed (resp. suffix-closed, factorial).

Given a DFA M we may easily construct a DFA M' accepting [formula] by making final every state in M that can reach a final state. To test if L(M) is not prefix-closed is to test the non-emptiness of [formula], which is easily done in polynomial time by the cross-product construction and the standard algorithm for testing the emptiness of a language accepted by a DFA.

To determine if L(M) is not suffix-closed, first let M  =  (Q,Σ,δ,0,F), where [formula]. We construct at most n new DFAs Mi, 0  ≤  i  ≤  n - 1, where i is a state of M reachable from 0 and Mi is identical to M except that i is the start state of Mi. We now test if any of the Mi accept a string not accepted by M. As before, this can be done in polynomial time for each Mi, and since we have at most n machines Mi, the overall runtime is polynomial.

To determine if L(M) is not factorial, we construct the Mi as above, but now for each Mi we make final every state of Mi that can reach a final state. Again, we now test if any of the Mi accept a string not accepted by M.

For more exact analysis of the running time, see [\cite=Brzozowski:2008].

State complexity results

We now turn to state complexity results. It is well known that, for all n  ≥  1, there exists an NFA with n states such that minimal equivalent DFA has 2n states. In this section we show that the maximum blow-up can still be achieved for alphabets of size ≥  2, if we demand that all states be final, initial, or both initial and final. We note that in computing the state complexity, we demand that our DFAs be complete, that is, that there is a well-defined transition from every state and every input symbol.

The situation is somewhat different for the unary case, with alphabet Σ  =  {a}. In the case of an NFA with all final states, the maximum blow-up in going from an NFA to a DFA is n  →  n + 1 states. To see this, note that if a unary n-state NFA with all final states has a directed cycle, then it accepts a*, which can be done with a 1-state DFA. Otherwise there exists a k  ≤  n such that ak is the shortest string not accepted. This can be accepted with a k + 1-state DFA (by adding the missing dead state). In the case k  =  n, this results in a n  →  n + 1 blowup. The same results occur for NFAs with all states initial and one final, or with all states both initial and final.

Now we turn to the case of larger alphabets.

For n  =  1 and every n  ≥  3 there exists an NFA M over a binary alphabet with n states, all of which are final, such that the minimal DFA accepting L(M) has 2n states. No such binary NFA exists for n  =  2, although over a ternary alphabet one exists.

For n  =  1 we take the automaton with a single state which is both initial and final, with a self-loop on only one of the two letters.

For n = 2 we can enumerate all possible binary NFAs with all states final and check that none of them have a minimal DFA with 4 states.

It is easy to verify that the ternary NFA in Figure [\ref=nfa6] has deterministic state complexity 4.

Now assume n  ≥  3. We define an NFA M  =  (Q,Σ,δ,0,F) (Figure [\ref=dfa1]), where [formula], Σ  =  {0,1}, F  =  Q, and for any i, 0  ≤  i  ≤  n - 1,

[formula]

Let M'  =  (2Q,Σ,δ',{0},F') be the DFA obtained by applying the subset construction to M. To show that M' is minimal we will show (a) that all states of M' are reachable, and (b) that the states of M' are pairwise inequivalent with respect to the Myhill-Nerode equivalence relation.

To prove part (a) let S  ⊆  Q be a state of M', where [formula] for some k and [formula]. There are two cases to consider.

Case 1: n - 1∉S. Then

[formula]

To see this, let wk  =  ε and for 1  ≤  i  ≤  k - 1, let

[formula]

For 1  ≤  i  ≤  k, let Si  =  δ'({0},wi). Then [formula]. We see that [formula]. Here, for m∈Q, the notation S  +  m refers to the set {x + m:x∈S}. Thus

[formula]

as required.

Case 2: n - 1∈S. By the argument of Case 1, [formula] is reachable. But then

[formula]

To see this, for 1  ≤  i  ≤  k - 1, let

[formula]

For 1  ≤  i  ≤  k - 1, let [formula]. Then

[formula]

We see that

[formula]

Thus

[formula]

as required.

To prove part (b) let S and T be distinct states of M'. We have 2 cases.

Case 1: n - 1 is in exactly one of S or T. Without loss of generality, suppose n - 1∉S and n - 1∈T. Then [formula] and δ'(T,0n - 1)  =  {n - 1}, so S and T are inequivalent.

Case 2: either n - 1 is in both of S and T or n - 1 is in neither. Without loss of generality, suppose there exists i∉S, i∈T. Then δ'(S,0n - 2 - i1)  =  S' and δ'(T,0n - 2 - i1)  =  T', where n - 1∉S' and n - 1∈T'. We now apply the argument of Case 1.

We now turn to the case where all states are both initial and final.

For every n  ≥  1 there exists an NFA M over a binary alphabet with n states, each of which is both initial and final, such that the minimal DFA accepting L(M) has 2n states.

For n  =  1 we take the automaton with a single state which is both initial and final, with a self-loop on only one of the two letters.

Now assume n  ≥  2. We define an NFA M  =  (Q,Σ,δ,Q,F) (Figure [\ref=dfa2]), where [formula], Σ  =  {0,1}, F  =  Q, and for any i, 0  ≤  i  ≤  n - 1,

[formula]

Let M'  =  (2Q,Σ,δ',Q,F') be the DFA obtained by applying the subset construction to M. To show that M' is minimal we will show (a) that all states of M' are reachable, and (b) that the states of M' are pairwise inequivalent with respect to the Myhill-Nerode equivalence relation.

To prove part (a) let S  ⊆  Q be a state of M', where [formula] for some k and [formula]. Then

[formula]

To see this, for 1  ≤  i  ≤  k, let

[formula]

and let Si  =  δ'(Q,wi). Then one easily verifies that

[formula]

so δ'(Q,wk0n - sk)  =  δ'(Sk,0n - sk)  =  (S  -  sk  -  n  +  sk) mod n  =  S.

To prove part (b) let S and T be distinct states of M'. Without loss of generality, suppose there exists i∉S, i∈T. Then [formula] and δ'(T,0i1n - 1)  =  {n - 1}, so S and T are inequivalent.

Finally, we consider the case where all states are initial, and only one state is final. An example of maximal blowup from n states to 2n deterministic states was first given by Gill and Kou [\cite=Gill&Kou:1974], but their construction was not over a fixed alphabet. Later, Veloso and Gill [\cite=Veloso&Gill:1979] gave an example over a binary alphabet. Here we give another example. The following NFA, which is a trivial variation on that in Figure [\ref=dfa2], demonstrates the maximum blow-up from n states to 2n deterministic states for all n  ≥  1. We omit the proof, which is a trivial variation of the proof of Theorem [\ref=allinitial].

State complexity of [formula], [formula], [formula]

In this section we consider the the state complexity of the operations [formula], [formula], and [formula].

If the state complexity of L is n, the state complexity of [formula] is also at most n, as can be seen from the standard construction for [formula] where we change every state from which a final state can be reached to final.

The state complexity of [formula] is more interesting.

Let M be a DFA with n states. Then [formula] can be accepted by a DFA with at most 2n  -  1 states, and this bound is tight.

Let M  =  (Q,Σ,δ,0,F), where [formula]. Then [formula] is accepted by the generalized NFA N  =  (Q,Σ,δ,P,F), where P  ⊆  Q is the set of states reachable from the start state. But it is clear that the empty set is not reachable from any nonempty set of states of N, so the minimal equivalent DFA has at most 2n  -  1 states.

To show the bound is tight, consider the DFA M  =  (Q,Σ,δ,0,F) on states [formula] (Figure [\ref=dfa3]) defined by

[formula]

and with F  =  {0}.

Now consider the generalized NFA N  =  (Q,Σ,δ,Q,F). By the argument above, N accepts [formula]. Let [formula] be the DFA obtained by applying the subset construction to N and removing the empty set. To show that M' is minimal we will show (a) that all states of M' are reachable, and (b) that the states of M' are pairwise inequivalent with respect to the Myhill-Nerode equivalence relation.

To prove part (a) let S  ⊆  Q be a state of M', where [formula] for some k and [formula]. Let T  ⊆  Q, [formula]. If both t and t + 1 are in T, t  <  n - 1, then one easily verifies that

[formula]

For 0  ≤  i  <  n - 1, define wi  =  1n - 1 - i01i + 1. We have two cases.

Case 1: sk  ≠  n - 1. We see that

[formula]

as required.

Case 2: sk  =  n - 1. Let [formula], where [formula]. By the argument of Case 1

[formula]

Since [formula], there exists a smallest t∈T, t  ≠  n - 1. If t  =  0, then [formula]. Otherwise,

[formula]

But now

[formula]

as required.

To prove part (b) let S and T be distinct states of M'. Without loss of generality, suppose there exists i∉S, i∈T. The set of final states F' consists of all subsets of Q containing 0. But 0∉δ'(S,1n - i) and 0∈δ'(T,1n - i), so S and T are inequivalent.

We now turn to the state complexity of [formula]:

Let M be a DFA with n states. Then [formula] can be accepted by a DFA with at most 2n - 1 states, and this bound is tight.

Let M  =  (Q,Σ,δ,0,F), where [formula]. Let us assume that M contains no unreachable states. Suppose that every state of M can reach a final state. Then [formula] and is accepted by a one state DFA. Let us suppose then that there exists q∈Q such that q cannot reach a final state. Then we may remove the state q and any associated transitions to obtain a equivalent NFA with n - 1 states. Then [formula] is accepted by the generalized NFA [formula], where P  ⊆  Q is the set of states that can reach a final state. The minimal DFA equivalent to N thus has at most 2n - 1 states.

To show the bound is tight, consider the DFA M on states [formula] (Figure [\ref=dfa4]) defined by

[formula]

and with F  =  {0}.

Note that state n - 1 cannot reach a final state. Let [formula] be the NFA obtained by removing state n - 1 from M, along with all associated transitions. Let N be the generalized NFA obtained from [formula] by making all states both initial and final. Then N accepts [formula]. Let [formula]. Let M'  =  (2Q',Σ,δ',Q',F') be the DFA obtained by applying the subset construction to N. To show that M' is minimal we will show (a) that all states of M' are reachable, and (b) that the states of M' are pairwise inequivalent with respect to the Myhill-Nerode equivalence relation.

To prove part (a) let S  ⊆  Q' be a state of M', where [formula] for some k, and [formula]. One easily verifies that for any T  ⊆  Q' and t∈Q',

[formula]

from which it is clear that S is reachable.

To prove part (b) let S and T be distinct states of M'. Without loss of generality, suppose there exists i∉S, i∈T. Then by the argument of part (a), there exists a string w such that [formula] and δ'(T,w)  =  {i}, so S and T are inequivalent.

Nondeterministic state complexity of complement

We now consider the following question. Let M be an NFA with all states final, accepting a language L. What is the maximum size of a minimal NFA accepting [formula]?

The case where we remove the restriction that all states be final was previously studied by Sakoda and Sipser [\cite=Sakoda&Sipser:1978], Birget [\cite=Birget:1993], Ellul et al. [\cite=Ellul&Krawetz&Shallit&Wang:2004], and Jirásková [\cite=Jiraskova:2005]. Jirásková constructed an n state NFA N over the alphabet {0,1} such that any NFA accepting [formula] requires at least 2n states.

Jirásková's NFA is defined as follows: let N  =  (Q,Σ,δ,0,F), where [formula], Σ  =  {0,1}, F  =  {n - 1}, and for any i, 0  ≤  i  ≤  n - 1,

[formula]

By modifying this construction we prove

For n  ≥  1, there exists an NFA M of n + 1 states over a three-letter alphabet with all states final such that any NFA accepting [formula] requires at least 2n states.

Let N be the NFA described above. Let [formula] and let M  =  (Q',{0,1,2},δ',0,Q'), where for any i, 0  ≤  i  ≤  n,

[formula]

Then by modifying the fooling set argument of Jirásková [\cite=Jiraskova:2005] one obtains a fooling set of size 2n for [formula], giving the desired result. (One obtains the fooling set for [formula] by appending a 2 to the second word in each pair of the fooling set for [formula].)

Shortest word not accepted

Finally, we consider one more problem. Given an n-state NFA M with all states final, such that [formula], how long can the shortest unaccepted string be? At first glance it might appear that such a string has to be of length ≤  n, but this is not the case.

There exists an n-state NFA M with all states final, such that the smallest string not accepted by M has length 2cn for some constant 0  <  c  ≤  1.

In [\cite=Ellul&Krawetz&Shallit&Wang:2004] the authors show that there exist n-state NFAs M over a 2-letter alphabet Σ such that the shortest string not accepted is of length 2cn for some constant 0  <  c  ≤  1. We take such an NFA M, and add a new symbol, say #  , with transitions on #   from every final state of M back to M's initial state. Now make all states final. Call the resulting NFA M'. Since M accepts ε, its initial state is also final, and hence M' has a transition from its initial state to itself on #  .

We claim that [formula], but the shortest string not accepted by M' is at least as long as that for M. Let w be the shortest string not accepted by M, of length N. Then either there is no path in M labeled w, or every path labeled w in M, arrives at a non-accepting state in M. In either case w  #   fails to be accepted by M'. On the other hand, M' accepts all strings shorter than w, since any shorter string w' is of the form [formula] for some strings [formula], where each wi has length <  N. Starting in the initial state of M', we read w1, which is accepted by M since it is of length <  |w|. If w'  =  w1, then w1 is accepted by M'. Otherwise we follow the transition on #   back to the initial state of M' and continue with w2, etc.

We can obtain a similar result for NFAs where all states are both initial and final. In this case, we again add a new symbol #  , with transitions on #   from every final state of M back to M's initial state, and then make all states both initial and final. Now we argue as above, except we consider the string #  w  #   instead.

Acknowledgments

We are very grateful to Andrew Malton for having suggested the problem. We thank the referees for reading the paper carefully and correcting several errors.