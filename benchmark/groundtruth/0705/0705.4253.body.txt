Convergence of the Min-Sum Algorithm for Convex Optimization

Introduction

Consider an optimization problem of the form

[formula]

Here, the vector of decision variables x is indexed by a finite set [formula]. Each decision variable takes values in the set X. The set C is a collection of subsets of the index set V. This collection describes an additive decomposition of the objective function. We associate with each set C∈C a component function (or factor) [formula], which takes values as a function of those components xC of the vector x identified by the elements of C.

The min-sum algorithm is a method for optimization problems of the form [\eqref=eq:separable]. It is one of a class of methods know as message-passing algorithms. These algorithms have been the subject of considerable research recently across a number of fields, including communications, artificial intelligence, statistical physics, and theoretical computer science. Interest in message-passing algorithms has been sparked by their success in solving certain classes of NP-hard combinatorial optimization problems, such as the decoding of low-density parity-check codes and turbo codes (e.g., [\cite=Gallager63] [\cite=Berrou93] [\cite=Richardson01]), or the solution of certain classes of satisfiability problems (e.g., [\cite=Mezard02] [\cite=Braunstein05]).

Despite their successes, message-passing algorithms remain poorly understood. For example, conditions for convergence and accurate resulting solutions are not well characterized.

In this paper, we consider cases where [formula], and the optimization problem is continuous. One such case that has been examined previously in the literature is where the objective is pairwise separable (i.e., |C|  ≤  2, for all C∈C) and the component functions {fC(  ·  )} are quadratic and convex. Here, the min-sum algorithm is known to compute the optimal solution when it converges [\cite=Weiss01] [\cite=Rusmevichientong01] [\cite=Wainwright03], and sufficient conditions for convergence identify a broad class of problems [\cite=Moallemi06b] [\cite=Malioutov06].

Our main contribution is the analysis of cases where the functions are convex but not necessarily quadratic. We establish that the min-sum algorithm and its asynchronous variants converge for a large class of such problems. The main sufficient condition is that of scaled diagonal dominance. This condition is similar to known sufficient conditions for asynchronous convergence of other decentralized optimization algorithms, such as coordinate descent and gradient descent.

Analysis of the convex case has been an open challenge and its resolution advances the state of understanding in the growing literature on message-passing algorithms. Further, it builds a bridge between this emerging research area and the better established fields of convex analysis and optimization.

This paper is organized as follows. The next section studies the min-sum algorithm in the context of pairwise separable convex programs, establishing convergence for a broad class of such problems. Section [\ref=se:generalconvex] extends this result to more general separable convex programs, where each factor can be a function of more than two variables. In Section [\ref=se:async], we discuss how our convergence results hold even with a totally asynchronous model of computation. When applied to a continuous optimization problem, messages computed and stored by the min-sum algorithm are functions over continuous domains. Except in very special cases, this is not feasible for digital computers, and in Section [\ref=se:impl], we discuss implementable approaches to approximating the behavior of the min-sum algorithm. We close by discussing possible extensions and open issues in Section [\ref=se:open].

Pairwise Separable Convex Programs

Consider first the case of pairwise separable programs. These are programs of the form [\eqref=eq:separable], where |C|  ≤  2, for all C∈C. In this case, we can define an undirected graph (V,E) based on the objective function. This graph has a vertex set V corresponding to the decision variables, and an edge set E defined by the pairwise factors,

[formula]

(Pairwise Separable Convex Program) A pairwise separable convex program is an optimization problem of the form

[formula]

where the factors {fi(  ·  )} are strictly convex, coercive, and twice continuously differentiable, the factors {fij(  ·  ,  ·  )} are convex and twice continuously differentiable, and

[formula]

Under this definition, the objective function F(x) is strictly convex and coercive. Hence, we can define [formula] to be the unique optimal solution.

The Min-Sum Algorithm

The min-sum algorithm attempts to minimize the objective function F(  ·  ) by an iterative, message-passing procedure. For each vertex i∈V, denote the set of neighbors of i in the graph by

[formula]

Denote the set of edges with direction distinguished by

[formula]

At time t, each vertex i keeps track of a "message" from each neighbor u∈N(i). This message takes the form of a function [formula]. These incoming messages are combined to compute new outgoing messages for each neighbor. The message J(t + 1)i  →  j(  ·  ) from vertex i to vertex j∈N(i) evolves according to

[formula]

Here, κ(t + 1)i  →  j represents an arbitrary offset term that varies from message to message. Only the relative values of the function J(t + 1)i  →  j(  ·  ) matter, so the choice of κ(t + 1)i  →  j does not influence relevant information.

At each time t > 0, a local objective function b(t)i(  ·  ) is defined for each variable xi by

[formula]

An estimate x(t)i can be obtained for the optimal value of the variable xi by minimizing the local objective function:

[formula]

The min-sum algorithm requires an initial set of messages {J(0)i  →  j(  ·  )} at time t = 0. We make the following assumption regarding these messages:

Assumption [\ref=as:pairwiseinit] guarantees that the messages at time t = 0 are convex functions. Examining the update equation [\eqref=eq:Jupdate], it is clear that, by induction, this implies that all future messages are also convex functions. Similarly, since the functions {fi(  ·  )} are strictly convex and coercive, and the functions {fij(  ·  ,  ·  )} are convex, it follows that the optimization problem in the update equation [\eqref=eq:Jupdate] is well-defined and uniquely1 minimized. Finally, each local objective function b(t)i(  ·  ) must strictly convex and coercive, and hence each estimate x(t)i is uniquely defined by [\eqref=eq:pairwiseest].

Assumption [\ref=as:pairwiseinit] also requires that the initial messages be sufficiently convex, in the sense of [\eqref=eq:J0convex]. As we will shortly demonstrate, this will be an important condition for our convergence results. For the moment, however, note that it is easy to select a set of initial messages satisfying Assumption [\ref=as:pairwiseinit]. For example, one might choose

[formula]

Convergence

Our goal is to understand conditions under which the min-sum algorithm converges to the optimal solution x*, i.e.

[formula]

Consider the following diagonal dominance condition:

An objective function [formula] is (λ,w)-scaled diagonally dominant if λ is a scalar with 0  <  λ  <  1 and [formula] is a vector with w  >  0, so that for each i∈V and all [formula],

[formula]

Our main convergence result is as follows:

Consider a pairwise separable convex program with an objective function that is (λ,w)-scaled diagonally dominant. Assume that the min-sum algorithm is initialized in accordance with Assumption [\ref=as:pairwiseinit]. Define the constant

[formula]

Then, the iterates of the min-sum algorithm satisfy

[formula]

Hence,

[formula]

The proof for Theorem [\ref=th:pairwiseconv] will be provided in Section [\ref=se:convproof].

We can compare Theorem [\ref=th:pairwiseconv] to existing results on min-sum convergence in the case of where the objective function F(  ·  ) is quadratic. Rusmevichientong and Van Roy [\cite=Rusmevichientong01] developed abstract conditions for convergence, but these conditions are difficult to verify in practical instances. Convergence has also been established in special cases arising in certain applications [\cite=Moallemi06a] [\cite=Montanari05].

More closely related to our current work, Weiss and Freeman [\cite=Weiss01] established convergence when the factors {fi(  ·  ),fij(  ·  ,  ·  )} are quadratic, the single-variable factors {fi(  ·  )} are strictly convex, and the pairwise factors {fij(  ·  ,  ·  )} are convex and diagonally dominated, i.e.

[formula]

The results of Malioutov, et al. [\cite=Malioutov06] and our prior work [\cite=Moallemi06b] remove the diagonal dominance assumption. However, all of these results are special cases of Theorem [\ref=th:pairwiseconv]. In particular, if the a quadratic objective function F(  ·  ) decomposes into pairwise factors so that the single-variable factors are quadratic and strictly convex, and the pairwise factors are quadratic convex, then F(  ·  ) must be scaled diagonally dominant. This can be established as a consequence of the Perron-Frobenius theorem [\cite=Malioutov06]. Finally, as we will see in Section [\ref=se:generalconvex], Theorem [\ref=th:pairwiseconv] also generalizes beyond pairwise decompositions.

The Computation Tree

In order to prove Theorem [\ref=th:pairwiseconv], we first introduce the notion of the computation tree. This is a useful device in the analysis of message-passing algorithms, originally introduced by Wiberg [\cite=Wiberg96]. Given a vertex r∈V and a time t, the computation tree defines an optimization problem that is constructed by "unrolling" all the optimizations involved in the computation of the min-sum estimate x(t)r.

Formally, the computation tree is a graph T = (V,E) where each vertex i∈V is in labeled by a vertex ĩ∈V in the original graph, through a mapping σ: V  →  V. This mapping is required to preserve the edge structure of the graph, so that if (i,j)∈E, then (σi,σj)∈E. Given a vertex i∈V, we will abuse notation and refer to the corresponding vertex σi∈V in the original graph simply by i.

Fixing a vertex r∈V and a time t, the computation tree rooted at r and of depth t is defined in an iterative fashion. Initially, the tree consists of a root single vertex corresponding to r. At each subsequent step, the leaves in the computation tree are examined. Given a leaf i with a parent j, a vertex u and an edge (u,i) are added to the computation tree corresponding to each neighbor of i excluding j in the original graph. This process is repeated for t steps. An example of the resulting graph is illustrated in Figure [\ref=fig:pairwise-tree].

Given the graph T = (V,E), and the correspondence mapping σ, define a decision variable xi for each vertex i∈V. Define a pairwise separable objective function [formula], by considering factors of the form:

For each i∈V, add a single-variable factor fi(xi) by setting [formula].

For each (i,j)∈V, add a pairwise factor fij(xi,xj) by setting [formula].

For each i∈V that is a leaf vertex with parent j, add a single-variable factor J(0)u  →  σi(xi), for each neighbor [formula] of i in the original graph, excluding j.

Now, let [formula] be the optimal solution to the minimization of the computation tree objective [formula]. By inductively examining the operation of the min-sum algorithm, it is easy to establish that the component r of this solution at the root of the tree is precisely the min-sum estimate x(t)r.

The following lemma establishes that the computation tree inherits the scaled diagonal dominance property from the original objective function.

Consider a pairwise separable convex program with an objective function that is (λ,w)-scaled diagonally dominant. Assume that the min-sum algorithm is initialized in accordance with Assumption [\ref=as:pairwiseinit], and let T = (V,E) be a computation tree associated with this program. Then, the computation tree objective function [formula] is also (λ,w)-scaled diagonally dominant.

Given a vertex i∈V, let [formula] be the neighborhood in the computation tree, and let N(i) be the neighborhood of the corresponding vertex in the original graph. If i∈V is an interior vertex of the computation tree, then

[formula]

where the inequality follows from the scaled diagonal dominance of the original objective function F(  ·  ).

Similarly, if i is a leaf vertex with parent j,

[formula]

Here, the second inequality follows from the scaled diagonal dominance of the original objective function F(  ·  ), and the third inequality follows from Assumption [\ref=as:pairwiseinit].

Proof of Theorem [\ref=th:pairwiseconv]

In order to prove Theorem [\ref=th:pairwiseconv], we will study the evolution of the min-sum algorithm under a set of linear perturbations. Consider an arbitrary vector [formula] with one component pi  →  j for each i∈V and j∈N(i). Given an arbitrary vector p, define {J(t)i  →  j(  ·  ,p)} to be the set of messages that evolve according to

[formula]

Similarly, define {b(t)i(  ·  ,p)} and {x(t)i(p)} to be the resulting local objective functions and optimal value estimates under this perturbation:

[formula]

The following simple lemma gives a particular choice of p for which the min-sun algorithm yields the optimal solution at every time.

Define the vector [formula] by setting, for each i∈V and j∈N(i),

[formula]

Then, at every time t  ≥  0,

[formula]

and x(t)j(p*)  =  x*j.

Note that the first order optimality conditions for F(x) at x* imply that, for each j∈V,

[formula]

If [\eqref=eq:Jpstar] holds at time t, this is exactly the first order optimality condition for the minimization of b(t)j(  ·  ,p*), thus x(t)j(p*)  =  x*j.

Clearly [\eqref=eq:Jpstar] holds at time t = 0. Assume it holds at time t  ≥  0. Then, when xj = x*j, the minimizing value of yi in [\eqref=eq:Jpstar] is x*i. Hence, [\eqref=eq:Jpstar] holds at time t + 1.

Next, we will bound the sensitivity of the estimate x(t)i(p) to the choice of p. The main technique employed here is analysis of the computation tree described in Section [\ref=se:comptree]. In particular, the perturbation p impacts the computation tree only through the leaf vertices at depth t. The scaled diagonal dominance property of the computation tree, provided by Lemma [\ref=le:comptreedd], can then be used to guarantee that this impact is diminishing in t.

We have, for all [formula], r∈V, [formula], and t  ≥  0,

[formula]

Fix r∈V, and let T = (V,E) be the computation tree rooted at r after t time steps. Let [formula] be the objective value of this computation tree, and let

[formula]

so that

[formula]

By the first order optimality conditions, for any j∈V,

[formula]

If j is an interior vertex of T, this becomes

[formula]

If j is a leaf with parent u, we have

[formula]

Now, fixed some directed edge (a,b), and differentiate [\eqref=eq:fo1]-[\eqref=eq:fo2] with respect to pa  →  b. We have, for an interior vertex j,

[formula]

and for a leaf vertex j with parent u,

[formula]

We can write this system of equations in matrix form, as

[formula]

Here, [formula] is a vector with components

[formula]

The vector [formula] has components

[formula]

The symmetric matrix [formula] has components as follows:

If j is an interior vertex,

[formula]

If j is an interior vertex and i∈N(j),

[formula]

If j is a leaf vertex with parent u,

[formula]

All other entries of Γ are zero.

Note that [formula]. Then, Lemma [\ref=le:comptreedd] implies that

[formula]

Define, for vectors [formula], the weighted sup-norm

[formula]

For a linear operator [formula], The corresponding induced operator norm is given by

[formula]

Define the matrices

[formula]

Then, [\eqref=eq:gammacont] implies that

[formula]

Hence, the matrix I  -  R  =  D- 1Γ is invertible, and

[formula]

Examining the linear equation [\eqref=eq:lineq], we have

[formula]

We are interested in bounding the value of the component va  →  br (recall that va  →  br  =  ∂x(t)r(p) / ∂pa  →  b). Hence, we have

[formula]

Since ha  →  b is zero on interior vertices, and any leaf vertex is distance t from the root r, we have

[formula]

Thus,

[formula]

Then,

[formula]

The following lemma combines the results from Lemmas [\ref=le:pstarexact] and [\ref=le:psensitivity]. Theorem [\ref=th:pairwiseconv] follows by taking p = 0.

Given an arbitrary vector [formula],

[formula]

For any j∈V, define

[formula]

We have, from Lemma [\ref=le:pstarexact],

[formula]

By the mean value theorem and Lemma [\ref=le:psensitivity],

[formula]

General Separable Convex Programs

In this section we will consider convergence of the min-sum algorithm for more general separable convex programs. In particular, consider a vector of real-valued decision variables [formula], indexed by a finite set V, and a hypergraph (V,C), where the set C is a collection of subsets (or "hyperedges") of the vertex set V.

A general separable convex program is an optimization problem of the form

[formula]

where the factors {fi(  ·  )} are strictly convex, coercive, and twice continuously differentiable, the factors {fC(  ·  )} are convex and twice continuously differentiable, and

[formula]

In this setting, the min-sum algorithm operates by passing messages between vertices and hyperedges. In particular, denote the set of neighbor hyperedges to a vertex i∈V by

[formula]

The min-sum update equations take the form

[formula]

Local objective functions and estimates of the optimal solution are defined by

[formula]

We will make the following assumption on the initial messages:

Then, we have the following analog of Theorem [\ref=th:pairwiseconv]:

Consider a general separable convex program. Assume that either:

The objective function F(x) is scaled diagonally dominant, and each pair of vertices i,j∈V participate in at most one common factor. That is,

[formula]

The factors {fC(  ·  )} are individually scaled diagonally dominant, in the sense that exists a scalar λ∈(0,1) and a vector [formula], with w  >  0, so that for all C∈C, i∈C, and [formula],

[formula]

Assume that the min-sum algorithm is initialized in accordance with Assumption [\ref=as:generalinit]. Define the constant

[formula]

Then, the iterates of the min-sum algorithm satisfy

[formula]

Hence,

[formula]

This result can be proved using the same method as Theorem [\ref=th:pairwiseconv]. The main modification required is the development of a suitable analog of Lemma [\ref=le:comptreedd]. In the general case, scaled diagonal dominance of the computation tree does not follow from scaled diagonal dominance of the objective function F(x). However, it is easy to verify that either of the hypotheses (i) or (ii) imply scaled diagonal dominance of the computation tree. The balance of the proof proceeds as in Section [\ref=se:convproof].

Asynchronous Convergence

The convergence results of Theorems [\ref=th:pairwiseconv] and [\ref=th:generalconv] assumed a synchronous model of computation. That is, each message is updated at every time step in parallel. The min-sum update equations [\eqref=eq:Jupdate] and [\eqref=eq:generalJupdate] are naturally decentralized, however. If we consider the application of the min-sum algorithm in distributed contexts, it is necessary to consider convergence under an asynchronous model of computation. In this section, we will establish that Theorems  [\ref=th:pairwiseconv] and [\ref=th:generalconv] extend to an asynchronous setting.

Without loss of generality, consider the pairwise case. Assume that there is a processor associated with each vertex i in the graph, and that this processor is responsible for computing the message Ji  →  j(  ·  ), for each neighbor j of vertex i. Each processor occasionally communicates its messages to neighboring processors, and occasionally computes new messages based on the most recent messages it has received. Define the Ti to be the set of times at which new messages are computed. Define 0  ≤  τj  →  i(t)  ≤  t to be the last time the processor at vertex j communicated to the processor at vertex i. Then, the messages evolve according to

[formula]

if t∈Ti, and

[formula]

otherwise.

We will make the following assumption [\cite=BertsekasPDP]: Total asynchronism is a very mild assumption. It guarantees that each component is updated infinitely often, and that processors eventually communicate with neighboring processors. It allows for arbitrary delays in communication, and even the out-of-order arrival of messages between processors.

Theorem [\ref=th:pairwiseconv] can be extended to the totally asynchronous setting. To see this, note that we can repeat the construction of the computation tree in Section [\ref=se:comptree]. As in the synchronous case, the initial messages only impact the leaves of computation tree. The total asynchronism assumption guarantees that these leaves are, eventually, arbitrarily far away from the root of the computation tree. The arguments in Lemma [\ref=le:psensitivity] then imply that the optimal value at the root of the computation tree is insensitive to the choice of initial messages. Convergence follows, as in Section [\ref=se:convproof].

The scaled diagonal dominance requirement of our convergence result is similar to conditions required for the totally asynchronous convergence of other optimization algorithms. Consider, for example, a decentralized coordinate descent algorithm. Here, the processor associated with vertex i maintains an estimate x(t)i of the ith component of the optimal solution at time t. These estimates are updated according to

[formula]

if t∈Ti, and x(t + 1)i  =  x(t)i, otherwise.

Similarly, consider a decentralized gradient method, where

[formula]

if t∈Ti, and x(t + 1)i  =  x(t)i, otherwise, for some small positive step size α. These methods are not guaranteed to converge for arbitrary pairwise separable convex optimization problems. Typically, some sort of diagonal dominance condition is needed [\cite=BertsekasPDP].

Implementation

The convergence theory we have presented elucidates properties of the min-sum algorithm and builds a bridge to the more established areas of convex analysis and optimization. However, except in very special cases, the algorithm as we have formulated it can not be implemented on a digital computer because the messages that are computed and stored are functions over continuous domains. In this section, we present two variations that can be implemented to approximate behavior of the min-sum algorithm. For simplicity, we restrict attention to the case of synchronous min-sum for pairwise separable convex programs.

Our first approach approximates messages using quadratic functions and can be viewed as a hybrid between the min-sum algorithm and Newton's method. It is easy to show that, if the single-variable factors {fi(  ·  )} are positive definite quadratics and the pairwise factors {fij(  ·  ,  ·  )} are positive semidefinite quadratics, then min-sum updates map quadratic messages to quadratic messages. The algorithm we propose here maintains a running estimate (t) of the optimal solution, and at each time approximates each factor by a second-order Taylor expansion. In particular, let (t)i(  ·  ) be the second-order Taylor expansion of fi(  ·  ) around (t)i and let (t)ij(  ·  ,  ·  ) be the second-order Taylor expansion of fij(  ·  ,  ·  ) around ((t)i,(j)j). Quadratic messages are updated according to

[formula]

where running estimates of the optimal solution are generated according to

[formula]

Note that the message update equation [\eqref=eq:quadratic-update] takes the form of a Ricatti equation for a scalar system, which can be carried out efficiently. Further, each optimization problem [\eqref=eq:quadratic-minimizer-update] is a scalar unconstrained convex quadratic program.

A second approach makes use of a piecewise-linear approximation to each message. Let us assume knowledge that the optimal solution x* is in a closed bounded set n. Let [formula], with [formula], be a set of points where the linear pieces begin and end. Our approach applies the min-sum update equation to compute values at these points. Then, an approximation to the min-sum message is constructed via linear interpolation between consecutive points or extrapolation beyond the end points. In particular, the algorithm takes the form

[formula]

for xj∈S, where

[formula]

for all [formula]. As opposed to the case of quadratic approximations, where each message is parameterized by two numerical values, the number of parameters for each piecewise linear message grows with m. Hence, we anticipate that for fine-grain approximations, our second approach is likely to require greater computational resources. On the other hand, piecewise linear approximations may extend more effectively to non-convex problems, since non-convex messages are unlikely to be well-approximated by convex quadratic functions.

Open Issues

There are many open questions in the theory of message passing algorithms. They fuel a growing research community that cuts across communications, artificial intelligence, statistical physics, theoretical computer science, and operations research. This paper has focused on application of the min-sum message passing algorithm to convex programs, and even in this context a number of interesting issues remain unresolved.

Our proof technique establishes convergence under total asynchronism assuming a scaled diagonal dominance condition. With such a flexible model of asynchronous computation, convergence results for gradient descent and coordinate descent also require similar diagonal dominance assumptions. On the other hand, for the partially asynchronous setting, where communication delays and times between successive updates are bounded, such assumptions are no longer required to guarantee convergence of these two algorithms. It would be interesting to see whether convergence of the min-sum algorithm under partial asynchronism can be established in the absence of scaled diagonal dominance.

Another direction will be to assess practical value of the min-sum algorithm for convex optimization problems. This calls for theoretical or empirical analysis of convergence and convergence times for implementable variants as those proposed in the previous section. Some convergence time results for a special case reported in [\cite=Moallemi06a] may provide a starting point. Our expectation is that for most relevant centralized optimization problems, the min-sum algorithm will be more efficient than gradient descent or coordinate descent but fall short of Newton's method. On the other hand, Newton's method does not decentralize gracefully, so in applications that call for decentralized solution, the min-sum algorithm may prove to be useful.

Finally, it would be interesting to explore whether ideas from this paper can be helpful in analyzing behavior of the min-sum algorithm for non-convex programs. It is encouraging that convex optimization theory has more broadly proved to be useful in designing and analyzing approximation methods for non-convex programs.

Acknowledgments

The first author was supported by a Benchmark Stanford Graduate Fellowship. This research was supported in part by the National Science Foundation through grant IIS-0428868.