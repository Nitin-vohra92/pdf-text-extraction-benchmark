Efficient quantum circuits for arbitrary sparse unitaries

Quantum Algorithm

Following [\cite=Aharonov_Tashma] we call an N  ×  N matrix V combinatorially block diagonal if there exists a permutation matrix P such that PVP- 1 is block diagonal and the largest block is d  ×  d for [formula]. We say V is row-computable if there is a polynomial-time algorithm which, given a row index [formula], computes the values of all of the nonzero matrix elements in row i of V. In [\cite=Aharonov_Tashma] Aharonov and Ta-Shma show that quantum circuits can efficiently implement all row-computable combinatorially block diagonal unitaries. More precisely, one can implement U satisfying [formula] using [formula] quantum gates. As a corollary to this, quantum circuits can also efficiently simulate time evolution according to combinatorially block diagonal Hamiltonians. That is, one can implement U satisfying [formula] using [formula] gates[\cite=Aharonov_Tashma].

We call a matrix row-sparse if each row has at most polynomially many nonzero entries. A row-sparse Hamiltonian can always be written as a sum of polynomially many combinatorially block diagonal Hamiltonians. Thus, using the Trotter formula, one can implement the time evolution e- iHt for any N  ×  N d-sparse Hamiltonian H to precision ε using a quantum circuit of [formula] gates[\cite=Aharonov_Tashma]. Subsequent work has improved the efficiency of such Hamiltonian simulations[\cite=Childs_thesis] [\cite=Cleve_sim]. This suggests the question of whether sparse unitaries can generically be implemented by quantum circuits of polynomially many gates. As shown below, the answer is yes.

Let U be an N  ×  N unitary such that each row or column has at most d nonzero entries, and these entries are efficiently computable. Adapting ideas from [\cite=Harrow] we let

[formula]

It is easy to see that H is a row-sparse, row-computable Hermitian matrix, [formula], and [formula]. Because [formula] it follows that

[formula]

As discussed above, the time evolution e- iHt induced by any row-sparse row-computable N  ×  N Hamiltonian H can be implemented to precision ε by a quantum circuit of [formula] gates. By equation 2, choosing t  =  π / 2 yields

[formula]

Thus,

[formula]

The global phase - i is irrelevant. The action |1〉  →  |0〉 on the ancilla qubit can be made into the identity by adding an initial NOT gate.

This technique works for all sparse efficiently computable unitaries, but it is not restricted to sparse unitaries. It works for any U such that H, as given by equation [\ref=hu], can be efficiently simulated. Recent results of Childs[\cite=Childs_nonsparse] show, among other things, how to efficiently simulate any Hamiltonian H whose entrywise absolute value has at most polynomially large operator norm. By our results, this implies efficient quantum circuits for all unitaries satisfying the same condition. Furthermore, any future advances in Hamiltonian simulation will imply, via the technique given here, a corresponding advancement in efficient quantum circuit implementation of unitaries.

Simple counting arguments show that arbitrary (non-sparse) unitaries on n qubits require exponentially many quantum gates to implement[\cite=Nielsen_Chuang]. A simple procedure using O(22n) quantum gates to implement an arbitrary unitary is given in section 4.5 of [\cite=Nielsen_Chuang]. Far more sophisticated techniques have subsequently been devised to construct more efficient (but still exponentially large) quantum circuits implementing arbitrary unitaries on n qubits[\cite=Shende] [\cite=Brennan] [\cite=Tucci] [\cite=Nakajima1] [\cite=Nakajima2] [\cite=Berry].

Applications

We can formulate a model of quantum computation based on sparse unitary matrices. On n qubits, we consider any row-sparse, column-sparse, row-computable, and column-computable unitary to be implementable with unit cost. By the results above, the computations achievable with polynomial cost in this model can all be simulated efficiently by quantum circuits. That is, the problems solvable in polynomial time in this model are all contained in BQP. Conversely, quantum gates are row-sparse, column-sparse, row-computable, and column-computable unitaries due to their tensor product structure. Thus the sparse unitary model is equivalent to BQP.

We next show that the quantum Turing machine model, anyonic models, permutational quantum computation, and discrete time quantum walks all lie within the sparse unitary model of quantum computation. Thus we obtain as an immediate corollary to our efficient implementation for sparse unitaries the fact that all of these models are contained in BQP. Previously, these containments were each proved by different methods, some fairly complicated[\cite=Freedman] [\cite=AJL] [\cite=Yao] [\cite=Jordan_permute] [\cite=Childs_thesis].

Quantum Turing Machines

Following [\cite=Bernstein_Vazirani], a quantum Turing machine consists of a two-way infinite tape such that each site has a finite alphabet Σ of states, and a head that moves along the tape one step at a time, manipulating the states of the sites and transitioning between a finite set Q of internal states. The location of the head, the strings written on the tape, and the internal state of the head are all allowed to go into superposition. The dynamics of the quantum Turing machine is determined by a transition rule [formula]. If q∈Q is the current state of the head, σ∈Σ is the letter on the tape at the current location of the head, and d∈{L,R}, then Δ(q,σ,q',σ',d) is the amplitude for the head to change the letter on the tape to σ', transition into the internal state q', and move one step left or right on the tape depending on the value of d. (In a slight variant, some definitions also allow the head to stay in place.) Δ is not allowed to be arbitrary. The evolution it induces on the combined state space of the head and tape must be unitary. Furthermore, to prevent the "smuggling" of uncomputable quantities into the model, the amplitudes are required to be efficiently computable.

Let UΔ be the unitary transition matrix induced by applying the transition rule defined by Δ once. If we consider the entire infinite tape, then UΔ is infinite-dimensional. However, after t computational steps, the number of tape locations that can have been accessed is at most 2t + 1. Thus, the dynamics at each of the first t steps is completely captured by an m  ×  m truncated matrix U(t)Δ with m  =  (2t + 1)|Q||Σ|2t + 1. In general, the matrix U(t)Δ lacks any simple tensor product structure or block diagonality. However, it is sparse. Specifically, by the rule Δ, a given configuration has nonzero transition amplitude to only 2|Σ||Q| other configurations. (Or 3|Σ||Q| if the head is allowed to stay in place.) From initial state |x〉, the computation performed by the quantum Turing machine after s  <  t steps is [formula]. To simulate this, we can use our general technique for sparse unitaries. There is one extra technicality: truncation can result in a matrix U(t)Δ that is not completely unitary. As shown in appendix [\ref=trunc], one can achieve exponentially small error by using U(2t)Δ rather than U(t)Δ in the Hamiltonian of equation [\ref=hu].

Topological and Permutational Computing

In topological quantum computation, one computates by braiding anyons. For example, it is thought that the SU(N)k Chern-Simons anyons may arise as quasiparticle excitations in certain quantum Hall systems, and these may provide a robust way of performing quantum computation. Braiding n anyons induces a unitary representation of the n-strand braid group Bn. In addition to braiding, one can also fuse and split anyons. As described in [\cite=Kauffman] [\cite=Jordan_permute], the fusion rules provide a natural basis for the state preparations prior to braiding and the measurements at the end of the topological computation.

The braid group Bn on n strands is generated by [formula], where σj is the clockwise crossing of the neighboring strands j and j + 1. For the SU(N)k Chern-Simons anyons, in the basis defined by the anyonic fusion rules, the representations of the generators [formula] are each direct sums of easily computable 2  ×  2 blocks. Thus, the representations of these generators are sparse row- and column-computable unitaries, so any braid of polynomially many crossings can be simulated efficiently in the sparse unitary model. Conversely, any quantum circuit of polynomially many gates can be simulated by a braid of polynomially many crossings[\cite=Freedman] [\cite=Freedman2] [\cite=AJL]. The quantum algorithms for estimating Jones and HOMFLY polynomials also work by implementing these same representations of Bn using quantum circuits[\cite=AJL] [\cite=Wocjan_Yard] [\cite=Jordan_Wocjan].

Recently, a model of computation has been proposed based on the permutation of spin-1/2 particles in states of definite total angular momentum[\cite=Jordan_permute]. This model is closely analogous to topological quantum computation. The transformations induced by permuting n particles form a unitary representation of the symmetric group Sn. The basis for state preparation and measurement come from the fusion rules for adding angular momentum (i.e. for the combination of irreducible representations of SU(2)). Sn is generated by [formula], where we imagine Sn permuting n objects arranged on a line, and sj exchanges the [formula] and [formula] objects. The resulting representations of [formula] in the fusion basis has the same 2  ×  2 block diagonal structure as in topological quantum computing. These computations thus also fall into the sparse unitary framework.

Subgroup Adapted Bases

The block diagonal structure of the representations of the generators of Sn and Bn is not a coincidence. This structure stems from the fact that the fusion bases are subgroup adapted to the chain of subgroups [formula] in the case of Sn and [formula] in the case of Bn. As described in [\cite=generalft] such subgroup adapted structure causes the irreducible representations of a suitable set of generators for many groups to be direct sums of constant or polynomial size matrices. Efficient implementations of the resulting sparse unitaries are an essential ingredient of many non-Abelian quantum Fourier transforms including Beals' efficient quantum Fourier transform over the symmetric group[\cite=Beals].

Quantum Walks

Discrete time quantum walks are a quantum analogue to classical random walks. For example, consider the standard discrete quantum walk on the torus [formula]. The Hilbert space is spanned by |x,i〉, where [formula] are the sites on the torus, and i∈{0,1} is the value of an ancilliary degree of freedom called the coin[\cite=Childs_coins] [\cite=Ambainis_coins]. Each step in the walk consists of two substeps. First, a Hadamard gate is applied to the coin. Then, the walker is moved one step to the right or left depending on the value of the coin:

[formula]

(Here the additions and subtractions are done modulo n.) The above two steps yield a 2n  ×  2n unitary matrix with two nonzero entries in each row or column, and which is not combinatorially block diagonal. More generally, one can implement a discrete time quantum walk on any regular graph of degree d by using a coin of dimension d. For constant or polynomial d, each step of the quantum walk is the application of a sparse unitary. This places quantum walks within the sparse unitary framework.

Conclusion

As shown above, essentially all known discrete models of quantum computation are special cases of our sparse unitary model. Thus, as an immediate corollary to our result we find that all of these models are efficiently simulatable by quantum circuits. Previously the proofs of this for the various models were spread over many papers. Although some of these proofs can be made by appealing to the previously known method for implementing combinatorially block diagonal unitaries, the proofs for discrete time quantum walks and Turing machines cannot. Discrete time quantum walks can be efficiently simulated on quantum circuits using elementary techniques [\cite=Ambainis_coins]. However in the case of Turing machines, our result on sparse unitaries provides a substantial simplification over previously known proofs. Beyond this, we hope that the sparse unitary model of computation will be useful for the discovery of new fast quantum algorithms.

Acknowledgements

We thank Dominik Janzing for helpful discussions. While preparing this manuscript we learned from Andrew Childs that he has independently formulated the construction of equations [\ref=hu] though [\ref=final] in unpublished work. S.J. gratefully acknowledges support from the Sherman Fairchild foundation and the National Science Foundation under grant PHY-0803371. P.W. gratefully acknowledges the support by NSF grants CCF-0726771 and CCF-0746600.

Truncation of Turing Machines

Corresponding to the transition rule Δ of a quantum Turing machine, we define a truncated transition matrix U(t)Δ acting on a finite-dimensional Hilbert space. Specifically, we define U(t)Δ by its matrix elements as follows.

[formula]

Here p and p' are head positions, allowed to range from - t to t, q and q' are internal states of the head, and s and s' are states of a finite tape consisting of the cells [formula]. In general, U(t)Δ is not quite unitary because the full Turing machine has nonzero amplitudes to transition to head positions outside [formula] and these have been cut off. Nevertheless, the corresponding Hamiltonian

[formula]

is Hermitian and sparse. Because U(t)Δ is not unitary, equation [\ref=sincos] does not hold. If we start with the head at site r and time evolve for time π / 2 with H(2t), the resulting state is

[formula]

An application of the transition rule Δ, and hence an application of U(2t)Δ or H(2t), moves the head at most one step to the left or right. Hence, for any r,n  <  t, Hn(2t)|r,q0,s0〉  =  Hn|r,q0,s0〉. Thus in applying e- iH(2t)π / 2 to any state |ψt〉 with support only at head positions between - t and t, the truncation error only appears at orders t and higher in the Taylor series [\ref=taylor]. Thus, the truncation error [formula] is

[formula]

Applying [formula] and [formula] yields

[formula]

To simulate the dynamics of the Turing machine for t steps, one must apply the unitary transition rule t times. If the head starts at location 0 then the state during the first t time steps always has support only on head locations between - t and t. Thus the above error analysis holds at each step, and the total error is therefore at most te-  Ω(t).