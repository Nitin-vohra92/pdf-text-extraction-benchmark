Theorem Corollary Proposition

Characterizations of Stable Model Semantics for Logic Programs with Arbitrary Constraint Atoms

Introduction

Answer set programming (ASP) as an alternative logic programming paradigm has been demonstrated to be an effective knowledge representation formalism for solving combinatorial search problems arising in many application areas such as planning, reasoning about actions, diagnosis, abduction, and so on [\cite=Baral03] [\cite=GL02] [\cite=Lif02] [\cite=MT99] [\cite=Nie99]. In recent years, researchers have paid particular attention to extensions of ASP with means to model aggregate constraints in particular, and constraints on sets in general [\cite=CFLP05] [\cite=DFILP03] [\cite=DPB01] [\cite=EPS04] [\cite=EPS05] [\cite=FLP04] [\cite=Ferr05] [\cite=LPST07] [\cite=LT05] [\cite=LT06] [\cite=MNT06] [\cite=MR04] [\cite=MT04] [\cite=Pel04] [\cite=PDB03] [\cite=PDB07] [\cite=PT04] [\cite=SY07] [\cite=SNS02] [\cite=SP06-1] [\cite=SPT06] [\cite=SPT07]. Logic programs with constraint atoms were introduced as a general framework for representing, and reasoning with, sets of atoms [\cite=MNT06] [\cite=MR04] [\cite=MT04]. This is in contrast with traditional logic programs, which are used primarily to reason with individuals.

The abstract form of a constraint atom takes the form (D,C), where D is a finite set of atoms and C a collection of subsets from the power set of D, which expresses a constraint on the domain D with the collection C of admissible solutions.

By allowing constraint atoms to appear anywhere in a rule, the framework of logic programs has become a highly expressive knowledge representation language. For example, many constraints can be conveniently and compactly represented with constraint atoms such as weight and cardinality constraints and aggregates (see, e.g. [\cite=CFLP05] [\cite=DFILP03] [\cite=DPB01] [\cite=FLP04] [\cite=MT04] [\cite=Pel04] [\cite=SNS02]). In fact, any constraint studied in the context of constraint satisfaction problem (CSP) can be represented by a constraint atom. In this way, the framework of logic programs with constraint atoms can express complex constraint satisfaction problems, such as those involving conditional constraints [\cite=Cond-CSP-introd] (called dynamic CSPs), which are useful in modeling configuration and design problems. When the head of a rule is allowed to be a disjunction of constraint atoms, logic programs become capable of expressing, not only conditional constraints, but also disjunctive constraints, both of which have been investigated by the constraint programming community outside of logic programming (see, e.g. [\cite=disjunctive-constraint] [\cite=disj-JACM] [\cite=disjunctive-CSP]). For example, disjunctive constraints have been widely used in scheduling to ensure that the time intervals over which activities require the same resource do not overlap in time [\cite=disjunctive-constraint]. Although practical ASP languages and systems typically incorporate concrete, predefined constraint atoms, such as weight constraint atoms [\cite=SNS02] and aggregate atoms [\cite=dell-faber-ijcai-03], the adoption of the abstract form of constraint atoms has made it possible to study the semantics and properties of these programs in an abstract setting.

In this paper, we characterize and define stable models for logic programs with constraint atoms by introducing a succinct abstract representation of constraint atoms. In the current literature as mentioned above, a constraint atom is expressed as a pair (D,C), where D is a finite set of ground atoms and C a collection of sets of atoms in D. We call this a power set form representation (w.r.t. D) of constraint atoms, as C may involve the whole power set 2D of D. This is the case even for special classes of constraint atoms such as monotone constraint atoms (a constraint atom (D,C) is monotone if for any S  ⊂  D, whenever S∈C all of its supersets in 2D are in C).

For instance, suppose we have a monotone constraint atom A1  =  (D,2D). Semantically, this constraint atom is a tautology, since for any set I of atoms, it is a fact that I satisfies A1, in the sense that [formula]. A clever representation would just need to express two pieces of information, the "bottom element" [formula] and the "top element" D; two elements together implicitly cover all the sets in between. So, instead of using the power set representation to express all the admissible solutions of this constraint atom, we could use a pair of sets. As another example, consider a monotone constraint atom [formula]. A minimal element (set inclusive) in [formula] is a singleton in 2D. In this case, any minimal element B in 2D and D form a pair with B being the bottom element and D being the top. So, we could represent this constraint atom by a collection of pairs, one for each singleton in D. The number of such pairs in this case equals to the size of D.

In this paper, we introduce such an abstract representation. In general, the abstract representation of a constraint atom (Ad,Ac) is expressed as (Ad,A*c), where A*c consists of what will be called abstract prefixed power sets, denoted [formula], with W,V  ⊆  Ad and [formula]. Intuitively, [formula] represents a collection of sets of the form [formula] with S∈2V, all of which are in Ac.

The abstract representation of constraint atoms not only yields a compact representation, but also captures the essential information embodied in constraint atoms appearing in the bodies of rules. To substantiate this claim, we show two applications.

In the first application, we restore the power of the Gelfond-Lifschitz transformation by generalizing it for logic programs with constraint atoms. The key idea is that given an interpretation I, each constraint atom A = (Ad,A*c) under our abstract representation can be concisely characterized by a set of abstract satisfiable sets of the form [formula] such that [formula] covers [formula]. Therefore, the standard Gelfond-Lifschitz transformation can be naturally generalized to logic programs with constraint atoms by representing each constraint atom by its abstract satisfiable sets. We then use the generalized Gelfond-Lifschitz transformation to define stable models for disjunctive logic programs with constraint atoms. It turns out that, for non-disjunctive logic programs with arbitrary constraint atoms, the stable models defined this way are precisely those defined by Son et al. [\cite=SPT06] [\cite=SPT07] for logic programs with arbitrary constraint atoms, and the equivalent semantics, called the ultimate stable semantics, for aggregate logic programs [\cite=DPB01]. These semantics are defined by a substantially different approach, the fixpoint approach.

One advantage of our approach is that the semantics is defined for disjunctive programs where a constraint atom can appear anywhere in a disjunctive rule. This is due to the power of the Gelfond-Lifschitz transformation. Roughly speaking, for a non-disjunctive program with constraint atoms, a stable model M is just the least model of the reduct by the generalized Gelfond-Lifschitz transformation, while for a disjunctive program with constraint atoms, a stable model M is a minimal model of the reduct. We show that logic programs whose constraint atoms appearing in disjunctive rule heads are elementary possess the minimality property; i.e., for such logic programs, all stable models under the generalized Gelfond-Lifschitz transformation are minimal models. Thus, by the known relationships among different definitions of stable models, the stable model semantics defined in this paper extends the semantics of conventional disjunctive logic programs [\cite=GL91], the semantics defined by Marek and Truszczynski [\cite=MT04] for non-disjunctive logic programs with monotone constraint atoms, the semantics by Son et al. [\cite=SPT06] [\cite=SPT07], and others equivalent to it [\cite=DPB01] [\cite=PDB03].

We note that disjunctive programs with aggregates have been studied previously in [\cite=FLP04] [\cite=PT04], where aggregates do not appear in the heads of program rules.

In the second application, we show that our abstract representation of constraint atoms provides a means to characterize the dependency relation among ordinary atoms in a program with constraint atoms. This dependency relation in the past is defined using a dependency graph. One question for logic programs with constraint atoms is how this dependency graph may be constructed so that the means to characterize the properties of programs by odd cycles, even cycles, call-consistency, acyclic programs in the traditional context is applicable to the new context. We show that the information captured in our abstract representation is essential in constructing the dependency graph for a program with constraint atoms. As we will see, this is due to a simple way to represent a logic program with constraint atoms by a normal logic program.

To summarize, the main contributions of this paper are:

We introduce an abstract yet compact representation of constraint atoms, independent of any programs in which they appear.

Using this abstract representation, we present a generalized form of Gelfond-Lifschitz transformation and apply it to define stable models for disjunctive logic programs with constraint atoms. For non-disjunctive programs, the semantics defined this way coincides with the one based on conditional satisfaction [\cite=SPT06] [\cite=SPT07], and with the ones equivalent to it [\cite=DPB01].

We show that our abstract representation of constraint atoms encodes the information needed to capture the atom dependency relation in a given program, thus the means to characterize the properties for normal programs can still be applied to programs with constraint atoms, and in the process, the unfolding approach [\cite=SP06-1] is made simple.

The paper is structured as follows. Following the preliminaries in the next section, in Section [\ref=sec-abs] we present our abstract representation of constraint atoms. In Section [\ref=sec-chara-catom], we show some characterization of constraint atoms under this abstract representation. In Section [\ref=sec-genGL], we introduce a generalized Gelfond-Lifschitz transformation and apply it to define stable models for disjunctive logic programs with constraint atoms. In Section [\ref=sec-Son], we prove the relationship of our approach with Son et al.'s fixpoint approach [\cite=SPT06]. Then in Section [\ref=properties], we show that our abstract representation of constraint atoms encodes precisely the needed information to define the dependency graph of a program with constraint atoms. In Section [\ref=sec-rel], we discuss the related approaches. Finally in Section [\ref=sec-concl], we provide conclusions and discuss future work.

Proofs of theorems and lemmas will be delayed to Appendix.

Some results of this paper have been reported in [\cite=SY07]. The current paper, however, contains substantial new results.

Preliminaries

We consider propositional (ground) logic programs and assume a fixed propositional language with a countable set V of propositional atoms (atoms for short). Any subset I of V is called an interpretation. A literal is an atom A (a positive literal) or its negation not A (a negative literal). For a set S  =  {A1,...,Am} of atoms, we use not S to denote {not A1,...,not Am} and |S| to denote the size of S. For convenience, when S appears in a logic expression, it represents a conjunction [formula]; when not S appears in a logic expression, it represents a conjunction [formula].

An abstract constraint atom (or c-atom following [\cite=SPT06] [\cite=SPT07]) A is a pair (D,C), where D is a finite set of atoms in V and C a collection of sets of atoms in D, i.e., C  ⊆  2D. For convenience, we use Ad and Ac to refer to the components D and C of A, respectively. As a general framework, c-atoms can be used to represent any constraints with a finite set Ac of admissible solutions over a finite domain Ad.

A c-atom A is elementary if it is of the form ({a},{{a}}), where a is an atom. Due to the equivalence in satisfaction, an elementary c-atom may be simply written by the atom in it. A is monotone if it has the property that for any S  ⊂  Ad, if S∈Ac then all of its supersets in 2Ad are in Ac. A is nonmonotone if it is not monotone. A is antimonotone if Ac is closed under subsets, i.e., for every X,Y  ⊆  Ad, if Y∈Ac and X  ⊆  Y then X∈Ac. A is convex if for any S1,S,S2  ⊆  Ad such that S1  ⊆  S  ⊆  S2 and S1,S2∈Ac, we have S∈Ac.

A disjunctive constraint program, or a disjunctive (logic) program with c-atoms, is a finite set of rules of the form

[formula]

where k  ≥  1, m,n  ≥  0 and Hi, Ai and Bi are either an atom or a c-atom ("←" is omitted when m = n = 0). P is a normal constraint program if k = 1 for all of its rules; P is a positive constraint program if n = 0 for all of its rules; P is a positive basic program if n = 0 and k = 1 with H1 being an elementary c-atom for all of its rules. As usual, P is a normal program if P is a normal constraint program where all c-atoms are elementary; P is a disjunctive program if P is a disjunctive constraint program where all c-atoms are elementary.

In the sequel, if not specifically quantified, a logic program (or simply a program) refers to a disjunctive constraint program. To make it explicit, when a program contains only elementary c-atoms, it may be called a program with ordinary atoms, or just a program without c-atoms.

Let r be a rule of the above form. We define head(r)  =  {H1,...,Hk} body(r)  =  {A1,...,Am,not B1,...,not Bn} which will be referred to as the head and the body of the rule, respectively, where body(r) denotes the conjunction of the elements in the set and head(r) the disjunction. Without confusion, we may use the set notation in a rule to express the body as well as the head. For example, given a rule r, we may write head(r)←body(r).

We will use At(P) to denote the set of atoms that appear in a program P.

The satisfaction relation is defined as follows. An interpretation I  ⊆  V satisfies an atom a if a∈I; not a if [formula]. I satisfies a c-atom A if [formula]; not A if [formula]. This relation extends to arbitrary expressions F mentioning negation not, conjunction [formula] and disjunction [formula], in a usual way. We will use [formula] to denote that I satisfies F, and [formula] to denote that I does not satisfy F. We say F is true (resp. false) in I if and only if I satisfies (resp. does not satisfy) F.

I satisfies a rule r if it satisfies head(r) or it does not satisfy body(r). I is a model of a logic program P if it satisfies all rules of P. I is a minimal model of P if it is a model of P and there is no proper subset of I which is also a model of P. I is a supported model of P if for any a∈I, there is r∈P such that a∈head(r) and [formula].

As commented earlier, atoms can be viewed as elementary c-atoms. This is due to the fact that for an atom a, an interpretation I satisfies a iff a∈I iff [formula].

Sometimes we say a model M restricted to the atoms appearing in a program P. By this we mean [formula], and denote it by M|At(P).

Note that c-atoms of the form [formula] are not satisfied by any interpretation. We will use a special symbol [formula] to denote any such c-atom.

Following [\cite=SPT07], for any c-atom A  =  (Ad,Ac), its negation not A is interpreted by its complement, which is a c-atom (Ad,A-c) where [formula]. So a logic program with negated c-atoms can be rewritten to a logic program free of negated c-atoms by replacing all occurrences of negated c-atoms with their respective complement c-atoms. Due to this assumption, in the sequel we only consider logic programs without negated c-atoms in rule bodies.

Given a disjunctive program P (where c-atoms are elementary) and an interpretation I, the standard Gelfond-Lifschitz transformation of P w.r.t.I, written as PI, is obtained from P by performing two operations: (1) remove from P all rules whose bodies contain a negative literal not A such that [formula], and (2) remove from the remaining rules all negative literals. Since PI is a positive constraint program where c-atoms are elementary, it has a set of minimal models. I is defined to be a stable model of P if it is a minimal model of PI [\cite=GL88] [\cite=GL91] [\cite=Przy91].

The cardinality and weight constraints can be represented by c-atoms. In some of the example programs of this paper we may write weight constraints instead of c-atoms. We will adopt the notation proposed in [\cite=SNS02]. A weight constraint is an expression of the form

[formula]

where ai and bj are atoms and wai is the weight of atom ai and wbj is the weight of negative literal not bj. The numbers l and u are lower and upper bounds of the constraint, respectively. A weight constraint is satisfied by a set of atoms S if the sum of the weights of the literals in the set {a1,...,an,not b1,...,not bm} that are satisfied by S is between l and u (inclusive).

A cardinality constraint is a special case of weight constraint where each weight is one. In writing a cardinality constraint, we will omit the weights. A choice constraint is a cardinality constraint of the form l{a1,...,an}u, where l = 0 and u = n. In writing a choice constraint, we will omit the bounds.

Abstract Representation of Constraint Atoms

In this section, we present a compact representation of c-atoms. In the current literature, for any c-atom A its admissible solutions are all explicitly enumerated and written in Ac. In many cases, Ac may involve a large portion of Ad. It is then of great interest if we can represent Ac using some abstract structure so that its size can be substantially compressed. We begin by introducing a notion of prefixed power sets.

Let I = {a1,...,am} and J = {b1,...,bn} (m,n  ≥  0) be two sets of atoms.

The I-prefixed power set of J, denoted by [formula], is the collection [formula]; i.e., each set in the collection consists of all ais in I plus zero or more bis in J. For any set of atoms S, we say S is covered by [formula] (or [formula] covers S) if I  ⊆  S and [formula].

For any two abstract prefixed power sets [formula] and [formula], [formula] is included in [formula] if any set covered by [formula] is covered by [formula].

When [formula] is included in [formula], we have I1  ⊆  I and [formula]. If [formula] is included in [formula] and [formula] is included in [formula], then [formula] is included in [formula].

Given a c-atom A, let I∈Ac and [formula]. [formula] is called I-maximal in A (or just maximal) if all sets covered by [formula] are in Ac and there is no J' with [formula] such that all sets covered by [formula] are in Ac .

Let A be a c-atom and S∈Ac. The collection of abstract S-prefixed power sets of A is [formula].

For instance, consider a c-atom A, where

[formula]

For [formula], the collection of abstract [formula]-prefixed power sets of A is [formula]; for {b}∈Ac, the collection is [formula]; for {c}∈Ac, the collection is [formula]. Note that [formula] is included in [formula]. It is easy to check that all abstract prefixed power sets for {a,c},{b,c},{a,b,c}∈Ac are included in [formula] and all those for {b,c},{c,d},{b,c,d}∈Ac are included in [formula].

When a collection contains two abstract prefixed power sets, [formula] and [formula] with [formula] being included in [formula], we say [formula] is redundant in this collection.

For instance, consider [formula] where I  =  {a,b} and J  =  {c}, and [formula] where I'  =  {a} and J'  =  {b,c}. Then, [formula] is redundant in a collection that contains [formula], since every set covered by [formula] is covered by [formula].

The abstract representation A* of a c-atom A is a pair (Ad,A*c) where A*c is the collection [formula], where CS is the collection of abstract S-prefixed power sets of A, with all redundant abstract prefixed power sets removed.

Observe that when [formula] is in A*c, all sets in the collection [formula] are in Ac. Conversely, when [formula], there exist W',V'  ⊆  Ad such that W'  ⊆  W and [formula], and [formula], i.e., [formula] is included in [formula]. In other words, A*c is the collection of maximal sublattices of the lattice (2Ad,  ⊆  ), of which all elements are in Ac. For such a maximal sublattice [formula], the bottom element is W and the top element is [formula].

Consider the above example c-atom A again. Its abstract representation is (Ad,A*c) with [formula].

Let A = (Ad,Ac) be a c-atom.

A has a unique abstract form (Ad,A*c).

For any interpretation I, [formula] if and only if A*c contains an abstract prefixed power set [formula] covering [formula].

For some special classes of c-atoms, their abstract representations are much simpler and can be stated more structurally.

We need a terminology: given a set S of sets, we say that I∈S is minimal (resp. maximal) in S if there is no I'∈S such that I'  ⊂  I (resp. I'  ⊃  I).

Let A be a c-atom.

A is monotone if and only if [formula] if and only if |W|  +  |V|  =  |Ad| for each [formula].

A is antimonotone if and only if [formula] if and only if [formula] for each [formula].

A is convex if and only if [formula].

By this theorem, given A*, to check if A is monotone (resp. antimonotone) it suffices to check if |W|  +  |V|  =  |Ad| (resp. [formula]) for each [formula]. This process takes linear time in the size of A*c. Let [formula] and [formula]. To check if A is convex, it suffices to check (i) there are no p,q∈S1 with p  ⊂  q, and (ii) there are no p,q∈S2 with p  ⊂  q. Case (i) guarantees that W is minimal while case (ii) guarantees [formula] is maximal in Ac, for each [formula]. The time for the two cases is bounded by O(|A*c|2  *  |Ad|2), where each subset check is assumed to take time |Ad|2. This leads to the following complexity result.

Given the abstract representation A* of a c-atom A, the time to check if A is monotone or antimonotone is linear in the size of A*c, while the time to check if A is convex is bounded by O(|A*c|2  *  |Ad|2).

We now discuss the issue of compactness. Given a c-atom A, its abstract representation A* is more compact than A when Ac contains some relatively large abstract prefixed power sets. This can be seen from the special classes of c-atoms in Theorem [\ref=mono-conv-catom]. Since the admissible solutions in such a c-atom are tightly clustered together, they easily form large abstract prefixed power sets. For example, since a monotone c-atom is closed under its supersets in Ac, for any minimal set S in Ac, all the sets in between S and Ad must be in Ac. Therefore, [formula] is an abstract S-prefixed power set. The bigger is the difference between S and Ad, the more information is captured compactly. As another example, we know that weight constraints without negative literals or negative weights are convex. That is, these constraints are of the form l{a1  =  wa1,...,an  =  wan}u, where wai  ≥  0, for all 1  ≤  i  ≤  n. Let A denote such a weight constraint. Then, Ad  =  {a1,...,an} and Ac consists of all subsets of Ad where the sum of the weights of the atoms in such a subset is between l and u. Thus, if the sets B and T are such that B  ⊆  T  ⊆  Ad, and B is minimal and T is maximal in Ac, then [formula] forms an abstract B-prefixed power set, representing all the sets in between.

Apparently, c-atoms that are nearly monotone (or antimonotone or convex) can greatly benefit from the abstract representation. For example, given a set S  =  {a1,...,an}, a c-atom that expresses all subsets of S except some V in between [formula] and S can easily fall outside of the above special classes. For instance, suppose S  =  {a,b,c} and let [formula]. Then [formula].

It should also be clear that there are situations where A* may not be strictly more compact than A. This is typically the case where the admissible solutions in Ac are largely unrelated. We say that two sets I and J are unrelated if either no one is a subset of the other, or I  ⊆  J and [formula] is not singleton.

For example, consider a c-atom A where Ac consists of all subsets of Ad with an equal size. In this case, no set in Ac is a subset of another in Ac. The abstract representation of such a c-atom A is (Ad,A*c) where [formula], which trivially enumerates all admissible solutions in Ac. As another example, consider a c-atom [formula]. In this case, for any I,J∈Ac, if J is a superset of I, then [formula] is not singleton. The abstract representation of A is (Ad,A*c), where [formula]. Again, A*c essentially enlists all admissible solutions in Ac.

Although all the evidence indicates that for any c-atom A the number of abstract prefixed power sets in A*c is less than or equal to the number of admissible solutions in Ac, i.e. |A*c|  ≤  |Ac|, a rigorous proof for this claim seems challenging. We leave this proof as an interesting open problem.

Finally in this section, we comment that for a c-atom A, it takes polynomial time in the size of A to construct A*. This result will be useful in determining the complexity of the semantics defined by the generalized Gelfond-Lifschitz transformation later in this paper.

Below, we give a bound for the construction.

Let A be a c-atom. The time to construct A* from A is bounded by O(|Ac|4  *  |Ad|2).

Characterizations of C-Atoms under Abstract Representation

In this section, we present some characterizations of c-atoms under the abstract representation. Essentially, these characterizations are related to the fact that a c-atom can be semantically represented by a propositional formula.

Recall that the standard semantics of a c-atom A is defined by its satisfaction: for any set of atoms M, [formula] if and only if [formula]. For nonmonotone c-atoms, a difficulty with this interpretation of the meaning of a c-atom is that the iterative construction by the one-step provability operator [\cite=LT06] [\cite=MNT06] may lead to an undesirable situation - there is no guarantee that once a c-atom is satisfied by a set of atoms I, it remains to be satisfied by an extension of I.

However, by definition, a set of atoms M satisfies a c-atom A if and only if M satisfies the propositional formula that corresponds to the admissible solutions in Ac. This formula is a disjunction of conjunctions, each of which represents an admissible solution in Ac. As a propositional formula, it can be simplified to a logically equivalent one. It turns out that this simplification process is significant as it reveals the nature of the information encoded in our abstract representation. Therefore, the main result of this section is to show that the abstract representation of a c-atom encodes the "simplest" propositional formula, in the form of a disjunctive normal form (DNF). We then use this insight to define what are called abstract satisfiable sets, which make it possible to define a new form of Gelfond-Lifschitz transformation.

Below, we make it precise as what the formula is, and state some facts which easily follow from the definition.

Let A = (Ad,Ac) be a c-atom with Ac  =  {S1,...,Sm}, and I be an interpretation. The DNF [formula] for A is defined as: each Ci is a conjunction [formula].

I satisfies A if and only if [formula] is true in I.

I satisfies not A if and only if [formula] is true in I.

Given a c-atom A, the DNF [formula] for A can be simplified. In propositional logic, we have [formula], for any formulas S and F.

Consider a monotone c-atom A  =  ({a,b},{{a},{b},{a,b}}). Its corresponding DNF is [formula], which can be simplified as follows: [formula] [formula] [formula] Note that in the second line above a disjunct in the previous DNF is added.

What is interesting is that the resulting propositional formula corresponds to the abstract representation of A, where [formula]. This correspondence is made precise in the following theorem.

Let A be a c-atom and M be a set of atoms. [formula] if and only if M satisfies

[formula]

The proof of this theorem requires the following lemma.

Let E  =  {a1,...,am} be a set of atoms and F be a DNF covering all possible interpretations on the ais, i.e.

[formula]

F can be simplified to true in propositional logic by applying the following rule:

[formula]

Note that rule ([\ref=s-rule]) is like the resolution rule in its underlying pattern, but it applies to a DNF while resolution applies to CNFs.

Theorem [\ref=sem-catom-2] shows that the satisfaction of a c-atom A can be simplified to ([\ref=sem2]) in terms of its abstract representation by applying rule ([\ref=s-rule]).

As a slightly more involved example, consider a c-atom

[formula]

The DNF for this c-atom is:

[formula]

which can be simplified to

[formula]

each disjunct of which corresponds to a prefixed power set in the abstract representation of B, i.e., [formula].

We say that a DNF is maximally simplified if it cannot be further simplified by applying rule ([\ref=s-rule]).

The following theorem shows that ([\ref=sem2]) is maximally simplified.

The semantic characterization ([\ref=sem2]) of a c-atom A is maximally simplified.

Theorems [\ref=sem-catom-2] and [\ref=sem-catom-3] suggest that the satisfaction of c-atom A can be described by its simplest DNF given in ([\ref=sem2]), independently of any interpretations. When we generalize the standard Gelfond-Lifschitz transformation for constraint programs, we can apply a given interpretation to further simplify this DNF. In the following, and in the rest of the paper, given an interpretation I, for any c-atom A we use TIA to denote [formula] and FIA to denote [formula].

We are ready to define abstract satisfiable sets.

Let A be a c-atom and I an interpretation. [formula] is an abstract satisfiable set of A w.r.t. I if [formula] covers TIA. In this case, W is called a satisfiable set of A w.r.t. TIA. We use AIs to denote the set of abstract satisfiable sets of A w.r.t. I.

The next two theorems characterize some properties of abstract satisfiable sets as well as satisfiable sets.

Let A be a c-atom and I an interpretation. [formula] if and only if [formula].

Let A be a c-atom and I an interpretation. If S is a satisfiable set of A w.r.t. TIA, then for every S' with S  ⊆  S'  ⊆  TIA, we have S'∈Ac.

A Generalization of the Gelfond-Lifschitz Transformation

In this section we show that the characterizations of c-atoms presented in the last section can be used to generalize the standard Gelfond-Lifschitz transformation for logic programs with c-atoms.

In the following, special atoms of the forms θA, βA and [formula] will be used, where A is a c-atom. Unless otherwise stated, we assume that these special atoms will not occur in any given logic programs or interpretations. Let Γθ and Γβ be the sets of special atoms prefixed with θ and β, respectively. Let [formula].

Given a logic program P and an interpretation I, the generalized Gelfond-Lifschitz transformation of P w.r.t. I, written as PI, is obtained from P by performing the following four operations:

Remove from P all rules whose bodies contain either a negative literal not A such that [formula] or a c-atom A such that [formula].

Remove from the remaining rules all negative literals.

Replace each c-atom A in the body of a rule with a special atom θA and introduce a new rule θA←A1,...,Am for each satisfiable set {A1,...,Am} of A w.r.t. TIA.

Replace each c-atom A in the head of a rule with [formula] if [formula], or replace it with a special atom βA and introduce a new rule B←βA for each B∈TIA, a new rule [formula] for each B∈FIA, and a new rule βA←TIA.

In the first operation, we remove all rules whose bodies are not satisfied in I because of the presence of a negative literal or a c-atom that is not satisfied in I. In the second operation, we remove all negative literals because they are satisfied in I. The last two operations transform c-atoms in the body and head of each rule, respectively.

Each c-atom A in the body of a rule is substituted by a special atom θA. By Theorem [\ref=catom-chara], θA can be defined by introducing a new rule [formula] for each abstract satisfiable set [formula]. Since the negative part [formula] is true in I, it can be removed from the rule body following the standard Gelfond-Lifschitz transformation. Note that the remaining part W is a satisfiable set. Therefore, in the third operation, θA is defined by introducing a new rule θA←A1,...,Am for each satisfiable set {A1,...,Am} of A w.r.t. TIA.

When [formula], each c-atom A in the head of a rule is replaced by a special atom βA. Note that βA represents a conclusion that every B∈TIA is true and every B∈FIA is false in I. Such a conclusion is formulated, in the fourth operation, by introducing a new rule B←βA for each B∈TIA, a new rule [formula] for each B∈FIA, and a new rule βA←TIA. [formula] is a special atom meaning false. The last rule comes from the rule [formula], where the negative part not FIA is true in I and thus is removed following the standard Gelfond-Lifschitz transformation. When [formula], we replace A with [formula]. In the case that [formula] appears in a disjunction [formula] with m > 0, [formula] can be removed, as the satisfaction of the disjunction is determined by the Bis.

Apparently, the generalized Gelfond-Lifschitz transformation coincides with the standard Gelfond-Lifschitz transformation when P contains no c-atoms.

Since the generalized transformation PI is a positive logic program without c-atoms, it has minimal models. We then define the stable model semantics of a constraint program in the same way as that of a logic program with ordinary atoms.

For any logic program P, an interpretation I is a stable model of P if [formula], where M is a minimal model of the generalized Gelfond-Lifschitz transformation PI.

Immediately, if P is a normal constraint program, then I is a stable model of P if [formula] and M is the least model of the generalized Gelfond-Lifschitz transformation PI. In other words, the extension to disjunctive constraint programs from normal constraint programs follows the same way as the extension to disjunctive programs from normal programs.

Again, stable models of P under the generalized Gelfond-Lifschitz transformation coincide with stable models under the standard Gelfond-Lifschitz transformation when P has no c-atoms. In the following, unless otherwise stated, by stable models we refer to stable models under the generalized Gelfond-Lifschitz transformation.

Consider the following program: P1:   p(1). p( - 1)←p(2). p(2)←({X|p(X)})  ≥  1.

The aggregate constraint ({X|p(X)})  ≥  1 can be represented by a c-atom A where

[formula]

Its abstract representation is (Ad,A*c) with

[formula]

Let us check if I  =  {p( - 1),p(1),p(2)} is a stable model of P1 using the generalized Gelfond-Lifschitz transformation. The first two operations do not apply. Since [formula] with [formula], A has only one abstract satisfiable set [formula], and thus it has only one satisfiable set {p(2)} w.r.t. TIA. So, in the third operation A is replaced by a special atom θA, followed by a new rule θA←p(2). Hence we have PI1:   p(1). p( - 1)←p(2). p(2)←θA. θA←p(2). The only minimal model of PI1 is {p(1)}, so I is not a stable model of P1.

It is easy to check that this program has no stable model.

Consider a disjunctive constraint program: P2:   [formula]. a←b. where A is a c-atom [formula] and [formula].

Let I1  =  {a,b}. After performing the fourth operation, we obtain PI12:   [formula] a←βA. βA←a. b←βB. βB←b. a←b. PI12 has only one minimal model, M  =  {a,βA}; hence, I1 is not a stable model of P2.

Let I2  =  {a}. After performing the fourth operation, we obtain PI22:   βA. a←βA. βA←a. a←b. PI22 has one minimal model, M  =  {a,βA}; hence, I2 is a stable model of P2.

The introduction of disjunction into the head of a rule increases the expressiveness of the language, and allows natural representation using disjunction.

In scheduling, combinatorial counting or grouping is often needed. For example, a shift either has a in it, or not. If a is in it, then either a goes along with exactly one in {b,c}, or any two in {d,e,f}. This can be represented by a disjunctive program with cardinality constraints.

1{a,not a}1. [formula] The semantics of this program can be understood by the semantics of the corresponding constraint program: [formula] [formula] This program has the following stable models: [formula], {a,b}, {a,c}, {a,d,e}, {a,d,f}, and {a,f,e}.

Once c-atoms are allowed to appear in the disjunctive head of a rule, disjunctive aggregates may be expressed.

Suppose the set of atoms in our propositional language is {p( - 1),p(1),p(2)}. Consider the following program.

[formula] [formula] Its stable models are: {p(1),p(2)}, {p( - 1),p(1)}, and {p( - 1)}.

As commented in [\cite=SNS02], a weight constraint can be transformed to one with negative weights but without negative literals. The weight constraints of this kind in fact express linear inequations. Thus, a disjunction of weight constraints can be viewed as specifying a disjunction of linear inequations. For instance, the second rule in the above example can be expressed using weight constraints. To encode the SUM aggregate constraint above, let l ~ Σ  ~  u denote l{p( - 1) =  - 1,p(1)  =  1,p(2) = 2}u, where l and u are the lower and upper bounds, respectively. When l (resp. u) is omitted, it means -    ∞   (resp. ∞  ). Then, we can write the following rule

[formula]

where the right hand side encodes the COUNT aggregate constraint.

We argue that disjunctive logic programming with constraint atoms provides a rich knowledge representation language for modeling conditional as well as disjunctive constraints, which have been studied in the past in constraint programming (see, e.g., [\cite=disjunctive-constraint] [\cite=disj-JACM] [\cite=disjunctive-CSP]).

Properties of stable models

We now show some properties of stable models.

Any stable model M of a logic program P is a model of P.

A stable model may not be a minimal model for some constraint programs. To illustrate, consider a logic program [formula] It is easy to check that {a}, {b} and {a,b} are all stable models of P. We see that {a,b} is not minimal.

It turns out that logic programs whose c-atoms appearing in rule heads are elementary possess the minimality property.

Let P be a logic program such that c-atoms appearing in the heads of its rules are all elementary. Any stable model of P is a minimal model of P.

Recall that any atom A can be expressed as a c-atom A'  =  ({A},{{A}}) and any negative literal not A can be expressed as a c-atom [formula], such that for any interpretation I, [formula] (resp. [formula]) if and only if [formula] (resp. [formula]). The following result further justifies our generalization of the standard stable model semantics to logic programs with c-atoms.

Let P be a logic program with ordinary atoms and P' be P with each positive literal A replaced by a c-atom ({A},{{A}}), and each negative literal not A replaced by a c-atom [formula]. An interpretation I is a stable model of P if and only if it is a stable model of P'.

If all c-atoms are coded in the abstract representation, the time complexity of the generalized Gelfond-Lifschitz transformation is as follows.

Let P be a logic program with n different c-atoms that are coded in the abstract representation and I be an interpretation. Let A be a c-atom such that [formula].

The time complexity of computing all satisfiable sets of A w.r.t. TIA is linear in the size of A*c.

The time complexity of the generalized Gelfond-Lifschitz transformation is bounded by O(|P|  +  n * (2MA*c  +  MAd + 1)), where MA*c and MAd are the maximum sizes of A*c and Ad of a c-atom in P, respectively.

The following result is immediate.

The size of PI is bounded by O(|P|  +  n * (MA*c  +  MAd  +  1)).

Finally, we show the complexity of the major decision problem, namely the stable model existence problem. In the following, we assume the explicit representation of c-atoms A in the form (Ad,Ac) in a given program P.

The problem of deciding whether a stable model exists for a normal constraint program P is NP-complete.

The problem of deciding whether a stable model exists for a disjunctive constraint program P is Σ2P-complete.

Relationship to Conditional Satisfaction

Recently, proposed a fixpoint definition of stable models for logic programs with c-atoms. They introduce a key concept termed conditional satisfaction.

Let R and S be two sets of atoms. The set R conditionally satisfies a c-atom A w.r.t. S, denoted [formula], if [formula] and for every S' such that [formula] and [formula], we have S'∈Ac.

An immediate consequence operator TP(R,S) is introduced, which evaluates each c-atom using the conditional satisfaction [formula] instead of the standard satisfaction [formula].

Let P be a positive basic logic program and R and S be two sets of atoms. Define

[formula]

When the second argument is a model of P, TP is monotone w.r.t. the first argument. In particular, given a model M and let R  ⊆  U  ⊆  M, then TP(R,M)  ⊆  TP(U,M)  ⊆  M. Thus, for any model I, the sequence [formula] with [formula] and [formula], converges to a fixpoint [formula]. I is defined to be a stable model if it is the same as the fixpoint.

The following result reveals the relationship between conditional satisfaction and satisfiable sets.

Let A be a c-atom and R and I be two interpretations with R  ⊆  I. Let [formula]. [formula] if and only if A*c has an abstract prefixed power set [formula] such that [formula] is included in [formula] (thus W is a satisfiable set of A w.r.t. TIA and [formula]).

Theorem [\ref=sat-set] leads us to the conclusion that Son et al.'s fixpoint definition and our definition of stable models are semantically equivalent for positive basic programs, as stated formally by the following theorem.

Let P be a positive basic program and I a model of P. I is a stable model under Son et al.'s fixpoint definition if and only if it is a stable model derived from the generalized Gelfond-Lifschitz transformation.

Note that by Theorem [\ref=th-smodel-1], any stable model of a positive basic program is a minimal model.

When the head A of a rule r is not elementary, given an interpretation I, transform r into the following set of rules:   B←body(r),     for each B∈TIA [formula], for each B∈FIA. Under our generalized Gelfond-Lifschitz transformation, r is transformed into the following set of rules:   βA←body(r),   B←βA,     for each B∈TIA [formula], for each B∈FIA   βA←TIA. Apparently, the two transformations are semantically equivalent in that when body(r) is true, they derive the same conclusions except for the special atoms. Combining with Theorem [\ref=equal-models], we then conclude that Son et al.'s fixpoint definition and our definition of stable models under the generalized Gelfond-Lifschitz transformation are semantically equivalent for normal constraint programs.

Note that any normal constraint program can be transformed into a positive basic program by replacing each negative literal not B with a c-atom [formula] and replacing each negative c-atom not A with the complement [formula] of A. Therefore, our approach with the generalized Gelfond-Lifschitz transformation is semantically equivalent to Son et al.'s approach for normal constraint programs, as stated by the following result.

Let P be a normal constraint program and I a model of P. Let P' be P with each negative literal not B being replaced by [formula] and each negative c-atom not A replaced by [formula]. I is a stable model of P' under Son et al.'s approach if and only if it is a stable model of P' derived from the generalized Gelfond-Lifschitz transformation.

Properties based on Dependency Relation

In normal logic programming, the dependency relation over the atoms in a program is an essential notion based on which a number of important properties are characterized (see, e.g., [\cite=fages94] [\cite=sato-dependency] [\cite=y-y-94]). In this section, we extend these characterizations to normal constraint programs. A central question here is what should be the dependency graph for a given program. We will see that our abstract representation of c-atoms in the bodies of rules is precisely what is needed to construct such a dependency graph, for the semantics defined by .

In this section, a basic program P refers to a collection of rules of the form

[formula]

where H is either [formula] or an elementary c-atom, and Ai are arbitrary c-atoms. Each rule in a basic program is also called a basic rule.

To be consistent with the original definition of stable model [\cite=GL88], we assume that a rule of the form

[formula]

in a basic program is already replaced by a rule with an elementary head

[formula]

where f is a new symbol representing the elementary c-atom ({f},{{f}}) and the c-atom [formula] in the body is its complement.

The proof of the main result of this section is based on a method of representing a basic program by a normal program, directly using the abstract representation of c-atoms, while preserving the stable model semantics. Since the material is of interest on its own, we will first present it in the next subsection.

Representing basic programs by normal programs

The semantics of logic programs with c-atoms or aggregates have been studied by the unfolding approach [\cite=PDB03] [\cite=SP06-1]. It turns out, under our abstract representation of c-atoms, the unfolding approach can be made simple.

Let P be a basic program. The normal program translation of P, denoted Pn, is a normal program defined as follows. For each rule in P

[formula]

we have a rule

[formula]

in Pn, where θAi are new symbols, plus the following rules: for each 1  ≤  i  ≤  n,

[formula]

Consider the program P2 in Example [\ref=prog-2] again, which consists of the following rules

[formula]

Let A denote the aggregate in P2. Recall that [formula]. Thus, Pn consists of

[formula]

It is clear that this normal program has no stable models.

A distinct feature of our translation, as compared with the previous unfolding approach [\cite=PDB03] [\cite=SP06-1], is that the abstract representation of c-atoms is defined independently of any given program, while in [\cite=PDB03] [\cite=SP06-1], the translation to a normal program is an integrated process. This difference contributes to the simplicity of our approach.

The use of the abstract representation of c-atoms is essential. The following example shows that a simple enumeration of admissible solutions in a c-atom does not work. This is the case even for logic programs with only monotone c-atoms.

We now show that our translation preserves the stable models semantics. Though the result is presented as a lemma for proving Theorem [\ref=dependency-theorem] of the next subsection, it is obviously of independent interest.

Below, given a program P, we denote by ST(P) the set of stable models of P.

Let P be a basic program and Pn be its normal program translation. Then, ST(P)  =  {M|At(P)|MPn}.

Dependency relation-based characterizations

We are now ready to extend some of the well-known characterizations for normal programs to normal constraint programs. The key is the notion of a dependency graph for normal constraint programs.

Let P be a basic program. The dependency graph GP is a graph (V,E), where V  =  At(P) and E is the set of positive and negative edges defined as the follows: there is a positive edge from u to v, denoted u  →  +v, if there is a rule r of the form ([\ref=basic-rule]) in P such that head(r)  =  u, and for some Ai∈body(r) and [formula], v∈W; there is a negative edge from u to v, denoted u  →  -v, if there is a rule r of the form ([\ref=basic-rule]) in P such that head(r)  =  u, and for some Ai∈body(r) and [formula], [formula].

It is important to notice that, in the definition above, for an abstract prefixed power set [formula], although we know that for any I such that [formula] we have I∈Aic, positive edges are only into atoms in W, not into any atom in [formula]. Also, in normal logic programming, negative edges are only into negative literals in rule bodies, but here a negative edge may result from a positive c-atom in the body of a rule.

Suppose program P consists of a single rule

[formula]

Let A be the c-atom in the body of the above rule. Since [formula], we have a  →  -a, a  →  -c, and a  →  +b.

We say that P has an positive cycle if there is a path in GP from an atom to itself via only positive edges. P has an odd cycle if there is a path in GP from an atom to itself via an odd number of negative edges, and P has an even cycle if there is a path in GP from an atom to itself via an even number of negative edges. P is said to be call-consistent if P has no odd cycles. P is acyclic if it has no cycle of any kind.

We remark that our definition of dependency graph reduces to the standard one for normal programs. Recall that the dependency graph for a normal program is defined as: for each normal rule in a normal program P

[formula]

there is a positive edge a  →  +bi in GP for each i, and a negative edge a  →  -cj for each j.

A normal program is in fact a basic program, in the sense that each positive literal bi in the rule above is replaced by an elementary c-atom ({bi},{{bi}}) and each negative literal not ci replaced by [formula], i.e., the complement of ({ci},{{ci}}). Let the resulting program be P'. Since if [formula] then [formula], by Definition [\ref=dependency-graph], there is a negative edge a  →  -ci in GP'.

The following theorem shows that the well-known properties based on the dependency graphs for normal programs as shown in [\cite=y-y-94] remain to hold for normal constraint programs under the new definition of dependency graph for the latter.

Let P be a basic program.

P has a stable model if P is call-consistent.

P has more than one stable model only if P has an even loop.

P has a unique stable model if P is acyclic.

If P has no positive cycles, then every supported model of P is a stable model of P.

To illustrate the point (2) above, consider the following program.

[formula]

The program has two stable models {p,a} and {p,b}. Then, according to the theorem, there must exist an even loop in its dependency graph. Indeed, the edges a  →  -b and b  →  -a form such an even cycle.

Related Work

The notion of logic programs with c-atoms is introduced in [\cite=MR04] [\cite=MT04] and further developed in [\cite=LT05] [\cite=MNT06] [\cite=SP06-1] [\cite=SPT06]. As we mentioned earlier, major existing approaches can be roughly classified into three types: unfolding approaches, fixpoint approaches, and minimal model approaches.

Representative unfolding approaches to handling c-atoms include [\cite=PDB03] [\cite=SP06-1], where a notion of aggregate solutions (or solutions) is introduced. Informally, a solution of a c-atom A  =  (Ad,Ac) is a pair 〈S1,S2〉 of disjoint sets of atoms of Ad such that for every interpretation I, if S1  ⊆  I and [formula] then [formula]. This definition is given by . define an aggregate solution A as a pair 〈S1,S2〉 with S1  ⊆  S2  ⊆  Ad such that for every interpretation I, if S1  ⊆  I and [formula] then [formula]. In the following, we use the former definition.

It turns out that each [formula] corresponds to a minimal solution [formula] of A. A solution 〈S1,S2〉 of A is minimal if for no S3  ⊂  S1 nor S4  ⊂  S2, 〈S3,S2〉 or 〈S1,S4〉 is a solution of A. Firstly, [formula] is a solution of A; by Theorem [\ref=sem-catom-2] for any interpretation I, if W  ⊆  I and [formula] then [formula]. Secondly, [formula] is a minimal solution of A, as by Theorem [\ref=sem-catom-3], [formula] cannot be further simplified.

Representative fixpoint approaches include [\cite=LPST07] [\cite=MNT06] [\cite=MT04] [\cite=Pel04] [\cite=PT04] [\cite=SPT06] [\cite=SPT07]. Son et al. [\citeyear=SPT06] [\citeyear=SPT07] can handle arbitrary c-atoms, while [\cite=MNT06] [\cite=MT04] [\cite=PT04] apply only to monotone c-atoms. extend [\cite=LT05] [\cite=MNT06] [\cite=MT04] [\cite=PT04] for arbitrary c-atoms based on a concept of computation. Son et al. [\citeyear=SPT06] [\citeyear=SPT07] show that their fixpoint approach is semantically equivalent to that of for normal logic programs with monotone c-atoms; equivalent to that of and for positive basic logic programs with monotone c-atoms; equivalent to that of [\cite=DPB01] [\cite=PDB03] for positive basic logic programs with arbitrary c-atoms. In Section [\ref=sec-Son], we show that our approach using the generalized Gelfond-Lifschitz transformation is semantically equivalent to Son et al.'s approach for normal logic programs with arbitrary c-atoms. Therefore, the stable model semantics defined in this paper for disjunctive logic programs with arbitrary c-atoms extends these existing semantics.

propose a minimal model approach. To check if an interpretation I is a stable model of P, they first remove all rules in P whose bodies are not satisfied by I, then define I to be a stable model if it is a minimal model of the simplified program. They consider the class of disjunctive logic programs whose rule heads are a disjunction of ordinary atoms. Stable models of P under this semantics are minimal models of P. defines a stable model semantics in a different way, which (when negated c-atoms are treated as their complement c-atoms) agrees with the minimal-model based one on this class of programs. show that for normal logic programs whose c-atoms appearing in rule heads are elementary, stable models under their semantics are stable models under the semantics of and . It immediately follows that for such normal logic programs, stable models under our semantics are stable models under the semantics of Faber et al. and Ferraris. However, the converse is not necessarily true, even for positive basic logic programs. Consider the positive basic logic program P: b←c. c←d. [formula] P has only one model I  =  {b,c,d}. It is easy to check that I is not a stable model under the semantics of and ours. However, I is a stable model under the semantics of and . Observe that the truth of b,c,d can only be inferred via a self-supporting loop:

[formula]

This example program indicates that both the semantics of Faber et al. and that of Ferraris allow self-supporting loops.

Conclusions and Future Work

In this paper we have introduced an abstract representation of c-atoms. To substantiate the claim that the abstract representation captures the essential information correctly and compactly, we showed two applications. In the first one, we show that the semantics based on conditional satisfaction [\cite=SPT06] [\cite=SPT07], and the one equivalent to it [\cite=DPB01], can be defined by a generalized form of Gelfond-Lifschitz transformation, thus demonstrating that Gelfond-Lifschitz transformation can still play an important role in the study of semantics for logic programs with arbitrary c-atoms. In the second application, we show that our abstract representation of c-atoms encodes the information needed to define the atom dependency relation in a given program. As a result, the properties known to normal programs can be extended to programs with c-atoms. In this process, the unfolding approach [\cite=SP06-1] is made simple.

Several interesting tasks remain open. One is the possibility of showing that other semantics may be characterized by our abstract representation of c-atoms. This is because prefixed power sets identify "monotone components" of c-atoms. Another task is to develop new algorithms for efficiently constructing the abstract form of c-atoms from the power set form representation. Finally, methods for computing the stable models (under our generalized Gelfond-Lifschitz transformation) of logic programs with arbitrary c-atoms remain a challenging open problem.

Acknowledgments

We would like to thank the anonymous referees for their constructive comments and suggestions that helped us improve this work. Yi-Dong Shen is supported in part by NSFC grants 60673103, 60721061 and 60833001, and by the National High-tech R&D Program (863 Program). The work by Jia-Huai You and Li-Yan Yuan is supported in part by the Natural Sciences and Engineering Research Council of Canada.

Proof of Theorems and Lemmas

Proof of Theorem [\ref=t1]: Assume that [formula] is included in [formula]. We first prove I1  ⊆  I. If on the contrary [formula], there is an atom a such that a∈I1 and [formula]. This means that every S covered by [formula] must contain a. Since I is covered by [formula], I is covered by [formula]. But I does not contain a, a contradiction. We now prove [formula]. If on the contrary [formula], [formula] is not covered by [formula]. This means [formula] is not included in [formula], a contradiction.

Next, assume that [formula] is included in [formula] and [formula] is included in [formula]. We have I2  ⊆  I1  ⊆  I, and [formula]. This means all sets covered by [formula] are covered by [formula]. That is, [formula] is included in [formula]. [formula] Proof of Theorem [\ref=ab-form]: (1) For each S∈Ac, the collection CS of abstract S-prefixed power sets of A is uniquely defined by Definition [\ref=ab-1], thus A*c is uniquely defined by Definition [\ref=ab-2].

(2) Assume [formula], i.e., [formula]. By Definition [\ref=ab-1], the collection CS of abstract S-prefixed power sets of A contains [formula] covering S. By Definition [\ref=ab-2], A*c has an abstract prefixed power set [formula] such that either [formula] or [formula] is included in [formula]. This means that [formula] covers S.

Conversely, assume that A*c has an abstract prefixed power set [formula] covering [formula]. By Definition [\ref=ab-2], [formula] is an abstract W-prefixed power set of A with W∈Ac. By Definition [\ref=ab-1], all sets covered by [formula] are in Ac. This means [formula], and hence [formula]. [formula] Proof of Theorem [\ref=mono-conv-catom]: Let [formula], where CS is the collection of abstract S-prefixed power sets of A. By Definition [\ref=ab-2], A*c is G with all redundants removed.

([formula]) Assume that A is monotone. Then, all supersets of S∈Ac from 2Ad are in Ac, so all abstract S-prefixed power sets in G must be of the form [formula]. If S is not minimal in Ac, [formula] is redundant in G since for some S'  ⊂  S, which is minimal in Ac, [formula] is in G. Therefore, [formula]. Clearly, |W|  +  |V|  =  |Ad| for each [formula].

([formula]) Assume that for every [formula], we have |W|  +  |V|  =  |Ad|; i.e. [formula]. Every abstract S-prefixed power set in G must be of the form [formula], for otherwise, there is one [formula] with W  ⊆  S and [formula]. As shown above, in this case every [formula] in G is redundant unless S is minimal in Ac. Therefore, A*c is G with all [formula] removed, where S is not minimal in Ac. That is, [formula]. This shows that for any S' which is minimal in Ac, all supersets of S' are in Ac. For any S∈Ac, there is some S'  ⊆  S, which is minimal in Ac. Since all supersets of S' are in Ac, all supersets of S are in Ac. This shows that A is monotone.

([formula]) Assume that A is antimonotone. Every abstract S-prefixed power set in G must be of the form [formula]. By Definition [\ref=ab-1], T is maximal in Ac. That is, [formula]. Clearly, [formula] for each [formula].

([formula]) Assume that every abstract prefixed power set in A*c is of the form [formula]. By Definition [\ref=ab-1], T is maximal in Ac. That is, [formula]. Clearly, for any T∈Ac all subsets of T are in Ac. This shows that A is antimonotone.

([formula]) Assume that A is convex. Consider [formula] in G. If B is not minimal in Ac, since A is convex [formula] is included in [formula], where B'  ⊂  B is minimal in Ac. For the same reason, if [formula] is not maximal in Ac, [formula] is included in [formula], where T'  ⊃  T and [formula] is maximal in Ac. In both cases, [formula] is redundant in G. Therefore, A*c is G with all [formula] removed, where either B is not minimal or [formula] is not maximal in Ac. That is, [formula].

([formula]) Assume [formula]. Then, for any S1,S2∈Ac with S1  ⊂  S2, there is some [formula] in A*c, which covers all S with [formula]. This means that all subsets in between S1 and S2 are in Ac. That is, A is convex.

[formula] Proof of Theorem [\ref=construction-abstract-rep]: Let A be a c-atom. We use a simple algorithm to construct A*c. The algorithm returns a set, say Π, which is set to [formula] at the beginning.

Note that for any p∈Ac, |p|  ≤  |Ad|. Therefore, for any p,q∈Ac it takes O(|Ad|2) time to determine if p is a subset of q. Moreover, when p  ⊂  q, there are at most [formula] sets w such that p  ⊂  w  ⊂  q.

For each pair (p,q), where p,q∈Ac and p  ⊂  q, let S be the set of all w∈Ac such that p  ⊂  w  ⊂  q. If [formula], we add [formula] to Π. Since there are at most O(|Ac|2) such pairs to check, and for each, it takes O(|Ac|  *  |Ad|2) time to perform the test (i.e., for each w∈Ac we check if p  ⊂  w  ⊂  q), the time for the above process is bounded by O(|Ac|3  *  |Ad|2). Note that |Π| is bounded by O(|Ac|2).

After the above process, all possible abstract prefixed power sets of A are in the resulting Π. Then, we remove all (redundant) π from Π if π is included in some other ξ∈Π. By Theorem [\ref=t1], it takes O(|Ad|2) time to check if π is included in ξ. Therefore, the time for this redundancy removing process is bounded by O(|Ac|4  *  |Ad|2).

As a result, Π consists of all non-redundant abstract prefixed power sets of A. By Definition [\ref=ab-2], Π is A*c. In total, it takes O(|Ac|4  *  |Ad|2) time to construct A* from A. [formula] Proof of Proposition [\ref=th-sem]: (1) Assume that I satisfies A; i.e., [formula]. Then, we have [formula] with Si  ⊆  I and [formula]. This means that both Si and [formula] are true in I. Hence, Ci is true in I and thus [formula] is true in I. Conversely, assume that [formula] is true in I. Some [formula] must be true in I, meaning that Si  ⊆  I and [formula]. This shows that [formula]. Since Si∈Ac, I satisfies A.

(2) Assume that I satisfies not A; i.e., [formula]. Then, every [formula] is false in I because either [formula] or [formula]. Thus, [formula] is true in I. Conversely, assume that [formula] is true in I; i.e., every [formula] is false in I. This means that for each Si∈Ac, either [formula] or [formula]; therefore, [formula]. This shows [formula]; thus I satisfies not A. [formula] Proof of Lemma [\ref=catom-lem]: The proof is by induction on k with 1  ≤  k  ≤  m. When k = 1 (induction basis), [formula]. For the induction hypothesis, assume that [formula] can be simplified to true by applying rule ([\ref=s-rule]) for any k < m. This holds for k = m, as shown below:   F  =   [formula] [formula]

[formula]