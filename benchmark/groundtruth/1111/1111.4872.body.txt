Flipping the Winner of a Poset Game

Introduction

Definition of a Poset Game

A partially-ordered set consists of a set V of elements {v1,v2,v3,...}, and an ordering relation ≥  . This ordering relation is reflexive, transitive, and anti-symmetric. It is possible that for some elements, neither vi  ≥  vj nor vj  ≥  vi holds. A poset game is a two-player game played on a poset. A move in a poset game consists of choosing an element vi and removing all elements vj such that vj  ≥  vi, so that a smaller poset remains. The two players alternate moves. If a player cannot move because all elements have been removed, that player loses.

Impartial Games and Nim-Values

Many different kinds of Poset games have been studied by mathematicians. The oldest such game is Nim, the winning strategy of which was discovered in 1902 [\cite=bouton1901nim]. A game of Nim is played on several piles of elements, and a move consists in taking any number of elements from any one pile. The player who cannot move loses. Nim was solved by finding a simple method to determine if any position was winning or losing. The nim-sum, denoted [formula], of two numbers is computed by representing the numbers in binary and taking the bitwise parity of the two. In nim, the nim-value of a position is the nim-sum of the number of elements in each pile. If a position does not have nim-value 0, elements can be removed from a pile so that the nim-value is 0. The next player must change the nim-value to something else, but then the other player can just change it back to 0. Therefore, the player who first moves from a position of a nim-value of 0 can be forced to move from every position of nim-value 0 reached in the game. The empty position without any elements left has nim-value 0, so the player who first moved from a position of nim-value 0 can be forced to lose. If the nim-sum of the number of elements in each of the piles is 0, then the game is winning, and if it is not 0, then it is losing. See [\cite=bouton1901nim] for a more detailed explanation and proof of the winning strategy.

A pile of x elements in Nim can be seen as an x-tower in a poset game, where an x-tower is a tower of x vertices with v1  ≤  v2  ≤  v3  ≤  ...  ≤  vx. Since any game of Nim can be represented like this, Nim is actually a specific type of poset game. Other types of poset games include Schuh's game of divisors[\cite=Schuh52], proposed in 1952 by F. Schuh, played with a number and all its divisors expect 1, where a move consists of taking away a divisor and each of its multiples. Another example is Chomp, proposed in 1974 by D. Gale [\cite=Gale74], played on a rectangular grid with the upper left square missing, where a move consists of taking away a square and all squares below and to the right of it.

Poset Games

The Sprague-Grundy theorem, discovered independently by Sprague [\cite=Sprague35] and Grundy [\cite=Grundy39] states that impartial games where the last player to move wins are equivalent to a pile in nim. The nim-value Nim(G) of any impartial game G is defined recursively as the smallest non-negative integer for which there does not exist a move to a game of that nim-value. Since only finite poset games will be considered, and poset games are impartial and have last-player-win rules, the Sprague-Grundy theorem can be applied. By the Sprague-Grundy theorem, if two poset games, G1 and G2, are put next to each other to make a new game, then the resulting game has a nim-value of [formula]. The second player has a winning strategy on a poset game G if and only if Nim(G) = 0

Constructing [formula]

Overview of the Construction

Let Poset game G have size g. We will describe a method for constructing a game [formula] such that the first player has a winning strategy if and only if the second player has a winning strategy on G. Nim(G) does not need to be computed to construct [formula]. We will add vertices to construct a game G' such that Nim(G'), when expressed in binary, has a 1 in a known digit if and only if Nim(G)  ≠  0. We will use this to construct a game G''' with a Nim(G''') equal to 2⌊Log2(g)⌋ + 3 if G was winning, and 0 otherwise. By putting this next to a game with nim-value 2⌊Log2(g)⌋ + 3, we have constructed a game G'''' in which the first player has a winning strategy if and only if the second player has a winning strategy on G.

Lemmas Necessary for the Construction

A bottom vertex is a vertex that is less than all other vertices in the game. The process of adding a bottom vertex consists of adding a vertex that is defined as less than all other vertices at the time it is added. If more vertices are added, they may be defined as less than, greater than, or incomparable to this vertex.

Adding a bottom vertex increases the nim-value of a poset game by 1.

We will use induction on j, the size of the game. For the base case, a poset game of size 1 has a nim-value of 1, and when a bottom vertex is added, the nim-value is 2. For a poset game of size j with a nim-value of k, there exist moves to games of nim-values 0,1,2,3,...,k - 1, but no move to a game of nim-value k exists. By the induction hypothesis, the nim-values of these games change to 1,2,3,4,...,k when a bottom vertex is added, since these games all have fewer vertices than the original game. A move to a zero game exists, by taking away the bottom vertex. No move to a game of nim-value k+1 exists, since no game with nim-value k existed before the bottom vertex was added. Since there are moves to games of nim-values 0,1,2,3,…k, but not k + 1, the nim-value has changed from k to k + 1 by adding a bottom vertex. This proves the lemma.

An x-tower has a nim-value of x.

We will use induction on k. A 1-tower has a nim-value of 1. From a k-tower there exist moves to towers of every size from 0 to k - 1, and by the induction hypothesis those games have nim-values of every value from 0 to k - 1. Thus, the k-tower has nim-value k, proving the lemma.

We have two operations for modifying nim-values in a predictable way. When we add a bottom vertex, we increase the nim-value by one, so adding x bottom vertices in sequence to a a game G will result in a game with nim-value of Nim(G) + x. By putting an x-tower next to a game G, we get a game with a nim-value of [formula]-tower[formula]. By using the operations [formula] and + x in pairs, we can modify positive nim-values without modifying the nim-value of games with nim-value 0. We will first describe how the process affects games with non-zero nim-values, and then we will show how it affects games with nim-value 0.

Constructing [formula]

First, we will look at the case where the nim-value is not zero, and show a construction that flips the winner. After, we will show that this construction also flips the winner if the nim-value is zero.

For any poset game G with g vertices, if Nim(G)  ≠  0, the following procedure will create a game [formula] with [formula]:

1. Set i = 0

2. While 2i  ≤  g, add 2i bottom vertices, then put it next to a 2i-tower, then increment i by 1.

3. Let the resulting graph be G'

4. Add 2i bottom vertices, and put it next to a 2i-tower to get G''. Increment i by 1.

5. Put G' next to G'' and a 2i tower to get [formula]

The first step of the construction of [formula] is to add a bottom vertex to G and then to put a 1-tower (a single vertex) on the side. Then, add 2 bottom vertices and then a 2-tower to the side. We will keep repeating this process for powers of 2. Since we are using powers of 2, this only acts on a single digit at a time, although carrying that results from the addition could modify digits further to the left. If we continue this process, then there will always be a binary digit " to the left of the last digit modified directly. We will show this by examining the step in which we add 2k and then nim-add 2k to a nim-value Nim(G). 2k has only one digit in binary, so it is easy to add and nim-add with it.

Case 1:

[formula]

So if the 2kth digit of Nim(G) is ", then there is no change to Nim(G). The " to the left has not been changed and there is still a " to the left.

Case 2:

[formula]

If the 2kth digit of Nim(G) is " and there is a " to its immediate left, then that " gets changed to a ". A new " has been generated to the left.

Case 3:

[formula]

If the 2kth digit of Nim(G) is " and there is a string of "s of any non-zero length to its immediate left, then that string of "s is changed to a string of "s and the " to the left of the string is changed to a ". A new " has been generated to the left.

Because there are only g possible moves, Nim(G)  ≤  g. Therefore, when Nim(G) is expressed in binary notation, it has at most ⌊Log2(g)⌋ + 1 digits. Let the continuation of this process for ⌊Log2(g)⌋ + 2 total steps result in game G' with nim-value Nim(G'). We will have acted on every digit in the original nim-value, with 2⌊Log2(g)⌋ + 1 being the last digit that was directly acted on. There still will be a "1" to the left of the last digit modified directly. This digit could not have been part of the original nim-value, and since a new "1" can only be created to the immediate left of a "1", there must have been a "1" in the 2⌊Log2(g)⌋ + 2 place during some point of the process. If that "1" was created by case 3, then only "0"s would be acted on from that point on, so the nim-value would not change anymore. If that "1" was created by case 2, then it was created in the last step, and thus the nim-value did not change after that. So, there is a "1" in the 2⌊Log2(g)⌋ + 2 digit of Nim(G') place.

We then construct another copy of G' using the same process. With this copy of G', add 2⌊Log2(g)⌋ + 2 bottom verticies and then put a 2⌊Log2(G')⌋ + 2-tower on the side, and let the resulting game be G''. Then, we put G' next to G'' to make game G'''.

[formula]

Nim(G'') only differs from Nim(G') in a single, known digit, so when they are nim-added, the resulting game Nim(G''') has a nim-value of 2⌊Log2(g)⌋ + 3. The final step is to put a 2⌊Log2(g)⌋ + 3-tower next to G''', resulting in game G'''' that has nim-value 0 if the original game was winning.

Now, we will look at how the same exact process would affect a game with nim-value zero.

For any poset game G, if Nim(G)  =  0, the procedure described earlier will create a game [formula] with [formula]

Since adding a number to 0 and then nim-adding the same number cancel each other out, nearly every step had no effect on the nim-value.

[formula]

We have found that if Nim(G) was positive, Nim(G'''') is 0, and if Nim(G) was 0, Nim(G'''') is positive. The first player had a winning strategy for G'''' if he did not have a winning strategy for G, and he will not have a winning strategy for G'''' if he did have a winning strategy for G. Therefore, G''''=[formula].

The relation between any two vertices in the graph can easily be computed in polylogarithmic time given the edges of the old graph. If one vertex was added as a bottom vertex, it can be checked if the other vertex was added before it or not. If a vertex was added as part of a side tower, it can easily be checked whether the other vertex is higher in the tower. If a vertex was in the original grame, then the other vertex can only be greater than it if it was greater in the original game.

The size of [formula] is only a linear blowup from G

[formula]

This shows that it is possible to construct the not of a game with only a linear blowup.

Reduction of Boolean Formulas to Poset Games

Constructing OR and AND Gates

We will now show how to construct [formula] of two games A and B with only a linear blowup. Computing the OR of poset games is a folklore result, but we give the construction and proof for completeness. Given game A with elements a1,a2,a3,...,av and game B with elements b1,b2,b3,...,bw, game [formula] has elements a1,a2,a3,...,av,b1,b2,b3,...,bw and the additional set of relations bi  ≥  aj

If the first player can win A, he plays the winning move in game A. B disappears, so only the remainder of game A is being played, and since the first player just played the winning move there, he will win. If the first player cannot win game A, but he can win game B, he can play the winning move in game B. Both players would try to avoid playing in game A, since any move there is losing. So, they both play in game B, trying to force the other to make the first move in A. Since the first player can win game B, he can force the second player to play first in game A, so will be able to win. If both game A and game B are losing, then the second player can force the first player to make the first move in A, so the first player will not be able to win. We see that the first player will win this game if and only if he can win game A or game B.

It is possible to construct an OR of two games and a NOT of a game with only a linear blowup, and since [formula]=[formula], we can construct the AND of two games with only a linear blowup by using ORs and NOTs. Before our results, there was no known efficient procedure for computing the AND of poset games.

Reducing NC1 circuits to Poset Games

Given a boolean formula, we can represent false variables with a poset game of two isolated vertices, a game which is losing for the first player. We can represent true variables with a single-vertex game, which is winning for the first player. By using the constructions we have shown, we can model Boolean circuits with bounded fan-in. The result of a boolean formula will be a single poset game, which will be a first-player win if and only if the formula evaluates to true. If the boolean formula is one that can be evaluated by log-depth circuits, the poset game it is reduced to will have polynomial-size. This shows that finding the winning player of a poset game is an NC1-hard problem.

Future Work

The gap between NC1-hard and PSPACE is very large, and closing the gap is a possible topic for future work. The method of modifying poset games used in this paper might be used to reduce to and from other problems. Results by Byrnes [\cite=Byrnes03] suggest that poset games may not be PSPACE-complete, and could in fact be far easier. Expanding periodicity theorems to multiple rows of chomp might lead to a way to calculate the nim-value of a generic poset game.

Acknowledgements

This work would not have happened without the guidance and supervision of Dr. Lance Fortnow. He introduced me to the problem and advised me in preparing this paper. I would also like to thank Dr. Robert Sloan and Dr. Gyurgy Turan for introducing me to Professor Fortnow, and Steve Fenner for his useful comments on this paper. I am grateful to my past and current teachers, to MathPath and Canada/USA Mathcamp, and to the Illinois Mathematics and Science Academy's SIR program. Professor Fortnow is partially supported by NSF grants CCF-0829754 and DMS-0652521.