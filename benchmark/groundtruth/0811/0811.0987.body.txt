Proposition

Modular difference logic is hard

Introduction

The goal of this paper is to attract attention to the following problem: Given a system Σ of inequalities, find out whether Σ is satisfiable in a given machine arithmetic. We formalize a special case of the problem, in Section [\ref=sec:MDL], as the satisfiability problem for modular difference logic (MDL). MDL is a variant of integer difference logic (IDL) described in Section [\ref=sec:IDL]. The IDL satisfiability problem admits a simple and efficient decision procedure. It turns out that the MDL satisfiability problem is infeasible (unless P=  NP).

The MDL satisfiability problem is of particular relevance in the context of program verification and analysis. Established program verification environments [\cite=ESCModula] and abstract interpretation methods [\cite=Mine] have long relied on arithmetic over integers or over real numbers for reasoning about programs, and for a good reason. There are well known efficient methods for solving the satisfiability of linear arithmetic constraints over the reals, such as dual simplex or interior point methods. And integer constraints can be approached by extending simplex with Gomory cuts and branching methods; besides, important special cases, such as integer difference logic, admit efficient procedures. So the use of integer or even real semantics is well justified from the perspective of state of the art algorithms.

The obvious problem of course is that neither reals nor integers capture the proper semantics of machine arithmetic. Modular arithmetic, on the other hand, does capture machine arithmetic. Further, a system of difference constraints can be satisfiable over any fixed modulus N > 1 but unsatisfiable over integers or reals, e.g. 0  ≤  x and x  +  1  ≤  0. And a system of difference constraints can be satisfiable over integers and over reals, but unsatisfiable over a given modulus N, e.g. [formula].

It follows that the common program analysis tools tend to rely on methods that are both unsound and incomplete with respect to the accurate program semantics. We prove here that the MDL satisfiability problem is NP hard and thus the development of efficient tools for the MDL satisfiability problem is likely to be elusive. We also show that the problem is NP. The search for efficient methods for the MDL satisfiability problem is on.

Integer difference logic

Integer difference logic (IDL) is a fragment of linear arithmetic. IDL constraints have the form where x,y are integer variables and k is an integer constant. A system of IDL constraints may or may not have a solution. For example, the constraint system

[formula]

is unsatisfiable, which can be established by adding the left and right-hand sides separately:

[formula]

The IDL constraint satisfiability problem (IDL-SAT) admits an efficient decision procedure.

IDL-SAT is solvable in polynomial time.

Some efficient procedures for IDL-SAT are based on the Floyd-Warshall or Ford-Fulkerson style algorithms [\cite=Floyd] [\cite=Warshall] [\cite=FF]. IDL-SAT can be generalized to octagon constraints ±  x  ±  y  ≤  k while still retaining polynomial time solvability [\cite=Mine].

For the reader's convenience, we prove here the proposition. Our proof is based on the Floyd-Warshall algorithm.

Let Σ be a system of IDL constraints. Without loss of generality, we presume that, for every pair (x,y) of variables there is at most one constraint of the form x - y  ≤  k. Extend Σ with an additional variable [formula] adding constraints [formula] (that is [formula]) for every original variable x; given any solution for Σ, set [formula] to the maximal value of the original variables to get a solution of the extended system Σ+.

We construct a weighted directed graph G on the variables of Σ+: every constraint x - y  ≤  k gives rise to an edge from x to y of weight k. In particular we have a weight-zero edge from any original variable x to [formula]. If G has a cycle of negative weight - n that starts and ends at vertex x then an unsolvable constraint x  -  x  ≤   - n is obtained by adding the inequalities from Σ+ that gave rise to the edges in the cycle.

The polynomial-time Floyd-Warshall algorithm [\cite=Floyd] [\cite=Warshall] finds out whether G has negative cycles. Furthermore, suppose that G has no negative cycles. Then the Floyd-Warshall algorithm computes the minimal weight W(x,y) of any path from x to y; if there is no path from x to y then W(x,y)  =    ∞  . This allows us to construct a solution S for Σ.

Set [formula] and [formula] for every variable in Σ. Every constraint x - y  ≤  k of Σ is satisfied. Indeed, by the minimality of W, we have [formula] and W(x,y)  ≤  k. Hence S(x)  ≤  k  +  S(y) and S(x)  -  S(y)  ≤  k. (Note that [formula] is the minimal weight of any path from x on the original variables, so [formula] is not really needed.)

But integer difference logic cannot be directly used when reasoning about constraints coming from machine arithmetic because machine arithmetic uses modular addition. The question thus arises what is the complexity of the constraint satisfiability problem in the case of modular arithmetic? We establish here that the problem is NP complete.

Modular difference logic

Modular difference logic (MDL) is similar to integer difference logic except that integers are replaced with residues [formula] modulo a fixed positive integer N. The residues are ordered in the obvious way; the maximal residue is N - 1.

Instead of restricting attention to the residues, it may be beneficial to work, modulo N, with arbitrary integers, and we will often do that. But one should be careful not to confuse (a) the standard integer order ≤   and (b) another relation on integers, which we call ≤  N and will define shortly, that reflects the order of the residues. Each integer i is equal modulo N to a unique residue iN. Define i  ≤  Nj if iN  ≤  jN. Relations =  N,  ≥  N,  <  N,  >  N are defined accordingly. These definitions precisely match the semantics of comparison operations supported by current hardware architectures for machine arithmetic.

In the case of integers, a constraint x  -  y  ≤  k is equivalent to constraint x  ≤  y  +  k. This is not necessarily true in modular arithmetic. For example 9  -  5  ≤  105 but [formula]. Similarly x  +  1  ≤  Ny is not necessarily equivalent to x  ≤  Ny  -  1. For example, 5  ≤  100  -  1  =  109 but 5 + 1  >  100.

We define MDL constraints to have the form

[formula]

where x,y are variables and [formula] are constants. The MDL Satisfiability Problem (MDL-SAT) is the satisfiability problem for systems of MDL constraints.

From the point of view of logic, modular difference logic is a fragment of the first-order theory T of discrete linear order with both ends (and two constants for the two ends) and with the cyclic successor and predecessor function. The two constants could be called Min and Max. The successor of Max is Min, and the predecessor of Min is Max. The question arises what's x + k? This depends on the sign of k. If k  ≥  0 then x + k is the result of k-fold application of the successor function to x; otherwise x + k is the result of |k|-fold application of the predecessor function. The residues modulo N form a model of T where Min = 0 and Max = N - 1. There are also infinite models of T. One of them can be obtained by reordering the integers as follows:

[formula]

This order is reminiscent of the order ≤  N, where - 1 is also the maximal element.

It is known (and not hard to check, by means of an Ehrenfeucht-Fraïssé game [\cite=EF]) that, for every first-order sentence φ in the language of T, there is a natural number n, such that φ does not distinguish between any two models of T of size ≥  n. It follows that all infinite models of T are elementarily equivalent. In that sense, one may speak about the infinite model of T.

We are interested primarily in the case of a modulus N that is large. From the point of view of logic, we can as well work with the infinite model of T. Every constraint-satisfaction problem for MDL can be formulated as an existential sentence in the language of T.

MDL-SAT is NP hard

We now establish that a very modest fragment of MDL-SAT is NP hard.

Suppose that N  ≥  4. Then the fragment of MDL-SAT with constraints of the form

[formula]

is NP hard.

Given a graph G, we construct a system of MDL constraints that is satisfiable if and only if the graph is 3-colorable. It will be convenient to assume that the vertices of G are linearly ordered. This allows us to represent edges as ordered pairs (v,w) where v < w.

With every vertex v of G we associate three variables v0,v1, and v2 and three constraints

[formula]

One consequence of constraints [\eqref=eq:1a] is that at least one of the three variables takes the maximal value N - 1. With each edge e  =  (v,w) we associate six variables e1,e2,e3,f1,f2,f3 and nine constraints: three constraints

[formula]

for each c  =  0,1,2. One consequence of the three constraints [\eqref=eq:1b] is that residues vc and wc cannot simultaneously have the maximal value N - 1. Indeed, if vc  =  wc  =  N - 1 then, by the first and second constraints, ec  =  fc  =  0 which contradicts the third constraint. If all the constraints are satisfied then we have a 3-coloring for G: the color of a vertex v is the first number c such that vc  =  N - 1. By [\eqref=eq:1a], every vertex has a unique color. By [\eqref=eq:1b], no two adjacent vertices have the same color.

Now we suppose that G is 3-colorable (with colors 0,1,2) and prove that the constraint system is satisfiable. For every color c and every vertex v of color c, set

[formula]

where addition in the subscripts is modulo 3. Clearly all inequalities [\eqref=eq:1a] are satisfied. Now consider an edge e  =  (v,w) and a color c. We show how to satisfy the three constraints [\eqref=eq:1b].

Case 1: c is the color of v, so that vc  =  N - 1. Since w does not have color c, we have wc∈{0,1}. To satisfy the first of the three constraints, set ec  =  0. To satisfy the third constraint, set fc  =  N  -  1. The second constraint is satisfied as well: wc  ≤  1  ≤  N - 2.

Case 2: c is the color of w, so that wc  =  N - 1 and vc∈{0,1}. To satisfy the second constraint, set fc  =  0. To satisfy the first and third constraints, set ec  =  2.

Case 3: neither v nor w is of color c, so that both vc and wc are ≤  1. Set fc  =  2 and ec  =  3.

One may be interested in the variant of MDL-SAT where the modulus N is not fixed but is a part of the input. Theorem [\ref=th:1] and its proof remain valid.

Strict Inequalities

Over integers, a non-strict inequality x  -  y  ≤  k is equivalent to a strict inequality x  -  y  <  k + 1. The relation between non-strict and strict inequalities is much more subtle in modular arithmetic. With this in mind, we prove a version of Theorem [\ref=th:1] with strict inequalities.

Suppose that N  ≥  9. Then the fragment of the modified MDL-SAT with constraints of the form is NP hard.

In fact, we will use only values 0,1,2 for k and only values 0,1, - 1 for [formula].

The proof is again by reduction from the 3-colorability problem, and it is similar to the proof of Theorem [\ref=th:1]. Constraints [\eqref=eq:1a] replaced with constraints

[formula]

and constraints [\eqref=eq:1b] are replaced with constraints

[formula]

For each vertex v, constraints [\eqref=eq:2a] force at least one of the three residues vc to be ≥  N - 2. The idea is that when vc has value ≥  N - 2, then c is an acceptable color for v. Constraints [\eqref=eq:2b] imply that residues vc and wc cannot be simultaneously ≥  N - 2. Indeed, by the first of the three constraints, vc cannot have the maximal value N - 1, and if vc  =  N - 2 then ec  =  0. Similarly, wc  ≠  N - 1, and if wc  =  N - 2 then fc  =  0. If vc  =  wc  =  N - 2 then ec  =  fc  =  0 and then the third inequality fails. Thus, any solution of the new system of constraints yields a 3-coloring of G.

In the other direction, we need to convert a given 3-coloring of G into a solution for the constraint system. For every color c and every vertex v of color c, we set

[formula]

Clearly [\eqref=eq:2a] is satisfied. Now consider an edge e  =  (v,w) and a color c. We show how to satisfy the three constraints [\eqref=eq:2b]. As in the proof of Theorem [\ref=th:1], we consider three cases.

Case 1: c is the color of v, so that vc  =  N - 2 and wc∈{1,4}. To satisfy the first constraint, set ec  =  0. To satisfy the third constraint, set fc  =  N - 1. The second constraint is satisfied as wc  ≤  4  <  N  -  2  =  fc  -  1.

Case 2: c is the color of w so that wc  =  N - 2 and vc∈{1,4}. Set ec  =  6 and fc  =  0. Clearly [\eqref=eq:2b] is satisfied.

Case 3: Neither v nor w is of color c so that both vc and wc are in {1,4}. Set ec  =  7 and fc  =  6.

MDL-SAT is NP

In this section, we modify the satisfiability problem MDL-SAT for modular difference logic in two ways. First, the modulus N is a part of the input. Second, we liberalize the notion of MDL constraints by allowing constraints in the form of non-strict inequalities of the form

[formula]

strict inequalities of the form

[formula]

as well as equalities of the form

[formula]

Both modifications make the problem harder and thus make the next theorem stronger.

The constraint satisfiability problem MDL-SAT for modular difference logic is NP.

Let Σ be a system of MDL constraints with p variables. Let m be the maximum of the absolute values of the constants in the Σ constraints. We prove that, if Σ has any solution, then it has a solution where the absolute values of all variables are ≤  (2m + 1)p. It follows that MDL-SAT is NP.

Suppose that Σ has a solution S that maps the variables into the residues modulo N. To simplify the exposition, we extend Σ with two additional variables vmin,vmax and with two equations vmin  =  0, vmax  =   - 1. The solution S extends appropriately.

We create an auxiliary graph GS. The vertices are the variables of Σ, and the edges are pairs {v,w} such that |S(v)  -  S(w)|  ≤  2m. Connected components of GS will be called clusters. The domain of a cluster C is a closed interval

[formula]

, and let r be the right end of the domain of the left neighbor of C, so that a > r. If r  <  a'  <  a, shift C leftward for distance d  =  a  -  a', that is, modify assignment S to an assignment S' that is like S except that S'(v)  =  S(v)  -  d on the variables v of C. It is easy to see that S' is a solution for Σ. In a similar way clusters could be shifted to the right.

Now we are ready to produce the desired small-value solution. If there are inner clusters, shift the leftmost inner cluster C1 to the left as far as possible (so that a'  =  r + 1 in the notation of the previous paragraph). If there are inner clusters to the right of C1, shift the right neighbor C2 of C1 to the left as far as possible. And so on until all inner clusters are packed as close as possible on the left side. Let S* be the resulting solution. In the rest of the proof, variables represent their S* values.

In addition to vmin  =  0, there are [formula] original variables in the cluster of vmin and the inner clusters: [formula]. Every vi + 1  -  vi  ≤  2m  +  1. It follows that every [formula]. A similar argument applies to the cluster of vmax except that there the distance between neighboring variables is ≤  2m. Every variable v there is within distance 2pm from the end, so that |v|  ≤  2pm + 1. That completes the proof.

We have not used the fact that modulus N is a part of the input. The theorem and the proof remain valid if the modulus is fixed or even if it is infinite as in Remark [\ref=rem:logic].