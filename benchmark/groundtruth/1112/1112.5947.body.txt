Random Context and Semi-Conditional Insertion-Deletion Systems

Introduction

Insertion-deletion systems are a powerful theoretical computational device which is based on two elementary operations of insertion and deletion of substrings in a string. These operations were first considered with a linguistic motivation in [\cite=Marcus] and latter developed in [\cite=Galiuk] [\cite=Kluwer]. These references investigate Marcus contextual grammars which capture many interesting linguistic properties like ambiguity and duplication.

Another motivation for these operations can be found in [\cite=Haussler82] [\cite=Haussler83] where the insertion operation and its iterated variant is introduced as a generalization of Kleene's operations of concatenation and closure [\cite=Kleene56]. The operation of concatenation would produce a string xyz from two strings xy and z. By allowing the concatenation to happen anywhere in the string and not only at its right extremity a string xzy can be produced, i.e., z is inserted into xy. In [\cite=Kari] the deletion is defined as a right quotient operation which happens not necessarily at the rightmost end of the string.

The third inspiration for insertion and deletion operations comes, surprisingly, from the field of molecular biology. In fact they correspond to a mismatched annealing of DNA sequences, see [\cite=dna] for more details. Such operations are also present in the evolution processes under the form of point mutations as well as in RNA editing, see the discussions in [\cite=Beene] [\cite=BBD07] [\cite=Smith] [\cite=dna]. This biological motivation of insertion-deletion operations led to their study in the framework of molecular computing, see, for example, [\cite=Daley] [\cite=cross] [\cite=dna] [\cite=TY].

In general, an insertion operation means adding a substring to a given string in a specified (left and right) context, while a deletion operation means removing a substring of a given string from a specified (left and right) context. A finite set of insertion-deletion rules, together with a set of axioms provide a language generating device: starting from the set of initial strings and iterating insertion-deletion operations as defined by the given rules, one obtains a language.

Even in their basic variants, insertion-deletion systems are able to characterize the recursively enumerable languages, see [\cite=VerlanH] for an overview of known results. Moreover, as it was shown in [\cite=cfinsdel], the context dependency may be replaced by insertion and deletion of strings of sufficient length, in a context-free manner. If the length is not sufficient (less or equal to two) then such systems are not able to generate more than the context-free languages and a characterization of them was shown in [\cite=SV2-2].

Similar investigations were continued in [\cite=MRV07] [\cite=KRV08] [\cite=KRV08c] on insertion-deletion systems with one-sided contexts, i.e., where the context dependency is asymmetric and is present only from the left or only from the right side of all insertion and deletion rules. The papers cited above give several computational completeness results depending on the size of insertion and deletion rules. We recall the interesting fact that some combinations are not leading to computational completeness, i.e., there are languages that cannot be generated by such devices.

Similarly as in the case of context-free rewriting, it is possible to consider a graph-controlled variant of insertion-deletion systems. Thus the rules cannot be applied at any time, as their applicability depends on the current "state", changed by a rule application. Such a formalization is rather similar to the definition of insertion-deletion P systems [\cite=membr]. One-sided graph-controlled insertion-deletion systems where at most two symbols may be present in the description of insertion and deletion rules were investigated in [\cite=FKRV10]. This correspond to systems of size (1,1,0;1,1,0), (1,1,0;1,0,1), (1,1,0;2,0,0), and (2,0,0;1,1,0), where the first three numbers represent the maximal size of the inserted string and the maximal size of the left and right contexts, resp., while the last three numbers represent the same information for deletion rules. It is known that such systems are not computationally complete [\cite=KRV10], while the corresponding P systems and graph-controlled variants are. A summary of these results can be found in [\cite=AKRV10b] [\cite=VerlanH].

Further adaptation of control mechanisms from the area of regulated rewriting leads us to matrix insertion-deletion systems [\cite=PV10], where insertion and deletion rules are grouped in sequences, called matrices, and either the whole sequence is applied consecutively, or no rule is applied. It was shown that in the case of such control the computational power of systems of sizes above is strictly increasing. Moreover, binary matrices suffice to achieve this result giving a characterization similar to the binary normal form for matrix grammars.

In this paper we continue the investigation on the "regulated" insertion-deletion. We adapt the idea of semi-contextual and random context grammars to these systems. More precisely, a permitting and forbidding condition is associated to each insertion and deletion rule. In the case of semi-contextual control the conditions are based on sets of words, while in the random context case the conditions are sets of letters. A rule can be applied if all the words from the permitting condition are present in the string, while no word from the forbidding condition is present. We show that the computational completeness can be achieved by semi-conditional insertion-deletion systems whose permitting and forbidding conditions contain words of length at most 2 and using context-free insertion and deletion of one symbol, i.e. rules of size (1,0,0;1,0,0). This is quite interesting result showing that the semi-conditional control is very powerful - even in the case of graph-controlled insertion-deletion systems with appearance check only recursively enumerable sets of numbers can be obtained with same insertion and deletion parameters.

Until now all the results in the area of insertion-deletion systems (with or without control mechanisms) exhibited the property that the computational completeness is achieved or not at the same time by both systems of size (n,m,m';p,q,q') and (p,q,q';n,m,m'), i.e. when the parameters of insertion and deletion are interchanged. This empirical property suggested that with respect to the computational completeness the insertion and deletion rules are similar (even if the proofs use quite different ideas). This article shows for the first time that this property does not always hold, the counterexample being random context insertion-deletion systems of size (2,0,0;1,1,0) which generate all recursively enumerable languages, while systems of size (1,1,0;2,0,0) (and more generally of size (1,1,0;p,1,1)) cannot do this.

Preliminaries

We do not present the usual definitions concerning standard concepts of the theory of formal languages and we only refer to [\cite=handbook] for more details. The empty string is denoted by λ. The family of recursively enumerable, context-sensitive and context-free languages is denoted by RE, CS and CF, respectively. We will denote the length of a string w with |w|; we will refer to the number of occurrences of the symbol a in the string |w| by the notation |w|a.

In the following, we will use special variants of the Geffert normal form for type-0 grammars (see [\cite=Geffert91] for more details).

A grammar [formula] is said to be in Geffert normal form [\cite=Geffert91] if the set of non-terminal symbols N is defined as N = {S,A,B,C,D}, T is an alphabet and P only contains context-free rules of the forms S  →  uSv with u∈{A,C}+ and [formula] as well as S  →  λ and two (non-context-free) erasing rules AB  →  λ and CD  →  λ.

We remark that in the Geffert normal form we can easily transform the linear rules (suppose that A, B, C and D are treated like terminals) into a set of left-linear and right-linear rules (albeit by increasing the number of non-terminal symbols, e.g., see [\cite=membr]). More precisely, we say that a grammar [formula] with [formula], S,S'∈N', and N'' = {A,B,C,D}, is in the special Geffert normal form if, besides the two erasing rules AB  →  λ and CD  →  λ, it only has context-free rules of the following forms:

[formula]

Moreover, except rules of the forms X  →  Sb and X  →  S'b, we may even assume that for the first two types of rules it holds that the right-hand side is unique, i.e., for any two rules X  →  w and U  →  w in P we have U = X.

The computation in a grammar in the special Geffert normal form is done in two stages. During the first stage, only context-free rules are applied. During the second stage, only the erasing rules AB  →  λ and CD  →  λ are applied. These two erasing rules are not applicable during the first stage as long as the left and the right part of the current string are still separated by S (or S') as all the symbols A and C are generated on the left side of these middle symbols and the corresponding symbols B and D are generated on the right side. The transition between stages is done by the rule S'  →  λ (which corresponds to the rule S  →  λ from the Geffert normal form). We remark that all these features of a grammar in the special Geffert normal form are immediate consequences of the proofs given in [\cite=Geffert91].

Since during the first stage symbols A, B, C and D act like non-terminals, if no confusion arises, we consider that during this stage there is only one non-terminal and there are only left- and right-linear rules.

We give below the definitions of semi-conditional and random-context grammars, as given in [\cite=handbook].

A semi-conditional grammar is a quadruple G = (N,T,S,P), where N,T,S are specified as in a context-free grammar and P is a finite set of triples of the form p = (A  →  w;E,F), where A  →  w is a context-free production over [formula] and E,F are finite subsets of [formula]. Then, p can be applied to a string [formula] only if A appears in x, each element of E and no element of F is a subword of x. If E or F is the empty set, then no condition is imposed by E, or respectively, F. E is said to be the set of permitting and F is said to be the set of forbidding context conditions of p.

We remark that in some sources, e.g. [\cite=paun97], the definition of semi-conditional grammars implies that |E|  ≤  1, |F|  ≤  1. We consider the definition from [\cite=handbook] where the above restriction is not present. We denote by SCi,j the family of semi-conditional grammars where |w1|  ≤  i, |w2|  ≤  j, for any w1∈E and w2∈F for any rule (A  →  w;E,F) of the grammar.

A random context grammar is a semi-conditional grammar where E,F  ⊆  N.

Semi-conditional grammars generate all recursively enumerable or all context-sensitive languages, depending on whether λ-rules are used or not, respectively.

Insertion-deletion systems

An insertion-deletion system is a construct ID = (V,T,A,I,D), where V is an alphabet; T  ⊆  V is the terminal alphabet (the symbols from [formula] are called non-terminal symbols); A  ⊆  V* is the set of axioms; I,D are finite sets of triples of the form (u,α,v), where u, α (α  ≠  λ), and v are strings over V. The triples in I are insertion rules, and those in D are deletion rules. An insertion rule (u,α,v)∈I indicates that the string α can be inserted between u and v, while a deletion rule (u,α,v)∈D indicates that α can be removed from between the context u and v. Stated in another way, (u,α,v)∈I corresponds to the rewriting rule uv  →  uαv, and (u,α,v)∈D corresponds to the rewriting rule uαv  →  uv. By ⇒  ins we denote the relation defined by the insertion rules (formally, x  ⇒  insy if and only if x = x1uvx2,y = x1uαvx2, for some (u,α,v)∈I and x1,x2∈V*), and by ⇒  del the relation defined by the deletion rules (formally, x  ⇒  dely if and only if x = x1uαvx2,y = x1uvx2, for some (u,α,v)∈D and x1,x2∈V*). By ⇒   we refer to any of the relations ⇒  ins,  ⇒  del, and by ⇒  * we denote the reflexive and transitive closure of ⇒  .

We will often consider [formula] and distinguish between insertion and deletion rules by the subscripts ins or del.

The language generated by ID = (V,T,A,I,D) is defined by

The complexity of an insertion-deletion system ID = (V,T,A,I,D) is described by the vector (n,m,m';p,q,q') called size, where

[formula]

The total size of an insertion-deletion system ID of size (n,m,m';p,q,q') is defined as the sum of all the numbers from the vector: Σ(ID) = n + m + m' + p + q + q'.

By INSm,m'nDELq,q'p we denote the families of languages generated by insertion-deletion systems having the size (n,m,m';p,q,q').

If one of the parameters n,m,m',p,q,q' is not specified, then instead we write the symbol [formula]. In particular, INS0,0*DEL0,0* denotes the family of languages generated by context-free insertion-deletion systems. If one of the numbers from the pairs m, m' and/or q, q' is equal to zero (while the other one is not), then we say that the corresponding families have a one-sided context. Finally we remark that the rules from I and D can be put together into one set of rules R by writing [formula] for [formula] and [formula] for [formula].

Conditional insertion-deletion systems

In a similar way to context-free grammars, insertion-deletion systems can be extended by adding some additional controls. We discuss here the adaptation of the idea of semi-conditional and random context grammars for insertion-deletion systems and define corresponding types of insertion-deletion systems.

A semi-conditional insertion-deletion system of degree [formula] is a construct

V is a finite alphabet,

T  ⊆  V is the terminal alphabet,

A  ⊆  V* is a finite set of axioms,

[formula], n  ≥  1 is a finite set of rules of the form [formula], where [formula], is an insertion rule if t = ins or a deletion rule if t = del, P  ⊆  Vi, Q  ⊆  Vj, 1  ≤  k  ≤  n.

The sentential form (also called configuration) of γ is a string w∈V*. For [formula] a transition [formula], for 1  ≤  k  ≤  n, is performed if w  ⇒  tw' (t∈{ins,del}) and for all x∈P, x is a subword of w and for no y∈Q, y is a subword of w.

The language generated by γ is defined by

For i,j > 1 we denote by SCi,jINSm,m'nDELq,q'p the families of languages generated by semi-conditional insertion-deletion systems of degree (i,j) having insertion and deletion rules of size (n,m,m';p,q,q').

We also define random context insertion-deletion systems as semi-conditional insertion-deletion systems where i = j = 1. They are denoted with RC  INSm,m'nDELq,q'p.

Semi-conditional insertion-deletion systems

In this section we show that semi-conditional insertion-deletion systems of degree (2,2) are computationally complete even if rules inserting or deleting a single symbol are used. We start by showing that that this result is optimal with respect to the size of insertion and deletion rules.

[formula].

Let γ = (T,T,A,R), γ∈INS0,01DEL0,00 be an insertion-deletion system. Consider the following context-free grammar G = ({S},T,S,P), [formula]. Let G' be the grammar obtained from G by the elimination of λ-productions. Since [formula], G' does not contain any erasing rules. This combined with the fact that the family of semi-contextual grammars without λ-productions is included in CS yields the result.

SC2,2INS0,01DEL0,01 = RE.

We will start by proving the inclusion SC2,2INS0,01DEL0,01  ⊇  RE. To achieve this goal, we will show the inclusion SC2,2INS0,01DEL0,01  ⊇  λRCac, where λRCac is the family of random context grammars.

Consider an arbitrary random context grammar G = (V,T,S,R). The set R contains context-free rules with permitting and forbidding contexts.

We can assume that for any random context rule [formula] of G, either |u| = 2, or |u| = 0. Indeed, any rule [formula] can be replaced by a set of following random context rules:

[formula]

The set QW above is defined as follows:

[formula]

where nr is the number of symbols in the right-hand side of the rule with label r.

It can be easily seen that the rules above will simulate the context-free rule [formula]. The context checking is performed during the application of the rule A  →  u1W(1)r. The presence of QW in the forbidding set ensures that once started, the sequence of related rules shall be terminated.

Before proceeding to the simulation we will do some preliminary considerations. First of all, the central problem with SC2,2INS0,01DEL0,01 systems is that there is no direct way to check the context of a specific symbol in the string. To address this problem, we encode every symbol a∈V with a pair of symbols âā and place special terminators B and E at the beginning and the end of the string correspondingly. Every rule will have a special forbidding context which will check whether the string has this form. We will refer to this forbidding context as to the normalization condition.

Now, to operate at a specific locus in the string, we insert some service symbol and use the permitting/forbidding contexts of the subsequent rules to check whether it is located in the appropriate position. We then insert and delete symbols as we need, and the normalization condition included in every rule will assure that the operations we are performing are only happening in some neighborhood of the service symbols: whenever the proper organization of the string is broken, no rules will be further applicable, thus blocking the computation at a string which contains non-terminal symbols.

Having done the overview of our approach, we are ready to present the solution itself.

Let [formula] be a coding defined as c(a) = âā, a∈V.

The normalization condition is the following forbidding condition added to the forbidding contexts of the majority of rules:

[formula]

It can be seen that if [formula] then [formula]. Indeed, the first group of restrictions requires that the string only contains an alternating sequence of hatted and barred symbols, the third group requires the string to begin by B and to end by E, while the second group states that the first symbol after B has a hat and the symbol before E has a bar. A string of the form above is said to be in a normalized form.

We construct the following semi-conditional insertion-deletion system Γ = (VΓ,TΓ,AΓ,RΓ).

The terminal alphabet TΓ  =  {â|a∈V} contains the hatted versions of original terminals. The alphabet VΓ includes contains the service symbols, the hatted and barred versions of every symbol in the alphabet of G, and the new terminal symbols:

[formula]

The only axiom of the insertion-deletion system is AΓ  =  {BŜS̄E}.

Note that we are defining the new terminal alphabet TΓ instead of re-using the old T only for the sake of keeping the description simple and that this change does not affect the result itself.

The set of rules RΓ is constructed in the following way:

for every rule [formula] we add to RΓ the rules

[formula]

for every rule [formula], X,Y,Z∈V we add to RΓ the rules

[formula]

we also add the rules

[formula]

We will start our explanations with analyzing the third and simplest group of rules. These rules permit to consecutively erase symbols B, E and x̄, where x∈T. The first forbidding condition ensures that the group is applicable only for strings of form w = B(x̂)*E, x,y∈T. So the result of the application of this group of rules on w is a projection of w over V̂.

We will now turn to simulating the erasing random context rule [formula]. The correct simulation sequence is as follows: where w1,w2∈V*Γ. Note that if w1X̂X̄w2 satisfies the normalization condition, then w1w2 also satisfies it.

It turns out that almost any other derivation sequence will result in an unproductive string with non-terminals. Indeed, the permitting context of rule p.2 will make it inapplicable if #  p has not been properly positioned by p.1. Further, if p.2 erases the wrong X̂ (i.e., not the X̂ located immediately to the right of #  p), then the string will not satisfy the normalization condition and the computation will halt at a string with non-terminals. The contexts of the rule p.3 assure that X̄ is erased only after the correct instance of X̂ has been erased by p.2. Note that the forbidding word X̂  #  p prevents p.3 from being applicable if p.1 inserts #  p between X̂ and X̄. Finally, if p.4 erases #  p when only X̂ has been erased, the string will no longer satisfy the normalization condition; on the other hand, if #  p is erased immediately after it has been inserted, no effect is produced at all.

Now observe that, after the applications of p.1, p.2, and p.3 two valid scenarios are possible. If w2  ≠  X̂X̄w'2, w'2∈V*Γ, then the only applicable rule is p.4, because the #  p blocks applications of any other rules. If, however, w2  =  X̂X̄w'2, then the rule p.2 is applicable again, together with p.4. Thus, instead of erasing #  p by p.4, the system may erase one more pair X̂X̄. This is not a problem, though, because this would correspond to the simulation of another application of the rule p.

Note that it is not necessary to check for the permitting and forbidding contexts of the original rule p (P and Q correspondingly) before the application of the rule p.2, even if p.2 may start as many simulations of the erasing rule p as there are consequent instances of X̂X̄ at the locus marked by #  p. The reason is that p.2 is only applicable after an application of p.1 (which adds a #  p), and p.1 includes both P and Q in its contexts already.

Quite as expected, the simulation of the generic context-free rule q:(X  →  YZ,P,Q) is the most complicated. As usual, we will start with showing the correct simulation sequence:

[formula]

Here, again, w1,w2∈V*Γ. We remark that if w1X̂X̄w2 satisfies the normalization condition, all the strings shown in this derivation sequence satisfy the normalization condition as well.

We claim that any derivations aside from the one shown above result in unproductive branches. In the next paragraphs we will briefly expose the rationale behind this statement.

It should be clear by now that the principal way to control the loci of insertions and deletions is to carefully construct the permitting and forbidding contexts of the rules which are to be applied next. Consider the contexts of q.2, which compel the rule q.1 to insert $(1)q exactly before an instance of X̂. Similarly, the application of q.2 will produce a valid string only $(2)q is inserted after an instance of X̄. Note that at the moment we have not assured yet that $(1)q and $(2)q are located before and after the same pair X̂X̄.

Once the symbols $(1)q and $(2)q have been inserted into the string before and after some pairs X̂X̄, the rule q.3 will erase an instance of X̂; the normalization condition will assure that the erased symbol was located exactly after $(1)q.

The contexts of the rule q.4 guarantee that the proper instance of X̂ has already been erased (the permitting condition $(1)qX̄) and will block the rule in the cases when $(1)q is inserted between X̂ and X̄ and when $(2)q is inserted after $(1)q; in the latter case q.3 would be blocked.

The rule q.5 assures the proper localization of $(3)q, i.e., before $(1)q. The effect of rules q.4 and q.5 is thus to substitute $(1)q with $(3)q.

The rule q.6 finalizes the erasure of X̂X̄. X̄ cannot be erased before $(1)q is erased, which also guarantees in the long run that $(3)q has been properly positioned.

In the good case we would now expect to have $(3)q$(2)q; however, we have not yet assured that the symbol $(2)q was inserted after the same pair X̂X̄ as the pair before which $(3)q was inserted. This is the job of the rule q.7: the symbol $(4)q is only inserted when there actually is a pair $(3)q$(2)q in the string. If this is not the case, $(4)q will not be inserted; it is easy to verify that the subsequent rules will be rendered inapplicable in this case, thus blocking the computation at a string with non-terminals.

The rule q.8 assures proper positioning of $(4)q. Again, if $(2)q is not erased here, all further rule applications will be blocked.

The rule q.9 inserts yet another service symbol $(5)q. The contexts of this rule assure that it is only applied at the proper time. The contexts of q.10 assure the proper positioning of $(5)q. An application of the rule q.10 inserts an instance of Ŷ and, by the normalization condition, this will not block any computations only if Ŷ is inserted to the left or to the right of a service symbol of the $ family. The contexts of the rules q.10 and q.11 assure that Ŷ is placed exactly between $(4)q and $(3)q. Similarly, the contexts of q.11 and q.12 guarantee the proper positioning of [formula]. And again, the situation is exactly the same for the rules q.12 and q.13, which are guaranteed to place the corresponding symbols at the proper sites.

A very important remark is that, once we have more than one non-special symbol between two special symbols (i.e, the symbols of the $ family), the normalization condition becomes relevant for the substring between the special symbols. This limits the number of times the insertion rules q.10 to q.13 can be applied.

The contexts of the rule q.14 provide the final verification of the configuration of the string around the symbols $(4)q, $(3)q, and $(5)q. Once $(3)q is erased, q.15 erases $(4)q. Note how the contexts of q.15 only allow this rule to be applied after the $(3)q has been erased. Finally, q.16 finalizes the clean-up of the string.

Now in order to finish the proof of the theorem we show the inclusion SC2,2INS0,01DEL0,01  ⊆  RE. Since INS0,01DEL0,01  ⊆  CF (see [\cite=SV2-2]) we obtain the inclusion SC2,2INS0,01DEL0,01  ⊆  SC2,2  ⊆  RE.

Random Context Insertion-Deletion Systems

In this section we consider random context insertion-deletion systems. We show that such systems having rules of size (2,0,0;1,1,0) are computationally complete, while systems of size (1,1,0;p,1,1), p > 0, are not.

Computational Completeness

We start by showing the computational completeness of the family RC  INS0,02DEL1,01.

RC  INS0,02DEL1,01 = RE.

We show only the inclusion RC  INS0,02DEL1,01  ⊇  RE. For the converse inclusion we invoke the Church-Turing thesis. We will simulate an arbitrary grammar in the special Geffert normal form. Let G = (V,T,S,R) be such a grammar. We will simulate G with the following random context insertion-deletion system Γ = (VΓ,T,{S},RΓ).

The alphabet VΓ is constructed in the following way: [formula] The set NΓ contains the non-terminal service symbols we add to Γ. These symbols are the hatted and barred version of A, B, C, and D, as well as the additional symbols of $r, #  q, and fr families, added on per-rule basis, as shown in the following paragraphs.

The set of rules RΓ is constructed in the following way:

for every rule (p:X  →  cY)∈R, c∈T we add the following to RΓ:

[formula]

for every rule (p:X  →  ZY)∈R, Z∈N we consider the rule p':(X  →  ẐY); this rule can be rewritten as {X  →  ẐX',X'  →  Y}; we then apply the same reasoning as in the previous paragraph,

for every rule (q:X  →  Yc)∈R, c∈T we add the following to RΓ:

[formula]

for every rule (q:X  →  YZ)∈R, Z∈N we consider the rule q':(X  →  YẐ); this rule can be rewritten as {X  →  X',X'  →  YẐ}; we then apply the same reasoning as in the previous paragraph,

for every rule (r:UV  →  λ)∈R, (U,V)∈{(A,B),(C,D)} we add the following to RΓ:

[formula]

Consider the application of the rule p:X  →  cY to w1Xw2, [formula]. Remember that, for any string w generated by a grammar in the special Geffert normal form, the following holds: [formula].

The correct sequence of Γ events simulating the rule p is as follows:

[formula]

Note that p.1 will only be applicable when there is one copy of X in the string and where there is no other symbol from [formula]. This, among others, prohibits starting the simulation of rule p if another rule is being simulated.

Now suppose that cY is inserted in a different place in the string (not before X). In this case p.2 will not be applicable in the new configuration and both X and Y will remain in the string. Since a simulation of a rule cannot start when there is more than one symbol from N' in the string, the derivation halts at this invalid string.

The simulation of the rule q:X  →  Yc takes more steps. The reason is that we use deletion rules to assure proper location of insertion sites, and deletion rules have left contexts, while in the string Yc the symbol c is to the right of Y.

The correct sequence of Γ events is the following.

[formula]

We will now focus on analysing the situations when the insertions do not happen at desired loci. Suppose that q.1 does not insert #  q  #  'q before X. In this case q.2 is not applied. The rule q.3 cannot be applied, because there is an instance of X in the string. The rule q.4 cannot be applied, because #  'q is located immediately after #  q. The rule q.5 is inapplicable, because there is an instance of #  'q in the string. Therefore, if #  q  #  'q is not inserted right before X, all three symbols from N' (namely, X, #  q, and #  'q) remain in the string. This prevents any further simulation of rules and the derivation halts at an invalid string.

The other insertion rule is q.3. Suppose that Yb is inserted in a place other than between #  q and #  'q. In that case the rule q.4 will never be applied and neither will q.5 (because the symbol q.4 will not be deleted). The string will contain three symbols from [formula] (Y, #  q, and #  'q), which makes any further simulation impossible. Again, the derivation halts at an invalid string.

The simulation of the rule UV  →  λ is the longest. The two problems with this rule are that we need to remove the symbols U and V only if they are located in a certain order and that we need to remove exactly one instance of U and one instance of V.

The correct simulation sequence is as follows:

[formula]

where [formula]. Note that r.18 will eventually erase all instances of Û when the string will only contain symbols from [formula].

The simulation of the erasing rule starts with fixing a $'r at the site between an instance of Û and Ū. An instance of $''r is then inserted before $'r and erases both $'r and the Ū which is located next to it. Next $'''r is inserted, which erases both $''r and the V̂ which should follow immediately in a valid string. Then we fix a site immediately after a [formula] by inserting frf'r and having [formula] erase fr. This allows to eventually insert [formula] whose mission is to erase $'''r and a [formula]. We demand that [formula] erase f'r in order to assure that, on the one hand, [formula] has erased [formula] and, on the other hand, that f'r is right after the currently processed sequence ÛŪV̂.

Note that, when erasing a sequence ÛŪV̂, we do not erase the Û. Instead, we rely on rule r.17 to do that when the string only contains terminals and, possibly, hatted versions of A and C. It is not necessary to erase Û because, by erasing the pairs ŪV̂ and discarding Û and [formula], we already do the necessary checking of whether the non-terminals {A,B,C,D} are organised in proper pairs. The only situation when the left-over instance of Â or Ĉ can interfere with other simulations of the rule r:UV  →  λ is when there are nested pairs, like ÂĀĈB̂. In this case, the inner pair will be erased first, leaving a Ĉ. When the $'''r corresponding to the rule AB  →  λ will need to erase $''r and B̂ from the string, it can also remove the left-over Ĉ by rule r.10. Thus, the garbage symbols Â and Ĉ cannot disrupt the simulation of other erasing rules.

On the other hand, observe that $'''r is programmed to erase either $''rV̂, or $''rÂV̂, or $''rĈV̂. Two hatted symbols one after another cannot be produced after the simulation of the context-free rules of the grammar, because those rules only produce pairs of hatted and barred symbols. This means that $'''r will successfully handle the garbage symbols resulting from the formerly existent nested pair, but will not be able to produce unwanted effects in other parts of the string.

We will explicitly remark that, according to the prohibiting set of r.1, the simulation of a rule UV  →  λ can only start once the simulation of all other types of rules have completed.

We will now try to see whether it is possible for the described simulation process to produce wrong results. Suppose that r.1 does not insert the pair $r$'r after Û. In this case r.2 will not be applicable. Furthermore, the rule r.3 will not be applicable either, because the symbol $r is still in the string. Obviously, the rules r.4, r.5, and r.6 cannot be considered because there is no symbol $''r. Since the symbol $'''r is not inserted either, the rules r.7 to r.11 are inapplicable. Because the pair frf'r is not inserted, the rules r.12 and r.13 cannot be applied. Finally, because no rule inserts [formula], the rules r.14 to r.17 are not applicable either. Nevertheless, the symbols $r and $'r are still in the string, which makes any other simulations impossible, which renders the whole branch of computation invalid.

Similar considerations apply to the insertion rule r.3. In the case $''r does not arrive at the proper site, $'r is not removed, which blocks further applications of rules. In an analogous way, the insertion of $'''r at an improper site renders the simulation invalid. And for the same reasons, the insertion of [formula] anywhere but immediately before $'''r blocks the computation. Note that, before allowing a the symbol $(i)r to erase the corresponding hatted or barred version of U or V, we demand that it erase the symbol $(i - 1)r. In this way we guarantee that the symbols of the $r family are always inserted inside the same sequence of ÛŪV̂ as the one that was fixed by the initial insertion of $r$'r.

The only insertion rule left is r.11. The rule r.12 and the forbidding contexts of the following rules guarantee that the symbol f'r is located after an instance of [formula]. There is however no guarantee that this will be the instance of [formula] which belongs to the processed sequence ÛŪV̂. Suppose that f'r is indeed inserted after a different instance of [formula]. In this case the rule r.16 will be inapplicable, because there can be only one instance of f'r in the string, and this instance is positioned improperly. This will not allow [formula] to eventually be erased by the rule r.17 and will therefore block any further computations.

Computational Incompleteness Results

In this section we will show that random context insertion-deletion systems of size (1,1,0;p,1,1) are not capable of generating all recursively enumerable languages, hence they are computationally incomplete.

The proof below is based on the observation that it is impossible to control the number of applications of an insertion rule [formula] when y is already present in the string.

Obviously, in the case [formula], if the rule can be applied once, it can also be applied any number of times. We also remark that including x in either P or Q gives no advantage; including x in the permitting context is redundant, while including it in the forbidding context would just make the rule never applicable. Hence, there are two remaining cases: [formula], and y∈Q. When [formula], the situation is exactly the same as with [formula] from the point of view of controlling the number of applications. On the other hand, when y∈Q, the rule r will only be applicable when the string contains no y. So, when symbol y is already present in the string, rule r can be applied any number of times.

[formula].

We show that the language L = (ab)+ cannot be generated with such systems. We shall do the proof by contradiction. Suppose that there is a random context insertion deletion system Γ  =  (V,T,S,R), Γ∈RC  INS1,01DEL1,1p, such that L(γ) = L. Without restricting generality, we will not allow R to contain rules erasing terminal symbols, see [\cite=AKRV10b] or [\cite=VerlanH] for more details.

Consider a derivation [formula], where w∈(ab)+. We will focus on a pair of symbols ab: w  =  w1abw2, where w1,w2∈(ab)*.

Since R does not contain rules erasing terminals, the instance of b which belongs to the current pair was either inserted at this site by an insertion rule or was a part of the axiom S. We will not examine this latter case, and will instead suppose that the word w is long enough. The rule which inserted b is of the form [formula]. It is very important to remark at this point that the permitting and forbidding contexts of the rule p cannot influence the position at which the insertion takes place. We are therefore not interested in the case x = λ, because such a rule would be allowed to insert the b at any site on the string, and, in particular, we could obtain the string [formula].

So, we have the following derivation:

[formula]

where w'1,w'2∈V*. Since w∈(ab)+ we can suppose that |w1'|b > 0 (as well as |w2'|b > 0). In this case, according to our remark above, rule p can be applied an arbitrary number of times yielding the following derivation:

[formula]

We observe that the last part of the derivation is possible because a deletion rule of size (p,1,1) cannot distinguish if there is one or more b present in the left or right context.

We therefore conclude that, if [formula], then [formula] and L(Γ)  ≠  (ab)+, which contradicts our initial supposition.

Conclusion

In this paper we introduced the mechanism of conditional application of rules for insertion-deletion systems based on semi-conditional and random context conditions. This mechanism permitted to achieve an increase in the computational power, especially for the case of semi-conditional insertion-deletion systems, which are showed to characterize the family of recursively enumerable languages with rather simple rules: context-free insertion or deletion of one symbol. This shows that the control mechanism is in some sense more powerful than the graph control, because in the latter case only the recursively enumerable sets of numbers can be generated [\cite=AKRV11]. The form of the rules and of the control mechanism permit to consider it as a particular case of Networks of Evolutionary Processors [\cite=NEP], so the obtained result can be transcribed in that area as well.

In the case of random-context conditions we obtained results exhibiting an interesting asymmetry between the computational power of insertion and deletion rules: systems having rules of size (2,0,0;1,1,0) are computationally complete, while those having the size (1,1,0;2,0,0) (and more generally of size (1,1,0;p,1,1)) are not. This result is surprising because until now all the obtained results in the area of insertion-deletion systems with or without additional controls were analogous if parameters of insertion and deletion rules were interchanged. The characterization of these classes gives an interesting topic for a further research.

We remark that all the constructions were additionally tested using a self-developed dedicated simulator that is available "on request" from the corresponding author. These tests permitted to verify that for a single rule application, all possible evolutions except the one corresponding to the correct one introduce in the string (groups of) non-terminal symbols that cannot be removed anymore.