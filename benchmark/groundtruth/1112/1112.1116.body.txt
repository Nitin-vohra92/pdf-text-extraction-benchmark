Approximating the Diameter of Planar Graphs in Near Linear Time

Introduction

The diameter of a graph is the largest distance between two vertices. Computing it is among the most fundamental algorithmic graph problems. In general weighted graphs, as well as in planar graphs, the only known way to compute the diameter is to essentially solve the (more general) All-Pairs Shortest Paths (APSP) problem and then take the pair of vertices with the largest distance.

In general weighted graphs with n vertices and m edges, solving APSP (thus diameter) currently requires Õ(n3) time. The fastest algorithm to date is O(n3( log  log n) /  log 2n) by Han and Takaoka [\cite=Han], or for sparse graphs O(mn  +  n2 log n) by Johnson [\cite=Johnson], with a small improvement to O(mn  +  n2 log  log n) [\cite=pettie-2002].

In weighted planar graphs, solving APSP can be done in O(n2) time by Frederickson [\cite=Frederickson]. While this is optimal for APSP, it is not clear that it is optimal for diameter. Currently, only a logarithmic factor improvement by Wulff-Nilsen [\cite=WN-diam] is known for the diameter, running in O(n2( log  log n)4  /   log n) time. A long standing open problem [\cite=Chung] is to find the diameter in truly subquadratic O(n2 - ε) time. Eppstein [\cite=Eppstein] has shown that if the diameter in a planar graph is bounded by a fixed constant, then it can be found in O(n) time. Fast algorithms are also known for some simpler classes of graphs like outer-planar graphs [\cite=16], interval graphs [\cite=23], and others [\cite=Chordal] [\cite=13].

In lack of truly subcubic-time algorithms for general graphs and truly subquadratic time algorithms for planar graphs it is natural to seek faster algorithms that approximate the diameter. It is easy to approximate the diameter within a factor of 2 by simply computing a Single-Source Shortest Path (SSSP) tree from any vertex in the graph and returning twice the depth of the deepest node in the tree. This requires O(m + n log n) time for general graphs and O(n) time for planar graphs [\cite=HKRS97]. For general graphs, Aingworth et al. [\cite=Aingworth] improved the approximation factor from 2 to 3/2 at the cost of [formula] running time, and Boitmanis et al. [\cite=5] gave an additive approximation factor of [formula] with [formula] running time. For planar graphs, the current best approximation is a 3/2-approximation by Berman and Kasiviswanathan running in O(n3 / 2) time [\cite=WADS]. We improve this to a (1 + ε)-approximation running in Õ(n) time for any fixed 0 < ε  <  1. More precisely, we prove the following theorem:

Given an undirected planar graph with n vertices, non-negative edge lengths, and diameter d. For any ε > 0 we can compute an approximate diameter d' (where d  ≤  d'  ≤  (1 + ε)  ·  d) in time [formula].

Summary of the Algorithm.

A lemma of Lipton and Tarjan [\cite=LiptonTarjan79] states that, for any SSSP tree T in a planar graph G, there is a non-tree edge e (where e might possibly be a non-edge of the planar graph) such that the strict interior and strict exterior of the unique simple cycle C in [formula] each contains at most 2 / 3  ·  n vertices. The vertices of C therefore form a separator consisting of two shortest paths with the same common starting vertex.

Let Gin (resp. Gout) be the subgraph of G induced by C and all interior (resp. exterior) vertices to C. Let d(Gin,Gout,G) denote the largest distance in the graph G between a marked vertex in V(Gin) and a marked vertex in V(Gout). In the beginning, all vertices of G are marked and we seek the diameter which is d(G,G,G). We use a divide and conquer algorithm that first approximates d(Gin,Gout,G), then unmarks all vertices of C, and then recursively approximates d(Gin,Gin,G) and d(Gout,Gout,G) and takes the maximum of all three. We outline this algorithm below. Before running it, we compute an SSSP tree from any vertex using the linear-time SSSP algorithm of Henzinger et al. [\cite=HKRS97]. The depth of the deepest node in this tree already gives a 2-approximation to the diameter d(G,G,G). Let x be the obtained value such that x  ≤  d(G,G,G)  ≤  2x.

Reduce d(Gin,Gout,G) to d(Gin,Gout,Gt) in a tripartite graph Gt:

The separator C is composed of two shortest paths P and Q emanating from the same vertex, but that are otherwise disjoint. We carefully choose a subset of 16 / ε vertices from C called portals. The first (resp. last) 8 / ε portals are all part of the prefix of P (resp. Q) that is of length 8x. The purpose of the portals is to approximate a shortest u-to-v path for u∈Gin and v∈Gout by forcing it to go through a portal. Formally, we construct a tripartite graph Gt with vertices (V(Gin),portals,V(Gout)). The length of edge (u∈V(Gin),v∈portals) or (u∈portals,v∈V(Gout)) in Gt is the u-to-v distance in G. This distance is computed by running the SSSP algorithm of [\cite=HKRS97] from each of the 16 / ε portals. By the choice of portals, we show that d(Gin,Gout,Gt) is a (1 + 2ε)-approximation of d(Gin,Gout,G).

Approximate d(Gin,Gout,Gt):

If [formula] is the maximum edge-length of Gt, then note that d(Gin,Gout,Gt) is between [formula] and [formula]. This fact makes it possible to round the edge-lengths of Gt to be in [formula] so that [formula] after rounding is a (1 + 2ε)-approximation to d(Gin,Gout,Gt) before rounding. For any fixed ε we can assume without loss of generality that 1 / ε is an integer. This means that after rounding d(Gin,Gout,Gt) is bounded by some fixed integer. We give a linear-time algorithm to compute it exactly, thus approximating d(Gin,Gout,G). We then unmark all vertices of C and move on to recursively approximate d(Gin,Gin,G) (the case of d(Gout,Gout,G) is symmetric).

Reduce d(Gin,Gin,G) to d(Gin,Gin,G+in) in a planar graph G+in of size at most 2 / 3  ·  n:

In order to apply recursion, we construct planar graphs G+in and G+out (that is constructed similarly to G+in). The size of each of these graphs will be at most 2 / 3  ·  n and their total size n + o(n). We would like G+in to be such that d(Gin,Gin,G+in) is a (1 + ε / (2 log n))-approximation to {d(Gin,Gin,G).

To construct G+in, we first choose a subset of 256 log n / ε vertices from C called dense portals. We then compute all O((256 log n / ε)2) shortest paths in Gout between dense portals. The graph B' obtained by the union of all these paths has at most O((256 log n / ε)4) vertices of degree >  2. We contract vertices of degree =  2 so that the number of vertices in B' decreases to O((256 log n / ε)4). Appending this small graph B' (after unmarking all of its vertices) as an exterior to Gin results in a graph G+in that has |Gin| + O((256 log n / ε)4) vertices and d(Gin,Gin,G+in) is a (1 + ε / (2 log n))-approximation of d(Gin,Gin,G).

The problem is still that the size of G+in is not necessarily bounded by 2 / 3  ·  n. This is because C (that is part of G+in) can be as large as n. We show how to shrink G+in to size roughly 2 / 3  ·  n while d(Gin,Gin,G+in) remains a (1 + ε / (2 log n))-approximation of d(Gin,Gin,G). To achieve this, we shrink the C part of G+in so that it only includes the dense portals without changing d(Gin,Gin,G+in).

Approximate d(Gin,Gin,G+in):

Finally, once |G+in|  ≤  2 / 3  ·  n we apply recursion to d(Gin,Gin,G+in). In the halting condition, when |G+in|  ≤  (256 log n  /  ε)4, we naively compute d(Gin,Gin,G+in) using APSP.

Related Work.

The use of shortest-path separators and portals to approximate distances in planar graphs was first suggested in the context of approximate distance oracles. These are data structures that upon query u,v return a (1  +  ε)-approximation of the u-to-v distance. Thorup [\cite=Thorup04] presented an O(1  /  ε  ·  n log n)-space oracle answering queries in O(1 / ε) time on directed weighted planar graphs. Independently, Klein [\cite=Klein2002] achieved these same bounds for undirected planar graphs.

In distance oracles, we need distances between every pair of vertices and each vertex is associated with a possibly different set of portals. In our diameter case however, since we know the diameter is between x and 2x, it is possible to associate all vertices with the exact same set of portals. This fact is crucial in our algorithm, both for its running time and for its use of rounding. Another important distinction between our algorithm and distance oracles is that distance oracles upon query (u,v) can inspect all recursive subgraphs that include both u and v. We on the other hand must have that, for every (u,v), the shortest u-to-v path exists (approximately) in the unique subgraph where u and v are separated by C. This fact necessitated our construction of G+in and G+out.

The Algorithm

In this section we give a detailed description of an algorithm that approximates the diameter of an undirected weighted planar graph G = (V,E) in the bounds of Theorem [\ref=theorem:main]. The algorithm computes a (1 + ε)-approximation of the diameter d = d(G,G,G) for G = G. This means it returns a value d' where d  ≤  d'  ≤  (1 + ε)  ·  d (recall that, before running the algorithm, we compute a value x such that x  ≤  d  ≤  2x by computing a single-source shortest-path tree from an arbitrary vertex in G). We focus on approximating the value of the diameter. An actual path of length d' can be found in the same time bounds. For simplicity we will assume that shortest paths are unique. This can always be achieved by adding random infinitesimal weights to each edge, and can also be achieved deterministically using lexicographic-shortest paths (see, e.g., [\cite=HartvigsenMardon]). Also, to simplify the presentation, we assume that ε  ≤  0.1 and we describe a (1 + 7ε)-approximation. (then just take ε'  =  ε / 7).

The algorithm is recursive and actually solves the more general problem of finding the largest distance only between all pairs of marked vertices. In the beginning, we mark all n = |V(G)| vertices of G = G and set out to approximate d(G,G,G) (the largest distance in G between marked vertices in V(G)). Each recursive call approximates the largest distance in a specific subset of marked vertices, and then unmarks some vertices before the next recursive call. We make sure that whatever the endpoints of the actual diameter are, their distance is approximated in some recursive call. Finally, throughout the recursive calls, we maintain the invariant that the distance between any two marked vertices in the graph G of the recursive call is a (1 + ε)-approximation of their distance in the original graph G (there is no guarantee on the marked-to-unmarked or the unmarked-to-unmarked distances). We denote by δG(u,v) the u-to-v distance in the original graph G.

The recursion is applied according to a variant of the shortest-path separator decomposition for planar graphs by Lipton and Tarjan [\cite=LiptonTarjan79]: We first pick any marked vertex v1 and compute in linear time the SSSP tree from v1 in G. In this tree, we can find in linear time two shortest paths P and Q (both emanating from v1) such that removing the vertices of [formula] from G results in two disjoint planar subgraphs A and B (i.e., there are no edges in V(A)  ×  V(B)). The number of vertices of C can be as large as n but it is guaranteed that |V(A)|  ≤  2 / 3  ·  n and |V(B)|  ≤  2 / 3  ·  n. Notice that the paths P and Q might share a common prefix. It is common to not include this shared prefix in C. However, in our case, we must have the property that P and Q start at a marked vertex. So we include in C the shared prefix as well. See Fig. [\ref=separator] (left).

Let Gin (resp. Gout) be the subgraph of G induced by [formula] (resp. [formula]). In order to approximate d(G,G,G), we first compute a (1 + 5ε)-approximation d1 of d(Gin,Gout,G) (the largest distance in G between the marked vertices of V(Gin) and the marked vertices of V(Gout)). In particular, d1 takes into account all V(C)  ×  V(G) distances. We can therefore unmark all the vertices of C and move on to approximate d2  =  d(Gin,Gin,G) (approximating d3  =  d(Gout,Gout,G) is done similarly). We approximate d(Gin,Gin,G) by applying recursion on d(Gin,Gin,G+in) where |V(G+in)|  ≤  2 / 3  ·  n. The marked vertices in G+in and in Gin are the same and d(Gin,Gin,G+in) is a (1 + ε / (2 log n))-approximation of d(Gin,Gin,G). This way, the diameter grows by a multiplicative factor of (1 + ε / (2 log n)) in each recursive call. Since the recursive depth is O( log n) (actually, it is never more than 1.8 log n) we get a (1 + 5ε)  ·  (1 + ε)  ≤  (1 + 7ε)-approximation d2 to d(Gin,Gin,G). Finally, we return max {d1,d2,d3}.

Reduce d(Gin,Gout,G) to d(Gin,Gout,Gt)

Our goal is now to approximate d(Gin,Gout,G). For u∈Gin and v∈Gout, we approximate a shortest u-to-v path in G by forcing it to go through a portal. In other words, consider a shortest u-to-v path. It is is obviously composed of a shortest u-to-c path in G concatenated with a shortest c-to-v path in G for some vertex c∈C. We approximate the shortest u-to-v path by insisting that c is a portal. The fact that we only need to consider u-to-v paths that are of length between x and 2x makes it possible to choose the same portals for all vertices.

We now describe how to choose the portals in linear time. Recall that the separator C is composed of two shortest paths P and Q emanating from the same marked vertex v1. The vertex v1 is chosen as the first portal. Then, for [formula] we start from vi - 1 and walk on P until we reach the first vertex v whose distance from vi - 1 via P is greater than εx. We designate v as the portal vi and continue to i + 1. We stop the process when we encounter a vertex v whose distance from v1 is greater than 8x. This guarantees that at most 8 / ε portals are chosen from the shortest path P and they are all in a prefix of P of length at most 8x. This might seem counterintuitive as we know that any shortest path P in the original graph G is of length at most 2x. However, since one endpoint of P is not necessarily marked, it is possible that P is a shortest path in G but not even an approximate shortest path in the original graph G. We do the same for Q, and we get a total of 16 / ε portals. See Fig. [\ref=separator] (right).

Once we have chosen the portals, we move on to construct a tripartite graph Gt whose three vertex sets (or columns) are (V(Gin),portals,V(Gout)). The length of edge (u∈V(Gin),v∈portals) or (u∈portals,v∈V(Gout)) is the u-to-v distance in G. This distance is computed by running the linear-time SSSP algorithm of Henzinger et al. [\cite=HKRS97] in G from each of the 16 / ε portals in total O(1 / ε  ·  |V(G)|) time. The following lemma states that our choice of portals implies that d(Gin,Gout,Gt) is a good approximation of d(Gin,Gout,G).

If d(Gin,Gout,G)  ≥  x, then d(Gin,Gout,Gt) is a (1 + 2ε)-approximation of d(Gin,Gout,G). Otherwise, d(Gin,Gout,Gt)  ≤  (1 + 2ε)x.

The first thing to notice is that d(Gin,Gout,Gt)  ≥  d(Gin,Gout,G). This is because every shortest u-to-v path in Gt between a marked vertex u∈V(Gin) of the first column and a marked vertex v∈V(Gout) of the third column corresponds to an actual u-to-v path in G.

We now show that d(Gin,Gout,Gt)  ≤  (1 + 2ε)  ·  d(Gin,Gout,G). We begin with some notation. Let Pt denote the shortest path in Gt realizing d(Gin,Gout,Gt). The path Pt is a shortest u-to-v path for some marked vertices u∈Gin and v∈Gout. The length of the path Pt is δGt(u,v). Let PG denote the shortest u-to-v path in G that is of length δG(u,v) and let PG denote the shortest u-to-v path in the original graph G that is of length δG(u,v). Recall that we have the invariant that in every recursive level for every pair of marked vertices δG(u,v)  ≤  (1 + ε)  ·  δG(u,v). We also have that δG(u,v)  ≤  2x and so δG(u,v)  ≤  2x  ·  (1  +  ε). For the same reason, since v1 (the first vertex of both P and Q) is also marked, we know that δG(v1,u) is of length at most 2x  ·  (1 + ε).

The path PG must include at least one vertex c∈C. Assume without loss of generality that c∈P. We claim that c must be a vertex in the prefix of P of length 8x. Assume the converse, then the v1-to-c prefix of P is of length at least 8x. Since P is a shortest path in G, this means that δG(v1,c) is at least 8x. However, consider the v1-to-c path composed of the v1-to-u shortest path (of length δG(v1,u)  ≤  2x  ·  (1 + ε)) concatenated with the u-to-c shortest path (of length δG(u,c)  ≤  δG(u,v)  ≤  2x  ·  (1  +  ε)). Their total length is 4x  ·  (1 + ε) which is less than 8x (since ε < 1) thus contradicting our assumption.

After establishing that c is somewhere in the 8x prefix of P, we now want to show that δGt(u,v)  ≤  (1 + 2ε)  ·  δG(u,v). Let λ(c) denote a closest portal to c on the path P. Notice that by our choice of portals and since c is in the 8x prefix of P we have that δG(c,λ(c))  ≤  εx. By the triangle inequality we know that δG(u,λ(c))  ≤  δG(u,c)  +  δG(c,λ(c))  ≤  δG(u,c)  +  εx and similarly δG(λ(c),v)  ≤  δG(c,v)  +  εx. This means that

[formula]

where in the last inequality we assumed that d(Gin,Gout,G)  ≥  x. Note that if d(Gin,Gout,G)  <  x, then d(Gin,Gout,Gt)  ≤  (1 + 2ε)  ·  x. The lemma follows.

By Lemma [\ref=lemma:G_t], approximating d(Gin,Gout,G) when d(Gin,Gout,G)  ≥  x reduces to approximating d(Gin,Gout,Gt). The case of d(Gin,Gout,G)  <  x means that the diameter d of the original graph G is not a (u∈Gin)-to-(v∈Gout) path. This is because d  ≥  x  >  d(Gin,Gout,G)  ≥  d(Gin,Gout,G). So d will be approximated in a different recursive call (when the separator separates the endpoints of the diameter). In the meanwhile, we will get that d(Gin,Gout,Gt) is at most (1 + 2ε)  ·  x and so it will not compete with the correct recursive call when taking the maximum.

Approximate d(Gin,Gout,Gt)

In this subsection, we show how to approximate the diameter in the tripartite graph Gt. We give a (1 + 2ε)-approximation for d(Gin,Gout,Gt). By the previous subsection, this means we have a (1 + 2ε)(1 + 2ε)  <  (1 + 5ε)-approximation for d(Gin,Gout,G). From the invariant that distances in G between marked vertices are a (1 + ε)-approximation of these distances in the original graph G, we get a (1 + 5ε)(1 + ε)  <  (1 + 7ε)-approximation for d(Gin,Gout,G) in the original graph G.

We now present our (1 + 2ε)-approximation for d(Gin,Gout,Gt) in the tripartite graph Gt. Recall that Pt denotes the shortest path in Gt that realizes d(Gin,Gout,Gt). By the definition of Gt, we know that the path Pt is composed of only two edges: (1) edge (u,p) between a marked vertex u of the first column (i.e., u∈V(Gin)) and a vertex p of the second column (i.e., p corresponds to some portal in G). (2) edge (p,v) between p and a marked vertex v of the third column (i.e., v∈V(Gout)).

Let X (resp. Y) denote the set of all edges in Gt adjacent to marked vertices of the first (resp. third) column. Let [formula] denote the maximum edge-length over all edges in [formula]. Notice that [formula]. We round up the lengths of all edges in [formula] to the closest multiple of [formula]. The rounded edge-lengths are thus all in [formula]. We denote Gt after rounding as G't. Notice that d(Gin,Gout,G't) is a (1 + 2ε)-approximation of d(Gin,Gout,Gt). This is because the path Pt is of length at least [formula] and is composed of two edges, each one of them has increased its length by at most [formula].

We now show how to compute d(Gin,Gout,G't) exactly in linear time. We first divide all the edge-lengths of G't by [formula] and get that G't has edge-lengths in [formula]. After finding d(Gin,Gout,G't) (which is now a constant) we simply multiply the result by [formula]. The following lemma states that when the diameter is constant it is possible to compute it exactly in linear time. Note that we can't just use Eppstein's [\cite=Eppstein] linear-time algorithm because it works only on planar graphs and in our case we get a non-planar tripartite graph G't.

d(Gin,Gout,G't) can be computed in time O(|V(G)|  /  ε + 2O(1 / ε)).

Recall that in G't we denote the set of all edges adjacent to marked vertices of the first and third column as X and Y. The length of each edge in [formula] is in [formula] where k = 1 / ε. The number of edges in X (and similarly in Y) is at most 16k  ·  |V(G)|. This is because the first column contains |Gin|  ≤  |V(G)| vertices and the second column contains j  ≤  16k vertices [formula] (the portals). For every marked vertex v in the first (resp. third) column, we store a j-tuple vX (resp. vY) containing the edge lengths from v to all vertices of the second column. In other words, the j-tuple [formula] where every [formula] is the length of the edge (v,vi). The total number of tuples is O(k  ·  |V(G)|) but the total number of different tuples is only t  =  kO(k) since each tuple has O(k) entries and each entry is in [formula].

We create two binary vectors VX and VY each of length t. The i'th bit of VX (resp. VY) is 1 iff the i'th possible tuple exists as some vX (reps. vY). Creating these vectors takes O(k  ·  |V(G)|) = O(|V(G)|  /  ε) time. Then, for every 1 bit in VX (corresponding to a tuple of vertex u in the first column) and every 1 bit in VY (corresponding to a tuple of vertex v in the third column) we compute the u-to-v distance in G't using the two tuples in time O(16k). We then return the maximum of all such (u,v) pairs. Notice that a 1 bit can correspond to several vertices that have the exact same tuple. We arbitrarily choose any one of these. There are t entries in VX and t entries in VY so there are O(t2) pairs of 1 bits. Each pair is examined in O(16k) time for a total of O(kt2) = kO(k) time.

To complete the proof we now show that this last term O(kt2) is not only kO(k) but actually 2O(k). For that we claim that the total number of different tuples is t  =  2O(k). We assume for simplicity (and w.l.o.g.) that all portals [formula] are on the separator P. We encode a j-tuple [formula] by a (2j - 1)-tuple v'X: The first entry of v'X is δ(v,v1). The next j - 1 entries are |δ(v,vi + 1)  -  δ(v,vi)| for [formula]. Finally, the last j - 1 entries are single bits where the i'th bit is 1 if δ(v,vi + 1)  -  δ(v,vi)  ≥  0 and 0 if δ(v,vi + 1)  -  δ(v,vi)  <  0.

We will show that the number of different (2j - 1)-tuples v'X is 2O(k). There are k options for the first entry of v'X and two options (0 or 1) for each of the last j - 1 entries. We therefore only need to show that there are at most 2O(k) possible (j - 1)-tuples [formula] where ai  =  |δ(v,vi + 1)  -  δ(v,vi)|. First notice that since δ(v,vi + 1) and δ(v,vi) correspond to distances, by the triangle inequality we have ai  =  |δ(v,vi + 1)  -  δ(v,vi)|  ≤  δ(vi,vi + 1). We also know that [formula] since all portals lie on a prefix of P of length at most 8x and we scaled the lengths by dividing by [formula]. We get that [formula]. In the last inequality we used the fact that [formula], if [formula], then we ignore this recursive call altogether (the diameter will be found in another recursive call). To conclude, observe that the number of possible vectors [formula] where every ai is non-negative and [formula] is at most 2O(k).

To conclude, we have so far seen how to obtain a (1 + 5ε)-approximation for d(Gin,Gout,G) implying a (1 + 7ε)-approximation for d(Gin,Gout,G) in the original graph G. The next step is to unmark all vertices of C and move on to recursively approximate d(Gin,Gin,G) (approximating d(Gout,Gout,G) is done similarly).

Reduce d(Gin,Gin,G) to d(Gin,Gin,G+in)

In this subsection we show how to recursively obtain a (1 + 5ε)-approximation of d(Gin,Gin,G) and recall that this implies a (1 + 7ε)-approximation of d(Gin,Gin,G) in the original graph G since we will make sure to maintain our invariant that, at any point of the recursion, distances between marked vertices are a (1 + ε)-approximation of these distances in the original graph G.

It is important to note that our desired construction can be obtained with similar guarantees using the construction of Thorup [\cite=Thorup04] for distance oracles. However, we present here a simpler construction than [\cite=Thorup04] since, as apposed to distance oracles that require all-pairs distances, we can afford to only consider distances that are between x and 2x.

There are two problems with applying recursion to solve d(Gin,Gin,G). The first is that |V(Gin)| can be as large as |V(G)| and we need it to be at most 2 / 3  ·  |V(G)|. We do know however that the number of marked vertices in V(Gin) is at most 2 / 3  ·  |V(G)| . The second problem is that it is possible that the u-to-v shortest path in G for u,v∈Gin includes vertices of Gout. This only happens if the u-to-v shortest path in G is composed of a shortest u-to-p path (p∈P) in Gin, a shortest p-to-q path (q∈Q) in Gout, and a shortest q-to-v path in Gin. To overcome these two problems, we construct a planar graph G+in that has at most 2 / 3  ·  |V(G)| vertices and d(Gin,Gin,G+in) is a (1 + ε / (2 log n))-approximation to {d(Gin,Gin,G).

Recall that the subgraph B of G induced by all vertices in the strict exterior of the separator C is such that |B|  ≤  2 / 3  ·  |V(G)| and [formula]. The construction of G+in is done in two phases. In the first phase, we replace the B part of G with a graph B' of polylogarithmic size. In the second phase, we contract the C part of G to polylogarithmic size.

Phase I: replacing [formula] with [formula].

To construct G+in, we first choose a subset of 256 log n  /  ε vertices from C called dense portals. The dense portals are chosen similarly to the regular portals but there are more of them. The marked vertex v1 (the first vertex of both P and Q) is chosen as the first dense portal. Then, for [formula] we start from vi - 1 and walk on P until we reach the first vertex whose distance from vi - 1 via P is greater than εx / (16 log n). We set this vertex as the dense portal vi and continue to i + 1. We do the same for Q, for a total of 256 log n / ε dense portals.

After choosing the dense portals, we compute all O((256 log n / ε)2) shortest paths in Gout between dense portals. This can be done using SSSP from each portal in total O(|V(Gout)|  ·   log n / ε) time. It can also be done using the Multiple Source Shortest Paths (MSSP) algorithm of Klein [\cite=Klein05] in total O(|V(Gout)|  ·   log n  +   log 2n / ε2) time.

Let B' denote the graph obtained by the union of all these dense portal to dense portal paths in Gout. Notice that since these are shortest paths, and since we assumed shortest paths are unique, then every two paths can share at most one consecutive subpath. The endpoints of this subpath are of degree > 2. There are only O((256 log n / ε)2) paths so this implies that the graph B' has at most O((256 log n / ε)4) vertices of degree >  2. We can therefore contract vertices of degree =  2. The number of vertices of B' then decreases to O((256 log n / ε)4), it remains a planar graph, and its edge lengths correspond to subpath lengths.

We then unmark all vertices of B' and append B' to the infinite face of Gin. In other words, we take the disjoint union of Gin and B' and identify the dense portals of Gin with the dense portals of B'. This results in a graph G+in that has |V(Gin)| + O((256 log n / ε)4) vertices. In Lemma [\ref=lemma:G_in^+] we will show that d(Gin,Gin,G+in) can serve as a (1 + ε / (2 log n))-approximation to d(Gin,Gin,G). But first we will shrink G+in so that the number of its vertices is bounded by 2 / 3  ·  |V(G)|.

Phase II: shrinking [formula].

The problem with the current G+in is still that the size of V(G+in) is not necessarily bounded by 2 / 3  ·  |V(G)|. This is because C (that is part of V(G+in)) can be as large as n. We now show how to shrink V(G+in) to size 2 / 3  ·  |V(G)| while d(Gin,Gin,G+in) remains a (1 + ε / (2 log n))-approximation of d(Gin,Gin,G). To achieve this, we shrink the C part of V(G+in) so that it only includes the dense portals. We show how to shrink P, shrinking Q is done similarly.

Consider two dense portals vi and vi + 1 on P (i.e., vi is the closest portal to vi + 1 on the path P towards v1). We want to eliminate all vertices of P between vi and vi + 1. Denote these vertices by [formula]. If vi is the last portal of P (i.e., i = 128 log n), then [formula] are all the vertices between vi and the end of P. Recall that A is the subgraph of G induced by all vertices in the strict interior of the separator C. Fix a planar embedding of G+in. We perform the following process as long as there is some vertex u in [formula] which is a neighbor of some pj, and which is on some face of the embedding that also contains vi. We want to "force" any shortest path that goes through an edge (u,pj) to also go through the dense portal vi. To this end, we delete all such edges (u,pj), and instead insert a single edge (u,vi) of length [formula]. Here, [formula] denotes the length of the edge (u,pj) (it may be that [formula] if (u,pj) is not an edge) and δG(pj,vi) denotes the length of the pj-to-vi subpath of P. It is important to observe that the new edge (u,vi) can be embedded while maintaining the planarity since we have chosen u to be on the same face as vi. Observe that once the process ends, the vertices pj have no neighbors in [formula].

Finally, we replace the entire vi + 1-to-vi subpath of P with a single edge (vi + 1,vi) whose length is equal to the entire subpath length. If vi is the last dense portal in P, then we simply delete the entire subpath between vi and the end of P. The entire shrinking process takes only linear time in the size of |V(G)| since it is linear in the number of edges of G+in (which is a planar graph).

The following Lemma asserts that after the shrinking phase d(Gin,Gin,G+in) can serve as a (1 + ε / (2 log n))-approximation to d(Gin,Gin,G).

d(Gin,Gin,G)  ≤  d(Gin,Gin,G+in)  ≤  d(Gin,Gin,G)  +  εx / (2 log n)

First observe that d(Gin,Gin,G+in)  ≥  d(Gin,Gin,G). This is because every vertex of Gin that is marked in G is also a marked vertex in G+in, and any shortest u-to-v path in G+in corresponds to an actual u-to-v path in G.

We now show that d(Gin,Gin,G+in)  ≤  d(Gin,Gin,G)  +  εx / (2 log n). Let P+ denote the shortest u-to-v path in G+in realizing d(Gin,Gin,G+in). Both u and v are marked vertices in Gin and the length of P+ is δG+in(u,v). Let PG denote the shortest u-to-v path in G that is of length δG(u,v).

Case 1: If PG does not include any vertex of C, then PG is also present in G+in and therefore d(Gin,Gin,G+in)  ≤  d(Gin,Gin,G).

Case 2: If PG includes vertices that are not in Gin (i.e., vertices in [formula]), then PG must be composed of a shortest u-to-p path (p∈P) in Gin, a shortest p-to-q path (q∈Q) in Gout, and a shortest q-to-v path in Gin.

We first claim that p must be a vertex in the prefix of P of length 8x (a similar argument holds for q and Q). Assume the converse, then the prefix of P from v1 (the first vertex of both P and Q) to p is of length at least 8x. Recall that we have the invariant that in every recursive level for every pair of marked vertices δG(u,v)  ≤  (1 + ε)  ·  δG(u,v)  ≤  2x  ·  (1 + ε). For the same reason we know that δG(v1,u)  ≤  2x  ·  (1 + ε). Since P is a shortest path in G, this means that δG(v1,p)  ≥  8x. However, consider the v1-to-p path composed of the v1-to-u shortest path (of length δG(v1,u)  ≤  2x  ·  (1 + ε)) concatenated with the u-to-p shortest path (of length δG(u,p)  ≤  δG(u,v)  ≤  2x  ·  (1  +  ε)). Their total length is 4x  ·  (1 + ε) which is less than 8x (since ε < 1) thus contradicting our assumption.

We now show that δG+in(u,v)  ≤  δG(u,v)  +  εx / (2 log n). For c∈P (resp. c∈Q), let λ(c) denote the first dense portal encountered while walking from c towards v1 on the path P (resp. Q). Notice that since p and q are in the 8x prefixes of P and Q we have that δG(p,λ(p))  ≤  εx / (16 log n) and δG(q,λ(q))  ≤  εx / (16 log n). From the shrinking phase, it is easy to see that G+in includes a u-to-λ(p) path of length δG(u,p)  +  δG(p,λ(p)) and so δG+in(u,λ(p))  ≤  δG(u,p)  +  εx / (16 log n). Similarly, δG+in(λ(q),v)  ≤  δG(q,v)  +  εx / (16 log n). Furthermore, since G+in was appended with shortest paths between dense portals in Gout we have δG+in(λ(p),λ(q))  ≤  δGout(λ(p),p)  +  δGout(p,q)  +  δGout(q,λ(q))  =  δG(λ(p),p)  +  δGout(p,q)  +  δG(q,λ(q))  ≤  δGout(p,q)  +  εx / (8 log n). To conclude we get that

[formula]

Case 3: Finally, we need to consider the case where PG includes only vertices of Gin. We assume PG includes vertices of P and[formula]or vertices of Q (otherwise this was handled in Case 1). We focus on the case that PG includes vertices of both P and Q. The case that PG includes vertices of one of P or Q follows immediately using a similar argument.

Since P and Q are shortest paths, then PG must be composed of the following shortest paths: a u-to-p path (p∈P) in Gin, a p-to-p' subpath (p'∈P) of P, a p'-to-q' path (q'∈Q) in Gin, a q'-to-q subpath (q∈Q) of Q, and a q-to-v path in Gin. Following the same argument as in Case 2, we know that p and p' (resp. q and q') must in the prefix of P (resp. Q) of length 8x. This means δG(c,λ(c))  ≤  εx / (16 log n) for every c∈{p,p',q,q'}.

From the shrinking phase, it is easy to see that G+in includes a u-to-λ(p) path of length δG(u,p)  +  δG(p,λ(p)) and so δG+in(u,λ(p))  ≤  δG(u,p)  +  εx / (16 log n). Similarly, we have that δG+in(λ(q),v)  ≤  δG(q,v)  +  εx / (16 log n), and we have that δG+in(λ(p'),λ(q'))  ≤  δG(λ(p'),p')  +  δG(p',q')  +  δG(q',λ(q'))  ≤  δG(p',q')  +  εx / (8 log n). Furthermore, since subpaths of P in G+in between dense portals capture their exact distance in G we have that δG+in(λ(p),λ(p'))  ≤  δG(λ(p),p)  +  δG(p,p')  +  δG(p',λ(p'))  ≤  δG(p,p')  +  εx / (8 log n) and similarly δG+in(λ(q'),λ(q))  ≤  δG(q',q)  +  εx / (8 log n). To conclude we get that

[formula]

If d(Gin,Gin,G)  ≥  x, then d(Gin,Gin,G+in) is a (1 + ε / (2 log n))-approximation of d(Gin,Gin,G). If d(Gin,Gin,G)  <  x, then d(Gin,Gin,G+in)  ≤  (1 + ε / (2 log n))  ·  x.

By the above corollary, approximating d(Gin,Gin,G) when d(Gin,Gin,G)  ≥  x reduces to approximating d(Gin,Gin,G+in). When d(Gin,Gin,G)  <  x it means that the diameter of the original graph G is not a (u∈Gin)-to-(v∈Gin) path and will thus be approximated in a different recursive call.

Finally, notice that indeed we maintain the invariant that the distance between any two marked vertices in the recursive call to G+in is a (1 + ε)-approximation of the distance in the original graph G. This is because, by the above corollary, every recursive call adds a 1 + ε / (2 log n) factor to the approximation. Each recursive call decreases the input size by a factor of (2 / 3 + o(1))- 1. Hence, the overall depth of the recursion is at most log 1.5 - o(1)n  <  1.8 log n. Since

[formula]

the invariant follows (we assume in the last inequality that ε  ≤  0.1). Together with the (1 + 5ε)-approximation for d(Gin,Gout,G) in the original graph G, we get a (1 + 5ε)  ·  (1 + ε)  ≤  (1 + 7ε)-approximation of d(Gin,Gin,G) in the original graph G, once we apply recursion to d(Gin,Gin,G+in).

We note that our recursion halts once |G+in|  ≤  (256 log n  /  ε)4 in which case we naively compute d(Gin,Gin,G+in) using APSP in time O(|G+in|2). Recall that even at this final point, the distances between marked vertices still obey the invariant.

Running time

We now examine the total running time of our algorithm. Let n denote the number of vertices in our original graph G and let V(G) denote the vertex set of the graph G in the current invocation of the recursive algorithm. The current invocation approximates d(Gin,Gout,Gt) as shown in subsection [\ref=ss:gt] in time O(|V(G)|  /  ε + 2O(1 / ε)). It then goes on to construct the subgraphs G+in and G+out as shown in subsection [\ref=ss:gplus], where we have that after contraction using dense portals, |V(G+in)|  =  α|V(G)| + O( log 4n / ε4) and |V(G+out)|  =  β|V(G)| + O( log 4n / ε4), where α,β  ≤  2 / 3 and α  +  β  ≤  1. The time to construct |V(G+in)| and |V(G+out)| is dominated by the time required to compute SSSP for each dense portal, which requires O(|V(G)|  ·   log n / ε). We then continue recursively to G+in and to G+out. Hence, if T(|V(G)|) denotes the running time for G, then we get that

[formula]

In the recursion's halting condition, once we get to components of size |V(G)|  =  (256 log n  /  ε)4, we naively run APSP. This takes O(|V(G)|2) time for each such component, and there are O(n / |V(G)|) such components, so the total time is O(n  ·  |V(G)|) = O(n log 4n  /  ε4). It follows that

[formula]

Concluding Remarks

We presented the first (1 + ε)-factor approximation algorithm for the diameter of an undirected planar graph with non-negative edge lengths. Moreover, it is the first algorithm that provides a nontrivial (i.e. less than 2-factor) approximation in near-linear time.

It might still be possible to slightly improve the running time of our algorithm by removing a logarithmic factor, or by replacing the exponential dependency on ε with a polynomial one. In addition, the technique of Abraham and Gavoille [\cite=AG06] which generalizes shortest-path separators to the class of H-minor free graphs may also turn out to be useful.