< -100 [formula] =0pt =0

< Example Conjecture Proposition Theorem Corollary Definition Lemma

On parity check collections for iterative erasure decoding that correct all correctable erasure patterns of a given size

Introduction

This note addresses iterative decoding of erasures for a binary linear code using a given, fixed collection of parity check equations. The idea is to correct erasures in a codeword one-by-one, where in each step a parity check equation is used that involves precisely one of the remaining erasure positions, thus allowing this erasure to be corrected. The correction procedure stops if no such parity check can be found for the set of current erasures; in that case the set of the positions of these erasures is called a stopping set for the given collection of parity checks [\cite=Di02]. As shown in [\cite=Di02], the correction procedure stops with erasures in the positions of the largest stopping set contained in the set of erased positions that we started with.

Each subset of the dual code can be used as collection of parity checks for this method. (Mostly we will consider only full-rank subsets that do not contain the all-zero word.) Different subsets in general lead to different stopping sets. Note however that the support of each nonzero codeword is always a stopping set: indeed, by definition each parity check involves an even number of positions from such a set.

A received word containing only correct symbols and erasures can be decoded unambiguously precisely when exactly one codeword agrees with this word in the non-erased positions; if the code is linear this is the case precisely when no support of a nonzero codeword is contained in the set of erasures. For this reason we will refer to a set of erasure as uncorrectable if it contains the support of a nonzero codeword, and as correctable otherwise. It can be seen [\cite=WeAb05b] that the iterative algorithm decodes each correctable set of erasures if the collection of parity checks consists of the entire dual code.

Motivated by these observations, we refer to a parity check collection as m-erasure reducing if each stopping set of size m for this parity check collection is uncorrectable. In other words, a parity check collection is m-erasure reducing precisely if for any correctable pattern of m erasures, a parity check equation from our collection can be used to remove a single erasure. We call a parity check collection m-erasure correcting if iterative decoding allows to decode all correctable patterns of m erasures.

The design of a parity check collection to be used for such an iterative decoding procedure involves a trade-off between the complexity of the resulting decoding method, which is determined amongst others by the size of the collection, and the effectiveness of the method, which in the case of a small erasure probability is mainly determined by the minimum size of a stopping set and the number of stopping sets of this size. From the above discussion we see that this minimum size can be as large as the minimum distance d of the code, with all stopping sets of size d being supports of codewords, and therefore it is interesting to investigate d-erasure correcting parity check collections. In [\cite=WeAb05a], which in fact inspired the present work, this problem was investigated for the r-th order

[formula]

Notations and definitions

In this section, we introduce some notations and definitions. Throughout this paper, we use boldface letters to denote row vectors. All vectors and matrices are binary. If there is no confusion about the length of vectors, we denote with [formula] and [formula] the vectors consisting of only zeroes or only ones, and with [formula] the i-th unit vector, the vector that has a one in position i and zeroes elsewhere.

The size of a set A is denoted by |A|. If H is a r  ×  n matrix and [formula], then the restriction H(E) of H to E denotes the r  ×  |E| matrix consisting of those columns of H indexed by E. Similarly, if [formula] and [formula], then the restriction [formula] of [formula] to E is the vector of length |E| consisting of the entries indexed by E.

The support supp(x) of a vector [formula] is the set of its non-zero coordinates, that is,

[formula]

and the weight wt(x) of x is the size [formula] of its support.

As usual, an

[formula]

code with r = n - k consisting of all vectors in [formula] that have inner product 0 with all words from C. The number r is referred to as the codimension or redundancy of the code. An r  ×  n matrix is called a parity check matrix for C if its rows span [formula]. When we speak about "code", we will always mean binary linear code.

A received word containing only correct symbols and erasures can be decoded unambiguously precisely when exactly one codeword agrees with this word in the non-erased positions; as we consider linear codes, this is the case precisely when the erased positions do not contain the support of a nonzero codeword. This motivates the following definition.

The relevance of the following definition is obvious in connection with the iterative scheme for erasure decoding described in the introduction. Note that the empty set is a stopping set as well. The iterative correction procedure applied to a set E of erasures stops with erasures in the largest stopping set contained in E [\cite=Di02]. Hence, E is correctable with H if and only if the iterative correction procedure, using H, removes all erasures. Note that uncorrectable sets with H are called dead-end sets for H in [\cite=WeAb05b].

Assume we apply the iterative correction procedure with H for retrieving words from the code C. We are interested in the behavior of the iterative error correction procedure only for C-correctable erasure patterns (for C-uncorrectable erasure patterns, no decoding algorithm can resolve all erasures). If C has codimension r, then for any (2r - r) subset H of [formula] not containing 0, every correctable erasure pattern is correctable with H [\cite=WeAb05b]. It is our aim to construct (smaller) sets of parity check equations H such that all C-correctable erasure patterns up to a given cardinality are correctable with H.

For analysis, the following definition, which deals with a single step in the iterative decoding algorithm, is useful.

Definition [\ref=meras] has the following consequence. An m-erasure reducing set H allows to resolve, for each C-correctable erasure pattern E of size m, at least one of the erasures from E with a parity check equation from H. In other words, with an m-erasure correcting set H for C, the iterative correction procedure can correct all C-correctable erasure patterns of size at most m by removing one erasure at the time, without ever getting stuck. The following example shows that an m-erasure reducing set need not be an m-erasure correcting set.

Let C be the binary

[formula]

Finally, we introduce the notion of a "generic" m-erasure reducing and correcting set for codes of a fixed codimension. The idea is to describe which linear combinations to take given any full-rank parity check matrix for any such code. At first sight, Definition [\ref=gendef] seems to be very restrictive. However, in the next section we will see that if the linear combinations work for the parity check matrix of the r-th order Hamming code, then they work for any parity matrix for any code of codimension r.

Generic (r,m)-erasure reducing and correcting sets

Here we will derive several properties of generic (r,m)-erasure reducing and correcting sets. We start with a simple and well-known observation.

Let H be a parity check matrix for a code C of length n, and let [formula]. The restriction H(E) of the matrix H has full rank if and only if there is no non-zero word [formula] such that supp(c)⊆  E.

The matrix H(E) has full rank if and only if no non-empty subset I of its columns add to 0. As H is a parity check matrix for C, the columns indexed by I add to 0 if and only if I is the support of a codeword.

The following characterization of generic (r,m)-erasure reducing sets will often be used.

A set [formula] is generic (r,m)-erasure reducing if and only if for any r  ×  m matrix M of rank m there is a vector a∈A such that wt(aM) = 1.

First, suppose that A is generic (r,m)-erasure reducing. Let M be an r  ×  m matrix with rank m. Let H: = (M|I), where I denotes the r  ×  r identity matrix, and let C denote the code with parity check matrix H. As M has full rank, Lemma [\ref=fullrank] implies that the set [formula] does not contain the support of a non-zero codeword. As A is generic (r,m)-reducing, there is a vector a∈A such that [formula] has weight one.

Conversely, suppose that A is such that for each r  ×  m matrix M of rank m there is a vector a∈A such that wt[formula]. Let C be a code of codimension r, and let H be an r  ×  n parity check matrix for C; so that H has full rank r. Let [formula] have size m and be such that it does not contain the support of a nonzero codeword. According to Lemma [\ref=fullrank], the matrix H(E) has rank m, and hence there is an a∈A such that [formula] has weight one.

Hamming codes play a special role: they are the "most difficult" codes to create m-erasure reducing sets for. The following proposition makes this statement precise.

Let C be a

[formula]

This is a direct consequence of Lemma [\ref=fullrank], Proposition [\ref=altdef], and the fact that up to a column permutation, each r  ×  m matrix of rank m occurs in H, as H contains each non-zero column exactly once.

Let 2  ≤  m  ≤  r. A generic (r,m)-erasure reducing set is a generic (r,m - 1)-erasure reducing set.

Let A be a generic (r,m)-erasure-reducing set. Let M be a binary r  ×  (m - 1) matrix of rank m - 1. We write

[formula]

where [formula] denotes the rightmost column of M. Let [formula] be a vector in [formula] that is not in the linear span of the columns of M, and let [formula] denote the r  ×  m matrix defined as

[formula]

As [formula] has rank m, there exists a vector a∈A such that wt[formula]. We claim that wt[formula]. This is clear if wt[formula], as then [formula]. If [formula], then ay[formula] and [formula], or vice versa. In either case, a[formula], from which we conclude that in this case also [formula] has weight 1.

Note that Proposition [\ref=mthenm-1] implies that the parity check equations induced by a generic (r,m)-erasure reducing set can also be used to resolve an erasure from a correctable erasure set of size [formula] (we have seen in Example [\ref=Ex1] that this need not hold for a specific m-erasure reducing set for a specific code). In other words, the following proposition holds.

Any generic (r,m)-erasure reducing set is a generic (r,m)-erasure correcting set.

Note that Proposition [\ref=Hamming] and Proposition [\ref=red=dec] imply that in [\cite=WeAb05a], Weber and Abdel-Ghaffar in fact construct generic (3,r)-erasure correcting sets. According to Proposition [\ref=red=dec], the terms "generic (r,m)-erasure reducing" and "generic (r,m)-erasure correcting" can be used interchangably. In the sequel, we mostly use "correcting", and base our results on the characterization given in Proposition [\ref=altdef].

Finally, for later reference we explicitly state two simple results.

If A is a generic (r,m)-erasure correcting set and if S is any invertible r  ×  r matrix, then the set [formula] is generic (r,m)-erasure correcting as well.

Let [formula] be (r,m)-erasure correcting. Let M be an r  ×  m matrix of rank m. Then the matrix SM is an r  ×  m matrix of rank m as well, and so there is a vector a∈A such that wt([formula])=1, so wt(([formula]=1.

We will say that two generic (r,m)-correcting sets A and [formula] with S invertible are equivalent.

For all r,m with 1  ≤  m  ≤  r, a generic (r,m)-erasure reducing set spans [formula].

Let [formula] be such that span[formula]. Let x be a non-zero vector in [formula]. Let S be any invertible matrix with [formula] as leftmost column. Finally, let M be an r  ×  m matrix of rank m for which the top row has odd weight and all other rows have even weight. As for each [formula] the vector [formula] starts with a zero, the vector [formula] has even weight. Consequently, [formula] is not a generic (r,m)-erasure reducing set. Now Proposition [\ref=propbasistransform] implies that A is not a generic (r,m)-erasure reducing set.

A construction for generic (r,m)-erasure correcting sets

We start this section with describing generic (r,m)-erasure correcting sets Ar,m for all r and m with r  ≥  m  ≥  2. We will see that the set Ar,3 is equivalent to the sets found by Weber and Abdel-Ghaffar

As Ar,m consists of all vectors that start with a one and have weight at most m - 1 in the positions 2,3, ,r, the statement on the size of Ar,m is obvious.

In order to show that Ar,m is indeed generic (r,m)-erasure correcting, we will use Proposition [\ref=altdef]. So let M be an r  ×  m matrix of rank m. We have to show that there is a vector a∈Ar,m such that wt(aM)=1. To this end, we proceed as follows. For 1  ≤  i  ≤  r, let mi denote the i-th row of M. Let [formula] be such that [formula] forms a basis for [formula]. We distinguish two cases.

(i): [formula].

In this case, we can and do choose I such that 1∈I. The set [formula] is (m - 1)-dimensional and hence cannot contain all unit vectors. So there exists a vector [formula] with x1 = 1 and wt([formula]. Now, let [formula] be the vector that agrees with [formula] in the positions indexed by I and has zeroes elsewhere. Then a1 = x1 = 1 and wt(a)=  wt[formula], hence a∈Ar,m and [formula], so wt[formula].

(ii): [formula].

Note that in this case 1∉I. As [formula] forms a basis, there are independent vectors [formula] such that [formula] for all j. As there is just one vector [formula] of weight m, and there are m  ≥  2 unit vectors, there is an index j such that wt[formula]. Now, let a be the vector that agrees with [formula] in the positions indexed by I, has a "1" in the first position, and zeroes elsewhere. As wt[formula], the vector a is in Ar,m. Moreover, we have that [formula].

We now compare our result for m = 3 with that of Weber and Abdel-Ghaffar [\cite=WeAb05a], which in our terminology states that

[formula]

is generic (r,3)-erasure correcting. To this end, let S be the matrix with the all-one vector as leftmost column, and with [formula] as j-th column for 2  ≤  j  ≤  r. Obviously S is invertible, and

[formula]

for 2  ≤  i  ≤  r and 2  ≤  j < k  ≤  r. As a consequence, we have that

[formula]

So Wr and Ar,3 are related via an element-wise multiplication with an invertible matrix, hence they are equivalent (see Proposition [\ref=propbasistransform]).

Some optimality results

In this section we investigate the minimum size F(r,m) of a generic (r,m)-erasure correcting set, where 1  ≤  m  ≤  r. We first show that F(r,1) = r and that for m = 2 and m = r, the set Ar,m is a generic (r,m)-erasure correcting set of minimal size. Moreover, we also characterize all generic (r,r)-erasure correcting sets of minimum size.

We have that F(r,1) = r for [formula] and F(r,2) = r for [formula].

The case r = 1 is trivial; for [formula] the proposition is a direct consequence of Proposition [\ref=span] (for the lower bound) and the fact that Ar,2 is generic (r,2)-erasure correcting of size r.

Let [formula] be generic (r,r)-erasure correcting. We claim that the complement [formula] does not contain r independent vectors. Indeed, let [formula] be independent vectors. Let U be the matrix with [formula] as i-th row, and let M: = U- 1. For 1≤  j  ≤  m, [formula] if and only if [formula]. As A is generic (r,r)-erasure correcting, at least one of the [formula]'s is indeed in A.

So the complement of A does not contain r independent vectors, and hence lies in a subspace of dimension r - 1; we conclude that

[formula]

with equality if and only if the complement [formula] is a hyperplane in [formula].

Conversely, suppose that [formula] is a hyperplane. Then a basis [formula] for [formula] can be found such that [formula] spans [formula], and so

[formula]

Let U be the r  ×  r matrix with [formula] as i-th row. For each [formula], we have that

[formula]

and so we have that

[formula]

As Ar,r is generic (r,r)-erasure correcting, and U is invertible, Proposition [\ref=propbasistransform] implies that A is also generic (r,r)-erasure correcting.

Next we investigate the inclusion-minimality of the sets Ar,m. First we show that removal of any word of weight m or m - 1 from Ar,m results in a set that is no longer generic (r,m)-erasure correcting; we also show that removing any word from Ar,r - 1 results in a set that no longer is generic (r,r - 1)-erasure correcting. Finally, we show that if r  ≥  2m - 1 + 1, then certain words of weight less than m - 2 can be removed such that the resulting set still is generic (r,m)-erasure correcting.

Let r  ≥  m  ≥  3. If [formula] has weight m or m - 1, then [formula] is not a generic (r,m)-erasure correcting set.

Let [formula] have weight at least m - 1. We will construct an r  ×  m matrix M such that [formula] is the only vector x in Ar,m such that wt(xM)=1.

First, assume that [formula] has weight m. We assume without loss of generality that [formula]. Let M be the r  ×  m matrix defined as

[formula]

where Im - 1 denotes the identity matrix of order m - 1. It is clear that M has rank m. Now let [formula]. As [formula], we have that

[formula]

Consequently, if [formula] has weight 1, then [formula], so [formula] is the only vector x in Ar,m for which [formula] has weight 1.

Next, assume that a has weight m - 1; we assume without loss of generality that a starts with m - 1 ones. Let M be the r  ×  m matrix defined as

[formula]

Clearly, M has rank m. Now let [formula]. As [formula], we have that

[formula]

Hence, if [formula] has weight 1, then [formula], and [formula]. As x is in Am,r, it has weight at most m; as x start with m - 1 ones, and has an even number of ones in the positions [formula], it follows that [formula], and so [formula].

Let m  ≥  3. No subset of Am + 1,m is generic (m + 1,m)-erasure correcting.

Let a be a vector of weight w, 1≤  w  ≤  m, in Am,m + 1. We show that [formula] is not generic (m + 1,m)-erasure correcting by constructing an (m + 1)  ×  m matrix M such that [formula] is the only vector x in Am + 1,m such that xM has weight 1. We assume without loss of generality that [formula] starts with w zeroes. Let M be the matrix

[formula]

Clearly, M has rank m. Let [formula]. As x1 = 1, we have that

[formula]

Hence, if wt([formula], then xj = 1 for 1  ≤  j  ≤  w, and [formula]. As wt[formula], it follows that xj = 0 for j  ≥  w + 1, and so [formula].

In fact, although we cannot prove it yet, we have reason to believe that the following is true.

We now come to one of the main results stating that the sets Ar,m are not optimal if [formula] and r is large with respect to m. The precise statement is as follows.

Let M be an r  ×  m matrix of rank m. We will show that there is an x[formula] such that wt[formula]. We denote the set [formula] by I, and the i-th row of M by [formula]. As Ar,m is generic (r,m)-erasure correcting, there is an [formula] such that wt[formula], say a[formula]. Let us assume that [formula], as otherwise we can take [formula]. We will add to a a vector of weight 1 and or 2 with support in J such that the resulting vector x, which is automatically in [formula], satisfies wt[formula]. We distinguish four cases.

(i): For some i∈I and some [formula], we have that [formula]. Then we take [formula]; note that x[formula].

(ii): For some distinct i,j∈I, [formula]. Then we take [formula].

(iii): For some i,j∈I and some [formula], [formula] and [formula]. Then we take [formula].

(iv): Finally, assume that we are in neither of the above cases. Let [formula]. Because we are not in case (b), |V| = |I| = 2m - 1. For [formula], let [formula]. As we are not in case a, [formula], and for [formula], [formula]. As we are not in case c, V contains at most m - 1 unit vectors, and so

[formula]

As a consequence, we have that

[formula]

As there are 2m - 1 - m vectors in [formula] of weight at least 2, Equation [\ref=setsize] implies that there is a vector [formula] of weight at least 2 such that [formula]. That is, there are row indices i and j in I such that [formula] and [formula]. We take [formula].

In fact it is not too difficult to show that the lower bound 2m - 1 + 1 on r in Theorem [\ref=imprgeneral] is optimal, in the sense that A*r,m is not generic (r,m)-erasure correcting if r = 2m - 1.

Theorem [\ref=imprgeneral] has the following interesting consequence.

For r  ≥  5, the set [formula] is generic (r,3)-erasure correcting.

The construction from [\cite=WeAb05a] therefore is not optimal (although the improvement of course only is marginal).

Concluding remarks

In this paper, we introduced and studied generic (r,m)-erasure reducing and correcting sets. An obvious extension of this work is to consider (r,m)-erasure reducing or correcting sets that are generic for a certain class of codes of codimension r only. As an example, let us consider the class of even weight codes. Such codes have an r  ×  n parity check matrix H for which the first row consists of the all-one vector. Let [formula] have size m = 4 and suppose that H(E) has rank four. We claim that there is an [formula] such that [formula] or [formula] has weight one. Indeed, as H(E) has rank four, it contains a row of odd weight, say its i-th row. If this row has weight one, then [formula] has weight one; if not, this row has weight three, and so [formula] has weight one. As a consequence, we have a set of size 2(r - 1) that is generic (r,4)-erasure reducing (in fact even generic (r,4)-erasure correcting) for even-weight codes. (Note that the set Ar,4 has a size of the order r3.) A manuscript on generic (r,m)-erasure reducing and correcting sets for even weight codes is in preparation.

We believe that the exact determination of F(r,m) is a difficult problem in general. However some progress may be possible for the case where m is close to r. Also, it is interesting to study F(r,m) for fixed m and large r. Both these cases will be the subject of a follow-up paper.