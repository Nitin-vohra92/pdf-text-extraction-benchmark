Lemma Corollary

A note on convex characters, Fibonacci numbers and exponential-time algorithms

Introduction

Phylogenetics is the science of accurately and efficiently inferring evolutionary trees given only information about contemporary species [\cite=semple_steel_2003]. An important concept within phylogenetics is convexity. Essentially this captures the situation when, within a phylogenetic (i.e. evolutionary) tree, each biological state emerges exactly once: it should not emerge, die out, and then re-emerge. More concretely, given a phylogenetic tree and a set of states assigned to its leaves, can we assign states to the internal vertices of the tree such that each state forms a connected "island" within the tree? If this is possible, the assignment of states to the leaves is known as a convex character.

In this article we present a number of results concerning the enumeration of convex characters. In Section [\ref=sec:prelim] we give formal definitions and describe relevant earlier work. In Section [\ref=sec:result] we start by showing that an earlier result counting convex characters can be simplified to a term of the Fibonacci sequence. We then seek to count convex characters with the added restriction that each state should occur on at least k leaves, proving the somewhat surprising result that (as for k = 1) tree topology is irrelevant for k = 2, and that a formulation in terms of Fibonacci numbers is again possible. We give an explicit example showing that for k  ≥  3 the topological neutrality breaks down. In Section [\ref=sec:dp] we show that for all k the size of the space can be counted in polynomial time and space using dynamic programming, which also permits listing and sampling uniformly at random, noting also that non-isomorphic trees can have exactly the same vector of space sizes (for k = 1,2,...). In Section [\ref=sec:alg] we give a number of algorithmic applications for NP-hard problems arising in phylogenetics that seek to quantify the dissimilarity of two phylogenetic trees. Finally, in Section [\ref=sec:conc] we briefy discuss a number of open problems arising from this work. The software associated with this article has been made publicly available.

Preliminaries

For general background on mathematical phylogenetics we refer to [\cite=semple_steel_2003] [\cite=dress2012basic]. An unrooted binary phylogenetic X-tree is an undirected tree T = (V(T),E(T)) where every internal vertex has degree 3 and whose leaves are bijectively labelled by a set X, where X is often called the set of taxa (representing the contemporary species). We use n to denote |X| and often simply write tree when this is clear from the context.

A character f on X is a surjective function f:X  →  C for some set C of states (where a state represents some characteristic of the species e.g. number of legs). We say that f is an r-state character if |C| = r. Each character naturally induces a partition of X and here we regard two characters as being equivalent if they both induce the same partition of X. An extension of a character f to V(T) is a function h:V(T)  →  C such that h(x)  =  f(x) for all x in X. For such an extension h of f, we denote by lh(T) the number of edges e = {u,v} such that h(u)  ≠  h(v). The parsimony score of a character f on T, denoted by lf(T), is obtained by minimizing lh(T) over all possible extensions h of f. We say that a character f:X  →  C is convex on T if lf(T)  =  |C|  -  1. Equivalently: a character f:X  →  C is convex on T if there exists an extension h of f such that, for each state c∈C, the vertices of T that are allocated state c (by h) form a connected subtree of T. We call such an extension h a convex extension of f. See Figure [\ref=fig:g2] for an example. The convexity of a character can be tested in polynomial [\cite=fitch_1971] [\cite=hartigan1973minimum] (in fact, linear [\cite=bachoore2006convex]) time.

We write g(T,r) to denote the number of r-state convex characters on T and gi(T,r) (i  ≥  1) to denote the number of those characters that have the additional property that each state used by the character appears on at least i taxa. It follows from the definition of character that g1(T,r)  =  g(T,r). We define:

[formula]

The value g1(T) is therefore equal to the total number of convex characters on T. For the tree shown in Figure [\ref=fig:g2], g(T) = g1(T) = 233 and g2(T) = 8. We adopt the standard convention that the binomial coefficient [formula] evaluates to 1 if k = 0, and 0 if n  <  k and k  >  0. In [\cite=steel1992complexity] it is proven that, for n,r  ≥  1,

[formula]

Hence,

[formula]

As observed in [\cite=steel1992complexity], the expression for g1(T,r) (somewhat surprisingly) does not depend on the topology of T, only on the number of taxa n. Hence we can write g(n),g1(n) and g1(n,r) without ambiguity.

Fibonacci numbers and convex characters

The value g2(T,r) only depends on n (i.e. the topology of T is not relevant) and for n  ≥  2,r  ≥  1 is given by the expression

[formula]

We prove this by induction on n. For the base case note that for n∈{2,3,4} there is only one binary tree topology (up to relabelling of taxa) possible on n taxa and that the expression correctly evaluates to 1 when r = 1 and, when r  ≥  2, evaluates to 0 in all cases except n = 4,r = 2 when it correctly evaluates to 1.

Consider then n  ≥  5, and let r be any value 2  ≤  r  ≤  ⌊n / 2⌋. (For r = 1 the expression correctly evaluates to 1, and for r  >  ⌊n / 2⌋ the expression correctly evaluates to 0). Every tree on 4 or more taxa contains at least one cherry: two taxa x,y that have a common parent u where the third neighbour of u is an interior vertex. Fix such a cherry. (A similar technique is used in [\cite=steel1992complexity] and [\cite=steel1995classifying]). Observe that any convex character f on T with the property that each state appears at least twice, has f(x) = f(y). This follows from the connected-subtree definition of convexity. Now, let [formula] and let [formula], where T|X' denotes the tree (on the set of taxa X') obtained from T by taking the minimum subtree connecting the elements of X' and then suppressing vertices of degree 2.

There are two cases to distinguish. The first case is when the state f(x) = f(y) does not appear on any other taxa. There are g2(T'',r - 1) such characters. The second case is when f(x) = f(y) does appear on at least one other taxon. There are g2(T',r) such characters. Hence,

[formula]

By the inductive hypothesis we have

[formula]

The last equality follows from the well-known identity known as Pascal's Rule i.e. [formula], which holds for 1  ≤  k  ≤  n. This completes the proof.

Consequently, the total number of convex characters on a tree T with each state appearing at least twice is independent of the topology of T. Specifically, we have:

[formula]

For even n, g2(n)  =  g1(n / 2).

This is immediate by observing that Equation ([\ref=eq:g2]) can be obtained by substituting n / 2 for n in Equation ([\ref=eq:g1]).

Let F(n) denote the nth Fibonacci number. That is, F(0) = 0, F(1) = 1 and for n  ≥  2, F(n)  =  F(n - 1)  +  F(n - 2). For comprehensive background on Fibonacci numbers see [\cite=koshy2011fibonacci].

For n  ≥  2, g2(n)  =  F(n - 1) and g1(n)  =  F(2n - 1).

The following identity is classical (n  ≥  0):

[formula]

If we index k from 1 rather than 0 we obtain,

[formula]

Now, if we replace n with n - 2:

[formula]

The expression for g1(n) is then obtained by applying Corollary [\ref=cor:switch].

The question arises whether the values g3(T,r) and/or g3(T) share the topological neutrality of their g1 and g2 counterparts. This is not the case: see Figure [\ref=fig:g3]. Here g3(T1) = 5, because g3(T1,1) = 1, g3(T1,2) = 3, g3(T1,3) = 1 and g3(T1,r) = 0 (for r  >  3). However, g3(T2) = 6, because g3(T2,1) = 1, g3(T2,2) = 4, g3(T2,3) = 1 and g3(T2,r) = 0 (for r > 3).

Computing gk(T) (and listing its elements) with dynamic programming

The results from the previous section give rise to a number of questions. Can we compute gk(T) in polynomial time, for k  ≥  3? Also, if we want to explicitly list all the elements counted by gk(T) (k  ≥  1), is it possible to achieve this in some reasonable total running time e.g. [formula]? We show that, for all k  ≥  1, the answer to both questions is yes. Specifically, we show how to compute gk(T) using dynamic programming, for each k  ≥  1. The combinatorial recurrence within the dynamic programming will also allow us to derive a polynomial-time computable bijection from [formula] to the characters counted by gk(T). Using this bijection it is then straightforward to list (or sample) these elements. Note that this is also an advance for g1(T), since the recurrence used in [\cite=steel1992complexity] to derive g1(n) is based on inclusion-exclusion: it is not obvious how to transform it into a bijection.

We begin by rooting T by subdividing an arbitrary edge with a new vertex and (implicitly) directing all edges away from this new vertex. The new vertex becomes the root of the tree. Note that this rooting operation has no impact on the convexity of characters, and the location of the root is irrelevant; it is simply a convenience which ensures that the term "child" is well-defined. The dynamic programming works bottom-up, from the leaves towards the root.

Here it is helpful to represent a character f on X as a set of non-overlapping, non-empty subsets [formula] that partition X, where each Bi corresponds to a state. We also need some new definitions. A character f is valid for gk(T) if

f is convex on T, and

for each Bi∈f, |Bi|  ≥  k.

Consider an ordered pair (f,B) where f is a character on X and B∈f. We call such a pair a character-root pair of T if

f is convex on T, and

there exists a convex extension of f in which the root of T is assigned state B.

Equality between character-root pairs is defined strictly i.e. (f,B)  =  (f',B') if and only if f = f' and B = B'. We say that a character-root pair (f,B) of T is semi-valid for gk(T) if, for each Bi∈f, Bi  ≠  B  ⇒  |Bi|  ≥  k. Note that if a character-root pair (f,B) is semi-valid for gk(T), then f is valid for gk(T) if and only if |B|  ≥  k.

At each vertex u of the tree we will compute and store the following k + 1 values, where Tu is simply the subtree rooted at u:

gk(Tu),

for each 1  ≤  m  ≤  k - 1 the number h(Tu,m) which is defined as the number of character-root state pairs (f,B) of Tu such that both the following conditions hold: (f,B) is semi-valid for gk(Tu) and |B|  =  m. We also store h(Tu,k) which is defined slightly differently: we replace the term |B|  =  m with |B|  ≥  k.

If u is a taxon, then:

gk(Tu) is equal to 1 if k = 1, and 0 if k > 1,

h(Tu,m) is equal to 1 if m = 1 and 0 if m  >  1.

We show how to compute these values recursively, assuming the corresponding values have already been computed for Tl (the subtree rooted at the left child of u) and Tr (the subtree rooted at the right child of u). First,

[formula]

The idea behind this recurrence is that characters counted by gk(Tu) can be created in two ways: (i) by taking the union of a character from the left subtree with a character from the right subtree, and (ii) by taking a character-root pair (f,B) from the left subtree, a character-root pair (f',B') from the right subtree, and then merging the root states to yield a character [formula]. Characters from the subtrees can only be used for (i) if they are already valid (with respect to gk) in their subtrees. The characters f and f' that are used for (ii) might not be valid with respect to their subtrees, but we do require that they can be combined to obtain a character that is valid for gk(Tu). This is possible if and only if (f,B) and (f',B') are semi-valid for their respective subtrees and the sum of the cardinalities of B and B' is at least k. See Figure [\ref=fig:rootMerge] for an example.

Second, for 1  ≤  m  ≤  k - 1 we have,

[formula]

Note that here m  ≤  k - 1, which means that the semi-valid character-root pairs (f,B) counted by this recurrence are such that f is not valid for gk(Tu). The first two terms of the recurrence concern the situation analogous to (i) above. Specifically, in this case we assume that no states are merged, so a new semi-valid character-root pair can be created for Tu if and only if it is constructed from the combination of a valid character from one subtree, with a semi-valid character-root pair from the other. The summation term corresponds to (ii). That is, we only count combinations of character-root pairs from the two subtrees if the cardinality of the merged state is exactly m.

Finally we have,

[formula]

This final recurrence is semantically very similar to the previous one. The main difference is that it counts all semi-valid character-root pairs (f,B) for gk(Tu) such that f is valid for gk(Tu). For a given vertex u, Equation ([\ref=eq:g]) can be computed in O(k2) time, assuming the values for Tl and Tr have already been computed earlier. The same time bound holds for Equations ([\ref=eq:h]) (for a specific 1  ≤  m  ≤  k - 1) and ([\ref=eq:h2]). Equation ([\ref=eq:h]) has to be computed for each m, yielding a naïve running time bound of O(k3) (per vertex u), but this can easily be improved to O(k2) by observing that a single 1  ≤  i,j  ≤  k sweep over the h(Tl,i) and h(Tr,j) values can be recycled for computation of all the different h(Tu,m) values. There are 2(n - 1) vertices in the tree. This yields the following theorem.

Let T be an unrooted binary tree on n taxa. For each 1  ≤  k  ≤  n, gk(T) can be computed in O(k2  ·  n) time and O(k  ·  n) space.

Let T be an unrooted binary tree on n taxa. For each 1  ≤  k  ≤  n, all the characters that are counted by gk(T) can be generated in O(gk(T)  ·  k2  ·  n) total time, and a character counted by gk(T) can be sampled uniformly at random in O(k2  ·  n) time and O(k  ·  n) space.

Critically, there is no inclusion-exclusion involved Equations ([\ref=eq:g]), ([\ref=eq:h]) and ([\ref=eq:h2]). This allows us to impose a canonical ordering on the characters (and character-root pairs) counted by these equations. For example, within Equation ([\ref=eq:g]) we can choose to place the type-(i) characters earlier in the ordering than the type-(ii) characters. Within the gk(Tl)gk(Tr) type-(i) characters we can refine the order as follows: the first character from the left subtree combined with in turn each of the gk(Tr) characters from the right subtree, then the second character from the left subtree combined in turn with each of the gk(Tr) characters from the right subtree, and so on. Once a canonical ordering has been chosen and the dynamic programming has been completed, we can start at the root of T and (using the g and h values computed at all vertices of the tree) recursively backtrack to generate the uniqely defined ith character. Hence, we obtain a bijection from [formula] to the characters counted by gk(T). The time and space requirements for backtracking through the tree (i.e. evaluating the bijection for a given element of [formula]) are dominated by the time and space requirements of executing the original dynamic program, which are O(k2  ·  n) and O(k  ·  n) respectively. This bijection can then be used to list all the characters counted by gk(T) or to sample uniformly at random from this space.

We have implemented the dynamic programming (and the corresponding algorithms for listing and sampling) in Java and this can be downloaded from . Finally within the section, for an unrooted binary tree T on n leaves, we define the g-spectrum as simply the vector [formula]. It is natural to ask whether two trees on n taxa have the same g-spectrum if and only if they are isomorphic (see e.g. [\cite=bordewich2005identifying] for related discussions of "identifiability"). Using the code above we have verified that, while this claim is true for n  ≤  10 leaves (see the software website for a proof), a counter-example exists for n = 11, see Figure [\ref=fig:spectrum].

Algorithmic applications

One of the advantages of expressing g1(n) and g2(n) as Fibonacci numbers is that it allows us to give tight bounds on their rate of growth. This can be particularly useful when bounding the running time of algorithms. Consider the following classical, closed-form expression for the Fibonacci numbers (n  ≥  0), where [formula] is the golden ratio:

[formula]

(It is obtained from Binet's Formula [formula] (1843) by observing that the term ( - φ)- n is vanishing.) Combining with Theorem [\ref=thm:fiblink] we obtain

[formula]

Using asymptotic notation, it is clear that there are Θ(φ2n) convex characters and Θ(φn) convex characters in which each state occurs on at least two taxa. We give two examples of how these insights yield non-trivial exponential-time algorithms for two NP-hard problems arising in phylogenetics.

Computation of maximum parsimony distance.

Let T1,T2 be two unrooted binary trees on the same set of taxa X. The metric dMP(T1,T2) (the maximum parsimony distance of T1 and T2) is defined as follows, where f ranges over all characters on X and lf(.) is as defined in Section [\ref=sec:prelim]:

[formula]

It is NP-hard to compute dMP [\cite=kelk2014complexity] [\cite=fischer2014maximum]. It can be used to quantify the dissimilarity of two phylogenetic trees and is a lower bound on the similarly NP-hard tree bisection and reconnection (TBR) distance, denoted dTBR [\cite=AllenSteel2001].

Given two unrooted binary trees T1,T2 on the same set of taxa X, where |X| = n, dMP(T1,T2) can be computed in time Θ(φn  ·  n2), where φ  ≈  1.618... is the golden ratio.

In [\cite=kelk2014complexity] [\cite=fischer2014maximum] it is proven that the optimum is achieved by some character f that is convex on T1 or T2 and where each state in the character occurs on at least two taxa. Hence simply looping through all the characters counted by g2(T1) and, separately, all the characters counted by g2(T2) is sufficient to locate an optimal character. Note that lf(.) can be computed in O(n2) time using Fitch's algorithm [\cite=fitch_1971] or dynamic programming. Hence, scoring each character f can easily be performed in quadratic time. The result then follows by leveraging Corollary [\ref=cor:listdp].

We have implemented the dMP algorithm in Java and for an exponential-time algorithm the results are encouraging; the code is freely available at . On a single 32-bit 1.66GHz Intel Atom (N450) processor the algorithm terminates for n = 20,25,30 in less than 1 second, 3 seconds and 51 seconds respectively. On a more powerful 64-bit 3.10GHz machine the previously fastest algorithm, the Integer Linear Programming (ILP) approach described in [\cite=kelk2014complexity], took 70 seconds to terminate on 12 taxa, and stalled completely on trees with more than 16 taxa, even using state-of-the-art ILP software. The enhanced range of our software has been recently used in experiments to verify that dMP is often a very good lower bound on dMP [\cite=kelk2015reduction].

Computation of TBR distance and maximum agreement forests.

Finally, we note that the results in this article also give an easy (although, in some cases, somewhat crude) upper bound on the number of agreement forests of two unrooted binary trees T1,T2 on n taxa. Recall that, for an unrooted binary phylogenetic tree T on X and X'  ⊆  X, T|X' is defined to be the unrooted binary phylogenetic tree on X' obtained by taking the minimal subtree of T that connects X', and suppressing vertices of degree 2. An agreement forest is a partition of X into non-empty subsets [formula] such that (i) within T1 (respectively, T2) the minimal connecting subtrees induced by the Xi are vertex-disjoint and (ii) for each Xi, T1|Xi  =  T2|Xi (where here equality explicitly takes the taxa into account). See [\cite=AllenSteel2001] and recent articles such as [\cite=chen2015parameterized] for further background on agreement forests. A maximum agremeent forest is an agreement forest with a minimum number of components, and this minimum is denoted dMAF. Note that due to part (i) of the definition every agreement forest induces a character that is convex on both T1 and T2 (although not all characters that are convex on both T1 and T2 necessarily correspond to agreement forests). Hence there are at most O(φ2n) agreement forests, which is O(2.619n). It is well-known that dTBR is equal to the number of components in a maximum agreement forest, minus 1 [\cite=AllenSteel2001]. Hence, again by leveraging Corollary [\ref=cor:listdp] we obtain:

Given two unrooted binary trees T1,T2 on the same set of taxa X, where |X| = n, dTBR(T1,T2)  =  dMAF(T1,T2)  -  1 can be computed in time Θ(2.619n  ·  (n)). Moreover, all agreement forests of T1 and T2 can be listed in the same time bound.

Conclusion

A number of interesting open problems remain. For example, can we characterize non-isomorphic trees that have the same g-spectrum? For a given k  ≥  3 and n, can we give analytical lower and upper bounds on gk(T), ranging over the space of all trees T on n taxa?

Acknowledgements

We thank Mike Steel for helpful discussions.