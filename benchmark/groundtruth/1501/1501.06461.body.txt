On The Average-Case Complexity of Shellsort

CWI and University of Amsterdam

Introduction

The question of a tight general lower bound or upper bound on the average-case complexity of Shellsort (due to D.L. Shell [\cite=Sh59]) has been open for more than five decades [\cite=Kn73]. We use "average" throughout in the sense of "arithmetic mean," and the average-case complexity is the average-case of the number of inversions. (The number of inversions is proportions to the running time, and the number of comparisons in p-pass Shellsort of n keys is np larger than the number of inversions.) We present an average-case lower bound on the number of inversions for a p-pass Shellsort with increments [formula] for every number of passes and increment sequences.

Shellsort sorts in situ a list of n elements in p passes using a sequence of increments [formula] with [formula]. In the kth pass the main list is divided in hk separate sublists of length n / hk, where the jth sublist consists of the elements in positions j mod hk of the main list ([formula]). Every sublist is sorted using a straightforward insertion sort. The efficiency of the method is governed by the number of passes p and the selected increment sequence [formula] satisfying hp = 1 to ensure sortedness of the final list. Shellsort is used for example in the C standard library, in the uClibc library, Linux kernel, and bzip2 compressor [\cite=Wi14].

Previous Work

Let log  denote the binary logarithm. The original log n-pass increment sequence [formula] of Shell [\cite=Sh59] uses worst case Θ(n2) number of inversions, but Papernov and Stasevich [\cite=PS65] showed that another related increment sequence uses worst-case number of inversions Θ(n3 / 2) and Pratt [\cite=Pr72] extended this to a class of all nearly geometric increment sequences and proved this bound was tight in the sense of coinciding with the upper bound. Incerpi and Sedgewick [\cite=IS85] constructed a family of O( log n)-length increment sequences for which Shellsort runs in [formula] number of inversions, for all ε  >  0. Plaxton, Poonen and Suel [\cite=PPS92] proved an [formula] lower bound for p passes of Shellsort using any increment sequence, for every ε  >  0 and showed that this bound is tight for p  =  Ω( log n). Since every pass takes at least n steps this shows an Ω(n log 2n / ( log  log n)2) lower bound on the worst-case of every Shellsort increment sequence. The currently best asymptotic method was found by Pratt [\cite=Pr72]. It uses all log 2n increments of the form 2i3j  <  ⌊n / 2⌋ to obtain number of inversions O(n log 2n) in the worst case. Moreover, since every pass takes at least n steps, the average-case complexity using Pratt's increment sequence is Θ(n log 2n). Knuth [\cite=Kn73] shows Θ(n5 / 3) for the average-case case of p = 2 passes and Yao [\cite=Yao80] derives an expression for the average case for p = 3 that gives not (yet) a direct bound but was used by Janson and Knuth to derive an upper bound of O(n23 / 15) on the average-case complexity of 3-pass Shellsort. In [\cite=JLV00] Jiang , Li and Vitányi derived a general lower bound of Ω(pn1 + 1 / p) on the average-case complexity of p-pass Shellsort. This lower bound shows that the only possibility of Shellsort to run on the average in Θ(n log n) inversions is for the number of passes p to satisfy p  =  Θ( log n). Apart from this, no nontrivial results were known for the average case until the results presented here. A more detailed history can be found in [\cite=Kn73].

Present Work

We show a lower bound on the average number of inversions (which is the same order of magnitude as the running time and the number of comparisons) of Shellsort expressed in the increment sequence used (Theorem [\ref=theo.shelllb]). The proof uses the fact that most permutations of n keys have high Kolmogorov complexity. Since the number of inversions in the Shellsort process is not easily amenable to analysis, we analyze a simpler process. This simpler process has at most as many inversions (the sum of the minor sequence in Definition [\ref=def.not]) as the original process. Hence a lower bound on the number of inversions in the simpler process is a lower bound on the number of inversions of the original process. We show that the largest number of inversions of each key in the kth pass of the simpler process is less than hk - 1 / hk where [formula] is the increment sequence and h0 = n (Claim [\ref=claim.mn]). Subsequently it is shown using the high Kolmogorov complexity of the permutation that most keys in each pass have a number of inversions close to the maximum. This gives a lower bound on the total number of inversions of the simpler process (Claim [\ref=claim.lbn]) and hence a lower bound for the original process. This holds for the chosen single permutation. Since all permutations but for a vanishing fraction (with growing n) have this high Kolmogorov complexity, the lower bound on the total number of inversions holds for the average case of the original Shellsort process (Theorem [\ref=theo.shelllb]). The lower bound seems to be tight since it coincides with the known bounds. For 2-pass Shellsort Knuth in [\cite=Kn73] determined the average-case complexity and the new lower bound on the average complexity coincides (Corollary [\ref=cor.23]). For 3-pass Shellsort Knuth and Janson [\cite=JK97], building on the work of Yao [\cite=Yao80], gave an upper bound on the average-case complexity and the new lower bound coincides (Corollary [\ref=cor.23]). This yields the new result that the average-case complexity of Shellsort for this increment sequence is now determined. They [\cite=JK97] conjecture an upper bound on the average-case complexity for another increment sequence. The lower bound on the average-case complexity established here for this sequence coincides with this upper bound (Corollary [\ref=cor.23]). For the logarithmic increment sequences of Shell [\cite=Sh59], Papernov and Stasevich [\cite=PS65], Hibbard [\cite=Hi63], and Pratt [\cite=Pr72] also reported in [\cite=Kn73], the lower bound on the average-case complexity for the respective increment sequences is Ω(n log n) (Corollary [\ref=cor.log]). No upper bound on the average-case complexity is known for any of these increment sequences. For the square logarithmic increment sequence of Pratt [\cite=Pr72] the average-case complexity is known. Again, the lower bound given here coincides (Corollary [\ref=cor.dlog]).

The Lower Bound

A Shellsort computation consists essentially of a sequence of inversion (swapping) operations. We count the total number of data movements (here inversions). Keys in the input permutation go by inversions to their final destination. The sequences of inversions constitute insertion paths. The proof is based on the following intuition. There are n! different permutations of n keys. Given the sorting process (the insertion paths in the right order) one can recover the original permutation from the sorted list. The sum of the lengths of the insertion paths must be at least as large as the length of a most concise representation of the starting permutation.

The average-case number of inversions in a p-pass Shellsort algorithm on n keys with increment sequence [formula], and denoting h0 = n, has a lower bound of [formula].

Let the list to be sorted consist of a permutation π of the keys [formula]. Let A be a p-pass Shellsort algorithm with increments [formula] such that hk is the increment in the kth pass and hp = 1. Denote the original permutation by π  =  π0 and the permutation resulting from pass k by πk. In each permutation the keys are ordered left-to-right. In the final permutation [formula] the least key 1 is on the left end and the greatest key n is on the right end.

For [formula], the kth pass starts from πk - 1 and this list (or permutation) is divided into hk separate sublists or hk-chains of length n / hk, where the hth hk-chain (1  ≤  h  ≤  hk) consists of the keys in positions j mod hk = h of the main list πk - 1 ([formula]). The insertion sort of a hk-chain goes as follows. We start at the left end. If the second key is less than the first key then the second key is swapped with the first key. Otherwise nothing happens. This creates a new hk-chain. If the third key is smaller than the first key or the second key in the new hk-chain, then the third key is inserted in its correct position in the <  -order before the first key or in between the first key and the second key. Otherwise nothing happens. We continue this way. The ith key is inserted in its correct position in the <  -order in the initial segment of the current hk-chain consisting of the first key through the (i - 1)th key. All keys greater than the ith key in this initial segment move one position to the right. This is possible since the inserted key left a gap at the ith position of the current hk-chain. An inversion is a swap of key i with key j which changes list [formula] to list [formula]. We can view the insertion above as the ith key changing place with the key before it (an inversion), then changing place with the key before that (a second inversion), and so on, untill it ends up in its correct position. The inversions it had to make to do so is called its insertion path. By the time the final key is inserted in its correct position in the <  -order the hk-chain involved is sorted.

All keys [formula] reside in an hk-chain. Let mi,k be the number of inversions of key i in its hk-chain in this sorting process. At the end of the sorting process the hk-many hk-chains are merged to establish permutation πk by putting the jth key of the hth sorted hk-chain into position h + (j - 1)hk of permutation πk (1  ≤  h  ≤  hk). That is, the jth position of a hk-chain has the same position in permutation πk - 1 as it has in permutation πk. The sum

[formula]

is the total number of inversions that algorithm A performs.

Let n, π, the increment sequence [formula] and the Shellsort algorithm be as described above. A simple Shellsort algorithm is a Shellsort algorithm where the insertion sort of the hk-chains is changed. For all keys [formula] and passes [formula], when it is the turn of key i in position j of its hk-chain, it does the following. It moves a number li,k, 0  ≤  li,k  ≤  n / hk - j, to the right by inversions subject to the following condition. The sequence [formula] is such that pass 1 starts with π and pass p finishes with the sorted list of keys [formula]. The minor sequence [formula] is the lexicographic in i,k (1  ≤  i  ≤  n and 1  ≤  k  ≤  p) the first sequence of a simple Shellsort algorithm such that [formula] is least over all [formula] for sequences [formula] associated with simple Shellsort algorithms. Denote [formula] for all 1  ≤  i  ≤  n such that [formula].

Given n,A and all ni,k's in appropriate fixed order, we can computably reconstruct the original permutation π.

Let the sequence of permutations resulting from the minor sequence be [formula]. The ni,p's in the appropriate order specify the initial permutation ρp - 1 of pass p. For [formula] given ρk we can in this way reconstruct the initial permutation of pass k. Hence given [formula] we can reconstruct the original permutation ρ0  =  π given the data items in the claim.

(i) T'  ≤  T.

(ii) ni,k  <  hk - 1 / hk for all 1  ≤  i  ≤  n, 1  ≤  k  ≤  p.

(iii) For every i (1  ≤  i  ≤  n) holds that from [formula] one can extract the ni,k's in the order [formula].

(i) By Definition [\ref=def.not] each Shellsort sequence [formula] is a simple Shellsort sequence. Hence by Definition [\ref=def.not] and the minimality of the minor sequence item (i) holds.

(ii) Let the sequence of permutations of the keys resulting from pass 1 through p using the ni,k's (1  ≤  i  ≤  n, 1  ≤  k  ≤  p) be [formula], respectively. Assume by way of contradiction that there exist i,k (1  ≤  i  ≤  n, 1  ≤  k  ≤  p) with i + k least such that ni,k  ≥  hk - 1 / hk. (In the following the rounding is ignored.) Define n(1)i,k - 1: = ni,k - 1 + 1 and n(1)i,k: = ni,k  -  hk - 1 / hk, while n(1)j,h = nj,h otherwise. If n(1)i,k - 1  ≥  hk - 2 / hk - 1 then n(2)i,k - 1: = n(1)i,k - 1 + 1 and n(2)i,k - 1: = ni,k - 1  -  hk - 2 / hk - 1, while n(2)j,h = n(1)j,h otherwise. This process is repeated as often as necessary. However, it is not possible that it goes all the way to the 1st pass and results in n(k - 1)i,1  ≥  h0 / h1. Namely this would imply that key i moves to a position greater than n / h1 in its h1-chain of length n / h1 which is impossible. Assume that the process above is repeated l  <  k times. The resulting permutations of the passes are [formula] where [formula] are possibly new permutations of the n keys. However for l > 0 the [formula], contradicting the minimality of the minor sequence [formula].

(iii) Let 1  ≤  i  ≤  n. The number of inversions which move key i from its position as the jth key in π from the left end to its final position as the ith key from the left end in [formula] is [formula] with [formula]. That is, max {j - i,0} is represented in a mixed radix system with radices [formula]. The question asked is whether this representation is unique or not. By the minimality of T' all [formula] are minimal. Hence in each [formula] the ni,k's are as great as possible subject to ni,k  <  hk - 1 / hk (item (ii)) and [formula] in the order [formula], for each 1  ≤  i  ≤  n. Since [formula] this shows the representation is unique.

There are n! permutations π of n keys to be sorted. Below we use the plain Kolmogorov complexity defined by Kolmogorov in [\cite=Ko65] and denoted by C in the text [\cite=LV08]. Let x,y,z be natural numbers. Here is used that C(x|y)  ≤   log x + O(1) for all x and y and C(z|y)  ≥   log x - c for fixed y and |bin(x)| - |bin(x)| / 2c numbers z  ≠  x such that |bin(z)| = |bin(x)|. Here bin(x) is the binary representation of x and |bin(x)| is its length in bits. Iterating the use of standard pairing functions, such natural numbers may consist of fixed finite sequences of natural numbers.

There are [formula] permutations of n keys (here π is for once the number π). By Stirling's approximation used below we are justified to choose the permutation π with Kolmogorov complexity

[formula]

with A the algorithm used in this p-pass Shellsort (including the increment sequence), and P a constant-size algorithm to process all the information and to output π.

Denote the minor sequence [formula] by [formula]. A computable description of Sn, given n,A and Q (an O(1) bit program included in P above), requires at most

[formula]

bits where D is the number of bits required to be able to parse the main part of descr(Sn) into its constituent parts, that is, the concatenated bit strings ni,k of length log ni,k (1  ≤  i  ≤  n, 1  ≤  k  ≤  p). By Claim [\ref=lem.descr] we can compute permutation π from descr(Sn), given n,A and Q. Hence

[formula]

From [\eqref=eq.compl] and [\eqref=eq.NC] it follows that

[formula]

Writing h0 = n we have

[formula]

In pass 1 for every key i (1  ≤  i  ≤  n) we have ni,1  <  n / h1. In general by Claim [\ref=claim.mn] item (ii) for every pass k (1  ≤  k  ≤  p) ni,k  <  hk - 1 / hk. Since [formula] we have by [\eqref=eq.descrN] and [\eqref=eq.ub] that

[formula]

where [formula] for [formula] and ak  ≥  0 by Claim [\ref=claim.mn] item (ii).

We show that D / n  =  o( log n). To be able to parse descr(Sn) into its constituent descriptions [formula] it suffices that [formula]. Since [formula] we have D  ≤  2n log  log n + O(1) (1  ≤  i  ≤  n). Namely, to encode every part Ti for 1  ≤  i  ≤  n such that it can be parsed from the total we double each bit of the part except the last bit which is followed by its complement. This doubles the length of each part. Additionally we require O(1) bits for a program to retrieve the Ti's and extract [formula] from them. This can be done in a unique way by Claim [\ref=claim.mn] item (iii). The total of the description D is o(n log n) bits.

Hence up to lower order terms the last inequality of [\eqref=eq.cd] is rewritten as [formula]. Since ak  ≥  0 for every 1  ≤  k  ≤  p we have ak  ≤  3. Writing ak out and reordering this gives up to lower order terms

[formula]

and by exponentiation of both sides of the inequality one obtains

[formula]

By the inequality of the arithmetic and geometric means and rearranging we obtain [formula] for every 1  ≤  k  ≤  p. Therefore, [formula].

Since T'  ≤  T by Claim [\ref=claim.mn] item (i), a lower bound for T' is also a lower bound for T. Therefore Claim [\ref=claim.lbn] proves the statement of the theorem for the particular permutation π.

By Stirling's approximation [formula]. Therefore n log n  -  1.5n  ≤   log n!  ≤  n log n  -  n for large n. Hence by [\cite=LV08] which uses a simple counting argument, at least a (1 - 1 / n)-fraction of all permutations π on n keys satisfy [\eqref=eq.compl]. Since 1 / n  →  0 for n  →    ∞  , and for all permutations π on n keys we have T = O(n2), a (1 - 1 / n)th fraction of all n! permutations has a lower bound as permutation π does, and a 1 / nth fraction has a lower bound of at least Ω(0) and at most Ω(n2). Hence the lower bound on the average number of inversions.

For p = 2 with h1 = n1 / 3, and h2 = 1 this yields

[formula]

which coincides with the best number of inversions for 2-pass Shellsort T = Θ(n5 / 3) using the same increment sequence h1 = n1 / 3,h2 = 1 as given by [\cite=Kn73].

For p = 3 with h1 = n7 / 15, h2 = n1 / 5, and h3 = 1 this yields

[formula]

The upper bound of O(n23 / 15) for 3-pass Shellsort using the same increment sequence h1  =  Θ(n7 / 15),h2  =  Θ(n1 / 5),h3 = 1 with the additional restriction that gcd(h1,h2) = 1 is given in [\cite=JK97]. This reference uses a complicated probabilistic analysis based on the still more complicated combinatorial characterization in [\cite=Yao80]. Together with the lower bound we establish the new fact that the average number of inversions of 3-pass Shellsort with this increment sequence is Θ(n23 / 15).

In Section 10 of [\cite=JK97] it is conjectured that with h1  ≈  n1 / 2 and h2  ≈  n1 / 4 (h3 = 1) one may obtain an average-case number of inversions of O(n3 / 2). Using the theorem above shows that T = Ω(n(n1 - 1 / 2 + n1 / 2 - 1 / 4 + n1 / 4)  =  Ω(n3 / 2). Therefore, if the conjecture on the upper bound is true then 3-pass Shellsort has an average-case number of inversions of Θ(n3 / 2) for this increment sequence.

The increment sequence [formula] with p = ⌊ log n⌋ of Papernov and Stasevich in [\cite=PS65] is [formula]. The worst-case number of inversions reported by [\cite=PS65] is Θ(n3 / 2). Since hk - 1 / hk  ≈  2 and 2  =  Ω(1), the theorem above gives a lower bound on the average number of inversions of [formula].

The increment sequence of Hibbard [\cite=Hi63] with increment sequence 2k - 1 until it passes n has a worst-case number of inversions Θ(n3 / 2). With a similar analysis as before it has a lower bound on the average-case of T = Ω(n log n). It is conjectured to lead to an average-case number of inversions of O(n5 / 4) in [\cite=We91] reported in [\cite=Kn73]. This conjecture is difficult to settle empirically. For n = 100,000 we have log n  ≈  n1 / 4. Hence we need to do many experiments for n much larger than 100,000 to obtain evidence. The upper bound may well be O(n log n).

Pratt's logarithmic increment sequence (one of his "hypergeometric" sequences) in [\cite=Pr72] also reported by [\cite=Kn73] is [formula] with hk = (3k - 1) / 2 not greater than ⌈n⌉. This increment sequence leads to a worst-case number of inversions of Θ(n3 / 2). In this case hk - 1 / hk  ≈  3 and 3 = Ω(1) and the number of passes is p =  log 3n. The theorem above gives a lower bound on the average number of inversions of [formula].

The original increment sequence used by Shell [\cite=Sh59] was ⌊n / 2⌋,⌊n / 22⌋, and so on for log n passes. Knuth [\cite=Kn73] remarks that this is undesirable when the binary representation of n contains a long string of zeroes. It has the result that Shellsort runs in worst-case time Θ(n2). Since this increment sequence satisfies the same analysis as the above one of [\cite=PS65] the lower bound on the average number of inversions is Ω(n log n).

By [\cite=JLV00] the average number of inversions of Shellsort can be Θ(n log n) only for an increment sequence [formula] with p = Θ( log n). We have shown here that the lower bound on the average inversions is Ω(n log n) for many increment sequences of this length. It is an open problem whether it can be proved that for some such increment sequence the average number of inversions is O(n log n).

For Pratt's square logarithmic increment sequence [formula] with p = Θ(( log n)2), the average-case number of inversions is lower bounded by [formula]. The precise average-case number (and worst-case number) of inversions is Θ(n( log n)2) in [\cite=Pr72], and therefore the lower bound is tight.

Conclusion

The lower bound on the average case number of inversions of Shellsort using p passes in [\cite=JLV00] is for worst-case increment sequences. Here we gave a lower bound on the average-case complexity for each increment sequence separately. This is in several cases larger than the lower bound of above reference. In fact, the lower bound given here seems to be tight as follows from the corollaries. If the increment sequence is the best possible for a given number of passes then the lower bound should reflect this. A tantalizing prospect is to obtain from the given lower bound one which is expressed only in the number n of keys to be sorted and the number of passes in the sorting process, and which is tighter than the lower bound of [\cite=JLV00].

Acknowledgment

I thank Ronald de Wolf for comments on an early draft of this paper.