Lower Bounds in the Preprocessing and Query Phases of Routing Algorithms

Introduction

The problem of finding shortest paths in road networks has been well-studied in the last decade, motivated by the application of computing driving directions. Although Dijkstra's algorithm runs in small polynomial time, for applications involving continental-sized road networks, Dijkstra's algorithm is simply not fast enough. There have been many different approaches to find algorithms that specifically run fast on real-world graphs.

Most recent innovations involve a two-stage algorithm: a preprocessing stage and a query stage. The preprocessing stage runs once and can spend hours calculating data. Then the query stage uses this data to find shortest paths very fast, often several orders of magnitude faster than Dijkstra's algorithm for a continental query. Once the preprocessing stage is completed, the users can run as many queries as they want. For a query between two nodes s and t (an s-t query), the algorithm returns (s,t), the cost of the shortest path between s and t. Most algorithms can also return the vertices on the shortest path using an extra data structure.

The current fastest routing algorithm on real-world graphs is hub labeling [\cite=hl], which achieves a speedup of six orders of magnitude over Dijkstra's algorithm. The transit node routing algorithm is second-fastest, and requires an order of magnitude less space than hub labeling. contraction hierarchies is also a fast routing algorithm, which was state of the art in 2008. For a comprehensive overview of the best routing algorithms, see [\cite=rptn].

Until recently, it was known that these algorithms performed very well on real-world maps, but there were no theoretical guarantees. In fact, it is not hard to construct specific graphs for which these algorithms perform no faster than Dijkstra's algorithm. So, an interesting theoretical question is to find properties present in all real-life graphs that explain why these algorithms work so well.

With this motivation in mind, Abraham et al. defined the notion of highway dimension [\cite=hdnew], intuitively, the extent to which all shortest paths are hit by at least one of a small set of access nodes. Although it is too computationally intensive to calculate the exact highway dimension for a continental road map, there is evidence that the highway dimension h is at most polylogarithmic in the number of vertices. It is conjectured that real-world routing networks always have low highway dimension, based on experimental evidence [\cite=hd]. Abraham et al. were able to prove strong upper bounds on the query times in terms of highway dimension and diameter d for four of the fastest routing algorithms: hub labeling, contraction hierarchies, transit node routing, and reach.

Our results

In this paper, we are interested in finding lower bounds for the current state-of-the-art routing algorithms. We show tight or near-tight bounds on the runtime for hub labeling, contraction hierarchies, and transit node routing.

Our lower bounds may facilitate proving better guarantees of these algorithms, or provide intuition for new routing algorithms, if one can find differences between the graphs we use and real world instances. For example, the graphs we use have low highway dimension, but they do not have small separators and are nonplanar, so perhaps there is a way to modify hub labeling to take this into account.

We show a tight lower bound for hub labeling, the fastest routing algorithm to date [\cite=rptn]. For contraction hierarchies and transit node routing, the definition of highway dimension in the lower bound versus upper bound is slightly different (because of a recent redefinition by Abraham et al. ), so we cannot quite say the bounds are tight.

We can also use our analysis to generalize a known result by Milosavljevi, which lower bounds the number of shortcut edges in the preprocessing stage of contraction hierarchies [\cite=milo]. This result assumes an optimal contraction order which is NP-hard to compute [\cite=hard]. So for real-world instances, we rely on using contraction orders based on heuristics. We show how to relax the assumption about the contraction order, which means the result can be applied to real-world instances.

We also contribute a hardness result for optimal preprocessing of hub labeling. In 2010, Bauer et al. established hardness for optimal preprocessing for a variety of the best routing algorithms, including contraction hierarchies and transit node routing. In this paper, we show that in hub labeling preprocessing, the problem of minimizing the maximum label size over all vertices is NP-hard.

This paper will proceed as follows. Section 2 will provide preliminary information, specifically about highway dimension, and also the graph construction used in our main theorems. In Section 3, we show a lower bound on the query time of the hub labeling algorithm, and prove that optimal preprocessing is NP-hard. In Section 4, we establish a lower bound on the query time for contraction hierarchies, and generalize a lower bound on the number of shortcut edges added in the preprocessing phase. Section 5 establishes a lower bound on the query time of transit node routing. We conclude and discuss future directions in Section 6.

Preliminaries

In this paper, we assume nonnegative integral edge lengths and unique shortest paths. We will also assume graphs are undirected in all sections except for the hardness result. These are standard assumptions to make when proving bounds on routing algorithms, for example, [\cite=hd] and [\cite=milo].

Br(v) represents all nodes u such that (u,v) < r. We say a set of nodes covers a set of paths if each path has at least one of its vertices in the set of nodes.

Highway Dimension

Now we will formally define the notion of highway dimension. The highway dimension of a graph G = (V,E) is the smallest h such that for all r  >  0 and for all B4r(v), there exists a set H  ⊆  V, such that |H|  ≤  h and H covers all shortest paths of length ≥  r in B4r(v). Highway dimension was specifically designed to explain why the best routing algorithms perform well on real-world graphs but do not perform well on arbitrary graphs. Although it is too computationally intensive to calculate the exact highway dimension of a continental-sized road network, it is conjectured that the highway dimension of real-world graphs is at most polylogarithmic in the number of vertices [\cite=hd].

Abraham et al. introduced a slightly refined version of the original highway dimension in 2013 [\cite=hdnew].

The difference in the new definition versus the old one is that instead of having to hit all local shortest paths of length ≥  r, we have to hit all paths P where there is a shortest path P' with endpoints s and t such that ł(P') > r, P  ⊆  P', and [formula]. That is, we have to hit all paths that can be obtained by removing zero, one, or both endpoints of a shortest path with length > r. We will refer to a graph's highway dimension as h for the first definition, and [formula] for the second definition.

The two definitions of highway dimension are very similar but have a few key differences. Most notably, the new definition bounds the degree of the graph, which was not true before [\cite=hd]. The new definition of highway dimension allowed Abraham et al. to improve their results on the runtime of routing algorithms.

Definition of Gt,k,q

Now we will define the family of graphs Gt,k,q that will be used in many of our proofs. Gt,k,q was designed to by Milosavljevi to show a lower bound on the number of shortcuts created during the preprocessing stage of contraction hierarchies [\cite=milo].

Consider a complete t-ary tree of height k for integers t,k  ≥  2. Let λ(v) denote the height of node v, and let λ(u,v) denote the height of the lowest common ancestor between two nodes u and v.

Now define the edges as follows: for all nodes v and w such that w is a proper ancestor of v, there is an edge between v and w with length 16λ(w)  -  1. This means the edge length from a node w to one of its descendants v is independent of λ(v). Furthermore, edge lengths increase for nodes higher up in the tree.

Denote this graph by Gt,k  =  (Vt,k,Et,k). See Figure [\ref=fig:gtkq] for an example. For convenience, we will still refer to this graph as a tree, even though the additional edges create cycles.

Now we will define Gt,k,q  =  (Vt,k,q,Et,k,q) by taking q copies of Gt,k, and naming them G(a)t,k  =  (V(a)t,k,E(a)t,k) for a = 1,2,...,q. The copy of a node v∈Gt,k in G(a)t,k is denoted v(a).

For all v∈Gt,k and a  ≠  b, we add edge v(a)-v(b) to Et,k,q with length 2λ(v) - k - 1. This ensures that switching copies has a low penalty (2λ(v) - k - 1 is always less than 1), and it is always cheaper to switch among copies lower down in the tree. See Figure [\ref=fig:gtkq] for an example.

Properties of Gt,k,q

We will now discuss properties of Gt,k,q. The following three lemmas are proven in [\cite=milo].

Given s,t∈Vt,k with lowest common ancestor w, the unique shortest s-t path is s-w-t.

Given s(a) and t(b) in Gt,k,q, let w be the lowest common ancestor between s and t. Then the shortest s(a)-t(b) paths are:

s(a)-s(b)-w(b)-t(b), if λ(s)  ≤  λ(t), and/or

s(a)-w(a)-t(a)-t(b), if λ(t)  ≤  λ(s).

The highway dimension h of Gt,k,q is equal to q, the diameter D is Θ(16k), and |Vt,k,q| = Θ(qtk).

It is worth noting that at the start we assumed graphs have unique shortest paths, but now many shortest paths in our main family of graphs are not unique. However, this is a common assumption in routing algorithm proofs because it is not hard to perturb the input to make all shortest paths unique while maintaining the validity of the proofs.

Additionally, integrality of edge lengths is violated. Since the smallest edge is 2- k (and all edge lengths are multiples of this), all of the edge weights can be multiplied by 2k to create integral lengths. This will increase D by a factor of k, doubling log D, which will not affect our results.

Hub Labeling

The hub labeling algorithm was first devised in 2004 by Gavoille et al. [\cite=gav], and further studied by Cohen et al. [\cite=cohen]. However, the algorithm was not practical for continental routing queries until 2011, when Abraham et al. came up with an efficient way to perform the preprocessing and query phases, which made it the fastest routing algorithm to date [\cite=hl].

In this section, we will first give an introduction to the hub labeling algorithm. Then we will present a lower bound on the query time. Finally, we will show the preprocessing phase is NP-hard to optimize.

The algorithm

hub labeling relies on the concept of labeling. Each node stores information about its shortest paths that allows us to reconstruct the shortest path during a query. This idea is used in a clever way to make queries run very fast.

In the hub labeling algorithm, we give each node v∈V a label consisting of other nodes (the hubs of v), and we store the shortest distances to the hubs from v. We define a labeling L as the set of labels L(v) for all v∈V.

We construct the labeling in such a way that for any pair of nodes s and t, [formula] contains at least one node on the shortest path from s to t. When satisfied, this is called the cover property. Then in order to perform an s-t query, we only need to find the [formula] that minimizes (s,v) + (v,t). This can be made to take O(|L(s)| + |L(t)|) time if the labels are sorted with some arbitrary node order. This process returns (s,t). To return the nodes on this shortest path, we need to add another data structure in the preprocessing stage, which does not increase the space complexity by more than a constant factor [\cite=hl].

In Section [\ref=hard], we will show that it is NP-hard to find the labeling that minimizes the maximum label size for all vertices. This was suspected to be true. Therefore, in practice we must rely on heuristics in the preprocessing stage.

Abraham et al. showed that the query time of hub labeling is O( log D), using a specific labeling [\cite=hdnew]. The proof did not use any properties of [formula] that are different from h, so we can also say that the query time is O(h log D).

It is not known how to construct the labeling used in their proof in polynomial time, so they showed a corollary that uses a polynomial preprocessing algorithm and permits queries to be handled in O(h log h log D) time.

Lower bounding the query time

We cannot prove a lower bound on the minimum query time, since labelings can be constructed to make any one query run in constant time. Instead, we will prove a bound on the average query time by bounding the sum of all label sizes.

For all h, D, n, there is a graph G = (V,E) with highway dimension h, diameter Θ(D), and |V|  ≥  n, such that for any choice of labeling L, the average query requires Ω(h log D) time.

We will show that Gt,k,q satisfies the desired requirements, with t, k, and q to be defined at the end of the proof.

Consider different classes of shortest paths between pairs of leaves distinguished by the height of their lowest common ancestor as follows.

For 0  ≤  i  ≤  k, let Pi  =  {s-t|s and t are leaves, and λ(s,t) = i}.

Let [formula]. Our goal is to show that a constant fraction of the k + 1 sets P0,  P1,...,Pk each contribute Ω(q2tk) distinct nodes to the sum H.

We make the assumption that all the neighbors of a leaf v(a), and the leaf itself, are in that leaf's label. That is, L(v(a)) contains v(b) for all b (even when b = a), and contains w(a) for all ancestors w of v. These are k + q + 1 nodes per leaf and tk(k + q + 1) total nodes, which is asymptotically less than Ω(tkq2k), the desired result. Therefore, this assumption will not affect the validity of our proof.

Now consider an arbitrary path in Pi. Label the endpoints of the shortest path Pi by s(a) and t(b). From Lemma [\ref=sp], Pi must equal s(a)-s(b)-w(b)-t(b), where w is the lowest common ancestor of s and t, and λ(w) = i.

[formula] must contain at least one of s(a), s(b), w(b), t(b) in order to satisfy the cover property. By our assumption above, s(a),s(b)∈L(s(a)) and w(b),t(b)∈L(t(b)). Now there are four cases.

Case 1: s(a)∈L(t(b)). Note that s(a) is not on any other shortest path starting at t(b).

Case 2: t(b)∈L(s(a)). Again, t(b) is not on any other shortest path starting at s(a).

Case 3: s(b)∈L(t(b)). s(b) is on all leaf-leaf shortest paths (that end at t(b)) of the form s(c)-s(b)-w(b)-t(b) for c  ≠  b. There are q - 1 such paths in Pi.

Case 4: w(b)∈L(s(a)). w(b) is on all leaf-leaf shortest paths (that start at s(a)) of the form s(a)-s(b)-w(b)-v(b) for v such that λ(s,v)  =  i. There are ti  -  ti - 1 such paths, since there are ti leaves with w(b) as an ancestor, and all but ti - 1 of those leaves have w(b) as the lowest height ancestor to get to s(a).

Furthermore,

[formula]

because there are [formula] ways to pick two copies of trees, tk choices for the first leaf, and ti  -  ti - 1 choices for the second leaf (in order to guarantee that the leaves have a lowest common ancestor of height i).

So if we assume ti - ti - 1  ≥  q - 1 (we will explain in the next paragraph why we can make this assumption), then we can achieve a lower bound on the number of labels needed for Pi by exclusively using Case 4 for our choice of labels.

[formula]

Therefore, the contribution of Pi to the total sum H is at least [formula]. For all i, the hubs that Pi contributes to the sum H have height i, ensuring that a node does not get double counted in H.

Let [formula], q = h, and pick t big enough such that qtk + 1  ≥  n (ensuring that |V|  ≥  n) and tk / 2  ≥  q (ensuring that at least half of the Pi's satisfy ti - ti - 1  ≥  q - 1).

Then the highway dimension of G is h and the diameter is Θ(D). Recall that |V|∈Θ(qtk). Then for any given labeling L,

[formula]

This completes the proof since query times depend on the size of the labels.

With this theorem, the upper bound presented in [\cite=hdnew] becomes tight.

Hardness of preprocessing

In 2010, Bauer et al. established hardness for optimal preprocessing for a variety of the best routing algorithms, including contraction hierarchies and transit node routing [\cite=hard]. We provide hardness for optimal preprocessing in hub labeling which was suspected to be true [\cite=hd]. By optimal preprocessing, we mean minimizing the maximum hub size over all vertices. Babenko et al. very recently established hardness for nearly the same problem, but they defined optimal preprocessing as minimizing over the total label size [\cite=babenko]. Our definition of optimal corresponds to minimizing the maximum query time, whereas the other definition corresponds to minimizing the average query time.

We will switch to directed graphs, which was the original setting of hub labeling [\cite=hl]. The main difference is that each node v has a forward label Lf(v) and a reverse label Lr(v), and the cover property states that for a directed s-t query, [formula] is not empty.

Now we formally define the problem minimum hub labeling (MHL) as follows: Problem (MHL). Given a directed graph G = (V,A) and an integer k, find a labeling L satisfying the cover property such that max v∈V( max (|Lf(v)|,|Lr(v)|))  ≤  k.

We will show a reduction from a classical NP-hard problem, exact cover by 3-sets (X3C). In an X3C instance (U,C), U is a set of elements, 3 divides |U|, and C is a set of triples of U. The problem is whether there exists a set C'  ⊆  C, [formula] such that C' covers U (an exact 3-covering of U).

Here is an outline of the proof. Given an X3C instance (U,C), we create an MHL instance (G,k) where G = (V,E), [formula] and for c∈C, u∈U, c-u∈E iff u∈c.

We also add a clique of vertices [formula] with arcs to nodes in U, whose sole purpose is to fill up the reverse labels of nodes in U. Finally, we add two vertices {a1,a2} = A with arcs to every node in C.

By filling up the reverse labels of nodes u∈U, we force the nodes a∈A to use nodes in C or U for the hubs of a-u shortest paths. And it is too inefficient to use nodes in U for the hubs, so nodes in C must act as the hubs. Then in order for A's label size to stay ≤  k, there must be an exact cover for U.

Minimum hub-labeling is NP-hard.

First we construct a graph G, and then prove lemmas about its labeling until we work up to proving the theorem.

Given an X3C instance (U,C), we create an MHL instance (G,k) where G = (V,E), [formula], |A| = 2, and [formula]. For all a∈A and c∈C, there is a directed edge (a,c)∈E. For all u∈U and c∈C such that u∈c, there is a directed edge (c,u)∈E. For all b1,b2∈B such that b1  ≠  b2, (b1,b2) and (b2,b1) are in E. Let B' be a subset of B such that [formula] (it does not matter which b's are in B'). For all b'∈B' and all u∈U, there is a directed edge (b',u)∈E. All edges are unit length. Finally, set [formula]. See Figure [\ref=fig:maxlabel].

First we prove the forward direction: if (G,k) is a yes instance, then (U,C) is a yes instance. We prove this using a few different lemmas.

If (G,k) is a yes instance, then for all b∈B, Lf(b) and Lr(b) contain k vertices from B.

Given b1, b2∈B, the shortest b1-b2 path is the edge b1-b2, since B is fully connected. Then to satisfy the cover property, either [formula] or [formula]. Each of these cases puts one vertex in a label that cannot be reused for any other shortest path (b1∈Lr(b2) or b2∈Lf(b1)).

First we note that for all b∈B, b∈Lf(b) and b∈Lr(b). If this were not the case, (WLOG b∉Lf(b)), then Lf(b) must contain [formula] vertices to satisfy all its outgoing shortest paths, which contradicts our assumption.

Now we note there are |B|(|B| - 1) total shortest paths, and each requires adding exactly one node to a label that cannot be reused for any other shortest path. Then the minimum max label we can hope to achieve is [formula], which corresponds to splitting the |B|(|B| - 1) vertices equally among B. So each forward and reverse label has size [formula]), plus the self hub to reach a total of [formula].

If (G,k) is a yes instance, then for all u∈U, B'  ⊆  Lf(u).

Given u∈U, b'∈B', the shortest u-b' path is the edge u-b'. Then to satisfy the cover property, either [formula], or [formula]. From Lemma [\ref=b], we know that Lr(b) already contains k vertices from B. Therefore, it must be the case that b'∈Lf(u). Then for all u∈U, B'  ⊆  Lf(u).

So, now we know that the reverse labels for nodes in U are almost full up. To finish off the forward direction, we need to show that the only way for vertices in A to have hubs ≤  k is to use an exact cover C' for U. Intuitively, it makes sense that the a-c-u shortest paths should use the vertices in C as hubs rather than vertices in A or U, because it can be used for three shortest paths instead of just one. However, we need to make certain that some hybrid label with A's, C's, and U's does not work.

Define A1 = |{u∈U|u∈Lr(a1)}| and A2 = |{u∈U|u∈Lr(a2)}|.

Also let U1 = |{u∈U|a1∈Lr(u)}|, and U2 = |{u∈U|a2∈Lr(u)}|.

If (G,k) is a yes instance, then A1 = A2 = U1 = U2 = 0.

From Lemma [\ref=b'], we know that for all u∈U, Lr(u) contains |B'| = k - 2 vertices from B'. Lr(u) will also need at least one total vertex for all the c-u shortest paths, for c such that u∈c. Therefore, we cannot put both a1 and a2 into Lr(u).

Then, for every u∈U such that a1∈Lr(u), u must be in Lf(a2), or else there would be no other way for the a2-u path to satisfy the cover property. Therefore, U1  ≤  A2. Similarly, U2  ≤  A1.

Now consider a1's forward label. Lf(a1) will need at least one total vertex for all the a-c shortest paths. Since there are A1 vertices u∈U such that u∈Lf(a1), there is room in Lf(a1) for k - 1 - A1 vertices, and we need to satisfy the cover property for |U| - U1 more shortest paths of the form a1 - u such that u∈U. The most efficient label for these shortest paths is to pick a vertex in C, which will cover three at a time. Then we must have |U| - U1  ≤  3(k - 1 - A1) = |U| - 3A1, from which it follows that 3A1  ≤  U1  ≤  A2. With the exact same argument, we get 3A2  ≤  A1. Then 9A1  ≤  A1 and so A1 = 0.

If (G,k) is a yes instance, then (U,C) is a yes instance.

From Lemma [\ref=only_c], it follows that for all a∈A and u∈U, there exists a c∈C, such that u∈c and [formula]. Then there must be at least [formula] vertices from C in Lf(a). Lf(a) also needs a hub for all a-c shortest paths where c∈C. The only way to accomplish that is to let a be the hub. Then Lf(a) contains a, plus some C'  ⊆  C such that for all u∈U, there exists a c∈C' such that u∈c. Since (G,k) is a yes instance, [formula]. But then C' is an exact cover for U, so (U,C) is a yes instance.

Now we will show the backward direction. Proving the forward direction alludes to a specific labeling, so now it is just a matter of showing this labeling is actually possible.

If (U,C) is a yes instance, then (G,k) is a yes instance.

Let C'  ⊆  C be an exact cover for C. Given u∈U, denote c'u as the element in C' that covers u. We present the following labeling L.

For a∈A, [formula], and [formula].

For c∈C, Lf(c) = {u|u∈c} and Lr(c)  =  A.

For u∈U, [formula] and [formula].

For bi∈B, [formula] and [formula].

It is easy to check this labeling satisfies the cover property. Each a-c shortest path uses a as a hub. Each a-u shortest path uses c'u as a hub. Each c-u shortest path uses u as a hub. Each b'-u shortest path uses u as a hub. Given bi,bj∈B. If j  ≤  i + k mod 2k, then the bi-bj shortest path uses bj as a hub. Otherwise, it uses bi as a hub.

Also, it it clear that every label has size ≤  k. This completes the proof.

The proof of Theorem [\ref=hard] follows directly from Corollary [\ref=hard_forward] and Lemma [\ref=hard_backward].

Contraction Hierarchies

Contraction hierarchies [\cite=ch] is a shortcut-based algorithm, making it fundamentally different from hub labeling. It works by running bidirectional Dijkstra search, pruning the searches based on a node's importance.

In this section, we explain how the contraction hierarchies algorithm works, prove a lower bound on the query time, and then generalize a result about the number of shortcut edges added in the preprocessing phase.

The algorithm

In the preprocessing stage for contraction hierarchies, we iteratively contract nodes using a predefined ordering, called a contraction ordering. The contraction operation called on v first deletes v from the graph, and then may add edges between v's neighbors if they are needed to preserve the shortest path lengths. Any such edge is put into a set E+. We contract every node in the graph based on the ordering, and we are left with the set E+ of "shortcut edges".

To run an s-t query, run bidirectional Dijkstra search from s and t on the graph [formula], except at node v, only consider edges v-w in which w was contracted after v. When there are no more nodes to consider in either direction, find the node v that minimizes the sum of its distances to s and to t.

In [\cite=ch], it is proven that v is guaranteed to be on the shortest path between s and t, which means that (s,t) = (s,v) + (v,t), so the query returns the shortest s-t path.

Note that any contraction ordering will give correct queries, but a better contraction ordering will make |E+| small, decreasing time and space requirements. Finding the optimal ordering is NP-hard [\cite=hard], but there are fast heuristics that make |E+| within log h of optimal [\cite=hdnew].

Abraham et al. showed an upper bound on the query time of contraction hierarchies that depends on Δ: O((Δ + h log D)(h log D)) [\cite=hd]. Using the new definition of highway dimension, Abraham et al. achieved the better bound of O(( log D)2) time. Both of these assume optimal preprocessing. If a polynomial time preprocessing algorithm is required, the bounds are modified to O(( log  log D)2) and O((Δ + h log h log D)(h log h log D)).

Lower bounding the query time

We show a lower bound using the old definition of highway dimension.

For all h, D, n, there is a graph G = (V,E) with highway dimension h, diameter Θ(D), and |V|  ≥  n such that the average query time is Ω((h log D)2) for contraction hierarchies.

Our strategy will be to find a lower bound assuming Abraham et al.'s (optimal) ordering, and then show that modifying the ordering can only increase the runtime.

[\cite=milo] provided a criterion for shortcut paths in the optimal ordering: the path s(a)-s(b)-w(b)-t(b) is shortcut if and only if a  ≠  b, w is a proper ancestor of s, and s(b) is contracted before s(a). First we present a proof sketch, and then we give the formal proof.

Here is an outline of the proof. Again we will use Gt,k,q, and we limit our analysis to leaf-leaf queries, which make up the majority of all queries. First we prove the theorem assuming Abraham et al.'s contraction order. For Gt,k,q, this means nodes are contracted based on their height in the tree. In the forward search of a leaf-leaf query s(a)-t(b), the only nodes we may visit are ancestors v(c) of s such that v(c) is contracted after v(a). Then half of these nodes will have lower contraction order than the other half, and so it can be shown that the shortcut criterion guarantees Ω(q2k2) edges will be created along half of the forward searches.

Then we show that veering away from this ordering will only increase the number of shortcut edges produced (or slightly decrease, but not by more than a constant factor). This is more technical. The main idea is to carefully examine the effects of contracting a node higher up in the tree, before all of its descendants were contracted. Although contracting a higher node v decreases some of the paths from any descendant u to v, it creates shortcuts between all pairs of descendants which have not yet been contracted, which could cause an exponential number of extra edges to be created. The overall difference does not increase the big-Omega bound from Abraham et al.'s contraction order.

We will show Gt,k,q satisfies the properties, defining t,k,q at the end of the proof. Consider a query between two leaves s(a) and t(b) such that λ(s,t) = k and a  ≠  b. This type of query makes up a constant fraction of all queries, so we will limit our analysis to this case. A regular Dijkstra search settles s(a) and all copies of s, and then it settles the parent of s(a) and all its copies, and continues to settle the successive ancestors of s(a) along with their copies. A total of q(k + 1) nodes are settled in this way. The backwards search goes through a similar process starting at t(b). For contraction hierarchies, each node only needs to look at neighbors with a higher contraction order than itself. If we are using an adjacency list to represent the graph, this can be done by reordering the adjacency list based on contraction order.

Assume initially that we are using Abraham et al.'s contraction ordering, which orders nodes by height from the bottom up (we will remove this assumption shortly). So in the forward search, the only nodes we may visit are ancestors of s (in any copy). We refer to this set of nodes as S and recall that it contains q nodes at each layer i in the tree. Among the nodes in S with height i, let Ti contain the [formula] nodes with lower contraction order than the other [formula] nodes in that layer. Let

[formula]

Suppose v(c) is one of the [formula] nodes in T. Recall that the shortcut criterion for Abraham et al.'s ordering says the path v(d)-v(c)-u(c) (where u is an ancestor of v) will be shortcut if v(c) is contracted before v(d). Then contracting v(c) will create at least [formula] shortcuts, since v(c) is in the bottom half of the tree and has a lower contraction order than half of the nodes v in other copies. Therefore, the forward search will need to look through at least [formula] nodes, making the average query take Ω(q2k2) time.

Now we will consider a general ordering by examining the effects of contracting an arbitrary node v(a) on edges in G(a)t,k.

If v(a) is contracted before a descendant u(a), shortcuts from u in any copy to v(a) will never be created. The number of queries this affects is based on the height of u. If u is a leaf, it only affects queries starting from u, but if u is higher up in the tree, it will affect all queries starting at leaves with u as an ancestor. In effect, we need to weight the nodes based on their importance. We do this using [formula], where u(a) is a descendant of v(a) with contraction order higher than v(a). The value of this sum is proportional to the loss in total query time when contracting v(a) compared to Abraham et al.'s ordering. Let λ(v) = i. If all of v(a)'s descendants were contracted before v(a), the sum would be [formula] because each layer can contribute at most ti to the sum. There are two cases to consider.

Case 1: [formula]. In this case, the average query time decreases by at most a factor of two, which doesn't affect our big-Omega bound.

Case 2: [formula]. The number of edges in G(a)t,k that are lost from v(a)'s contraction is ≤  ti, the number of v(a)'s descendants. However, contracting v(a) before many of its descendants will create many leaf-leaf shortcuts.

The smallest possible set of contracted descendants would contain the ≥  ti / 2 nodes in the top [formula] layers below v(a).

Given two of these nodes x(a) and y(a) with λ(x,y) = λ(v), a shortcut will be created between x(a) and y(a). Half of the subtrees rooted at v(a)'s children will have half of their nodes with contraction order higher than v(a), so we will gain at least [formula] extra shortcuts this way.

Therefore, the number of edges decreases by at most a constant factor, which does not affect our big-Omega bound.

In both cases, we maintain the Ω(q2k2) bound even with an arbitrary ordering.

Now let [formula] and q = h, and we pick t big enough such that qtk  ≥  n. Then the average query for contraction hierarchies is Ω((h log D)2).

Lower bounding the size of E+

Abraham et al.'s upper bound of O(( log D)2) on the query time involves proving that |E+|∈O(n log D). The latter bound was proven tight in [\cite=milo]. However, the proof assumes the contraction order from the algorithm in Abraham et al. which is thought to be NP-hard to compute. We show a new proof of this lower bound generalized to any contraction order.

For all h, D, n, there is a graph G = (V,E) with highway dimension h, diameter Θ(D), and |V|  ≥  n such that for any contraction ordering, |E+|∈Ω(h|V| log D).

We will show Gt,k,q satisfies the desired requirements, setting the values of t,k,q at the end of the proof.

We will be concerned only with shortcuts added when contracting leaves. We will first count the number of shortcuts added by contracting all of the leaves first, as in the preprocessing algorithm by Abraham et al. Recall the criterion for creating a shortcut in this ordering, which was stated in Section [\ref=chlb]. A path s(a)-s(b)-w(b)-t(b) is shortcut if and only if a  ≠  b, w is a proper ancestor of s, and s(b) is contracted before s(a). Then the number of shortcuts added when contracting all of the leaves is [formula] since there are tk ways of picking a leaf, k ways of picking a proper ancestor, and [formula] ways of picking two copies.

In general, the number of shortcuts created for leaf v(a) at the time of its contraction is the number of ancestors v(a) has in G(a)t,k multiplied by the number of copies v(b), b  ≠  a, in other trees. We will now consider the effects of arbitrary contraction order on the number of edges a leaf has in its own copy at its time of contraction.

Given an arbitrary contraction order θ and a non-leaf v, let ci, 1  ≤  i  ≤  t, be the number of leaves with contraction order higher than v in the subtree with v's ith child as a root. Then 0  ≤  ci  ≤  tλ(v) - 1 for all i.

Contracting v causes [formula] leaf descendants of v to lose one edge each. However, contracting w also increases the number of leaf-leaf edges by [formula].

Then the net edge gain for contracting v instead of all leaves first is

[formula]

In order to find the minimum value of Av,θ, we consider four cases.

Case 1: ≥  3 ci's are nonzero. Without loss of generality, let the ci's make a decreasing sequence. So [formula] and c3  ≥  1. Then c1c3  ≥  c1,  c1c2  ≥  c2,  c2c3  ≥  c3,...,  ct - 1ct  ≥  ct. It follows that

[formula]

Case 2: Exactly two ci's are nonzero. So c1  ≥  c2  ≥  1 and [formula]. Then Aw,θ  =  c1c2  -  c1  -  c2  =  (c1  -  1)(c2  -  1)  -  1. If c2  >  1, then (c1  -  1)  ≥  (c2  -  1)  ≥  1, so Av,θ  ≥  0. If c2  =  1, then c1  -  1  =  0, so Av,θ  =   - 1.

Case 3: Exactly one ci is nonzero. So c1  ≥  1 and [formula]. Then Av,θ  =   - ci, so the minimum value of Av,θ in this case is - tλ(v) - 1.

Case 4: All ci's are zero. Then clearly Av,θ  =  0.

Therefore, the minimum value of Av is - tλ(v) - 1 from case 3.

Note that the possible leaf-leaf edges we gain from contracting a non-leaf v are independent of other leaf-leaf edges we gain from contracting another non-leaf u: if λ(v)  =  λ(u), the leaves in the edges must be different since they cannot have both v and u as an ancestor. If λ(v)  ≠  λ(u), the edges must be different since the lowest common ancestors between the endpoints of each edge are at different heights.

So given an arbitrary contraction order, the number of leaf-edges within a copy G(a)t,k (at the time of the leaf's contraction) is

[formula]

Then

[formula]

We let [formula] and q = h, and we pick t such that qtk + 1  ≥  n. Then G has highway dimension h, diameter Θ(D), and has |V|  ≥  n. Finally, given a contraction order θ, |E+|∈Ω(h|V| log D).

Transit Node Routing

transit node routing [\cite=tnr] was devised in 2007 by Bast et al., and it (and variants) remain the second-fastest family of routing algorithms, behind hub labeling [\cite=rptn]. However, transit node routing requires about an order of magnitude less space than hub labeling. In this section, we first review the transit node routing algorithm, and then we give a lower bound on the query time.

The algorithm works by picking a set T  ⊂  V of transit nodes that hits many long-distance shortest paths. |T| is often chosen to be in [formula], which makes the algorithm run fastest while maintaining that additional memory requirements are bounded by the input graph size. Usually, the contraction order is used to pick T (since contraction order essentially seeks to measure a node's importance with respect to shortest paths), which works well in practice.

Next, given any node v, A(v)  ⊂  T is the set of that node's access nodes, which are chosen to hit the long-distance queries stemming from v. This usually means that we want to pick nodes in T that are close to v.

The distances between all pairs of transit nodes are computed and stored, as well as the distances between a node v and each of its access nodes. A query is called a global query if min ((s,u) + (u,v) + (v,t)  |  u∈A(s),  v∈A(t))  =  (s,t). Otherwise, it is a local query. To run an s-t query, first run a quick locality filter that determines whether the query is local. This filter is allowed to make one-sided errors; it can misclassify a global query as local, but not the other way around. Locality filters are historically calculated using the coordinates of the vertices. If it is a global query, calculate the minimum (s,u) + (u,v) + (v,t) by trying all combinations of access nodes from A(s) and A(t). Local queries are handled by a fast local search such as contraction hierarchies.

Abraham et al. use a choice of T based on multiscale shortest-path covers to prove that access nodes are bounded in size by O(), from which it follows that global queries can be handled in O(2) time. Local queries done using contraction hierarchies can be handled in O(( log D)2) time as we saw in the previous section (however, local queries tend to be small, making the queries run much faster than the average contraction hierarchies query).

This bound is not possible without the new definition of highway dimension. Again, if we want polynomial time preprocessing, the query time bound for global queries increases to O(( log )2).

Lower bounding the query time

While the upper bound for transit node routing was for global queries only, our lower bound will include both local and global searches. We will use contraction hierarchies for local queries.

For all h, D, n, there is a graph G = (V,E) with highway dimension h, diameter Θ(D), and |V|  ≥  n such that for any choice of transit nodes T and access nodes A, the average query time is Ω(h2).

We work up to the proof of Theorem [\ref=tnr_lb] using a series of definitions and lemmas.

Call a leaf-leaf shortest path regular if the shortest path is global and neither endpoint is a transit node. We would like to exclude irregular shortest paths from our analysis.

First, we show that queries with a transit node as an endpoint do not make up a constant fraction of all queries. Since [formula], the number of shortest paths in which at least one endpoint is a transit node is [formula].

Next, we consider the case in which local queries make up at least a [formula] fraction of total queries. In the previous section, we showed in Theorem [\ref=ch_lb] that the average query for contraction hierarchies requires Ω((h log D)2) time. The proof showed a constant fraction of all queries required this amount of time. If we lower all of the constants in the proof, we can show that given any set of [formula] of total queries, a constant fraction of those queries require Ω((h log D)2) time (thus a constant fraction of all queries require that amount of time). This big-Omega bound is higher than the one we seek to prove for global queries, so for the rest of our analysis we can assume that a [formula] fraction of total queries are irregular. In particular, this means a constant fraction of the total queries are regular.

There is a simple intuition for the rest of the proof. Given a regular shortest path s(a)-t(b), either s(a) or t(b) must have an access node in the other's copy, since the non-endpoint vertices on the shortest path all come from one copy. The proof becomes technical because we must show that a constant fraction of leaves have a large amount of access nodes in distinct copies and subtrees. But we are able to show that a constant fraction of the nodes need Ω(q2) access nodes, and the proof follows.

If the number of local leaf-leaf queries is a [formula] fraction of total queries, then there is a set of [formula] copies in which there are [formula] leaves that are each an endpoint of [formula] regular shortest paths going to at least [formula] different copies.

Assume the number of local leaf-leaf queries is o(|V|2), but assume the lemma is false. Then there must be [formula] copies with the following property: [formula] leaves are each endpoints of [formula] regular shortest paths going to [formula] copies.

Now consider the maximum number of regular leaf-leaf shortest paths possible in Gt,k,q under that assumption. Making all four inequalities tight, we have [formula] copies with [formula] leaves each as endpoints of [formula] regular shortest paths going to [formula] copies each. In other words, in half of the copies, half of the leaves each have the property that in half of the copies, half of the shortest paths going from that leaf to the copy are regular. This means that at the very least [formula] of all leaf-leaf shortest paths must not be regular.

This violates one of our assumptions, so we have a contradiction.

Now we have the machinery necessary to prove Theorem [\ref=tnr_lb].

We will show that Gt,k,q has the desired properties, with the values of t, k, and q to be defined at the end of the proof.

From our previous argument at the start of this subsection, we need only consider the case where [formula] of all queries are irregular.

We use Lemma [\ref=halfs] to define a set S of regular shortest paths such that there are exactly [formula] copies that have exactly [formula] leaves with exactly [formula] regular shortest paths in S going to [formula] copies.

Then

[formula]

We added another factor of [formula] because these shortest paths can be double counted.

Given a path P∈S, P's endpoints are two leaves s(a) and t(b) in different copies and must be of the form s(a)-s(b)-w(b)-t(b) or s(a)-w(a)-t(a)-t(b) by Lemma [\ref=sp]. Without loss of generality, assume that P is s(a)-s(b)-w(b)-t(b). Since the path is global, s(a) must have an access node on P. The access node can't be s(a) itself since P is regular. Therefore, the access node must be in G(b)t,k.

This access node hits at most [formula] paths in S stemming from s(a) because that is the total number of shortest paths in S from s(a) to a leaf in G(b)t,k.

So given an arbitrary path in S, we have shown that an access node for some node v(a) must exist that can hit at most [formula] other shortest paths in S. Then the total number of access nodes needed in S is at the very least

[formula]

As in earlier proofs, we let [formula] and q = h, and we pick t such that qtk + 1  ≥  n. Then G has highway dimension h, diameter Θ(D), and has |V|  ≥  n.

Queries in which both endpoints' access node sets are Ω(h) will take Ω(h2) time, and these make up a constant fraction of all global queries.

Conclusions and Future Work

We proved lower bounds on the query time of hub labeling, contraction hierarchies, and transit node routing. The proofs are all quite different, despite using the same family of graphs for each proof. We also generalized a lower bound on the size of E+ in contraction hierarchies preprocessing, and established hardness for optimal preprocessing in hub labeling.

Although we have proven lower bounds for the query times of three state-of-the-art algorithms, the graphs used in the arguments are not representative of real-world graphs. For instance, the graphs do not have small separators and are not planar. This implies it may be possible to circumvent this lower bound using different properties that better capture the structure of real-world graphs.

Another way to work with more realistic road networks is to use the idea of multiscale dispersed graphs, defined in [\cite=mdg], as a new model for graphs that simulate real-world graphs. One may be able to obtain better bounds on the query time with this model.

Throughout this paper, we assumed undirected graphs, so future work could extend these results to the directed case. Furthermore, apart from hub labeling, the upper and lower bounds are not tight because of the different definitions of highway dimension. Ideally, we would find a way to prove the lower bounds using the more recent definition of highway dimension. However, we cannot use Gt,k,q for this task. Under the new definition, Gt,k,q has highway dimension at least q + k, since the new definition guarantees a graph's degree is bounded by its highway dimension.

Acknowledgments

The results in this paper are from the senior honors thesis of the author, written under the direction of Prof. Lyle McGeoch, at Amherst College. We would like to give a huge thanks to Lyle McGeoch for helpful discussions and suggestions throughout the writing process. We are grateful for the Post-Baccalaureate Summer Research Fellowship program at Amherst College, which supported the writing of this paper.