Corollary Lemma Proposition Definition Remark Example

Classification of Finite Dynamical Systems

Introduction

In this paper a finite dynamical system will mean a mapping from the set of binary strings of a certain length to itself. Such mappings occur in a variety of contexts, in particular in the theoretical study of computer simulations. Representing a computer simulation as a particular finite dynamical system is one possible approach to its mathematical analysis, carried out in [\cite=br] [\cite=bmr] [\cite=bmr2]. The finite dynamical systems considered there, so-called sequential dynamical systems (SDS), incorporate the essential features of a computer simulation. Local variables [formula] take on binary states which evolve in discrete time, based on a local update function fi attached to each variable vi, and which depends on the states of certain other variables, encoded by the edges of a dependency graph Y on the vertices [formula]. Finally, an update schedule prescribes how these local update functions are to be composed in order to generate a global update function

[formula]

of the system. An important question, which can be answered in this setting, is how many different systems one can generate simply by varying the update schedule. The upper bound is in terms of invariants of the dependency graph Y.

In applications the dependency graph Y frequently varies over time, however. The need for a framework that allows for such a change inspired the investigation of properties of tuples of "local" functions in [\cite=LP] and certain equivalence relations on them. That paper also contains a Galois correspondence between sets of tuples of local functions and certain graphs. Tuples of local functions can be interpreted as parallel systems f:{0,1}n  →  {0,1}n, so that the results pertain to the study of parallel systems as well. The present paper makes the connection between tuples of local functions (parallel systems) and sequential systems, in particular SDS, explicit by exploiting this Galois correspondence. In order to describe our main results we need to recall some definitions and results from [\cite=LP].

Let [formula], and let [formula] be the n-fold cartesian product of [formula]. When convenient we will view [formula] as the field with two elements.

Let n be a positive integer, let d be a nonnegative integer, and let Y be a graph with vertex set [formula].

A function [formula] is d-local on Y if, for any 1  ≤  j  ≤  n, the j-th coordinate of the value of f on [formula] depends only on the value of those coordinates of x that have distance less than or equal to d from vertex j∈Y. In other words, if [formula], then [formula] depends only on those coordinates that have distance less than or equal to d from j.

For 1  ≤  d  <  n and 1  ≤  j  ≤  n, let Ljd(Y) be the set of all functions [formula] such that and [formula] depends only on the values of those coordinates of x which have distance at most d from j in Y. Hence Ljd(Y) consists of d-local functions on [formula], which are the identity on all but possibly the j-th coordinate.

For d = n, define Ljn(Y) to be the set of all functions on [formula], which are the identity on all but possibly the j-th coordinate. Observe that if Y is connected, then this definition of Ljn(Y) directly extends the definition in (2).

Observe that Lj0(Y) = Lj0 does not depend on the graph Y and neither does Ljn(Y). Furthermore, Lj0 is isomorphic to [formula], that is, it contains all four possible functions, namely the identity on [formula], the two projections to one element in [formula], and the inversion.

In this paper we study the set

[formula]

that is, the set of n-tuples of functions [formula] which only change the ith coordinate. To be precise, [formula], with arbitrary functions [formula]. We denote by F the power set of this set without the empty set. The following theorem is one of the main results in [\cite=LP].

There is a Galois correspondence between F and the set G of subgraphs of the complete graph Kn on the vertex set [formula].

For the convenience of the reader we recall the construction of this Galois correspondence. Let F∈F. Define a subgraph Φ(F) of Kn as follows. First construct the set [formula] of all n-tuples [formula], which either are in F or arise from an element in F by replacing one of the coordinates by a 0-local function, that is, by a function from Li0 for some i. Now define the graph Φ(F) as follows. An edge (i,j) of Kn is in Φ(F) if and only if [formula] for all [formula].

Conversely, let G  ⊂  Kn be a subgraph. We define a set Ψ(G) of n-tuples of functions on [formula] by

[formula]

where [formula] is the complement of G in Kn. Then Φ and Ψ together form the desired Galois correspondence.

In particular, if F∈F consists of one element [formula], then the graph Φ({f}) = Φ(f) encodes the dependency relations among the local functions fi. Conversely, for a subgraph G  ⊂  Kn, the set Ψ(G) contains all n-tuples of local functions whose dependency relations are modeled by G. This observation provides the paradigm for the results in this paper.

First we encode the local functions as polynomials, which allows us to give an algebraic criterion to compute Φ(f). More importantly, it suggests a natural choice for the linearization of a system, which we define in the next section. Using this notion of linearization we explore a natural equivalence relation on tuples, setting two equivalent if they have the same dependency graph. We show that systems that are equivalent in this sense have the same linearization.

Finally, we consider systems [formula] which are obtained by composing local functions from an n-tuple [formula]. We show that, if t  ≥  1 is an integer and Wt is the set of all words in the integers [formula] of length t, allowing for repetitions and for the case that t < n, then we obtain an upper bound for the number of different systems [formula] one can construct by forming

[formula]

where [formula] ranges over all elements in Wt.

This upper bound generalizes one for SDS, derived in [\cite=R]. It suggests that a part of the theory of SDS can be derived for systems that are SDS-"like," but have fewer restrictions on the local functions. In particular, it is not necessary to make the dependency graph an explicit part of the data defining an SDS. This approach is explored further in [\cite=LP2], in which a more general notion of SDS is introduced, and morphisms of SDS are defined, forming a category with interesting properties, that contains "classical" SDS as a subcategory. A morphism between two SDS can be viewed as a simulation of one system by the other.

Computation of Φ

In this section we give a method for computing the graph Φ(f) for an n-tuple of local functions f. It relies on the representation of local functions as polynomials, for which we now give an elementary proof.

Let [formula] be a function. Then f can be represented as a polynomial. That is, there is a polynomial [formula] such that

[formula]

for all [formula].

We will prove the lemma by showing that there are exactly as many different polynomial functions as there are functions. Since [formula], there are 22n functions from [formula] to [formula]. Now let [formula] be the subspace with the basis containing the 2n monomials

[formula]

where [formula] is given by the binary expansion [formula] of i. Then V contains 22n elements, which is equal to the number of functions [formula]. Thus it suffices to show that different polynomials give rise to different functions on [formula].

Suppose that f,g∈V, with f  ≠  g. Let [formula] be a monomial of smallest total degree which is in f but not in g, and let h = f - g = m + q. Let [formula]. Then [formula]. Now observe that any monomial of q which involves a variable that does not appear in m evaluates to 0 at [formula]. But since m was chosen to have minimal degree, there cannot be any monomials in q that involve only variables appearing in m. Hence [formula], and [formula]. This shows that [formula], and the proof is complete.

Therefore, any function in Ljn can be written as an n-tuple of polynomials in n variables [formula]. Also observe that (xj)m  =  xj for all 1  ≤  j  ≤  n and for all m > 0. Furthermore, [formula]. Thus, we can represent an element of [formula] as an n  ×  (2n)-matrix in which the ith row corresponds to the ith local function fii.

Let f  =  (f1,f2,f3) where

[formula]

Then the 3  ×  8 matrix, denoted by Mf, associated to f with respect to the ordered basis

[formula]

is equal to

[formula]

Let [formula] be an element of [formula] and let Φ(f) be its associated graph. The following result gives an important characterization of Φ(f) in terms of the polynomial representation of the entries of f.

There is an edge between vertex i and vertex j in Φ(f) if and only if xi does not divide any monomial of fjj and xj does not divide any monomial of fii.

Suppose first that xi does not appear in fjj and xj does not appear in fii. It is clear that then fi and fj commute. Now consider an [formula] which is obtained from f by replacing the jth coordinate by a 0-local function [formula]. It also does not depend on xi. Similarly, no [formula] depends on xj. Thus [formula] for all [formula] obtained from f by replacing one of the coordinates by a 0-local function. Hence the edge (i,j) is in the graph Φ(f).

Conversely, suppose that xi divides a monomial of fjj or xj divides a monomial of fii. Without loss of generality, suppose xi divides a monomial of fjj. Let [formula] be the set of all monomials of fjj such that xi|ml for all [formula]. Let ms be a monomial in M of minimal degree, say [formula], where [formula]. Define [formula] as follows, for 1  ≤  l  ≤  n, Then the jth coordinate of fj(a) is equal to

[formula]

Let [formula] be the 0-local function, projection to zero, in the ith coordinate. The jth coordinate of [formula] is equal to

[formula]

On the other hand, [formula]. So the jth coordinate of [formula] is

[formula]

Thus [formula]. Therefore, [formula], and hence there cannot be an edge between vertices i,j in Φ(f).

This proposition provides an easy algorithm to compute Φ(f) for any f, or, more generally, any set of such functions. (A C++ implementation is available from the authors.) It also suggests a natural notion of a linear system, which will be explored in the next section.

Linearization of Systems

For classical dynamical systems, a standard technique is to linearize the system, and then study the linearization. Proposition [\ref=main:thm1] suggests a natural definition of linearity for a finite system

[formula]

One can then define the notion of linearization for a finite system and study the relationship between the original system and its linearization. In this section we study the notion of linearization with respect to the dependency relations among the local functions.

Each [formula] can be represented as a polynomial in the variables [formula], which changes only the ith coordinate. That is, [formula], with each [formula].

A system [formula] is called linear if all functions fii are [formula]-linear polynomials.

Observe that a linear system [formula] can be represented by an (n  ×  n)-matrix with entries in [formula], since the constant term and all nonlinear terms of all functions fij are equal to zero. Conversely, any (n  ×  n)-matrix M over [formula] can be interpreted as a linear system

[formula]

Let G be a graph on n vertices. Then there exists a linear system [formula] such that Φ(lG)  =  G.

We construct a linear system lG by providing the associated n  ×  n-matrix MlG of lG. For 1  ≤  i  <  j  ≤  n, let

[formula]

And let (MlG)ii  =  0, for all 1  ≤  i  ≤  n. It is clear that lG is a linear system. Moreover, by Proposition [\ref=main:thm1], Φ(lG)  =  G.

The matrix MlG is the adjacency matrix of the complement of the graph Φ(lG)  =  G. Observe that lG is not the only linear system which gives the graph G. The matrix MlG is symmetric. Consider a pair i  ≠  j for which the (i,j)-entry (and the (j,i)-entry) is equal to 1. If we change exactly one of these two entries to a 0, then lG and lG' have the same graph G as their image under Φ. We will see later (Theorem [\ref=equivalence]), however, that the incidence matrix of the complement of G is not just a canonical, but a natural choice of linear system in the inverse image of a graph G under Φ.

Let [formula] be a system and let G  =  Φ(f). There exists a linear system [formula] such that Φ(lG)  =  Φ(f).

By Lemma [\ref=main:cor1], there exists a linear system lG such that Φ(lG)  =  G  =  Φ(f).

The linear system lG corresponding to the adjacency matrix of the complement of G is called the linearization of the system f.

The linearization of a system should ideally bear a certain relationship to the original system. Our focus in this paper is the structure of the dependencies among the component functions. The linearization of a system as defined here, has the same dependency structure among the component functions. Its dynamics will in general be very different, however.

Graph equivalence

Using the Galois correspondence we now define an equivalence relation on n-tuples of local functions, which captures equivalence of dependency relations among the entries in the tuples.

We say that [formula] are graph equivalent if and only if [formula] is isomorphic to [formula]. This relation is denoted by [formula].

Let f  =  (f1,f2,f3), where

[formula]

We will usually denote such a function by f  =  (x2 + x3,1 + x2,x1). Let g = (x2,x3,0). Then f  ~  g, since their graphs both have three vertices 1,2,3, with edge (2,3) in Φ(f), and edge (1,3) in Φ(g).

The main result in this section is a characterization of graph equivalence of systems using a relationship on the matrices of the corresponding linearizations. We first define an action of the symmetric group on the set of matrices.

Let Sn be the group of permutations of n elements. We define an Sn-action on the set of n  ×  n-matrices as follows. For any (n  ×  n)-matrix M and π∈Sn, πM is the (n  ×  n)-matrix such that

[formula]

That is, π acts on M by permuting rows and columns.

The Sn-action in Definition [\ref=def:action] is a group action of Sn on the set of (n  ×  n)-matrices over [formula].

Clearly eM  =  M, where e is the identity permuation. Let π,σ∈Sn, then

[formula]

A graph automorphism can be represented by a permutation of the vertices of the graph which preserves adjacency. So we can represent automorphisms of a graph with n vertices as permutations in Sn, and obtain in this way an Sn-action on the set of subgraphs of Kn.

Let G1 and G2 be two graphs with (n  ×  n)-adjacency matrices M1 and M2, respectively. Then G1 is isomorphic to G2 via an automorphism π∈Sn (i.e., π(G1)  =  G2) if and only if πM1 = M2.

Suppose first that πM1 = M2. For any two vertices i and j of G2, (i,j)∈E(G2) if and only if

[formula]

This happens if and only if

[formula]

which is the case if and only if the edge (π- 1(i),π- 1(j))∈E(G1). Thus π(G1)  =  G2.

Conversely, if π(G1)  =  G2, then (M2)ij  =  1 if and only if (i,j)∈E(G2), that is, if and only if (π- 1(i),π- 1(j))∈E(G1). This is the case if and only if (M1)π- 1(i)π- 1(j)  =  (M1)π- 1(j)π- 1(i) = 1. Therefore, π  ·  M1 = M2.

Let f and g be two systems on [formula]. Then f is graph equivalent to g (i.e., π(Φ(f))  =  Φ(g) for some π∈Sn) if and only if π  ·  MlΦ(f)  =  MlΦ(g).

First observe that if G1 and G2 are graphs, then G1 is isomorphic to G2 via π if and only if [formula] is isomorphic to [formula] via π. Therefore, π(Φ(f))  =  Φ(g) if and only if [formula]. By Remark [\ref=main:rem1], MlΦ(f) (resp. MlΦ(g)) is the adjacency matrix of [formula] (resp. [formula]). Now, by Theorem [\ref=main:thm3], [formula] if and only if π  ·  MlΦ(f)  =  MlΦ(g). Therefore, π(Φ(f))  =  Φ(g) if and only if π  ·  MlΦ(f)  =  MlΦ(g).

This theorem suggests that our choice of the adjacency matrix of [formula] as the linearization of a system f is a natural one, since it preserves graph equivalence and makes the construction of lG from G equivariant with respect to the Sn-action on both.

An Upper Bound for Sequential Systems

The real object of interest in many cases are composed systems [formula] rather than merely tuples of local functions. Such systems are obtained by composing the local functions in some order. The order often corresponds to a choice of update schedule of the variables in a system, such as a simulation. A theoretical question which has important practical consequences is how many different systems one can obtain by simply varying the update schedule of the variables, that is, by composing the local functions in a different order. In this section we derive an upper bound for this number.

Let [formula], and let Wt be the set of all words on [formula] of length t, for some t  ≥  1, allowing for repetitions. For [formula], we denote by fπ the finite dynamical system given by

[formula]

Let FWt(f)  =  {fπ|π∈Wt}, the collection of all systems [formula] that can be obtained by composing the coordinate functions of f in all possible ways, using up to t of them.

We now define an equivalence relation on Wt.

Let G be a graph on the n vertices [formula]. Let ~  G be the equivalence relation on Wt generated by the following relation. Let [formula]. For 1  ≤  k < t, if ik = ik + 1 or there is no edge between ik and ik + 1 in G, then

[formula]

where [formula]

If [formula] is such that Φ(f)  =  G, and [formula], then

[formula]

We now derive an upper bound on the size of the set FWt(f), that is, on the number of different systems one obtains by composing the coordinate functions of f in all possible orders, with up to t of them at a time.

Let [formula], and let G(f) = G = Φ(f). Let [formula]. Let Hπ(f) = Hπ be the graph on t vertices [formula], corresponding to [formula] (with va  ≠  vb even in the case that ia = ib), with an edge between va and vb if and only if the following two conditions hold:

ia  ≠  ib,

the edge (ia,ib) is not in G.

Observe that if π∈Sn, that is, t = n and π contains no repetitions, then Hπ  =  .

Let [formula] be the set of all acyclic orientations of a graph H. Given [formula], we construct an acyclic orientation of Hπ by orienting an edge (vi,vj) toward the vertex whose label occurs first in π. If all entries of π are distinct, then this clearly produces an acyclic orientation. But even if an entry is repeated we cannot produce an oriented cycle, since there is no edge between the vertices corresponding to the repetitions. Denote this acyclic orientation by Oπ(f).

If [formula], then Hπ(f) = Hπ'(f) and Oπ(f) = Oπ'(f).

If [formula], then they differ by a sequence of transpositions of adjacent letters, which are either equal, or for which the corresponding vertices in G are connected by an edge. Hence Hπ(f) and Hπ'(f) have the same vertex set. Furthermore, an edge (a,b) is in Hπ(f) if and only if ia  ≠  ib and (ia,ib) is an edge in G. Similarly for Hπ'(f). Observe that the transposition in π of adjacent letters which are connected by an edge in G does not change the resulting acyclic orientation, because, by construction, the vertices va and vb are not connected by an edge in Hπ(f). Hence the proof of the lemma is complete.

The next proposition is a generalization of a result from Cartier-Foata normal form theory. See, e.g., [\cite=D] [\cite=R].

Let f be a system and G = Φ(f). There is a one-to-one correspondence

[formula]

We assign to a word π∈Wt the associated acyclic orientation Oπ(f) on Hπ(f). By Lemma [\ref=orientation] this induces a mapping ψG on [formula]. There is an obvious inverse mapping, assigning to an acyclic orientation on Hπ the corresponding π', equivalent to π, such that ia appears before ib in π' if there is an edge (a,b) in Hπ(f), oriented from a to b.

We illustrate this correspondence with the following example. Let G be a 4-cycle with vertices [formula], and let π = (1,2,1,3). Then Hπ has the four vertices 1,11,2,3, where 11 represents the vertex corresponding to the second 1 in π. There is an edge 3  →  1, which becomes oriented toward 1 in the acyclic orientation Oπ.

The next theorem provides an upper bound on the number of different systems [formula] one can obtain from composing the coordinate functions of an n-tuple [formula], up to t of them at a time.

Let [formula] be a system of local functions on [formula], and let FWt(f) = {fπ|π∈Wt}. Then

[formula]

By Proposition [\ref=main:lem1], [formula]. But we have seen that if [formula] then fπ  =  fπ'. Hence

[formula]

This result shows in particular that if [formula], then the two systems fπ and fπ' are equal. The following example shows that the upper bound in the theorem is not attained in general.

Let [formula]. Then Φ(f) does not contain any edges. Let π  =  (3,2,1),π' = (3,1,2). Then [formula]. However,

[formula]

If π∈Sn, then {Acyc(Hπ(f)):π∈Wn}  =  {Acyc()}. Thus in this case we recover the upper bound for the number of different SDS obtained in [\cite=bmr].

If we restrict ourselves to SDS, this bound is known to be sharp. For general systems this seems to be a substantially more difficult question.

Finite Systems and SDS

The approach to the study of finite systems taken in this paper was originated in [\cite=LP], motivated by the desire to better understand sequential dynamical systems.

Recall that an SDS [formula] is given by a graph Y with n vertices, functions [formula], which change only the ith coordinate and take as input those coordinates connected to i in the graph Y. These functions are then composed according to an update schedule given by a permutation π∈Sn. That is,

[formula]

The functions fi are required to be symmetric in their inputs, that is, permuting the inputs does not change the value of the function.

In this paper we study n-tuples of functions [formula], which change only the ith coordinate, without any further restrictions. In particular, we do not suppose the a priori existence of a graph Y, that governs the dependencies among these functions. The Galois correspondence Ψ, constructed in [\cite=LP], provides such a graph when needed. And, as for SDS, it is the invariants of this graph that determine many properties of the n-tuple and finite systems derived from it. It shows that even for SDS it is not necessary to explicitly include the dependency graph Y in the data defining an SDS. The Galois correspondence also shows that in general there will be more than one system whose dependency relations are modeled by a given graph. There is, however, a natural choice, which also provides a definition for the linearization of a system.

An important theoretical result, proved in [\cite=R], gives a sharp upper bound on the number of different SDS that can be obtained by varying the update schedule over all of Sn. The proof of this result assumes that all vertices of Y that have the same degree also have the same local function attached to them. Theorem [\ref=thm:gral] generalizes this upper bound by removing the restrictions on the local functions fi and on the graph Y. More importantly, it removes the restriction that the update schedule be given by a permutation. Thus, the upper bound holds for compositions of the coordinate functions, which allows for repetitions of the functions, and does not require that all functions are actually used.

These generalizations suggest that a more relaxed definition of SDS can still lead to a class of systems about which one can prove theorems like the above upper bound. Such a definition is proposed in [\cite=LP2], where a category of more general SDS is developed.

In [\cite=R2] an upper bound for dynamically non-equivalent SDS is given. In general, two maps [formula] are dynamically equivalent if there exists a bijection [formula] such that

[formula]

This upper bound relies on the fact that conjugacy yields an SDS with the same graph and local functions. This is not true for the general systems discussed in this paper as the following example shows. Thus, this upper bound holds exactly for the class of SDS.

Let [formula]. Then Φ(f) is the graph on three vertices 1,2,3 with edges (1,2),(1,3). Hence there are only two functionally non-equivalent systems which correspond to the permutations id  =  (123) and (321), that is, the systems [formula] and [formula]. These two systems have the state spaces in Figure [\ref=states].

Nevertheless, if we let φ  =  (213), then the system [formula] has the state space in Figure [\ref=conjugate].

As expected, this state space is isomorphic to the state space of fid but it is not equal to any of the two possible state spaces given in Figure [\ref=states]. In fact, it is not equal to the state space of any system obtained by composing the functions f1,f2,f3 according to any word. This is easily seen because, for example, the state (1,0,1) is sent to itself, but f1 is the zero function. So f1 cannot be involved. On the other hand, the first coordinate of other states changes, so there must be a function involved that changes the first coordinate.

Stably isomorphic systems

In this section we answer a question that suggests itself naturally from the Galois correspondence. Given two systems that have the same dependency graphs, are they stably isomorphic, that is, do they have the same limit cycle structure in their state spaces? Recall that the state space of a system is a directed graph, whose vertices are the states of the system, that is, all binary strings of a given length. Directed edges correspond to system transitions.

Let f1,f2 be systems with state spaces Sfi and subdigraphs of limit cycles Lfi. We call f1 and f2 stably isomorphic if there exists a digraph isomorphism between Lf1 and Lf2.

Let [formula] and [formula] be two systems with the same dependency graphs, that is, Φ(f)  =  Φ(g). One can now ask if [formula] is stably isomorphic to [formula] for all π∈Wt. In this section we show that this is not true, by providing a counterexample.

Let f  =  (f1,f2,f3) and g  =  (g1,g2,g3) be two triples of functions with

[formula]

By using Theorem [\ref=main:thm1], it is easy to see that Φ(f)  =  Φ(g) is the graph on vertices 1,2,3, with the single edge (2,3).

Let [formula] and [formula]. The state spaces of f and g are given in Figure [\ref=state].

From Figure [\ref=state], it is clear that f and g are not stably isomorphic.