HIDE & SEEK: End-to-End Packages to Simulate and Process Radio Survey Data

Introduction

Forward-modeling has become a common approach in various fields of astronomy where mock data sets are simulated and analyzed in parallel with the science data. This has become especially prevalent in cosmology where large data sets are used and high precision is required. Prominent examples are analyses of the cosmic microwave background [\citep=reinecke2006simulation], spectroscopy [\citep=nord2016spokes] and weak gravitational lensing [\cite=bridle2009handbook] [\cite=refregier2014way] [\cite=bruderer2015calibrated] [\cite=peterson2015simulation]. These forward-modeling pipelines simulate the astrophysical signals, the instrument response and the data reduction process in order to understand any systematic biases from hardware or software and to estimate statistical errors in the measurement chain.

In this paper, we implement this forward-modeling approach for radio surveys. We develop two software packages: the HI Data Emulator (HIDE) and the Signal Extraction and Emission Kartographer (SEEK). HIDE forward models the entire radio survey system chain, while SEEK processes both the simulated data and the observed survey data in a reproducible and consistent way. Although different simulation and data reduction pipeline packages for radio astronomy exist [\citep=swinbank2015lofar] [\citep=mcmullin2007casa] [\citep=dodson2016imaging], many of them are either non-open source or tailored to the specific need of the different projects. In view of this, HIDE & SEEK are developed with a high level of flexibility, reproducibility as well as code quality. Both packages are developed in pure Python with rigorous testing and a modular architecture. Developing the two packages simultaneously has the advantage that the individual components of one pipeline can be cross validated against its counter part in the other pipeline.

HIDE & SEEK are developed based on the hardware system and data products from the 7m telescope at the Bleien Observatory as described in Chang et al. (in prep, hereafter C16). This framework is then used to forward-model a Galactic survey conducted at the Bleien Observatory for testing and science verification purposes. Such an analysis allows us to forecast the expected power of this survey with the existing hardware system at Bleien. Comparing the results of the forward model and data also helps to identify areas that require improvements in HIDE & SEEK as well as the hardware system.

This paper is organized as follows. In Section [\ref=sec:pipelines] we first describe the basic architecture and design of HIDE & SEEK. Detailed implementations for specific functionalities are described in [\ref=sec:beam_convolution], [\ref=sec:rfi] and [\ref=sec:flux_calibration]. In Section [\ref=sec:application2bgs], we apply HIDE & SEEK to forward-model a survey based on early data taken at the Bleien Observatory. This includes customizing the various functionalities to this specific survey and providing a forecast for the expected outcome of the survey. Finally, we conclude in Sections [\ref=sec:conclusion]. In [\ref=sec:comparison] we show an example of how we applied SEEK to process part of the early data from the Bleien Observatory and what we learn comparing these results to the HIDE simulations. Information for downloading and installing HIDE & SEEK, as well as the default file format is described in [\ref=sec:distribution] and [\ref=sec:fileformat], respectively.

The HIDE & SEEK pipelines

HIDE is a simulation pipeline for single-dish radio telescopes and SEEK is a data processing pipeline for observed or simulated radio telescope data. We have developed the two independent software packages simultaneously, which means that one pipeline can be used to cross validate the other. For example, in HIDE we simulate radio frequency interference (RFI) signals, while in SEEK we detect and mask the RFI signals. This suggests that the quality of the RFI masking in SEEK can be assessed using simulated data from HIDE. On the other hand, the goodness of the modeling in HIDE can be verified by processing real data with SEEK and comparing the results with the simulation. Both pipelines share a common design. Fig. [\ref=fig:flow] shows a schematic illustration of both packages.

To ensure the common design and facilitate the switching between HIDE & SEEK, both package are based on the simple plugin-based workflow engine Ivy, which we introduce in Section [\ref=sec:ivy]. In Section [\ref=sec:data] we briefly describe the two main data structures that are used in HIDE & SEEK.

Ivy: Plugin-based workflow engine

Ivy is a generic workflow engine written in Python and is open-source under the GPLv3 license. Its architecture ensures that individual elements of pipelines (which we refer as "plugins" here) are self-contained. The interaction between the plugins is done via a context object that is passed from plugin to plugin by the framework. Ivy's design fosters reusability and maintainability of the code. As every plugin is loosely coupled to the pipeline and the other plugins, unit testing the individual components becomes greatly simplified. Furthermore, new features can easily be added to an existing pipeline in the form of a new plugin without interfering with the other plugins.

A pipeline developed with the Ivy framework always consists of a configuration file, that contains a list of the plugins that belong to this pipeline and parameters that are used by the plugins. An Ivy pipeline can be executed in parallel on multiple CPU cores with minimal work. By default Ivy uses Python's built-in multiprocessing package but alternative parallelization scheme such as IPython cluster can be chosen. The workload is automatically distributed among the available CPU's and Ivy executes the plugins in parallel.

Data structures: time-ordered data and Healpix maps

The two relevant data structures used in HIDE & SEEK are time-ordered data (TOD) and Healpix [\citep=Gorski2005] maps. TOD refers to the data type we record at the end of the instrument chain (a bolometer or a spectrometer). Typically, one or multiple values that scale linearly with the signal received by the telescope is recorded over time. In our case, since the measurement instrument is a spectrometer, we have one value per frequency channel per time, which results in a 2D plane with time and frequency on the two axes (see Fig. [\ref=fig:tod] for an example of the observed and simulated TOD). This data format itself is agnostic about where the signal is from in the sky. Only by combining the data with the telescope pointing we map the TOD to the sky coordinates.

A Hierarchical Equal Area isoLatitude Pixelation (Healpix) map refers to a specific pixelation scheme implemented on a sphere. This format is commonly used in cosmology. Healpix maps have by construction equal-area pixels and the pixelation introduces minimal distortions and errors compared to other projection methods. Healpix maps can be manipulated with the Python wrapper Healpy. In this work, we use Healpix maps whenever the celestial coordinate is relevant. This includes the input Milky Way signal in HIDE and the final reconstructed map in SEEK.

HIDE architecture

HIDE & SEEK both follow the plugin design concept of the Ivy framework described above. The architecture allows the user to easily add new features or replace existing functionality. In the following, we give a high-level overview of the functionalities in both packages.

HIDE is a package for simulating a single dish radio telescope survey. As such, it takes Healpix maps as inputs and processes them into TOD. The design is flexible and can be customized to different instruments and survey designs. In the following, we describe the setup of the HIDE pipeline. This is not an exhaustive list for generic surveys and can easily be extended. The left half of Fig. [\ref=fig:flow] shows the structure of the pipeline and includes the following steps:

We note that the most computationally demanding step in the HIDE pipeline is the step of convolving the signals with the beam. We speed up this step by using Quaternions and a KD-tree data structure. The technical details of this operation is described in [\ref=sec:beam_convolution].

SEEK architecture

SEEK is a flexible and easy-to-extend data processing pipeline for single dish radio telescopes. It takes the observed (or simulated) TOD in the time-frequency domain as an input and processes it into Healpix maps while applying calibration and automatically masking RFI. The data processing is parallelized using Ivy's parallelization scheme.

We outline the setup of the SEEK pipeline below. Again, this list is not exhaustive but can easily be extended and modified given a different experiment. The structure of the SEEK pipeline is illustrated in the right half of Fig. [\ref=fig:flow] and includes the following steps:

In the SEEK pipeline, tackling the RFI is the most computationally challenging task. This includes both the RFI masking in the TOD plane and the final outlier-rejection applied at the Healpix map level. We describe our specific treatment of RFI in [\ref=sec:rfi].

Quality assurance

We developed HIDE & SEEK using best practice from software engineering. In particular, we use tools common in the Python community. Both packages follow a standardized packaging, which simplifies the development and installation including resolving dependent third party packages. The standardization releases by the Python Package authority defines the directory structures of a package, which enforces the separation of functionality and makes it easier for new developers to engage in the project. Furthermore, it defines how to store meta-information of the package. In order to maintain a high level of quality and that newly developed features do not infer with existing code, we rigorously test the functionality of the packages with unit tests. To develop those tests we use the common testing framework py.test. Finally, both packages are fully documented using the standardized reStructuredText syntax such that we can automatically generate and publish a documentation using the Sphinx package.

Forward-modeling a Galactic survey with HIDE & SEEK

In this section, we describe how we apply HIDE & SEEK to model and analyze data for a mock Galactic survey. The design of this mock survey is based on the early Science Verification (SV) data from the Bleien Observatory as described in C16 and allows us to develop realistic models and test the robustness of the code. This data set was collected using a 7m single-dish telescope operating in drift-scan mode with a frequency range of 990-1260 MHz. In addition to the continuous scanning, calibration data was taken every 8 days to provide an anchor for various calibration tests. For more details of this data set, we refer the readers to C16.

We discuss below the survey-specific implementations that we have adopted in HIDE (Section [\ref=sec:simulatingbgs_hide]) and SEEK (Section [\ref=sec:simulatingbgs_seek]), respectively. For other experiments, these implementations may need to be modified or replaced. We then show an example of a forecast for the Galactic survey in Section [\ref=sec:forecast] with the current pipelines.

Simulating a Galactic survey with HIDE

We customize the functionalities of HIDE to match the characteristics of the SV data from the Bleien Observatory. For the beam profile, or the angular response of our telescope, we use an Airy disk profile, which is a good approximation for an underilluminated 7m parabolic dish (C16). For the size of the beam, we use values inferred from transits of the Sun as described in C16. We generate data with [formula] MHz bandwidth between 990 MHz and 1260 MHz, resulting in 276 frequency channels. We use a drift-scan strategy that follows the schedule used in the SV data.

We assume that the TOD has an frequency- and elevation-dependent baseline that is otherwise independent of azimuth and time of the pointing as well as its Galactic coordinates. We furthermore assume that the frequency- and elevation-dependencies factorize, i.e. our baseline B(f,el) is given by

[formula]

where f is the frequency, el is the elevation, b(f) is the frequency-dependent baseline and δb(el) is a further elevation-dependent modulation of the baseline. To generate the model parameters for Eq. [\eqref=eq:baseline] that are motivated by data, we calculate the median of the TOD over a time window during the night (from midnight to 4:00 UT) over all survey days during SV after RFI mitigation. We then fit a second-order polynomial to the mean of the medians as a function of elevation (see Figure [\ref=fig:elmodel], left panel). Finally, we use the mean of the normalized medians as a model for the frequency-dependent baseline b(f). In the right panel of Figure [\ref=fig:elmodel], we show the agreement between the observed medians and the calibrated model B(f,el).

As shown in C16, the instrument noise in our TOD is very close to white noise due to the stable phase-switch implemented in the system. To model the amplitude of the noise, we estimate the standard deviation from TOD recorded in the night during SV. To avoid biases from RFI that was not properly mitigated, we estimate the scale of the noise per frequency channel as the mean of the 16 and 84 percentiles of the TOD for a given night. We use the mean of the estimated scales over all days for clean channels and the minimum over all days for the contaminated channels as model for the standard deviation of the TOD in units of ADU.

The Bleien Observatory is in a location with non-negligible RFI from man-made sources such as satellites and aircraft communication in the frequency range of interest. Due to the large variety of distinct RFI patterns, developing a realistic RFI model is challenging. As a result, we choose to adopt a simple model for the RFI, where each RFI burst is defined by the same profile in time and frequency (either exponential or Gaussian) and an amplitude. For each frequency, the amplitudes are sampled randomly from a uniform distribution between the standard deviation of the noise and a maximum value inferred from the real data. The rate of RFI bursts per frequency is chosen such that, on average, the number of pixels affected by RFI greater than the noise-level is matching the fraction of masked pixels inferred from the real data. This model can be implemented efficiently by starting with a zero time-frequency plane and setting the randomly chosen positions in time to the randomly drawn amplitudes for each frequency. The final simulated RFI is then given by a two-dimensional FFT convolution of the time-frequency plane with the chosen RFI profile. Figure [\ref=fig:tod] shows the TOD from the Bleien Observatory on March 21st, 2016, next to a simulated TOD from HIDE. We note that even though this model is not capturing all aspects of the RFI, it approximately reproduces the RFI-induced data-loss and gives us the possibility to explore the performance of the RFI mitigation in SEEK.

Analyzing simulated data with SEEK

Next, we analyze the TOD and reconstruct the astronomical signals with SEEK. Having a simulation that is expected to be close to the observation allows us to implement a SEEK pipeline that can be used for the processing of the observation as well as simulation data with minimal modifications.

The first step after loading the TOD in the SEEK pipeline is to obtain the gain factor G(λ) that converts the observed ADU values in the TOD into physical units. This procedure is referred to as flux calibration and the exact implementation is described in [\ref=sec:flux_calibration]. Fig. [\ref=fig:gain] shows the gain factors used for the simulation in HIDE (blue line) and the gain factor recovered from SEEK's flux calibration. The accuracy of the flux calibration is biased by the RFI contamination and the noise in the data set. We use a simplified model and assume that G(λ) is constant over time. From repeated measurements in SV we see variation in G(λ) can vary up to 10%.

For object-masking, we configure SEEK such that data is masked if the angular separation of the telescope pointing and the Sun is smaller than [formula]. Depending on the Moon phase data is masked if the separation is smaller than [formula].

For RFI mitigation we have implemented the SumThreshold algorithm [\citep=offringa2010post] with a morphological dilation of the resulting mask (for more details we refer to [\ref=sec:rfi]). We set the parameters for the SumThreshold and mask dilation such that most of the RFI is being masked while minimizing the fraction of incorrectly masked data. The tuning of these parameters is done by analyzing the RFI masks of simulated data where the positions of the RFI pixels are exactly known. We then inspect the mask visually and statistically. Fig. [\ref=fig:roc] shows the receiver operating characteristic (ROC) curve of the mask obtained from SumThreshold and mask dilation. The x-axis displays the ratio of pixels incorrectly labeled as RFI and the y-axis represents the ratio of correctly masked pixels. Each point represents a different frequency while the color is showing the fraction of RFI in this channel. If the RFI contamination is low in a specific channel, SumThreshold has a low probability to mask the RFI pixels. As the fraction of contaminated pixels increases, the algorithm correctly masks the unwanted signal while maintaining a low rate of incorrectly masked clean pixels. In highly RFI-contaminated channels the true positive rate reaches almost 1. However, due to the high density of masked pixels, the mask dilation also increases the false positive rate.

Fig. [\ref=fig:tod] displays the visual inspection of a representative observed and simulated data set recorded on 21st of March 2016. The left and central panel (observed and simulated TOD respectively) show the unmasked data where strong broad- and narrow-band RFI contamination is visible. The right panel shows the same data overlaid with the RFI mask obtained from SumThreshold and mask dilation. Most of the RFI is well captured including weaker narrow-band RFI not visible in the central panel.

Forecast

In this section we apply the full HIDE & SEEK framework to produce an end-to-end simulation for the mock Galactic survey described above. That is, given the survey design and our understanding of the data characteristics from the Bleien Observatory, we forecast the expected map of the Milky Way we will measure at the end of SV data collection after processing all the data through SEEK. We also forecast the expected signal-to-noise ratio of the observed Milky Way at different positions on the sky.

For this purpose, we set up a suite of HIDE simulations with the parameters listed in the top half of Table [\ref=tbl:params], and analyze the simulations using SEEK with the parameters listed in the bottom half of Table [\ref=tbl:params]. These parameters are chosen to best match the SV data set from the Bleien Observatory. We show examples of the resulting Healpix maps for this forecast run at 991.5 MHz in the top-left panel of Fig. [\ref=fig:forecast]. To obtain the pure "signal" for the signal-to-noise calculation described below, we also create a second HIDE simulation without observational effects such as noise, RFI, gain, and baseline. Analyzing this second simulation with SEEK yields a map that is convolved in the same way as the forecasted map, but does not suffer from any other observational effects.

From the SV data, we inferred strong variations of the RFI contamination over frequencies as well as time of day. RFI from airplane communication, for example, only happens during the day as Zurich airport is open from 6:00 am to 11:00 pm and affects the TOD in the frequency range from 1050 MHz to 1150 MHz (see Fig. [\ref=fig:tod], left panel). As RFI leads to data-loss, both the signal to noise and the sky coverage of our forecasts depend on frequency. We define signal-to-noise of a pixel as the ratio between the clean simulation (signal) and the error in the forecasted map estimated from the standard deviation in each pixel (noise). As an example, we show the signal-to-noise map at a frequency of 991.5 MHz in the top-right panel of Fig. [\ref=fig:forecast]. We further define the sky coverage as the ratio between the number of pixels with at least 2 observations and the total number of pixels.

In the lower right panel of Fig. [\ref=fig:forecast] we show histograms of the distribution over frequency of the sky coverage, median pixel noise, and median signal-to-noise of our forecasts simulations. We find a median signal-to-noise of 2.3. The best frequencies in the ranges 990 MHz to 1010 MHz and 1185 MHz to 1195 MHz achieve a median signal-to-noise of approximately 9 and 8, respectively. For the pixel noise in our maps, we find a median error of 0.24 K. The best frequency range from 1185 MHz to 1195 MHz reaches an error of 0.09 K. Finally, the median sky coverage is given by 57% and the highest values of 70% are achieved by the channels from 990 MHz to 1010 MHz.

We also study systematic differences between the forecasted and the map without observational effects by looking at the difference map between them shown in the lower left panel of Fig. [\ref=fig:forecast]. We find that the systematic differences in the maps are due to cumulated inaccuracies of the reconstruction of baseline and gain described in section [\ref=sec:simulatingbgs_seek] as well as unmitigated RFI. The mild elevation dependent stripes in Fig. [\ref=fig:forecast] imply that the dominant contribution to the systematics is coming from the baseline correction which is the only elevation-dependent artifact in the simulations. We defer the development of a more complicated and realistic baseline model to future work.

Conclusion

In this paper, we present two software packages, HIDE & SEEK, for simulating and processing data from single-dish radio surveys. HIDE simulates the entire system chain of a radio telescope from the astronomical signal to the time-ordered-data (TOD). SEEK on the other hand processes simulated and real observed TOD to Healpix maps while calibrating the signal and automatically masking contamination from radio frequency interference (RFI). The two packages together provide an end-to-end forward-modeling framework that can be used to systematically understand and test the various steps in the data processing procedure. They can also be used independently if only simulation or data processing is needed. The packages were developed based on the data taken at the Bleien Observatory, but can be easily adjusted to model and process similar projects. The other strength of using both HIDE & SEEK is the possibility to perform cross-validation between the simulation and the analysis algorithm. We demonstrate how the two packages are used together to study systematic effects such as imperfect baseline removal and RFI leakage.

We present the main architecture of the codes and how typical data is simulated and processed. We then describe more specifically how we apply the two packages to a forward-modeling exercise of a Galactic survey. We use HIDE to simulate the entire survey with the main survey characteristics matched to the Science Verification data from the Bleien Observatory. We then process this simulated data with SEEK, using settings close to that used for the observed data. The result of this forward model is a forecast of the expected output from an idealized Galactic survey, with simplifications that are well-understood. We predict a median sky coverage of 50% and a median signal-to-noise ratio of 2.3. In the channels from 990 MHz to 1010 MHz we expect a sky coverage up to 70% with signal-to-noise ratio of approximately 9.

HIDE & SEEK follow common software engineering best practices. Being compliant with well-established coding standards, they offer great flexibility for defining data processing pipelines. Although some of the current implementations in HIDE & SEEK are relatively simple and more general compared to existing software such as [\cite=offringa2010lofar] [\cite=peck2013serpent] [\cite=mcmullin2007casa], they have the advantage of being open-source code with a rigorous structure, and thus provide an easy-to-use foundation to build upon for more complicated functionalities. We have developed both packages in pure Python and increase the performance of computationally intensive parts by just-in-time compilation. By doing so, we are able to perform the RFI mitigation of the TOD in SEEK at an rate of 190-200 GB/h/CPU. Using Ivy's parallelization scheme, we can furthermore distribute the workload to multiple cores and make efficient use of the available hardware. This allows us to easily process the expected data volume from a five-month survey on a notebook. In HIDE we implemented an efficient beam convolution on the sphere by using Quaternions combined with a KD-Tree. Creating the simulations for the Galactic survey with HIDE took around 3 hours on a single-core average notebook. Further information such as documentation of the software can be found at .

Implementation of beam convolution on a sphere

In order to convolve the beam response with the simulated astronomical signal, we have to rotate the grid that defines the beam geometry on a sphere. As this step is repeated for every telescope pointing defined by the scanning strategy as well as for every simulated frequency, high efficiency for the operation is crucial.

Conventionally, spherical rotations are implemented by using the Euler matrix rotation. Applying this rotation scheme to a Healpix map requires transforming the spherical pointing angles (θ and φ) into Euler coordinates (x,y,z). This involves computing the rotation matrix R, applying this matrix to the coordinate vector, transforming the results back into spherical coordinates, and finally performing the convolution. Typically, applying rotation on multiple axes requires a repetition of the above steps for each axis. This can be computationally even more demanding and numerically less stable.

We have implemented all the coordinate rotations with Quaternions, a technique commonly used in 3D computer vision [\cite=shoemake1985animating]. Rotations over multiple axes can be concentrated into one operation with Quaternions, which make them computationally more efficient and stable. Furthermore they do not suffer from the so-called gimbal lock as Euler rotation do, where a rotation along one axis may produce coordinates that do not allow further rotations [\cite=shoemake1985animating].

Additionally, this allowed us to easily implement a lookup table with a binary search for the sine and cosine function to further speed up the rotations. In order to efficiently find the pixels relevant for the rotation of the beam geometry we also use store all the Healpix pixel information in a KD-Tree adapted for spherical coordinates.

RFI masking

The SEEK package was designed to be able to process data that is heavily contaminated with RFI. SEEK's automated RFI masking mechanism is based on two steps: the SumThreshold algorithm and a Healpix pixel-based outlier rejection. The SumThreshold method was first proposed in [\cite=offringa2010post] and since then successfully implemented in different radio processing pipelines [\citep=offringa2010lofar] [\citep=peck2013serpent]. Its simple concept and high detection efficiency makes it an attractive candidate for the SEEK package.

SumThreshold gradually builds a mask that flags the unwanted RFI in the data. The underlying assumption of the algorithm is that the astronomical signal is relatively smooth in both time and frequency (i.e., on the TOD plane), while RFI signals have sharp edges. Under this assumption, SumThreshold iteratively improves a model of the true astronomical signal by smoothing the TOD with a Gaussian filter. It then clips pixels that lie above a certain threshold after subtracting this model from the data. The masking naturally starts with localized, strong RFI bursts. The threshold is progressively lowered in each iteration such that more RFI is detected and masked along the process. We also take into account that RFI often extends in both time and frequency directions. That is, the algorithm combines neighboring pixels and masks them if their sum exceeds a threshold. Finally, we apply a morphological dilation of the mask, i.e. we enlarge the mask depending on the density of masked pixels in a region in order to capture possible missed RFI leakage. The iterative Gaussian smoothing in the presence of a mask is the most computationally intensive part. In order to accelerate the process while keeping the code fully Python, we use the HOPE just-in-time compiler package [\citep=akeret2015hope], which translates the Python code into C++ and compiles at runtime. This allows SEEK to perform the RFI mitigation step at a rate of 190-200 GB/h/CPU, which is faster than other existing Python implementations of the similar algorithm.

The second step in the RFI mitigation is applied during the Healpix map-making process. Pixel values X0..n belonging to the same Healpix pixel are analyzed in order to remove outliers. We use a simple but robust outlier criterion defined through ωi, where with where X̂ is the median of X0..n, [formula] the median of X0..n' and t a predefined threshold. This replaces the mean and standard deviation often used in sigma clipping, which can be biased toward the outliers.

Flux calibration

We are interested in converting the raw data value M that is recorded in the native instrument units of ADU into a surface temperature Ts with the units of Kelvin - this process is referred as flux calibration. Surface temperature is a measure of the luminosity of the source under a given resolution, and is independent of other instrument properties. We refer to this conversion as "Gain" G, or

[formula]

For the data set used in this work, calibration data taken during the survey consists of several transit measurements of astronomical sources with well known spectra. Transit measurements are taken with the telescope parked at some position on the sky where the source of interest is expected to cross due to the rotation of the Earth. The data from these transits give an estimate of the beam response profile. Since we know the spectra of these sources, we can derive G given our knowledge of the beam.

[formula]

where λ is the wavelength in meters, Ae is the effective aperture size of the instrument in square meters, k is the Planck constant, Fref is the spectral density of the reference source in Jansky (10- 26W / m2 / Hz), and Mref is the measured ADU value at the peak of the transit for the reference source. Ae is defined through

[formula]

where ΩA is the beam solid angle defined

[formula]

and Pn is the beam profile with its peak normalized to 1.

We calculate Ae assuming the an Airy disk profile with size measured from transit data of the Sun. For Mref, since we are only interested in the main beam here, we fit the transit data with a Gaussian profile.

Apply SEEK to SV data at the Bleien Observatory

We have used SEEK to process the SV data from Bleien (see C16 for details of the SV data) to demonstrate the usability of SEEK on real data. Fig. [\ref=fig:bgs_sv] shows the resulting map at ~  991.5 MHz with [formula]MHz bandwidth at a Healpix resolution of nside= 64. The Galactic plane is clearly visible, as well as the brightest point sources close to the plane such as Cassiopeia A and Cygnus A. There are, however, clear patterns of stripes in the declination direction in the map, which corresponds to the drift-scan pattern used in the SV data. These patterns originate from a time-varying baseline which varies on the time scale of several hours and cannot be removed with our simple baseline-removal method in SEEK. The baseline also appears to be correlated with the ambient temperature and thus higher during day time. This coincides with the time where the Galactic center is observed in the SV months, making the Galactic center brighter than expected. Furthermore, comparing Fig. [\ref=fig:bgs_sv] and Fig. [\ref=fig:forecast], we see a higher masked area in the data, which originates from artifacts in the data that were manually masked. These artifacts appear as broad-band, bright bursts that are potentially related to the moisture on the cover of the feed horn.

After a quantitative analysis of the maps from SV, we find that the statistical uncertainty of the maps are close to expectation from the simulations. However, the systematic uncertainties associated with the varying baseline will limit the usage of these maps in cosmological studies. We conclude that the stability of the overall system needs to be improved. Although the electronic chain described in C16 is stable, the existing observatory environment and other supporting infrastructure still need further upgrades to meet the stringent requirements set for cosmological surveys.

Below, we discuss several aspects of the system stability that we plan on improving in the future. In parallel, we will also work on incorporating these effects in the HIDE simulations and developing more sophisticated baseline-removal techniques in SEEK. First, the temperature of the main electronics is only controlled by a moderate heating system which can regulate temperature swings up to 40 degrees. Unfortunately, during the survey, there were several occasions where the temperature change exceeded this range and the electronic temperature was no longer regulated, which in turn resulted in fluctuations of the baseline. Furthermore, temperature at the feed horn is not controlled, which adds to the baseline instability. Second, the frontend electronics were not properly shielded. This means that water from rain and dew leaks in under extreme weather conditions, and the frontend is more heated by the Sun at certain pointing directions than others. During the SV observations, there were incidents of heavy rainfall that caused the frontend to response strangely and/or stop responding.

All these valuable lessons learned from studying the SV data will feed into the next stage of observations at the Bleien Observatory as well as other future surveys.

Code distribution

Detailed documentation and installation instructions can be found on the package website . The HIDE & SEEK packages are released under the GPLv3 license The development is coordinated on GitHub and . We welcome all contributions to the code development.

TOD file format

The default TOD file format and structure used in HIDE & SEEK are designed to be consistent with that collected at the Bleien Observatory. All files are in HDF5 file formats, and are compressed using the common lossless gzip compression. Each HDF5 file contains several "dataset" units. Four datasets are used to store the time-frequency planes ("P/Phase0", "P/Phase1", 'P2/Phase0", and "P2/Phase1") and an additional dataset for the time-axis that records the time-stamp for each pixel ("TIME"). The structure of the four time-frequency planes originated from the special design of the BGS project, but one can easily adapt HIDE & SEEK to a different file format.