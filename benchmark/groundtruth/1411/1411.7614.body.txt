Observation Definition Corollary

Derandomizing Isolation Lemma for K3,3-free and K5-free Bipartite Graphs

Introduction

The perfect matching problem is one of the most extensively studied problem in combinatorics, algorithms and complexity. In complexity theory, the problem plays a crucial role in the study of parallelization and derandomization. In a graph G(V,E), a matching is a set of disjoint edges and a matching is called perfect if it covers all the vertices of the graph. Edmonds [\cite=Edm65] gave the first polynomial time algorithm for the matching problem. Since then, there have been improvements in its sequential complexity [\cite=MV80], but an [formula] (efficient parallel) algorithm for it is not known. The perfect matching problem has various versions:

[formula]: Decide if there exists a perfect matching in the given graph.

[formula]: Construct a perfect matching in the given graph, if it exists.

A randomized [formula] ([formula]) algorithm for [formula] was given by [\cite=Lov79]. Subsequently, [formula] was also shown to be in [formula] [\cite=KUW86] [\cite=MVV87]. The solution of Mulmuley et al. [\cite=MVV87] was based on the powerful idea of Isolation Lemma. They defined a notion of an isolating weight assignment on the edges of a graph. Given a weight assignment on the edges, weight of a matching M is defined to be the sum of the weights of all the edges in it.

For a graph G(V,E), a weight assignment [formula] is isolating if there exists a unique minimum weight perfect matching in G, according to w.

The Isolation Lemma states that a random weight assignment (polynomially bounded) is isolating with a good probability. Other parts of the algorithm in [\cite=MVV87] are deterministic. They showed that if we are given an isolating weight assignment (with polynomially bounded weights) for a graph G then a perfect matching in G can be constructed in [formula]. Later, Allender et al. [\cite=ARZ99] showed that the [formula] is in [formula], if an isolating weight assignment can be constructed in L (see also [\cite=DKR10]). A language L is in class [formula] if its characteristic function χL:Σ*  →  {0,1} can be (log-space) reduced to computing determinant of an integer matrix.

Derandomizing the Isolation Lemma remains a challenging open question. It has been derandomized for some special classes of graphs: planar bipartite graphs [\cite=DKR10] [\cite=TV12], constant genus bipartite graphs [\cite=DKTV12], graphs with small number of matchings [\cite=GK87] [\cite=AHT07] and graphs with small number of nice cycles [\cite=Hoa10]. A graph G is bipartite if its vertex set can be partitioned into two parts V1,V2 such that any edge is only between a vertex in V1 and a vertex in V2. A graph is planar if it can be drawn on a plane without any edge crossings.

We make a further step towards the derandomization of Isolation Lemma. We derandomize it for K3,3-free bipartite graphs and K5-free bipartite graphs. These classes are generalizations of planar bipartite graphs. For a graph H, G is an H-free graph if H is not a minor of G. K3,3 is the complete bipartite graph with (3,3) nodes and K5 is the complete graph with 5 nodes. A planar graph is simultaneously K3,3-free and K5-free.

For a K3,3-free or K5-free bipartite graph, an isolating weight assignment (polynomially bounded) can be constructed in log-space.

This theorem together with the results of Allender et al. [\cite=ARZ99] and Datta et al. [\cite=DKR10] gives us the following results about matching.

For a K3,3-free or K5-free bipartite graph,

[formula] is in [formula].

[formula] is in [formula].

[formula] is in [formula].

Here, [formula] refers to a log-space transducer with access to an [formula] oracle. The problem [formula] asks to construct the minimum weight perfect matching in a given graph with polynomially bounded weights on its edges.

For K3,3-free bipartite and K5-free bipartite graphs, an [formula] algorithm for [formula] was known. This is implied by combining two results: (i) [formula] (counting the number of perfect matchings) is in [formula] for K3,3-free graphs [\cite=Vaz89] and K5-free graphs [\cite=STW14] (ii) [formula] [formula]-reduces to [formula] for bipartite graphs [\cite=KMV08]. The limitation of this idea is that [formula] is #  P-hard for general bipartite graphs. Thus, there is no hope of generalizing this approach to work for all graphs. While, our ideas can potentially lead to a solution for general/bipartite graphs.

After our work, small genus bipartite graphs is the only remaining class of bipartite graphs for which [formula] is in [formula] [\cite=GL99] [\cite=KMV08], but construction of an isolating weight assignment is not known.

Main Idea:

We start with the idea of Datta et al. [\cite=DKR10] which showed that nonzero circulation (weight in a fixed orientation) for every nice cycle implies isolation of a perfect matching. To achieve nonzero circulation in a K3,3-free or K5-free graph, we work with its 3-connected or 4-connected component decomposition given by [\cite=Wag37] [\cite=Asa85] (can be constructed in log-space [\cite=TW14] [\cite=STW14]). The components are either planar or constant-sized. These components form a tree structure, when components are viewed as a node and there is an edge between two components if they share a separating pair/triplet. For any cycle C, we break it into its fragments contained within each of these components, which we call projections of C. These projections themselves are cycles.

Circulation of any cycle can be seen as a sum of circulations of its projections. The components, where a cycle has a non-empty projection, form a subtree of the component tree. The idea is to assign weights such that there is 'central' node in this subtree which gets a weight higher than the total weight coming from other nodes in the subtree. Weights within a component are given by modifying the already known techniques for planar graphs [\cite=DKR10] [\cite=Kor09] [\cite=TV12] and constant sized graphs.

This idea would work only if the component tree has a small depth, which might not be true in general. Thus, we create an O( log n)-depth working tree, which has the same nodes as the component tree but the edge relations are different. The working tree 'preserves' the subtree structure in some sense. This working tree can be constructed using the standard recursive procedure for finding a set of centers. But, a log-space implentation needed a non-trivial idea (Section [\ref=sec:workingTree]).

As there are O( log n) levels, we need to ensure that at every level the total weight gets multiplied by only a constant. Thus, in a planar component, every edge cannot be assigned a weight on a higher scale. Instead, we choose only those edges which surround a separating pair/triplet, and scale their weight by the total weight coming from the subtree attached at that separating pair/triplet.

Achieving non-zero circulation in log-space also puts directed rechability in [formula] [\cite=RA00] [\cite=BTV09] [\cite=TV12]. Thus, we get an alternate proof for the result - directed reachability for K3,3-free and K5-free graphs is in [formula] [\cite=TW14].

In Section [\ref=sec:prelim], we introduce the concepts of nonzero circulation, clique-sum, graph decomposition and the corresponding component tree. In Section [\ref=sec:nonzeroCirc], we give a logspace constrcution of a weight assignment with nonzero circulation for every cycle, for a class of graphs defined via clique-sum operations on planar and constant-sized graphs. In Section [\ref=sec:reductions], we argue that K3,3-free and K5-free graphs fall into this class.

Preliminaries

Let us first define a skew-symmetric weight function on the edges of a graph. For this, we consider the edges of the graph directed in both the directions. We call this directed set of edges [formula]. A weight function [formula] is called skew-symmetric if for any edge (u,v), w(u,v)  =   - w(v,u).

For a cycle C, whose edges are given by [formula], its circulation is defined to be [formula].

Clearly, as our weight function is skew-symmetric, changing the orientation of the cycle, only changes the sign of the circulation. The following lemma [\cite=TV12] gives the connection between nonzero circulations and isolation of a matching. For a bipartite (undirected) graph G(V1,V2,E), a skew-symmetric weight function [formula] on its edges, has a natural interpretation on the undirected edges as [formula] such that [formula], where u∈V1 and v∈V2.

Let [formula] is skew-symmetric weight function on the edges of a bipartite graph G such that every cycle has a non-zero circulation. Then, [formula] is an isolating weight assignment for G.

The bipartiteness assumption is needed only in the above lemma. We will construct a skew-symmetric weight function that guarantees nonzero circulation for every cycle, for K3,3-free and K5-free graphs, i.e. without assuming bipartiteness.

Clique-Sum

We will show construction of a nonzero circulation weight assignment for a special class of graphs, defined via a graph operation called clique-sum.

Let G1 and G2 be two graphs each containing a clique (of same size). A clique-sum of graphs G1 and G2 is obtained from their disjoint union by identifying pairs of vertices in these two cliques to form a single shared clique, and by possibly deleting some of the edges in the clique. It is called a k-clique-sum if the cliques involved have at most k vertices.

One can form clique-sums of more than two graphs by a repeated application of clique-sum operation on two graphs (see Figure [\ref=fig:cliqueSum] in Appendix [\ref=sec:appendix]). Using this, we define a new class of graphs.

Let Pc be the class of all planar graphs together with all graphs of size at most c, where c is a constant. Define 〈Pc〉k to be the class of graphs constructed by repeatedly taking k-clique-sums, starting from the graphs which belong to the class Pc. The starting graphs are called the component graphs. We will construct a nonzero circulation weight assignment for the graphs which belong to the class 〈Pc〉3.

Taking 1-clique-sum of two graphs will result in a graph which is not biconnected. As we are interested in perfect matchings, we only deal with biconnected graphs (see Section [\ref=sec:biconnected]). Thus, we assume that every clique-sum operation involves either 2-cliques or 3-cliques. The 2-cliques with respect to which we take cliques-sums are called separating pairs and 3-cliques are called separating triplets, as their deletion will make the graph disconnected. In general, they are called separating sets. Usually, a separating pair/triplet means any pair/triplet of vertices, whose deletion will make the graph disconnected. But, in this section, a separating pair/triplet will only mean those pairs/triplets which are used in a clique-sum operation.

Component Tree

In general, clique-sum operation can be performed many times using the same separating set. In other words, many components can share a separating set. In Section [\ref=sec:reductions], we show that any graph in 〈Pc〉3 can be modified via some matching preserving operations such that on decomposition, any separating set is shared by only two components. Henceforth, in this section we assume this property.

Using this assumption, we can define a component graph for any graph G∈〈Pc〉3 as follows: each component is represented by a node and two such nodes are connected by an edge if the corresponding components share a separating set. Observe that this component graph is actually a tree. This is because when we take repeated clique-sums, a new component can be attached with only one of the already existing components, as a clique will be contained within one component. In literature [\cite=HT73] [\cite=TW14], the component tree also contains a node for each separating set and it is connected by all the components which share this separating set. But, here we can ignore this node as we have only two sharers for each separating set.

In the component tree, each component is shown with all the separating sets it shares with other components. Thus, a copy of a separating set is present in both its sharer components. Moreover, in each component, a separating set is shown with a virtual clique, i.e. a virtual edge for a separating pair and a virtual triangle for a separating triplet. These virtual cliques represent the paths between the nodes via other components (see Figure [\ref=fig:componentTree]). If any two vertices in a separating set have a real edge in G, then that real edge is drawn in one of the sharing components, parallel to the virtual edge. Note that while a vertex can have its copy in two components, any real edge is present in exactly one component.

In literature [\cite=HT73] [\cite=TW14], for any real edge in a separating set, the component tree contains a new node called "3-bond" (a real edge with two parallel virtual edges). But, here we do not have this node and represent the real edge as mentioned above.

Nonzero Circulation

In this section, we construct a nonzero circulation weight assignment for a given graph in the class 〈Pc〉3, provided that the component tree and the planar embeddings of the planar components are given. Moreover, to construct this weight assignment we will make some assumptions about the given graph and its component tree.

In any component, a vertex is a part of at most one separating set.

Each separating set is shared by at most two components.

Any virtual triangle in a planar component is always a face (in the given planar embedding).

In Section [\ref=sec:reductions] we show how to construct a component tree for a given K3,3-free or K5-free graph and then to modify it to have these properties. The third property comes naturally, as the inside and outside parts of any virtual triangle can be considered as different components sharing this separating triplet. All these constructions are in log-space. Let, in any non-planar component, the number of real edges is bounded by m. In Section [\ref=sec:reductions] we show that this bound is 60, for a K3,3-free or K5-free graph.

Components of a cycle

We look at a cycle in the graph as sum of many cycles, one from each component the cycle passes through. Intuitively, the original cycle is broken at the separating set vertices which were part of the cycle, thereby generating fragments of the cycle in various nodes of the component tree. In all nodes containing these fragments, we include the virtual edges of the separating sets in question to complete the fragment into a cycle, thus resulting in component cycles in the nodes of the tree (see Figure [\ref=fig:cycleComponents]).

Consider a directed cycle [formula] in a graph G  =  (V,E). Without loss of generality, consider that G is separated into two components G1 and G2 via a separating pair (vi,v0) or a separating triplet (vi,v0,u), where 1  ≤  i < k and [formula]. Then, one of the components, say G1, will contain the vertices [formula], and the other (G2) will contain the vertices [formula]. Then the cycles [formula] and [formula] in G1 and G2 respectively are the component cycles of C, and we say that C is the sum of C1 and C2. Observe that the edges (vi,v0) and (v0,vi) are virtual.

Repeat the processes recursively for C1 and C2 until no separating set breaks a cycle component, and we get the component cycles of the cycle C. Note that any edge in C is contained in one and only one of the component cycles, and for any component cycle, all its edges, other than the virtual edges, are contained in C.

Observe that for any separating set in a component, a cycle can use one of its vertices to go out of the component and another vertex to come in (this transition is represented by a virtual edge in the component). As any separting set has size at most 3, a cycle can visit a node of the component tree only once. In other words, a cycle can have only one component cycle in any component tree node (this would not be true if we had separating sets of size 4). Also, a component cycle can take only one edge of any virtual triangle.

For a given component node N in the component tree, the component cycle of a cycle C in N is called the projection of C on N. If there is no component cycle of C in N, then C is said to have an empty projection on N.

Within any component, weight of a virtual edge will always be set to zero. This is ensured by our weight function described in Section [\ref=sec:weightingScheme]. Hence, the following lemma,

The circulation of a cycle is the sum of the circulations of its component cycles.

It is easy to see that for any cycle C, the components on which C has a non-empty projection, form a subtree of the component tree.

Weighting Scheme

The actual weight function we employ is a combination of two weight functions w0 and w1. They are combined with an appropriate scaling so that they do not interfere with each other. w1 assures that all the cycles which are within one component have a non-zero circulation and w0 ensures that all the cycles which project on at least two components have a non-zero circulation. We first describe the construction of w0.

Working Tree: The given component tree can have arbitrary depth, while our weight construction would need the tree-depth to be O( log n). Thus, we define a new working tree. It is a rooted tree, which has the same nodes as the component tree, but the edge relations are different. The working tree, in some sense, 'preserves' the subtree structure of the original tree.

For a tree S, its working tree [formula] is constructed as follows: Find a 'center' node c(S) in the tree S and mark it as the root of the working tree, [formula]. Deleting the node c(S) from the tree S, would give a set of disjoint trees, say [formula]. Apply this procedure recursively on these trees to construct their working trees [formula]. Connect each [formula] to the root [formula], as a subtree. This completes the construction.

The 'center' nodes are chosen in a way so that the working tree depth is O( log n). Section [\ref=sec:workingTree] gives the exact log-space construction of the working tree.

Note that for any two nodes v1∈Si and v2∈Sj such that i  ≠  j, [formula] in S passes through the node [formula]. Thus, we get the following property for the working tree.

For any two nodes u,v∈S, let their least common ancestor in the working tree [formula] be the node a. Then [formula] in the tree S passes through a.

The root [formula] of the working tree [formula] is said to be at level 1. For any other node in [formula], its level is defined to be one more than the level of its parent. Henceforth, level of a node will always mean its level in the working tree. From Observation [\ref=obs:path], we can easily conclude the following.

Let S' be an arbitrary subtree of S, with its set of nodes being [formula]. There exists [formula] such that for any j  ≠  i*, vj is a descendant of vi* in the working tree [formula].

Let l* be the minimum level of any node in S', and let vi* be a node in S' with level l*. We claim that every other node in S' is a descendant of vi*, in the working tree [formula]. For the sake of contradiction, let there be a node vj∈S', which is not a descendant of vi*. Then, the least common ancestor of vj and vi* in [formula], must have a level, strictly smaller than l*. By observation [\ref=obs:path], this least common ancestor must be a present in the tree S'. But, we assumed l* is the minimum level in S'. Thus, we get a contradiction.

This observation plays a crucial role in our weight assignment construction, as for any cycle C in the graph G, the nodes in the component tree, where C has a non-empty projection, form a subtree of the component tree.

Complementary to the level, we also define height of every node in the working tree. Let the maximum level of any node in the working tree be L. Then, the height of a node is defined to be the difference between its level and L + 1.

To assign weights in the graph G, we work with the working tree of its component tree. Let the working tree be T. We start by assigning weight to the nodes having the largest level, and move up till we reach level 1, that is, the root node r(T).

Circulation of cycles spanning multiple components:

For any subtree T of the working tree T, the weights to the edges inside the component r(T) will be given by two different schemes depending on whether the corresponding graph is planar or constant sized.

Let the maximum possible number of edges in a constant sized component be m. Then, let K be a constant such that K >  max (2m  +  2,7). Also, suppose that the height of a node N is given by the function h(N), and the number of leaves in subtree T is given by l(T). Lastly, suppose the set of subtrees attached at r(T) is [formula].

Constant sized graph: Let the set of (real) edges of the graph is [formula]. The edge ej will be given weight 2j  ×  Kh(r(T)) - 1  ×  l(T) for an arbitrarily fixed direction. The intuition behind this scheme is that powers of 2 ensure that sum of weights for any subset of edges remain nonzero even when they contribute with different signs. Later, we prove that for a cycle C fully contained within a subtree T of the working tree, the upper bound on its circulation is Kh(r(T))  ×  l(T).

Planar graph: Let us fix a planar embedding of the graph. For a given weight assignment [formula] on the edges of the graph, we define the circulation of a face as the circulation of the corresponding cycle in the clockwise direction i.e. traverse the boundary edges of the face in the clockwise direction and take the sum of their weights. Here our weighting scheme will fix circulations for the inner faces of the graph. Lemma [\ref=lem:faceToEdge] describes how to assign weights to the edges of a planar graph to get the desired circulation for each of the inner faces.

Assigning circulations to the faces:

If T is a singleton, and thus there are no subtrees attached at T, we give a zero circulation to all the faces (and thus to all the edges) of r(T).

Otherwise, consider a separating pair {a,b} where a subtree Ti is attached to r(T). The two faces adjacent to the virtual edge (a,b) will be assigned circulation 2  ×  Kh(r(Ti))  ×  l(Ti). Similarly, consider a triplet {a,b,c} where a subtree Tj is attached. Then all the faces (at most 3) adjacent to the virtual triangle {a,b,c} get circulation 2  ×  Kh(r(Tj))  ×  l(Tj). Repeat this procedure for faces adjacent to all the pairs and/or triplets where subtrees are attached. If a face is adjacent to more than one virtual edge/triangle, then we just take the sum of different circulations due to each virtual edge/triangle.

Here, we mean that each face has a positive circulation in the clockwise direction. The intuition behind this scheme is the following: circulation of any cycle in the planar component is just the sum of circulations of the faces inside it. As, all of them have same sign, they cannot cancel each other. Moreover, contribution to the circulation from this planar component cannot be canceled by the contribution from any of its subtrees.

Now, we formally show that this weighting scheme ensures that all the cycles spanning multiple components in the tree get non-zero circulation.

Nonzero Circulation of a cycle:

Firstly, we derive the upper bound UT on the circulation of any cycle completely contained in a subtree T of the working tree.

The upper bound on the circulation of any cycle contained in a subtree T of the working tree T is UT  =  Kh(r(T))  ×  l(T).

We prove this using induction on the height of r(T).

Base case: The base case is when the height of r(T) is 1. Notice that this means that r(T) has the maximum level amongst all the nodes in T, and therefore, r(T) is a leaf node, and T is a singleton. Consider the two cases: i)when r(T) is a planar node, and ii)when it is a constant sized node.

By our weight assignment, if r(T) is planar, the total weight of all the edges is zero. On the other hand, if r(T) is a constant sized graph, the maximum circulation of a cycle is the sum of weights of its edges, that is, [formula]. Thus, the circulation is upper bounded by Kh(r(T))  ×  l(T).

Induction hypothesis: The upper bound for any tree T' with h(r(T'))  ≤  j - 1 is UT'  =  Kh(r(T'))  ×  l(T').

Induction step: We will prove that the upper bound for any tree T, with h(r(T)) = j, is UT  =  Kh(r(T))  ×  l(T).

Let the subtrees attached at r(T) be [formula]. For any cycle in T, sum of the circulations of its projections on the subtrees [formula] can be at most [formula].

First, we handle the case when r(T) is planar. For any subtree Ti, the total circulation of faces in r(T) due to connection to Ti can be 6  ×  Kh(r(Ti))  ×  l(Ti). This is because the circulation of each face adjacent to the separating set connecting with Ti is 2  ×  Kh(r(Ti))  ×  l(Ti), and there can be at most 3 such faces. Here, note that for all i, level of r(Ti) is one more than level of r(T), and thus height of r(Ti) is one less than height of r(T). Thus,

[formula]

Now, consider the case when r(T) is a small non-planar graph. The maximum possible contribution from edges of r(T) to the circulation of a cycle in T is less than 2m + 1  ×  Kh(r(T)) - 1  ×  l(T). Similar to the case when r(T) is planar, contribution from all subtrees is at most Kh(r(T)) - 1  ×  l(T). The total circulation of a cycle in T can be at most the sum of these two bounds, and is thus bounded above by (2m + 1 + 1)  ×  Kh(r(T)) - 1  ×  l(T). Since, K > 2m + 2, the total possible circulation is less than Kh(r(T))  ×  l(T).

Therefore, the upper bound UT  =  Kh(r(T))  ×  l(T).

To see that each cycle gets a nonzero circulation, recall Lemma [\ref=lem:breakCycle], which says that the circulation of the cycle is the sum of circulations of its projections on different components. Consider a cycle C. We look at the minimum 'level' component on which C has a non-empty projection. We show two things: (i) the contribution to the circulation from this component is nonzero, and (ii) the contribution to the circulation from this component is larger than sum of all the circulation contributions from its higher level descendants in the working tree.

Observe that proving the above two will automatically prove that any cycle C projecting on multiple component nodes has a non-zero circulation. This is because the nodes having non-empty projection from cycle C form a subtree SC in the component tree; and when looking at the nodes of SC in the working tree T, we can always find a node v*∈SC such that all other nodes in SC are its descendants (see Observation [\ref=obv:subtree]). Let v* be the root of a subtree T in the working tree. If the contribution from v* (or equivalently [formula]) to the cycle circulation is non-zero and exceeds the contribution from all its descendants, circulation of the cycle C is certainly non-zero.

Again, let the subtrees attached at r(T) be [formula].

Case 1: When the component is constant-sized. It is easy to see that the circulation of any cycle in this component will be nonzero as long as it takes a real edge, because the weights given are powers of 2. Also, the minimum weight of any edge in r(T) is [formula]. Thus, when a cycle takes a real edge, contribution to its circulation from r(T) is larger than contribution from higher level components (components in the subtrees attached at r(T)). And any cycle has to take a real edge, as the virtual edges and triangles all have disjoint set of vertices. (Here, the virtual triangle does not count as a cycle).

Case 2: When the component is planar. The crucial observation here is that all the faces inside a cycle contribute to its circulation in the same orientation.

In a planar graph with a given planar embedding, circulation of a cycle in clockwise orientation is the sum of circulations of the faces inside it (Proof given in Appendix [\ref=sec:appendix]).

As all faces have positive circulation in clockwise direction, the total sum remains nonzero. Now, observe that if the cycle C goes through the subtree Ti, then its projection in r(T), say Ci, must contain at least one of the faces adjacent to the pair/triplet in r(T), at which Ti is connected. Since, circulation of this face is 2UTi, contribution from this component will surpass the total sum of all the subtrees where C passes through.

Thus, we can conclude the following.

Circulation of any cycle which passes through at least two components is nonzero.

Weights from faces to edges: Now, we come back to the question of assigning weights to the edges in a planar component such that the faces get the desired circulations. Lemma [\ref=lem:faceToEdge] describes this procedure for any planar graph. But, the scheme will assign weights to all the edges, while we are not allowed to give weights to virtual edges/triangles. So, first we collapse all the virtual triangles to one node and all the virtual edges to one node. As no two virtual triangles/edges are adjacent, after this operation, every face remains a non-trivial face (except the virtual triangle face). Now, we apply the procedure from Lemma [\ref=lem:faceToEdge]. After undoing the collapse, the circulations of the faces will not change and we will have the desired circulations.

Let G(V,E) be a planar graph with F being its set of inner faces in some planar embedding. For any given function on the inner faces [formula], a skew symmetric weight function [formula] can be constructed in log-space such that every face f∈F has a circulation w'(f) (Proof is described in Appendix [\ref=sec:appendix]).

Circulation of cycles contained within a single component:

For planar components, to construct w1, we assign + 1 circulation to every face using Lemma [\ref=lem:faceToEdge] (similar to the case of multiple components). This would ensure nonzero circulation for every cycle within the planar component. This construction has been used in [\cite=Kor09] for bipartite planar graphs. [\cite=TV12] also gives a log-space construction which ensures nonzero circulation for all cycles in a planar graph, using Green's theorem.

For the non-planar components, w0 already ensures that each cycle has non-zero circulation. Therefore, we set w1 = 0. Use a linear combination of w0 and w1 such that they do not interfere with each other. This together with Lemma [\ref=lem:multiCycleNonZero] gives us the following.

Circulation of any cycle is non-zero.

Polynomially bounded weights:

Now, we show that the weight given by this scheme is polynomially bounded.

The total weight given by the weighting scheme is polynomially bounded.

The weight w1 is polynomially bounded according to the procedure in Lemma [\ref=lem:faceToEdge].

Consider w0. Observe that the upper bound [formula] for the circulation of a cycle in T is actually just the sum of weights of all the edges in constant sized components, and of all the faces in planar components. Also, sum of the circulations of faces in a planar graph equals the sum of weight given to edges, by the construction given in the proof of Lemma [\ref=lem:faceToEdge]. Therefore, [formula] gives the bound on the weight function w0. Since the maximum level of any node in T can be at most [formula], the height of r(T), that is [formula]. Also, the total number of leaves in T is at most [formula].

[formula]

If n is the size of the original graph G, then clearly [formula]. Therefore, [formula]. Recall that K is a constant, and thus, w0 is also polynomially bounded.

Since we use a linear combination of w0 and w1, the total weight function is polynomially bounded.

Construction of the Working Tree

Now, we describe the log-space construction of the working tree. The idea is inspired from the construction of [\cite=LMR07], where they create a O( log n)-depth tree of well-matched substrings of a given well-matched string. Recall that for a tree S, the working tree [formula] is constructed by first choosing a center node c(S) of S and marking it as the root of [formula], and then recursively finding the working trees for each component obtained by removing the node c(S) from S and connecting them to root of [formula], as subtrees.

First consider the following possible definition of the center: for any tree S with n nodes, one can define its center to be a node whose removal would give disjoint components of size [formula]. Finding such a center is an easy task and can be done in log-space. Clearly, the depth of the working tree would be O( log n). It is not clear if the recursive procedure of finding centers for each resulting component can be done in log-space. Therefore, we give a more complicated way of defining the centers, so that the whole recursive procedure can be done in log-space.

First, we make the tree S rooted at an arbitrary node r. To find the child-parent relations of the rooted tree, one can do the standard log-space traversal of a tree: for every node, give its edges an arbitrary cyclic ordering. Start traversing from the root r by taking an arbitrary edge. If you arrive at a node u using its edge e then leave node u using the right neighbor of e. This traversal ends at r with every edge being traversed exactly twice.

For any node v, let Sv denote the subtree of S, rooted at v. For any node v and one of its descendant nodes v' in S, let Sv,v' denote the tree [formula]. Moreover Sv,ε would just mean Sv, for any v. With our new definition of the center, at any stage of the recursive procedure, the component under consideration will always be of the form Sv,v', for some nodes v,v'∈S. Now, we give a definition of the center for a rooted tree of the form Sv,v'.

Center c(Sv,v'): case (i) When v'  =  ε, i.e. the given tree is Sv. Let c be a node in Sv, such that its removal gives components of size [formula]. If there are more than one such nodes then choose the lexicographically smaller one (there is at least one such center [\cite=Jor69]). Define c as the center of Sv,v'.

Let the children of c in Sv be [formula]. Clearly, after removing c from Sv, the components we get are [formula] and Sv,c. Thus, they are all of the desired form and have size [formula].

case (ii) When v' is an actual node in Sv. Let the node sequence on the path connecting v and v' be [formula], with u0  =  v and up  =  v'. Let 0  ≤  i  ≤  p be the least index such that [formula]. This index exists because [formula]. Define ui as the center of Sv,v'.

Let the children of ui, apart from ui + 1, be [formula]. After removal of ui from Sv,v', the components we get are [formula], Sui + 1,v' and Sv,ui. By the choice of i, [formula]. Thus, [formula]. So, the only components for which we do not have a guarantee on their sizes, are [formula]. Observe that when we find a center for the tree Scj,ε in the next recursive call, it will fall into case (i) and the components we get will have their sizes reduced by a factor of 1 / 2.

Thus, we can conclude that in the recursive procedure for constructing the working tree, we reduce the size of the component by half in at most two recursive calls. Hence, the depth of working tree is O( log n). Now, we describe a log-space procedure to construct the working tree.

For any tree S, its working tree [formula] can be constructed in log-space.

We just describe a log-space procedure for finding the parent of a given node x in the working tree. Running this procedure for every node will give us the working tree.

Find the center of the tree S. Removing the center would give many components. Find the component S1, to which the node x belongs. Apply the same procedure recursively on S1. Keep going to smaller components which contain x, till x becomes the center of some component. The center of the previous component in the recursion will be the parent of x in the working tree.

In this recursive procedure, to store the current component Sv,v', we just need to store two nodes v and v'. Apart from these, we need to store center of the previous component and size of the current component.

To find the center of a given component Sv,v', go over all possibilities of the center, depending on whether v' is ε or a node. For any candidate center c, find the sizes of the components generated if c is removed. Check if the sizes satisfy the specified requirements. Any of these components is also of the form Su,u' and thus can be stored with two nodes.

By the standard log-space traversal of a tree (see, for example [\cite=Lin92]), for any given tree Sv,v', one can count the number of nodes in it and test membership of a given node. Thus, the whole procedure works in log-space.

Complexity of the weight assignment

We use simple log-space procedures in sequence to assign the weights in the working tree. After construction of the working tree, we use iterative log-space procedures to store the following for each node: i) the level of the node, and ii) the number of leaves in the subtree rooted at it. Both just require tree traversal while keeping a counter, and can clearly be done in log-space. Also, since we have the maximum level amongst all the nodes, we can use it in another straightforward log-space function to compute the height of every node. We store one more piece of information. Let the subtrees of the component tree S attached at a node N be [formula]. Correspondingly, in the working tree, the children of N will be [formula]. For all i (1  ≤  i  ≤  k), we remember which virtual edge/triangle of N is shared with the subtree Si by storing a pointer to the node [formula].

Next, we iterate on the nodes of the working tree to assign the weights. For every non-planar component, we iterate on edges inside it in an arbitrary (deterministic) fashion, and assign a weight of 2i  ×  K(h(N) - 1)  ×  l(T(N)), where i is the iteration count, N is the node, and T(N) is the subtree rooted at N.

In the next step, we again iterate on the nodes, and for every node N, we visit all its virtual edges/triangles. For a given virtual edge/triangle τi, let the child of N in the working tree attached at τi be Ni. We add a circulation of 2  ×  Kh(Ni)  ×  l(T(Ni)) to all the faces adjacent to τi. As the last step, we find the weights for the edges which would give the desired circulations of the faces. Lemma [\ref=lem:faceToEdge] shows that it can be done in log-space.

K3,3-free and K5-free graphs

In this section, we show how to construct the desired component tree for any given K3,3-free or K5-free graph and modify it to satisfy the assumptions made in Section [\ref=sec:nonzeroCirc]. All these constructions are in log-space.

Biconnected Graphs

If a graph G is disconnected then a perfect matching in G can be constructed by taking a union of perfect matchings in its different connected components. As connected components of a graph can be found log-space [\cite=Rei08], we will always assume that the given graph is connected.

Let G be a connected graph. A vertex a in G is called an articulation point, if its removal will make G disconnected. A graph without any articulation point is called biconnected. Let a be an articulation point in G such that its deletion creates connected components [formula]. It is easy to see that for G to have a perfect matching, exactly one of these components should have odd number of vertices, say G1. Then, in any perfect matching of G, the vertex a will always be matched to a vertex in G1. Thus, we can delete any edge connecting a to other components, and all the perfect matchings will still be preserved. It is easy to see that finding all the articulation points and for each articulation point, performing the above mentioned reduction can be done in log-space, via reachability queries [\cite=Rei08] [\cite=TW14]. Thus, we will always assume that the given graph is biconnected.

Matching Preserving Operation

Vertex-Split: For a graph G, we define an operation called vertex-split, which preserves matchings, as follows: Let v be a vertex and let X be the set of all the edges incident on v. Let [formula] be an arbitrary partition of X. Create two new vertices v' and v'' (see Figure [\ref=fig:vertexSplit]). Make the edges (v,v') and (v',v''). We call these two edges as auxiliary edges. For all the edges in X2, change their endpoint v to v''. We denote this operation by vertex-split(v,X1,X2).

Let the modified graph be G'. One can go back to the graph G by identifying vertices v, v' and v'' and deleting auxiliary edges. This operation is matching preserving in the following sense.

There is a one-one correspondence between perfect matchings of G and G'.

Consider a perfect matching M in G, where v is matched with a vertex in X1. It is easy to see that the matching [formula] is a perfect matching in G'. The other case when v is matched with a vertex in X2 is similar.

Consider a perfect matching M' in G'. Removing the auxiliary edge from M' and identifying the vertices v, v' and v'' will give us a perfect matching in G.

Component Tree

Wagner [\cite=Wag37] and Asano [\cite=Asa85] gave exact characterizations of K5-free graphs and K3,3-free graphs, respectively. These characterizations essentially mean that any graph in these two classes can be constructed by taking 3-clique-sums of graphs which are either planar or have size bounded by 8.

Let C be the class of all planar graphs together with the 5-vertex clique K5. Then 〈C〉2 is the class of K3,3-free graphs.

Let C be the class of all planar graphs together with the four-rung Möbius ladder V8 (Figure [\ref=fig:v8]). Then 〈C〉3 is the class of K5-free graphs.

As mentioned in Section [\ref=sec:biconnected], we can assume that the given graph is biconnected. It is known that for any given biconnected K3,3 graph G, its component tree can be constructed in log-space [\cite=TW14]. The components here are all planar or K5, which share separating pairs. Also, for any given biconnected K5-free graph G, its component tree can be constructed in log-space [\cite=STW14]. The components here are all planar or V8. They can share a separating pair or a separating triplet. The planar embedding of a planar component can be computed in log-space [\cite=AM04] [\cite=Rei08].

The component tree defined in [\cite=TW14] [\cite=STW14] slightly differs from our definition in Section [\ref=sec:componentTree]. They have an extra component for each separating set. This component is connected to all the components which share this separating set. Moreover, whenever there is a real edge between two nodes of a separating set, it is represented by a 3-bond component (one real edge and two parallel virtual edges). The 3-bond component is also connected to the corresponding separating set node. For our purposes, these two kinds of components are not needed.

For any given biconnected K3,3-free graph or K5-free graph G, we start with the component trees which are constructed by [\cite=TW14] [\cite=STW14]. We show how to modify the component tree, in log-space, to have the assumptions made in Section [\ref=sec:nonzeroCirc].

Applying the clique-sum operations on the modified component tree will give us the actual modified graph G'. We will argue that all these modifications in G are just repeated application of the vertex-split operation (Lemma [\ref=lem:vertexSplit]) in G. Thus, these are matching preserving. As mentioned earlier, from a perfect matching in G', one can get a perfect matching in G by just deleting the auxiliary vertices and edges created in the vertex-split operations.

We reiterate here that there may be some pairs/triplet in the graph G (or G'), such that their removal will make the graph disconnected, but still the graph is not decomposed with respect to them and they do not play any role in the component tree. Here, by separating pair/triplet we only mean those pairs/triplets which are shared by different components of the component tree.

(i) Removing "3-bond" components:

For all the 3-bond components we do the following: Remove the 3-bond component. Let τ be the separating set and Cτ be the corresponding node in the component tree, where this 3-bond component is attached (a 3-bond component is always a leaf). Take an arbitrary component attached to Cτ. This component will have a virtual clique for τ. Make an appropriate real edge parallel to the existing virtual edge, in this virtual clique corresponding to τ. Note that if this component was planar, it will remain so. Moreover, it is easy to adjust the planar embedding. Clearly, this operation can be done in log-space. This does not change the actual graph G in any way.

(ii) Any separating set is shared by at most two components:

Let τ be a separating set shared by m components [formula]. Let the cardinality of τ is t (t can be 2 or 3). Let us define a gadget M as follows: it has three sets of nodes {ai|1  ≤  i  ≤  t}, {bi|1  ≤  i  ≤  t}, {ci|1  ≤  i  ≤  t}. For each i, connect ai with bi by a length-2 path and also connect ai with ci by a length-2 path. Make 3 virtual cliques each of size t, one each for nodes {ai}i, {bi}i and {ci}i. Thus, three components can be attached with M.

Now, we construct a binary tree T which has exactly m - 1 leaves. Replace leaves of T with components [formula]. Replace all other nodes of T with copies of the gadget M. Further, make an edge between component G1 and the root of T (see Figure [\ref=fig:binaryTree]). Any node of type M, in this binary tree, shares its separating set {ai}i with its parent node, shares its separating set {bi}i with its left child node and shares its separating set {ci}i with its right child node. The components [formula] share their copy of τ with their respective parent nodes in the tree T. The component G1 shares its copy of τ with the root node of T.

Doing this procedure for every separating set will ensure that every separating set is shared between at most two components. Moreover, now there is no extra component for the separating set, and the components which share a separating set are joined directly by an edge. A binary tree with m - 1 leaves can be easily constructed in log-space (Take nodes [formula], xi has children x2i and x2i + 1). All the other operations here are local like deleting and creating edges and changing vertex labels. Thus it can be done log-space.

Now, we want to argue that this operation is matching preserving for the actual graph G. Let us view this operation as a repeated application of the following operation: Partition the the set of components [formula] in two parts, say G'1 and G''1. Now, take a copy of the gadget M and connect it to all three components G1, G'1 and G''1. M shares its separating sets {ai}i, {bi}i and {ci}i with G1, G'1 and G''1 respectively. In the actual graph G, this operation separates the edges incident on a vertex in τ into three parts: edges from G1, G'1 and G''1 respectively. These three sets of edges are now incident on three different copies of the vertex. Moreover two of the copies are connected to the first copy via a length-2 path. Hence, it is easy to see this as applying vertex-split (Lemma [\ref=lem:vertexSplit]) operation twice. Now, we recursively do the same operation after partitioning the set of components G'1 and G''1 further. Thus, the whole operation can be seen as a vertex-split operation applied many times in the actual graph G.

Instead of a binary tree we could have also taken a tree with one root and m - 1 leaves. This operation would also be matching preserving but the component size will depend on m. On the other hand, in our construction the new components created have size at most 15 (number of real edges is bounded by 12). Thus, the graph G' remains in class 〈Pc〉3.

(iii) Any vertex is a part of at most one separating set:

Let a be vertex in a component C, where it is a part of separating sets [formula]. We apply the vertex-split operation (Lemma [\ref=lem:vertexSplit]) on a, m times, to split a into a star. Formally, create a set of m new nodes [formula]. Connect each ai with a by a path of length 2. For each i, replace a with ai in the separating set τi. Let the updated separating set be τ'i. The edge in the component tree which corresponds to τi, should now correspond to τ'i. Any real edge in the component C which is incident on a, remains that way (see Figure [\ref=fig:star]). Clearly, doing this for every vertex in all the components will ensure that every vertex is a part of at most one separating set.

It is easy to see that a planar component will remain planar after this operation. The modification of the planar embedding and other changes here are local and can be done in log-space.

Now, we want to argue that this operation is matching preserving. Let us see how does this operation modifies the actual graph G. Let Ci be the component which shares τi with C. Removal of τi would split the graph G into two components, say G'i and G''i, where G'i is the one containing C. The above operation means that any edge in G''i which was incident on a, is now incident on ai instead of a. As each ai is connected to a by a length-2 path, this operation can be seen as a repeated application of the vertex-split operation (Lemma [\ref=lem:vertexSplit]). Thus, this operation is matching preserving.

Increase in the size of non-planar components: After this operation the size of each component will grow. Let us find out the new bound on the size of constant-sized graphs. For a K3,3-free graph, all non-planar components are of type K5. Moreover, they are only involved in a 2-clique-sum. Hence, it can have at most [formula] separating pairs. In this case, each vertex is a part of four separating pairs. Thus, each vertex will be split into a 4-star, creating 8 new vertices and 8 new edges. Totally, there will be 45 vertices and 40 real edges. Additionally, there can be some already existing real edges, at most 10. Thus, the total number of edges is bounded by 50.

For a K5-free graph, all non-planar components are of type V8. Moreover, they do not have a 3-clique, thus, can only be be involved in a 2-clique-sum. In worst case, it has 12 separating pairs. Each vertex is a part of 3 separating pairs. Each vertex will be split into a 3-star, creating 6 new vertices and 6 new edges. Totally, there will be 56 vertices and 48 edges. Thus, together with already existing real edges, total number of real edges is bounded by 60.

(iv) A separating triplet in a planar component already forms a face:

If a separating triplet does not form a face in a planar component. Then the two parts of the graph, one inside the triplet and the other outside, can be considered different components sharing this triplet. In fact, the construction in [\cite=STW14] already does this. When they decompose a graph with respect to a triplet, the different components one gets by deleting this triplet are all considered different components in the component tree.

Discussion

One of the open problems is to construct an isolating weight assignment for a more general class of graphs, in particular, for all bipartite graphs. Note that nonzero circulation for every cycle is sufficient but not necessary for constructing an isolating weight assignment. Although existence of an isolating weight assignment can be shown by randomized arguments, no such arguments exist for showing the existence of a nonzero circulation weight assignment. It needs to be investigated whether it is possible to achieve a nonzero circulation for every cycle (with polynomially bounded weights) in a complete bipartite graph? Log-space construction of such a weight assignment would imply that Bipartite Perfect Matching is in [formula] and answer the [formula]=[formula]? question.

Till now, isolation of a perfect matching is known only for those graphs for which counting the number of perfect matchings is easy. On the other hand, O( log n)-genus bipartite graphs and general planar graphs are two classes of graphs for which counting is easy, but construction of an isolating weight assignment is not known. It is surprising, as counting seems to be a much harder problem than isolation.

Acknowledgements

RG thanks TCS PhD research fellowship for support.

Skipped proofs

Here we prove the lemmas whose proofs were skipped in the main part of the paper.

We give the proof using mathematical induction on the number of faces inside the cycle.

Consider a planar graph G = (V,E). For any cycle C, its circulation is denoted by w(C).

Base case: The base case is a cycle containing only one face inside it. By definition of the circulation of a face, for a clockwise-oriented cycle, its circulation equals the circulation of the face. Induction hypothesis: The circulation of a cycle having k faces is the sum of circulations of the faces inside it.

Induction step: Consider a clockwise-oriented cycle C having k faces, [formula], inside it. Now consider a cycle C' having the same orientation as C and with all but one face of C inside it. Without loss of generality, let this face be fk.

We use the notation Eij to show the set of edges shared between faces fi and fj, taken in a clockwise direction around fi.

Denote by Sk the set of clockwise edges (w.r.t fk) shared between fk and other faces inside C, that is, [formula]. Let S- k denote the same set of edges taken in the opposite direction.

Also, we use the notation E(C) to denote the set of edges taken by a cycle C. Similarly, Ek denotes the set of edges around a face fk, taken in the clockwise direction. Similar to S- k, we can define E- k.

We can see that [formula], and [formula].

[formula]

Thus, the circulation of C is the sum of circulations of the faces contained in it.

The construction in [\cite=Kor09] gives + 1 circulation to every face of the graph and is in [formula]. We modify it to assign arbitrary circulations to the faces and argue that it works in log-space.

Let G* be the dual graph of G and T* be a spanning tree of G*. The dual graph can be easily constructed in log-space from the planar embedding. See [\cite=NT95] [\cite=Rei08] for log-space construction of a spanning tree. Make the tree T* rooted at the outer face of G. All the edges in [formula] will get weight 0. For any node f in G* (a face in G), let T*f denote the subtree of T* rooted at f. Let w'(T*f) denote the total sum of the weights in the tree, i.e. [formula]. This function can be computed for every node in the tree T*, by the standard log-space tree traversal. For any inner face f, let ef be the edge connecting f to its parent in the dual tree T*. We assign the edge ef, weight w'(T*f) in clockwise direction (w.r.t. face f).

We claim that under this weight assignment, circulation of any inner face f is w'(f). To see this, let us say [formula] are the children of f in the dual tree T*. These nodes are connected with f using edges [formula] respectively. Now, consider the weights of these edges in the clockwise direction w.r.t. face f. For any 1  ≤  i  ≤  k, weight of efi is -  w'(T*fi) and weight of ef is w'(T*f). Clearly, sum of all these weights is w'(f).