Recommending the Most Encompassing Opposing and Endorsing Arguments in Debates

Introduction

The process of gathering signatures for petitions has been extended by enabling supporters and opposers to add justifications for their stances (). As a peculiarity of this system, authors of the signatures are authenticated, and each author can reference a single justification for a given petition. Given the large number of justifications that can be submitted in such a system, the need for a recommender system to help spot the most relevant justifications is emerging.

Opposition and abstention.

While commonly petitions can be signed only for support, we assume that that an electronic system can afford and benefit from enabling manifestations of opposition or abstention to a petition. These other manifestations can offer observers a hint to the strength of the opposition to the petition (even if less statistically relevant than polls with a controlled distribution of the subjects). More importantly, these other manifestations provide a mechanism enabling people not supporting the petition to provide early a controlled/authenticated feedback to the petition supporters and observers, via justifications as described next.

Justification.

We also consider it important to enable the submission of justifications (i.e. some natural language explanation) with the signatures of support or opposition. A justification contains a set of arguments. These justifications can be seen as ways to boost reciprocal understanding between people with opposing views, and as a way to encourage activism [\cite=Hibbing13]. They can also help bring democracy in media, mitigating its frequently raised critique of manipulation and censorship by powerful groups of interests.

Justification Type.

A justification can be classified based on the type of signature (i.e., support, opposition, abstention) that it accompanies. Here we start by proposing solutions with only two types of justification: supporting justification and opposing justification. Two justifications are of the same type if both accompany the same type of signature (support or opposition).

Threading: Relations between justifications.

Unlike classical argumentation where relations are extracted from formal arguments, we assume that certain relations are explicitly offered by associating them with opaque arguments (in an opaque justification). This is commonly done in existing fora, where relations are provided via a threading model (e.g., each comment may answer another comment). While a formal logical argumentation could be used as support for much more complex mechanisms, the mechanism of opaque arguments we use can be seen as a basic case, where arguments in each provided justification form the premise of the associated vote (support or opposition):

[formula]

[formula]

The simplification to this basic case can help us to concentrate better on the semantic of the conclusion (i.e., associated signature). This is an element that was not sufficiently analyzed in the past. Once this semantic is well established (with appropriate weights given to the relations), the extension to more complex arguments (i.e., to restricted languages) can be seen as a combination with what has been done in the past in the argumentation area.

Another type of relation we support is contradicts, where a justification is presented as an answer to a different justification that it corrects or enhances. A third type of relation that we discuss is includes, claiming that a justification subsumes a second justification (claim explicitly introduced by a voter and that may or may not be automatically verifiable). The last type of relation is more_recent and can sort justifications based on their submission date.

In the following, this approach/interface to electronic petitions (i.e., with opposing views and justifications) is considered a given. Other approaches may be possible and further work may generate and compare such competing approaches to electronic petitions.

Background and Problem

Work in argumentation framework focuses on multiple final goals:

finding a set of laws (rules) that are compatible and have support [\cite=Dokow].

finding the strongest chains of arguments [\cite=Amgoud].

aggregating arguments into a summary of arguments [\cite=Pigozzi].

All these efforts refer to the case when a committee must follow some rules (being supervised by a superior authority). This superior authority wants to understand the bases of the decisions and to verify them. They start with a set of values and prove that they can logically justify their decisions based on these values (not being accusable of corruption).

In our case this is not applicable since in our setting (a kind of forum) everybody has a different set of values. Therefore on a free forum the arguments are in general not comparable, and the generation of a unique justification (proving lack of corruption) is not the main issue at this point. As such, here we assume that in petitions, the declared utility (i.e. type of signature) is more important than the logic correctness of arguments. On politically sensitive topics a human frequently uses arguments to justify a sentimentally taken decision (often inherited from her social circle), decision taken prior to the crystallization of her own arguments [\cite=Hibbing13].

For example, if one succeeds to show a person from a different political party that his arguments are false, this commonly does not make the person to change his opinion but rather to search and find new arguments (as can be observed in the US from generations of debating republicans and democrats that do not seem to converge) [\cite=Alford13].

Arguments may help people to understand and tolerate each other (in so much as this understanding removes fear) [\cite=Alford13] [\cite=Hibbing13], but from a democratic perspective, what is important is the declared utility (the taken decision/vote), more than the arguments.

In DirectDemocracyP2P, we have a somewhat different framework (both from the perspective of the environment, and in what is desirable and expected as a result of the study of arguments):

We assume no supreme authority individual, but rather the sole supreme authority is formed by the entire constituency (at least in grassroot organizations), and arguments are presented in natural language. Since the arguments are in natural language we do not expect that they can be robustly parsed and prepared as formal logical statements. Therefore the only thing that we plan to exploit automatically is the association vote-justification and the structure obtained from threading.

Therefore, following (A), the final goal of an argumentation study would be the help given to a constituent in finding the most complete proposed arguments, as revealed by her predecessors' inputs. This is, we should formalize a partial argumentation (under development). A voter (new or ancient) studies current arguments with the purpose of selecting the most complete justification for her vote (justification which can be subjective).

We address two problems: finding candidate justifications, and suggesting components of a new justification.

Problem 1: Find candidate justifications.

If an existing justification subsumes all the arguments that a new voter considers relevant (from this voter's point of view), then the voter will select that particular justification. Therefore we want an algorithm that detects candidates for such a subsuming justification to be used as someone's justification of a binary conclusion (pro or against the petition). The overall system can be seen as a Captcha exploiting social computation to find subsuming justifications to a current pool of arguments (found in a set of justifications).

When no such justifications exists, that according to a new voter subsumes all known arguments from the point of view of the voter, then the voter will create a new justification.

The detection of the subsuming justification will be based on a hierarchy of justifications. We cannot build this hierarchy on the base of the arguments found in the content of the justification, as we agreed to consider this content as being opaque. However we can build it on the basis of some relations between justifications.

We can have two types of (voted) relations between two justifications a and b.

a claimed_subsumes b (read: justification a is claimed to subsume justification b).

a claimed_refutes justification b (where b has an opposite conclusion/vote to a, read: justification a is claimed to refute justification b).

The concepts of claimed_subsumes and claimed_refutes can be defined from the perspective of logic or social and political sciences. Finally the definition to be used is to be left to the users specifying these relations (since the natural language arguments are anyhow opaque to the computational system, which cannot verify and enforce a definition). For generality, for now we treat these relations simply as arcs in a bipartite graph. This bipartite graph can be exploited in ways that fit the expectations of the users.

What we can do, is an algorithm using available inputs to propose the best (i.e., most complete) subsuming candidates for justifications of the two opposing conclusions.

Problem 2: Suggesting components of a new justification.

Another problem that is raised in our framework is: What is the "best" subset that subsumes the arguments of a conclusion/vote (based on the two types of voted relations). This is necessary not only for the voter that wants to propose a new argument, subsuming all the old ones, but also for the undecided voter that wants to study existing arguments in order to construct her opinion.

In order to measure "good" in this problem, as well as in the previous problem, we can propose several metrics:

the most voted

the newest (in time)

the most complete (from the perspective of the existing relations)

Further, metrics can consist of any combinations of these three ones proposed here.

Concepts

Here, after defining the concept of answer, we introduce incrementally three basic frameworks (used by the two algorithms in the subsequent section). Then one can define generalizations and combinations of these frameworks.

A justification is said to answer to a voter if either it is associated with the signature of that voter, or if it was created with a specification that it claimed_refutes the justification selected by that voter.

The Subsuming Justification Problem (SJP) for a given petition M consists of a tuple 〈N,P,V,R,K〉. Here N = {n1,....,nmn} is a set consisting of mn opposing justifications of M, and P = {p1,...,pmp} is a set of mp supporting justifications for M.

Each justification j is associated with a number of vj signatures, as per the set [formula]. The relation [formula] where R|P:P  →  N and R|N:N  →  P, associates each opposing justification ni with at most one supporting justification pni, and each supporting justification pi with at most one opposing justification npi, by the claimed_refutes relation.

[formula]

The SJP problem is to find a set of at most K supporting justifications that answer to a maximum number of signatories (both supporting and opposing M), and a set of at most K opposing justifications that answer to a maximum number of signatories (either supporting and opposing M).

In a further complication it is possible to have each voter specify explicitly the justification that his selected justification claimed_refutes (rather than inheriting the one specified at the creation of his justification). This allows to better adjust the relations from good old justifications to more_recent justifications.

The Weighted Subsuming Justification Problem (WSJP) for a given petition M consists of a tuple 〈N,P,V,R,K〉. Here N = {n1,....,nmn} is a set consisting of mn opposing justifications of M, and P = {p1,...,pmp} is a set of mp supporting justifications for M.

Each justification j is associated with a number of vj signatures, as per the set [formula]. The relation [formula] associates a weight to each pair between an opposing justification ni and supporting justification pj, and to each pair between a supporting justification pi and an opposing justification nj, by the claimed_refutes relation. Each element (i,wi,j,j) of the R relation is weighted with the number wi,j of signatories of the left-hand justification i that have explicitly stated that this justification claimed_refutes the justification j on the right-hand of the relation.

[formula]

The WSJP problem is to find a set of at most K supporting justifications that answer to a maximum number of signatories (both supporting and opposing M), and a set of at most K opposing justifications that answer to a maximum number of signatories (either supporting and opposing M).

To detect a reduced set of justifications that cover existing arguments, to be used in creating a new justification, one has to consider the claimed_subsumes relation.

The Components Subsuming Justification Problem (CSJP) for a given petition M consists of a tuple 〈N,P,V,R,S,K〉. Here N = {n1,....,nmn} is a set consisting of mn opposing justifications of M, and P = {p1,...,pmp} is a set of mp supporting justifications for M.

Each justification j is associated with a number of vj signatures, as per the set [formula]. The function [formula] where R|P:P  →  N and R|N:N  →  P, associates each opposing justification ni with at most one supporting justification pni, and each supporting justification pi with at most one opposing justification npi, by the claimed_refutes relation. The function [formula] where S|P:P  →  P(P) and S|N:N  →  P(N), associates each justification j to a set of justifications of the same type that it claimed_subsumes.

[formula]

The CSJP problem is to find a set of at most K supporting justifications that answer to a maximum number of signatories (both supporting and opposing M), and a set of at most K opposing justifications that answer to a maximum number of signatories (either supporting and opposing M).

Algorithms

Each of these frameworks (as well as their combinations) can be solved approximately via an algorithm similar to mini-max, that traverses the search tree down to a certain depth. More exactly, in the basic case one starts with the given justification and in subsequent steps one can apply a kind of transitivity of the relation claimed_refutes. Under the assumption that each voter selects the most complete justification fitting his vote, this transitivity is of the type:

[formula]

Using this special transitivity one can search for the justifications that (within a limited depth) refute the largest number of justifications of the other type.

The algorithm pseudo-code is shown in Figure [\ref=fig:co]:

One can integrate the votes on justifications (and relations) as weights to arguments (modeling their importance), and they can further be discounted with a factor γ < 1 to consider their depth in the tree:

[formula]

where votes(k) can integrate the number of signatures for all justifications at level k as well as for the claimed_refutes relations in the two directions used for the transitivity: [formula]

This function can be applied to all justifications (for some level), and then one can compute the cardinality of the results to estimate the justifications containing the most arguments.

[formula]

The higher the level, the worse propagate errors from the mentioned assumptions. The lower the level, the less insight is available into the debate. We foresee that the bests levels will be somewhere in the set {2,3,4}. The best parameters will be identified as described later (based on a simulation).

Any algorithm to compute a transitive closure can exploit the claimed_subsumes relations to define a closure (a small set of justifications subsuming most other relevant justifications).

From the perspective of graph theory, the analysis can be done with bipartite graphs (supporting justifications vs. opposing justifications).

Combinations and generalizations can handle the fact that the static relations from framework SJP and CSJP can be voted individually (as at framework WSJP), etc.

The frameworks can further be augmented by association with a timestamp to each argument. Thereby one obtains an additional relation, more_recent, that enables an extension of the concept answers.

Generative models

It is also possible to build a Bayesian network modeling this problem. Let us denote with AM the set of possible arguments for the petition M. Each justification can contain any subset of AM, and ca be modeled either with a discrete or a continuous variable.

In such a network corresponding to a SJP, there are two nodes, Aj and Rj, for each justification j, introduced in the network in the order induced by the more_recent relation. The domain of Aj is the power set of AM, P(AM). The domain of Rj is the set of possible justification (that are less recent than j), and specifies a justification that j claimed_refutes.

The distribution of Aj is uniform over the power set of AM. We could consider that the nodes Aj are independent, while the nodes Rj are dependent on all Ai that correspond to justifications i that are more_recent than j. The distribution of Rj assigns to prior justifications a probability proportional with the number of arguments that they contain. The votes could be distributed proportionally with the number of arguments.

The Aj variables are hidden while the Rj variables are evidence.

The number of values for the variables of such a Bayesian Network is pretty high, therefore more research is needed on how to efficiently exploit it directly for inferring the the justifications where Aj are assigned to the largest subsets of AM.

This network can be used for generating (sampling) test cases, as an artificial "ground truth" (valid in as far as it correctly models the world). Theoretically, Bayesian networks are general enough to model quite complex human behavior. This potential "ground truth" can be used for evaluating the success of the recognition with the previous algorithms (mini-max for justifications).

Deliberation

In the area of argumentation, researchers strive to have computers deliberate on behalf of humans, reasoning with logical arguments. In our case (since each participant has different foundational values, the deliberation is not something automated by artificial intelligence. Rather, the deliberation is made by the people (who reevaluate their fears based on seen arguments), while the artificial intelligence is used to help people find the most relevant arguments.

Conclusion

We propose a logical framework to reason about arguments in debates. It is a type of abstract argumentation framework and can be used to recommend relevant opinions to readers navigating the debate graph.

The framework is particularly relevant for debates where arguments (seen as atomic entities in an attack/support relation) are submitted in a decentralized fashion by a set of involved peers. This framework is designed as a mechanism to provide recommendations in the system.

Acknowledgments

We acknowledge the help of Dr. Ioan Alfred Leia who recommended us the relevant related work in the argumentation area.