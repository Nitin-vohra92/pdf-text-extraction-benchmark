On the Complexity of Learning with Kernels

Yishay Mansour

Ohad Shamir

Introduction

We consider the well-known problem of kernel learning (see, e.g., [\cite=scholkopf2001learning]), where given a training set of labeled examples [formula] from a product domain X  ×  Y, our goal is to find a linear predictor [formula] in a reproducing kernel Hilbert space which minimizes the average loss, possibly with some regularization. Formally, our goal is to solve

[formula]

where W is a convex subset of some reproducing kernel Hilbert space H, ψ:X  ↦  H is a feature mapping to the Hilbert space, [formula] is a loss function convex in its first argument, and λ  ≥  0 is a regularization parameter. For example, in the standard formulation of Support Vector Machines, we take [formula] to be the hinge loss, pick some λ > 0, and let W be the entire Hilbert space. Alternatively, one can also employ hard regularization, e.g., setting λ = 0 and taking [formula].

It is well-known that even if H is high or infinite dimensional, we can solve [\eqref=eq:erm] in polynomial time, provided there is an efficiently computable kernel function k such that [formula]. The key insight is provided by the representer theorem, which implies that an optimum of [\eqref=eq:erm] exists in the span of [formula]. Therefore, instead of optimizing over [formula], we can optimize over a coefficient vector [formula], which implicitly specifies a predictor via [formula]. In this case, [\eqref=eq:erm] reduces to

[formula]

Defining the m  ×  m kernel matrix [formula], we can re-write the above as

[formula]

This is a convex problem, which can generally be solved in polynomial time. The resulting [formula] implicitly defines the linear predictor [formula] in the Hilbert space: Given a new point [formula] to predict on, this can be efficiently done according to

[formula]

Unfortunately, a major handicap of kernel learning is that it requires computing and handling an m  ×  m matrix, where m is the size of the training data, and this can be prohibitive in large-data applications. This has led to a large literature on efficient kernel learning, which attempts to reduce its computational complexity. As far as we know, the algorithms proposed so far fall into one or more of the following categories (see below for specific references):

Limiting the number of kernel evaluations: A dominant computational bottleneck in kernel learning is computing all entries of the kernel matrix. Thus, several algorithms attempt to learn using a much smaller number of kernel evaluations - either by sampling them or using other schemes which require "reading" only a small part of the kernel matrix.

Low-Rank Kernel Approximation: Instead of using the full m  ×  m kernel matrix, one can use instead a low-rank approximation of it. Learning with a low-rank matrix can be done in a computationally much more efficient manner than with a general kernel matrix (e.g., [\cite=scholkopf2001learning] [\cite=Bach13]).

Projection to a low-dimensional space: Each instance [formula] is mapped to a finite-dimensional vector [formula] where d  ≪  m, so that [formula]. Note that this is equivalent to a kernel problem where the rank of the kernel matrix is d, so it can be seen as a different kind of low-rank kernel approximation technique.

Existing theoretical results focus on performance guarantees for various algorithms. In this work, we consider a complementary question, which surprisingly has not been thoroughly explored (to the best of our knowledge): What are the inherent obstacles to efficient kernel learning? For example, is it possible to reduce the number of kernel evaluations while maintaining the same learning performance? Is there always a price to pay for low-rank matrix approximation? Can finite-dimensional projection methods match the performance of algorithms working on the original kernel matrix?

Specifically, we study information-theoretic lower bounds on the attainable performance, measured in terms of optimization error on a given training set. We consider two distinct types of constraints:

The number of kernel evaluations (or equivalently, the number of entries of the kernel matrix observed) is bounded by B, where B is generally assumed to be much smaller than m2 (the number of entries in the kernel matrix).

The algorithm solves [\eqref=eq:kernelerm], but using some low-rank matrix [formula] instead of K. This can be seen as using a low-rank kernel matrix approximation.

We make no assumptions whatsoever on which kernel evaluations are used, or the type of low-rank approximation, so our results apply to all the methods mentioned previously, and any future potential method which uses these types of approaches. We note that although we focus on optimization error on a given training set, our lower bounds can also be potentially extended to generalization error, where the data is assumed to be sampled i.i.d. from an underlying distribution. We discuss this point further in Section [\ref=sec:discussion].

Our first conclusion, informally stated, is that it is generally impossible to make kernel learning more efficient in a non-trivial manner. For example, suppose we have a budget B on the number of kernel evaluations, where B  ≪  m2. Then the following "trivial" sub-sampling method turns out to be optimal in general: Sub-sample [formula] examples from the training data uniformly at random (throwing away all other examples), compute the full [formula] kernel matrix based on the sub-sample, and train a predictor using this matrix. This is an extremely näive algorithm, throwing away almost all of the data, yet we show that there are cases where no algorithm can be substantially better. Another pessimistic result can be shown for the low-rank matrix approximation approach: There are cases where any low-rank approximation will impact the attainable performance.

Our formal results go beyond these observations, and quantify the attainable performance as a function of several important problem parameters, such as the kernel matrix rank, regularization parameter, norm of the desired predictor, and the nature of the loss function. In particular:

Given a kernel evaluation budget constraint B:

For the absolute loss, no regularization (λ = 0), and a constant norm constraint on the domain, we have an error lower bound of Ω(B- 1 / 4). A matching upper bound is obtained by the sub-sampling algorithm discussed earlier.

For soft regularization (with regularization parameter λ  >  0 and no norm constraint), we attain error lower bounds which depend on the structure of the loss function. Some particular corollaries include:

For the absolute loss, [formula]. Again, a matching upper bound is attained by a sub-sampling algorithm.

For the hinge loss, Ω(1) as long as B < 1 / λ2. Although it only applies in a certain budget regime, it is tight in terms of identifying the kernel evaluation budget required to make the error sub-constant. Moreover, it sheds some light on previous work (e.g., [\cite=CoShSr12]) which considered efficient kernel learning methods for the hinge loss.

For the squared loss, [formula], as long as B  ≪  m2. Like the result for the other losses, it implies that no sub-constant error is possible unless B  ≥  1 / λ2.

For learning with low-rank approximation, with rank parameter d, in the case of Ridge Regression (squared loss and soft regularization), we attain an error lower bound of Ω((λd)- 3). Thus, to get sub-constant error, we need the rank to scale at least like 1 / λ.

The role of the loss function is particularly interesting, since it has not been well-recognized in previous literature, yet our results indicate that it may play a key role in the complexity of kernel learning. For example, as we discuss in Section [\ref=sec:budget], efficient kernel learning is trivial with the linear loss, harder for smooth and non-linear losses, and appears to be especially hard for non-smooth losses. Our results also highlight the importance of the kernel matrix rank in determining the difficulty of kernel learning. While it has been recognized that low rank can make kernel learning easy (see references below), our results formally establish the reverse direction, namely that (some) high-rank matrices are indeed hard to learn with any algorithm.

Related Work

The literature on efficient kernel methods is vast and we cannot do it full justice. A few representative examples include sparse greedy kernel approximations [\cite=scholkopf2001learning], Nyström-based methods, which sample a few rows and columns and use it to construct a low-rank approximation [\cite=DrMa05] [\cite=kumar2009sampling], random finite-dimensional kernel approximations such as random kitchen sinks [\cite=RaRe07] [\cite=RaRe08] [\cite=dai2014scalable], the kernelized stochastic batch Perceptron for learning with few kernel evaluations [\cite=CoShSr12], the random budget Perceptron and the Forgetron [\cite=cavallanti2007tracking] [\cite=dekel2008forgetron], divide-and-conquer approaches [\cite=ZDW13] [\cite=hsieh2014divide], sequential algorithms with early stopping [\cite=yao2007early] [\cite=RaWaYu14], other numerical-algebraic methods for low-rank approximation, e.g., [\cite=fine2002efficient] [\cite=shawe2004kernel] [\cite=BaJo05] [\cite=mahoney2009cur] [\cite=kumar2009sampling], combinations of the above [\cite=dai2014scalable], and more. Several works provide a theoretical analysis on the performance of such methods, as a function of the rank, number of kernel evaluations, dimensionality of the finite-dimensional space, and so on. Beyond the works mentioned above, a few other examples include [\cite=cortes2010impact] [\cite=yang2012nystrom] [\cite=Bach13] [\cite=lin2014sample].

In terms of lower bounds, we note that there are existing results on the error of matrix approximation, based on partial access to the matrix (see [\cite=bar2003sampling] [\cite=frieze2004fast]). However, the way the error is measured is not suitable to our setting, since they focus on the Frobenius norm of K - , where K is the original matrix and [formula] is the approximation. In contrast, in our setting, we are interested in the error of a resulting predictor rather than the quality of matrix approximation. Therefore, even if [formula] is large, it could be that [formula] can still be used to learn an excellent predictor. Another distinct line of work studies how to reduce the complexity of a kernel predictor at test time, e.g., by making it supported on a few support vectors (see for instance [\cite=cotter2013learning] and references therein). This differs from our work, which focuses on efficiency at training time.

Paper Organization

Our paper is organized as follows. In Section [\ref=sec:hard], we introduce the class of kernel matrices which shall be used to prove our results, and discuss how they can be generated by standard kernels. In Section [\ref=sec:budget], we provide lower bounds in a model where the algorithm is constrained in terms of the number of kernel evaluations used. We consider this model in two flavors, one where there is a norm constraint and no regularization (Subsection [\ref=subsec:norm]), and one where there is regularization without norm constraint (Subsection [\ref=subsec:reg]). In the former case, we focus on a particular loss, while in the latter case, we provide a more general result and discuss how different types of losses lead to different types of lower bounds. In Section [\ref=sec:lowrank], we consider the model where the algorithm is constrained to use a low-rank kernel matrix approximation. We conclude and discuss open questions in Section [\ref=sec:discussion]. Proofs appear in Appendix [\ref=sec:proofs].

Hard Kernel Matrices

For our results, we utilize a set Kd,m of "hard" kernel matrices, which are essentially permutations of block-diagonal m  ×  m matrices with at most d blocks. More formally:

Let K'd,m be the class of all block-diagonal m  ×  m matrices, composed of at most d blocks, with entry values of 1 within each block. We define Kd,m to be all matrices which belong to K'd,m under some permutation [formula] of their rows and columns:

[formula]

From the definition, it is immediate that any K∈Kd,m is positive semidefinite (and hence is a valid kernel matrix), with rank at most d. Moreover, the magnitude of the diagonal elements is at most 1, which means that our data lies in the unit ball in the Hilbert space.

Since our focus is on generic kernel learning, it is sufficient to consider this class in order to establish hardness results. However, it is still worthwhile to consider what kernels can induce this class of kernel matrices. A sufficient condition can be quantified via the following lemma.

Suppose there exist [formula] such that [formula]. Then any K∈Kd,m is induced by some m instances [formula].

The proof is immediate: Given any K, for any block i of size ni, create ni copies of [formula], and order the instances according to the relevant permutation.

It is straightforward to see that Lemma [\ref=lem:suffkern] holds for linear kernels [formula] and for homogeneous polynomial kernels [formula]. It also holds (approximately) for Gaussian kernels [formula] if there exist d equi-distant points in X, where the squared distance is much larger than γ. In that case, instead of 0 outside the blocks, we will have ε where ε is exponentially small, and can be shown to be negligible for our purposes.

However, a close inspection of our results reveals that they are in fact applicable to a much larger class of matrices: All we truly require is to have [formula] such that [formula] and [formula] for some distinct constants a,c for all i  ≠  j. This condition holds for most kernels we are aware of. For example, if there are d equi-distant points [formula], then this condition is fulfilled for any shift-invariant kernel (where [formula] is some function of [formula]). Similarly, if there are d points [formula] which have the same inner product, then the condition is fulfilled for any inner product kernel (where [formula] is some function of [formula]). In order to keep a more coherent presentation we will concentrate here on the Boolean case defined previously, where a = 1 and c = 0.

Although our formal results and proofs contain many technical details, their basic intuition is quite simple: When d is sufficiently large, any matrix in Kd,m is of high rank, and cannot be approximated well by any low-rank matrix. Therefore, under suitable conditions, no low-rank matrix approximation approach can work well. Moreover, when d is large, then the kernel matrix is quite sparse, and contains a large number of relatively small blocks. Thus, for an appropriate randomized choice of a matrix in Kd,m, any algorithm with a limited budget of kernel evaluations will find it difficult to detect these blocks. With a suitable construction, we can reduce the kernel optimization problem to that of detecting these blocks, from which our results follow.

Budget Constraints

We now turn to present our results for the case of budget constraints. In this setting, the learning algorithm is given the target values [formula], but not the kernel matrix K. Instead, the algorithm may query at most B entries in the kernel matrix (where B is a user-defined positive integer), and then return a coefficient vector based on this information. This model represents approaches which attempt to reduce the computational complexity of kernel learning by reducing the number of kernel evaluations needed. Standard learning algorithms essentially require B = Ω(m2), and the goal is to learn to similar accuracy with a budget B  ≪  m2. In this section, we discuss the inherent limitations of this approach.

Norm Constraint, Absolute Loss

We begin by demonstrating a lower bound using the absolute loss [formula] on the domain [formula] (or equivalently, coefficient vectors [formula] satisfying [formula]), and our goal is to minimize the average loss, which equals

[formula]

For any rank parameter d, any sample size m  ≥  27d, any budget size [formula], and for any budgeted algorithm, there exists a kernel matrix K∈K2d,m and target values [formula], such that the returned coefficient vector [formula] satisfies

[formula]

The proof and the required construction appears in Subsection [\ref=subsec:budget]. Note that the algorithm is allowed to return any coefficient vector (not necessarily one satisfying the domain constraint [formula]).

The theorem provides a lower bound on the attainable error, for any rank parameter d and assuming the sample size m and budget B are in an appropriate regime. A different way to phrase this is that if B is sufficiently smaller than m2, then we can find some d on the order of [formula], such that Theorem [\ref=thm:absmain] holds. More formally:

There exist universal constants c,c' > 0 such that if B  ≤  cm2, there is an m  ×  m kernel matrix K (belonging to K2d,m for some appropriate d) and target values in

[formula]

In words, the attainable error given a budget of B cannot go down faster than [formula]. Next, we show that this is in fact the optimal rate, and is achieved by the following simple strategy:

Given a training set [formula] of size m, sample [formula] training examples uniformly at random (with replacement), getting [formula].

Compute the kernel matrix [formula] defined as [formula], using at most B queries.

Solve the kernel learning problem on the sampled set, getting a coefficient vector [formula]:

[formula]

Return the coefficient vector [formula] such that αtj  =  j for [formula], and αt = 0 otherwise.

Essentially, this strategy approximately solves the original problem by drawing a subset of the training data --small enough so that we can compute its kernel matrix in full-- and solving the learning problem on that data. Since we use a sample of size [formula], then by standard generalization guarantees for learning bounded-norm predictors using Lipschitz loss functions (e.g., [\cite=kakade2009complexity]), we get a generalization error upper bound of

[formula]

which matches the lower bound in Corollary [\ref=cor:sqrt4B] up to constants.

To summarize, we see that with the absolute loss, given a constraint on the number of kernel evaluations, there exist no better method than throwing away most of the data, and learning on a sufficiently small subset. Moreover, any method using a non-trivial budget (significantly smaller than m2) must suffer a performance degradation.

Soft Regularization, General Losses

Having obtained an essentially tight result for the absolute loss, it is natural to ask what can be obtained for more generic losses. To study this question, it will be convenient to shift to the setting where the domain W is the entire Hilbert space, and we use a regularization term. Following [\eqref=eq:kernelerm], this reduces to solving

[formula]

We start by defining the main quantity we are interested in,

[formula]

where [formula] is a loss function.

First, we provide a general result, which applies to any non-negative loss function, and then draw from it corollaries for specific losses:

Suppose the loss function [formula] is non-negative. For any rank parameter d, any sample size m  ≥  27d, any budget [formula], and for any budgeted algorithm, there exists a kernel matrix K∈K2d,m and target values [formula] in Y, such that the returned coefficient vector [formula] satisfies

[formula]

where

[formula]

The proof and the required construction appears in Subsection [\ref=subsec:general].

Roughly speaking, to get a non-trivial bound, we need the loss to be such that when the regularization parameter is order of λd, then scaling it by a factor of 2 changes the location of the optimum u* by a factor different than 2. For instance, this rules out linear losses of the form [formula]. For such a loss, we have

[formula]

Thus we get that (2u*1 - u*2)2 = 0 and the lower bound is trivially 0. While this may seem at first like an unsatisfactory bound, in fact this should be expected: For linear loss and no domain constraints, we don't need to observe the kernel matrix K at all in order to find the optimal solution! To see this, note that the optimization problem in [\eqref=eq:kernelerm] reduces to

[formula]

or, equivalently,

[formula]

where [formula] is a known vector and K is the partially-unknown kernel matrix. Differentiating the expression by [formula] and equating to [formula], getting

[formula]

Thus, an optimum of this problem is simply [formula], regardless of what is K. This shows that for linear losses, we can find the optimal predictor with zero queries of the kernel matrix.

Thus, the kernel learning problem is non-trivial only for non-linear losses, which we now turn to examine in more detail.

Absolute Loss

First, let us consider again the absolute loss in this setting. We easily get the following corollary of Theorem [\ref=thm:lossmain]:

Let [formula] be the absolute loss. There exist universal constants c,c' > 0, such that if B  ≤  cm2, then for any budgeted algorithm there exists an m  ×  m kernel matrix K and target values y such that [formula] is lower bounded by [formula].

To apply Theorem [\ref=thm:lossmain], let us compute (2u*1 - u*2)2, where we use the particular choice [formula]. It is readily verified that [formula], leading to the lower bound

[formula]

In particular, suppose we choose [formula]. Then we get a lower bound of [formula] for c' = 2- 13. The conditions of Theorem [\ref=thm:lossmain] are satisfied if [formula] and [formula]. The latter always holds, whereas the former is indeed true if B is smaller than cm2 for c = 2- 20.

As in the setting of Theorem [\ref=thm:absmain], this lower bound is tight, and we can get a matching [formula] upper bound by learning with a random sub-sample of [formula] training examples, using generalization bounds for minimizers of strongly-convex and Lipschitz stochastic optimization problems [\cite=sridharan2009fast].

Note that, unlike our other lower bounds, Corollary [\ref=cor:abs] is proven using a different choice of y for each λ. It is not clear whether this requirement is real, or is simply an artifact of our proof technique.

Hinge Loss

Intuitively, the proof of Corollary [\ref=cor:abs] relied on the absolute loss having a non-smooth "kink" at [formula], which prevented the optimal u*1,u*2 from moving as a result of the changed regularization parameter. Results of similar flavor can be obtained with any other loss which has an optimum at a non-smooth point. However, when we do not control the location of the "kink" the results may be weaker. A good example is the hinge loss, [formula], which is non-differentiable at the fixed location p = 1:

Let [formula] be the hinge loss. There exist universal constants c,c',c'' > 0, such that if [formula] and [formula], then for any budgeted algorithm, there exist an m  ×  m kernel matrix K and target values y in { - 1, + 1} such that [formula] is lower bounded by c''.

To apply Theorem [\ref=thm:lossmain], let us compute (2u*1 - u*2)2, where we use the particular choice y = 1. It is readily verified that u*1 = u*2 = 1, as long as pλd  ≤  1, and is certainly satisfied for any [formula] by assuming [formula]. Therefore, if [formula], then in Theorem [\ref=thm:lossmain], we get u*1 = u*2 = 1, and thus a lower bound of [formula].

In particular, suppose we pick [formula]. Since we assume [formula], this means that the lower bound above is [formula]. The conditions of Theorem [\ref=thm:lossmain] are satisfied if [formula] and [formula], which are indeed implied by the corollary's conditions.

Unlike the bound for the absolute loss, here the result is weaker, and only quantifies a regime under which sub-constant error is impossible. In particular, the condition [formula] is not interesting for constant λ. However, in learning problems λ usually scales down as m- q where q  ≥  1 / 2 and often q = 1. In that case, we get constant error as long as B  ≪  m2q, which establishes that learning is impossible for a budget smaller than a quantity in the range from Ω(m) to Ω(m2), depending on the value of q. For q = 1, that is λ  =  Θ(1 / m), learning is impossible without querying a constant fraction of the kernel matrix.

Moreover, it is possible to show that our lower bound is tight, in terms of identifying the threshold for making the error sub-constant. As before, we consider the strategy of sub-sampling [formula] training examples and learning with respect to the induced kernel matrix. Since we use [formula] examples and λ-strongly convex regularization, the expected error scales as [formula] [\cite=sridharan2009fast]. This is sub-constant in the regime B = ω(1 / λ2), and matches our lower bound. We emphasize that when B is ω(1 / λ2), we do not have a non-trivial lower bound, and it remains an open problem to understand what can be attained for the hinge loss in this regime.

Another interesting consequence of the corollary is the required budget as a function of the norm of a "good predictor" we want to compete with. In [\cite=CoShSr12], several algorithmic approaches have been studied, which were all shown to require [formula] kernel evaluations to be competitive with a given predictor [formula], even in the "realizable" case where the predictor attains zero average hinge loss. An examination of the proof of theorem 2 reveals that the construction is such that there exists a predictor [formula] which attains zero hinge loss on all the examples, and whose norm is [formula]. Corollary [\ref=cor:hinge] shows that the budget must be at least [formula] to get sub-constant error in the worst case. Although our setting is slightly different than [\cite=CoShSr12], this provides evidence that the [formula] bounds in [\cite=CoShSr12] are tight in terms of the norm dependence.

Squared Loss

In the case of absolute loss and hinge loss, the results depend on a non-differentiable point in the loss function. It is thus natural to conclude by considering a smooth differentiable loss, such as the squared loss:

Let [formula] be the squared loss. There exist universal constants c,c' > 0, such that

If [formula], then for any budgeted algorithm there exists an m  ×  m kernel matrix and target values in

[formula]

such that [formula] is lower bounded by [formula].

This lower bound is weaker than the [formula] lower bound attained for the absolute loss. This is essentially due to the smoothness of the squared loss, and we do not know if it is tight. In any case, it proves that even for the squared loss, at least 1 / λ2 kernel evaluations are required to get sub-constant error. In learning problems, where λ often scales down as m- q (where q  ≥  1 / 2 and often q = 1), we get a required budget size of m2q. This is super-linear when p > 1 / 2, and becomes m2 when q = 1 - in other words, we need to compute a constant portion of the entire m  ×  m kernel matrix.

To apply Theorem [\ref=thm:lossmain], let us compute (2u*1 - u*2)2. It is readily verified that [formula] and [formula], leading to the lower bound

[formula]

Taking in particular y = 1, we get

[formula]

We now consider two ways to pick d, corresponding to the two cases considered in the corollary:

If [formula], we pick [formula]. Since λ  ≤  1, we have dλ < 7, and this means that [\eqref=eq:sqlowbound] is bounded below by c' = 2- 18. The conditions of Theorem [\ref=thm:lossmain] are satisfied if [formula] and [formula]. These are satisfied by assuming [formula] for c = 2- 20.

If [formula], we pick [formula]. Plugging this into [\eqref=eq:sqlowbound] and using the assumption [formula] (or equivalently, [formula]), we get a lower bound of [formula] for an appropriate constant c' = 2- 18 < 1 / 960. Moreover, the conditions of Theorem [\ref=thm:lossmain] are satisfied if [formula] and [formula]. The latter always holds, whereas the former indeed holds if B is less than cm2 for c = 2- 20.

This completes the proof.

Low-Rank Constraints

In this section, we turn to discuss the second broad class of approaches, which replace the original kernel matrix K by a low-rank approximation K'. As explained earlier, many rank-reduction approaches - including Nyström method and random features - use a low-rank approximation K' with entries defined by [formula], where [formula] is the training set and [formula] is a given feature mapping, typically depending on the data.

The next result shows a lower bound on the error for any such low-rank approximation method when the algorithm used for learning is kernel Ridge Regression (i.e., when we use the squared loss and employ soft regularization).

Suppose there exist a kernel function k on X and 2d points [formula] such that [formula]. Then there exists a training set [formula], with corresponding kernel matrix K, such that for any feature mapping [formula] (possibly depending on the training set), the coefficient vector [formula] returned by the Ridge Regression algorithm operating on the matrix K' with entries [formula] satisfies

[formula]

where d is any upper bound on the rank of K' such that 2d divides m. Given a training set [formula] with corresponding kernel matrix K, suppose the learning algorithm returns

[formula]

where K' is any matrix of rank at most d (where 2d divides m), and [formula] for some mapping [formula] (possibly depending on the training set). Furthermore, suppose there exist [formula] such that [formula]. Then there exists a training set such that

The induced kernel matrix K is in K2d,m

[formula]

The coefficient vector [formula] returned by the algorithm satisfies

[formula]

When λd  ≥  1, we get a [formula] bound. This bears similarities to the bound in Corollary [\ref=cor:squared], which considered the squared loss in the budgeted setting, where d is replaced by [formula] (i.e., [formula] when [formula]). The bound implies that to get sub-constant error, the rank required must be larger than 1 / λ. When λ itself scales down with the sample size m, we get that the required rank grows with the sample size. When λ = 1 / m, the required rank is Ω(m), which means that any low-rank approximation scheme (where d  ≪  m) will lead to constant error. As in the case of Corollary [\ref=cor:squared], we do not know whether our lower bound is tight.

Discussion and Open Questions

In this paper, we studied fundamental information-theoretic barriers to efficient kernel learning, focusing on algorithms which either limit the number of kernel evaluations, or use a low-rank kernel matrix approximation. We provided several results under various settings, highlighting the influence of the kernel matrix rank, regularization parameter, norm constraint and nature of the loss function on the attainable performance.

For general losses and kernel matrices, our conclusion is generally pessimistic. In particular, when the number of kernel evaluations is bounded, there are cases where no algorithm attains performance better than a trivial sub-sampling strategy, where most of the data is thrown away. Also, no algorithm can work well when the regularization parameter is sufficiently small or the norm constraint is sufficiently large. On a more optimistic note, our lower bounds are substantially weaker when dealing with smooth losses. Although we do not know if these weaker lower bounds are tight, they may indicate that better kernel learning algorithms are possible by exploiting smoothness of the loss. Smoothness of the squared loss has been used in [\cite=ZDW13], but perhaps this property can be utilized more generally.

In our results, we focused on the problem of minimizing regularized training error on a given training set. This is a different goal than minimizing generalization error in a stochastic setting, where the data is assumed to be drawn i.i.d. from some underlying distribution. However, we believe that our lower bounds should also be applicable in terms of optimizing the risk (or expected error with respect to the underlying distribution). The main obstacle is that our lower bounds are proven for a given class of kernel matrices, which are not induced by an explicit i.i.d. sampling process of training instances. However, inspecting our basic construction in Subsection [\ref=subsec:budget], it can be seen that it is very close to such a process: The kernel is constructed by pairs of instances sampled i.i.d. from a finite set [formula]. We believe that all our results would hold if the instances were to be sampled i.i.d. from [formula]. The reason that we sample pairs is purely technical, since it ensures that for every i, there is an equal number of [formula] and [formula] in the training set, making the calculations more tractable. Morally, the same techniques should work with i.i.d. sampling, as long as the probability of sampling [formula] and [formula] are the same for all i.

Our work leaves several questions open. First, while the results for the absolute loss are tight, we do not know if this is the case for our other results. Second, the low-rank result in Section [\ref=sec:lowrank] applies only to squared loss (Ridge Regression), and it would be interesting to extend it to other losses. Third, it should be possible to extend our results also to randomized algorithms that query the kernel matrix a number of times bounded by B only in expectation (with respect to the algorithm's internal randomization), rather than deterministically. Finally, our results may indicate that at least for smooth losses, better kernel learning algorithms are possible, and remain to be discovered.

Acknowledgements

This research was carried out in part while the authors were attending the research program on the Mathematics of Machine Learning, at the Centre de Recerca Matemàtica of the Universitat Autònoma de Barcelona (Spain). Partial support is gratefully acknowledged.

Proofs

Construction properties from Section [\ref=sec:budget]

We consider a randomized strategy, where the kernel matrix is sampled randomly from K2d,m (according to a distribution D to be defined shortly), and [formula] are fixed deterministically in a certain way. We will analyze what is the best possible performance using any budgeted algorithm, in expectation over this strategy.

To define the distribution D, we let [formula] be the standard basis vectors in [formula], and sample a kernel matrix from D as follows:

Pick [formula] uniformly at random.

For all [formula], define [formula] as

[formula] if σi = 1,

[formula] and [formula] if σi = 0.

For [formula], choose [formula] uniformly at random from [formula].

Choose a permutation [formula] uniformly at random.

Return the kernel matrix K defined as [formula] for all [formula].

To understand the construction, we begin by noting that K represents the inner product of a set of vectors, and hence is always positive semidefinite and a valid kernel matrix. Moreover, [formula] are all in the set [formula], and therefore the resulting kernel matrix equals (up to permutation of rows and columns) a block-diagonal matrix of the following form:

Here, Si is an all-zero block if σi = 0, and an all-ones block if σi = 1. In other words, the matrix is composed of d blocks, one for each value of [formula]. If σi = 1, then block i is a monolithic all-ones block (corresponding to [formula]), and if σi = 0, then block i is composed of two equal-sized sub-blocks (corresponding to [formula] and to [formula]). This implies that the kernel matrix is indeed in K2d,m.

Our proofs rely on the following intuition: To achieve small error, the learning algorithm must know the values of the entries in [formula] (i.e., the values of [formula]). However, when d is large, these blocks are rather small, and their entries are randomly permuted in the matrix. Thus, any algorithm with a constrained query budget is likely to "miss" many of these blocks.

To simplify the presentation, we will require a few auxiliary definitions. First, given a kernel matrix K∈K2d,m constructed as above, let

[formula]

denote the set of row/column indices in the kernel matrix, corresponding to instances which were chosen to be [formula] (respectively [formula]). Note that {Ti,1,Ti,2}di = 1 is a disjoint partition of all indices [formula], and |Ti,1| = |Ti,2|. We then define,

[formula]

and also define,

[formula]

to be the sum of the corresponding coefficients in the solution [formula] returned by the algorithm. With these definitions, we can re-write the average loss and the regularization term as follows.

For any coefficient vector [formula],

[formula]

where βi,1,βi,2 are defined in [\eqref=eq:betadef].

The proof is a straightforward exercise based on the definition of K. Finally, we define Ei to be the event that the algorithm never queries a pair of inputs in Ti, i.e., the algorithm's queries [formula] on the kernel matrix satisfy

[formula]

To prove our results, we will require two key lemmas, presented below, which quantify how any budgeted algorithm is likely to "miss" many blocks, and hence have its output relatively insensitive to [formula].

Suppose m  ≥  2d and [formula]. Then for any deterministic learning algorithm,

[formula]

The formal proof is provided below. Although it is quite technical, the lemma's intuition is very simple: Recall that the kernel matrix is composed of d blocks, each of size [formula] in expectation. Thus, if we choose an entry uniformly at random, the chance of "hitting" some block is approximately [formula]. Thus, if we sample B points uniformly at random, where B  ≪  d2, then the number of "missed" blocks [formula] is likely to be Ω(d). The lemma above simply quantifies this, and shows that this holds not just for uniform sampling, but for any algorithm with a budgeted number of queries.

Recall that each Ti corresponds to one of d blocks in the kernel matrix (possibly composed of two sub-blocks). The algorithm queries [formula]. For each possible query at time t we define the set Qs,t of blocks such that s was queried with a member of that block and we obtained a value zero in the kernel matrix. Namely,

[formula]

Given the query (st,rt) we define Lt = Qst,t to be the blocks in which some member was queried with st, and Rt = Qrt,t the blocks in which some member was queried with rt.

We introduce a quantity Pt defined as follows: Pt  =  d + 1 if there is a query t'  <  t such that Kst',rt'  =  1 and, moreover, st  =  st' or rt  =  rt' (that is, the block of st or the block of rt was already discovered). Otherwise, let [formula].

Let Dt be the event that the t-th query discovers a new block. That is, Dt is true if and only if Kst,rt  =  1 and Pt  <  d + 1. Using this notation,

[formula]

We will now show that unless [formula], we can upper bound N deterministically by [formula]. We do this by considering separately the case [formula] and the case [formula]:

Assume first [formula], and let [formula] be the times tk such that [formula]. Now fix some k and note that, because the common block to which stk and rtk both belong is discovered, neither stk nor rtk can occur in a future query (st,rt) that discovers a new block. Therefore, in order to have [formula] for [formula] times, at least

[formula]

queries must be made, where each term [formula] accounts for the fact that each one of the previous k - 1 discovered blocks might contribute with at most a query to making [formula]. So, it must be

[formula]

queries to discover the first [formula] blocks, which contradicts the lemma's assumption that [formula]. Therefore, [formula].

Assume that [formula]. Using the same logic as before, in order to have [formula] for [formula] times, at least

[formula]

queries must be made. So, it must be

[formula]

or, equivalently, N2 - (d + 1)N  +  2B  ≥  0. Solving this quadratic inequality for N, and using the lemma's assumption that [formula], we have that [formula]. Using the lemma's assumption that [formula] we get that [formula].

We now bound the first term of ([\ref=eq:clubound]) in expectation. For any time t and query (st,rt), we say that st is paired with rt if [formula] for some [formula], where [formula]. Clearly, [formula], where the probability is over the random draw of the permutation π. Hence,

[formula]

Let [formula]. Note that the two points st and rt have independent block assignments when conditioned on st not paired with rt. Moreover, conditioned on Pt  <  d / 2, the event Dt implies st,rt∈Ti for some [formula], where [formula] and for any [formula] we use [formula] to denote [formula].

Since, by definition of Lt, the block of st is not in Lt, and there were no previous queries involving st and a point belonging to a block in [formula], we have that

[formula]

Likewise,

[formula]

Hence, for L',R' ranging over all subsets of [formula] of size strictly less than [formula],

[formula]

because [formula], [formula] and [formula]. Therefore, using m  ≥  2d we can write

[formula]

where we used the lemma's assumption that m  ≥  2d. Putting everything together, we get the following upper bound on the expectation of [\eqref=eq:clubound]:

[formula]

On the other hand, we have

[formula]

Combining [\eqref=eq:clubound1] and [\eqref=eq:clubound2], we get that

[formula]

To finish the lemma's proof, suppose on the contrary that [formula]. Then from the equation above, we would get that

[formula]

which implies [formula], contradicting the lemma's assumptions. Therefore, we must have [formula] as required.

Suppose the kernel matrix K is sampled according to the distribution D as defined earlier (using a parameter [formula]). Let Ai be any event that, conditioned on Ni, depends only on βi,1 and βi,2, (as returned by a deterministic algorithm based on access to the kernel matrix), and let g(Ni) be some non-negative function of Ni. Then

[formula]

We begin by noting that

[formula]

We now continue by analyzing the probabilities in the expression:

[formula]

We will need two auxiliary results. First, we argue that for all i,

[formula]

To prove this, we note that since the algorithm is deterministic, the occurrence of the event Ei is determined by the kernel matrix, and more specifically the entries of the kernel matrix observed by the algorithm. Therefore, if the kernel matrix is such that Ei occurs, then the algorithm's output would not change if we flip the value of σi as it only affects entries which were not touched by the algorithm. Therefore, [formula]. Since σi is either 0 or 1, this means that these probabilities also equal [formula].

Second, we argue that

[formula]

This holds because if Ei occurs, then βi,1,βi,2 depend only on entries which are independent of σi. Moreover, Ni is also independent of σi. Therefore Ai, which is assumed to depend only on βi,1,βi,2 when conditioned on Ni, is also independent of σi when conditioned on Ei and Ni, from which [\eqref=eq:preq2] follows.

Using [\eqref=eq:preq1], [\eqref=eq:preq2], and the fact that σi is uniformly drawn from {0,1} and independent of Ni, we have that [\eqref=eq:preq0] equals

[formula]

Plugging this lower bound on [\eqref=eq:preq0] back into [\eqref=eq:bgnot], the result follows.

Finally, we will also require the following auxiliary result:

Let [formula] where [formula] are i.i.d. Bernoulli random variables with parameter 1 / d. Also, let g(N) be a non-negative function of N. Then for any event Z,

[formula]

Let [formula]. We can lower bound the expectation by

[formula]

Since N is distributed as twice the sum of m / 2 i.i.d. Bernoulli random variables with parameter 1 / d, so its expectation is m / d, and by multiplicative Chernoff bounds and union bounds,

[formula]

Substituting this back into [\eqref=eq:asdf], the result follows.

Proof of Theorem [\ref=thm:absmain]

Suppose we pick [formula] for all t. Using Yao's minimax principle, it is sufficient to prove a lower bound for

[formula]

where the expectation is with respect to the kernel matrix K drawn according to the distribution D specified earlier, and [formula] is any deterministic function of K encoding the learning algorithm. This ensures that for any (possibly randomized) algorithm, there exists some K which satisfies the theorem statement.

First, we will show that for any K∈K2d,m, there exists some [formula] such that

[formula]

This implies that [\eqref=eq:expabs] can be re-written as

[formula]

To see this, we utilize Lemma [\ref=lem:beta] to rewrite [\eqref=eq:toshow] as

[formula]

where {βi,1,βi,2} are the appropriate functions of [formula]. Note that these constraints are indeed satisfied for any [formula] for which [formula] if σi = 0, and [formula] if σi = 1. Again using Lemma [\ref=lem:beta], we can rewrite [\eqref=eq:expabs2] as

[formula]

Let us consider the expression [formula] for some fixed choice of the kernel matrix K. In particular:

If σi = 1 and [formula], then

[formula]

If σi = 0 and [formula], then either βi,1 or βi,2 must be less than [formula], and therefore

[formula]

Let Ai be the event that [formula]. Since the algorithm is deterministic, {βi,1,βi,2} and hence Ai is determined by the kernel matrix K. By the analysis above, we can lower bound [\eqref=eq:expabs3] by

[formula]

By Lemma [\ref=lem:indep] and Lemma [\ref=lem:getrid] this is lower bounded by

[formula]

Since we assumed that [formula] and m  ≥  27d, we can apply Lemma [\ref=lem:block], which lower bounded this by

[formula]

where we used again the assumption that m  ≥  27d. [formula]

Proof of Theorem [\ref=thm:lossmain]

The proof is broadly similar to the one of Theorem [\ref=thm:absmain], but using a generic loss rather than the absolute loss.

Suppose we pick yt = y∈Y for all t, where y∈Y will be determined later. Using Yao's minimax principle, it is sufficient to prove a lower bound for

[formula]

where --as in the proof of Theorem [\ref=thm:absmain]-- the expectation is with respect to the kernel matrix K drawn according to the distribution D, and [formula] is any deterministic function of K encoding the learning algorithm. This ensures that for any (possibly randomized) algorithm, there exists some K which satisfies the theorem statement.

Utilizing Lemma [\ref=lem:beta], we can rewrite ([\ref=eq:exploss]) as

[formula]

This can be written in a simplified form as

[formula]

where

[formula]

Now, let Ai be the event that g0Ni(βi,1,βi,2) < g1Ni(βi,1,βi,2). We consider two cases:

If σi = 1 and Ai occurs, then

[formula]

If σi = 0 and Ai does not occur, then

[formula]

Therefore, using the fact that gσn is non-negative by definition, we have

[formula]

Substituting this back into [\eqref=eq:simplified1], and using Lemma [\ref=lem:indep], Lemma [\ref=lem:getrid] and Lemma [\ref=lem:block] in order, we get a lower bound of the form

[formula]

where the first inequality follows from Lemma [\ref=lem:indep], the second inequality is from Lemma [\ref=lem:getrid], and the third inequality is by Lemma [\ref=lem:block]. Since we assume m  ≥  27d, this is at least

[formula]

We now turn to analyze [formula]. By definition of gσn(u,v), we have that

[formula]

It is readily seen that this function is λ-strongly convex in (u,v), and attains a minimal value of 0 at some (u*1,u*1), where

[formula]

Using the property of λ-strong convexity, we have for all u,v that

[formula]

Also, by definition,

[formula]

which is a λ strongly-convex function in u + v, and attains a minimal value of 0 at any u2,v2 such that u*2 = u2 + v2, where

[formula]

Using the property of λ-strong convexity, we have for all u,v that

[formula]

Combining [\eqref=eq:f0] and [\eqref=eq:f1], and using the fact that the maximum is lower bounded by the average, this implies that

[formula]

A straightforward calculation reveals that this expression is minimized at [formula], leading to a value of [formula]. To summarize, we showed that

[formula]

where

[formula]

This computation holds for any value of y, and therefore we have

[formula]

where u*1,u*2 are as defined above. Substituting this back into [\eqref=eq:minmax], we get

[formula]

Finally, to write this in a simpler form, let [formula]. Then we can equivalently write u*1,u*2 as

[formula]

Moreover, the constraint [formula] implies that [formula], so we can lower bound [\eqref=eq:f2] by

[formula]

as desired. [formula]

Proof of Theorem [\ref=thm:lowrank]

Recall that we assume that m is divisible by 2d. Given [formula], define

[formula]

to be the partition function of [formula] into 2d equal-sized blocks:

[formula]

and so on, until i(m) = 2d.

Suppose we choose the target values [formula] according to yi = zi(t), where [formula] is to be chosen later, and let [formula] for [formula]. Recall that [formula]. It is easily seen that these instances induce a block-diagonal kernel matrix K∈K2d,m, composed of 2d all-one blocks of equal size m / (2d). Moreover, any low-rank matrix K' used by the algorithm will also have a block-wise structure (with possibly different values for the entries), where [formula].

Given any such block-wise kernel matrix K, composed of 2d uniform blocks of size m / 2d, let GK be the 2d  ×  2d matrix defined as Gi(t),i(t') = Kt,t'. Note that since K is symmetric, GK is symmetric as well. Finally, given some coefficient vector [formula], define [formula] as

[formula]

With this notation, we can re-write the objective function and resulting solution using the following lemma.

For any block matrix K, where Kt,t' = Kr,r' if i(t) = i(r) and i(t') = i(r'), and any coefficient vector [formula] with corresponding [formula], we have

[formula]

Moreover, if [formula], then [formula].

The proof is a technical exercise, and appears separately in Subsection [\ref=subsec:techlemma].

In our case, we chose the training instances so that K is a block-diagonal matrix composed of 2d equal-sized all-ones block. Therefore, GK in our case is simply the d  ×  d identity matrix. By Lemma [\ref=lem:alphabeta], we can write the objective function as

[formula]

This function is [formula]-strongly convex in [formula], and is minimized at [formula]. Therefore, the error obtained by any other solution [formula] is at least

[formula]

According to Lemma [\ref=lem:alphabeta] and the definition of the algorithm, the [formula] corresponding to the coefficient vector [formula] returned by the learning algorithm (using a kernel matrix K') satisfies [formula]. Plugging this back into [\eqref=eq:excbeta], we get an error lower bound of

[formula]

Let [formula] be the spectral decomposition of GK', where [formula] is an orthonormal matrix, and S is a diagonal matrix with eigenvalues [formula] on the diagonal. Moreover, since K' is a matrix of rank at most d, it follows that GK' is also of rank at most d, hence [formula]. We can therefore re-write [\eqref=eq:lowrank2] as

[formula]

We are now free to choose [formula], which induces some choice of the target values [formula], to get the final bound. In particular, we argue that there exist some [formula] such that

[formula]

from which the result follows. To show this, we use the probabilistic method: Suppose that [formula] is chosen uniformly at random from { - 1, + 1}2d. Then

[formula]

This means that there must exist some [formula] such that [formula] as required. [formula]

Proof of Lemma [\ref=lem:alphabeta]

The fact that

[formula]

is a straightforward exercise. The second part of the equation can be shown as follows:

[formula]

As to the second claim in the lemma, let [formula] be the spectral decomposition of GK (where [formula]). Then we argue that [formula] is a valid spectral decomposition of K, where [formula] are defined as

[formula]

This is because V's columns are orthonormal (this can be easily checked based on U's columns being orthonormal), and moreover, for any [formula] such that i(t) = j,i(t') = j', we have

[formula]

so [formula].

Therefore, we get than any entry t of [formula] can be written as follows:

[formula]

from which it follows that for all [formula],

[formula]

Hence [formula] as required.