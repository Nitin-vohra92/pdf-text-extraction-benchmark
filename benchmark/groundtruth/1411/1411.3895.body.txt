Learning Fuzzy Controllers in Mobile Robotics with Embedded Preprocessing

Introduction

The control architecture of mobile robots usually includes a number of behaviors that are implemented as controllers, which are able to solve specific tasks such as motion planning, following a moving object, wall-following, avoiding collisions, etc. in real time. These behaviors are implemented as controllers whose outputs at each time point (control commands) depend on both the internal state of the robot and the environment in which it evolves. The robot sensors (e.g. laser range finders, sonars, cameras, etc.) are used in order to obtain the augmented state of the robot (internal state and environment). When the robot operates in real environments, both the data obtained by these sensors and the internal state of the robot present uncertainty or noise. Therefore, the use of mechanisms that manage them properly is necessary. The use of fuzzy rules is convenient to cope with this uncertainty, since it combines the interpretability and expressiveness of the rules with the ability of fuzzy logic for representing uncertainty.

The first step for designing controllers for mobile robots consists of the preprocessing of the raw sensor data: the low-level input variables obtained by the sensors are transformed into high-level variables that are significant for the behavior to be learned. Usually, expert knowledge is used for the definition of these high-level variables and the mapping from the sensorial data. After this preprocessing stage, machine learning algorithms can be used to automatically obtain the mapping from the high-level input variables to the robot control commands. This paper describes an algorithm that is able to perform the preprocessing stage embedded in the learning stage, thus avoiding the use of expert knowledge. Therefore, the mapping between low-level and high-level input variables is done automatically during the learning phase of the controller.

The data provided by the sensors is of high dimensionality. For example, a robot equipped with two laser range finders can generate over 720 low-level variables. However, in mobile robotics it is more common to work with sets or groupings of these variables, (e.g. "frontal sector") that are much more significant and relevant for the behavior. As a result, it is necessary to use a model that is capable of grouping low-level variables, thus reducing the dimensionality of the problem and providing meaningful descriptions. The model should provide propositions that are able to summarize the data with expressions like "part of the distances in the frontal sector are high". This kind of expressions can model the underlying knowledge in a better way than just using average, maximum or minimum values of sets of low level variables. Moreover, these expressions also include the definition of the set of low-level variables to be used. Since these propositions involve fuzzy quantifiers (e.g. "part"), they are called Quantified Fuzzy Propositions (QFPs) [\cite=mucientes2010_pr]. QFP provide a formal model that is capable of modeling the knowledge involved in this grouping task.

Evolutionary algorithms have some characteristics that make them suitable for learning fuzzy rules. The well-known combination of evolutionary algorithms and fuzzy logic (genetic fuzzy systems) is one of the approaches that aims to manage the balance between accuracy and interpretability of the rules [\cite=cordon2004ten] [\cite=herrera2008_ei]. As it was pointed out before, fuzzy rules can be composed of both conventional and QFPs (therefore, they will be referred to as QFRs). Furthermore, the transformation from low-level to high-level variables using QFPs produces a variable number of propositions in the antecedent of the rules. Therefore, genetic programming, where the structure of individuals is a tree of variable size derived from a context-free grammar, is here the most appropriate choice.

This paper describes an algorithm that is able to learn QFRs of variable structure for the design of controllers with embedded preprocessing in mobile robotics. This proposal, called Iterative Quantified Fuzzy Rule Learning (IQFRL), is based on the Iterative Rule Learning (IRL) approach and uses linguistic labels defined with unconstrained multiple granularity, i.e. without limiting the granularity levels. This proposal has been designed to solve control (regression) problems in mobile robotics having as input variables the internal state of the robot and the sensors data. Expert knowledge is only used to generate the training data for each of the situations of the task to be learned and, also, to define the context-free grammar that specifies the structure of the rules.

The main contributions of the paper are: (i) the proposed algorithm is able to learn using the state of the robot and the sensors data, with no preprocessing. Instead, the mapping between low-level variables and high-level variables is done embedded in the algorithm; (ii) the algorithm uses QFPs, a model able to summarize the low-level input data; (iii) moreover, IQFRL uses linguistic labels with unconstrained multiple granularity. With this approach, the interpretability of the membership functions used in the resulting rules is unaffected while the flexibility of representation remains. The proposal was validated in several simulated and real environments with the wall-following behavior. Results show a better and statistically significant performance of IQFRL over several combinations of well-known learning algorithms and preprocessing techniques. The approach was also tested in three real world behaviors that were built as a combination of controllers: path tracking with obstacles avoidance, object tracking with fixed obstacles avoidance, and object tracking with moving obstacle avoidance.

The paper is structured as follows: Section [\ref=Sec:related] summarizes recent work related with this proposal and Section [\ref=Sec:QFR] presents the QFRs model and its advantages in mobile robotics. Section [\ref=Sec:evoAlg] describes the IQFRL algorithm that has been used to learn the QFRs. Section [\ref=Sec:results] presents the obtained results, and Section [\ref=Sec:realWorld] shows three real world applications of IQFRL in robotics. Finally, Section [\ref=Sec:conclusions] points out the most relevant conclusions.

Related Work

The learning of controllers for autonomous robots has been dealt with by using different machine learning techniques. Among the most popular approaches can be found evolutionary algorithms [\cite=bonte2010_aiai] [\cite=martinez2014genetic], neural networks [\cite=umar2011_rcim] and reinforcement learning [\cite=agostini2010_INSTICC] [\cite=lo2014intelligent]. Also hibridations of them, like evolutionary neural networks [\cite=kondo2007_asc], reinforcement learning with evolutionary algorithms [\cite=samsudin2011_asc] [\cite=mabu2010_smc], the widely used genetic fuzzy systems [\cite=senthilkumar2009hybrid] [\cite=mucientes2007_asc] [\cite=mucientes2009_ijis] [\cite=Mucientes10_eswa] [\cite=kuo2009_his] [\cite=khanian2009_cira] [\cite=Mucientes06_sc], or even more uncommon combinations like ant colony optimization with reinforcement learning [\cite=juang2009_ie] or differential evolution [\cite=hsu2013evolutionary] or evolutionary group based particle swarm optimization [\cite=juang2011_fs] have been successfully applied. Furthermore, over the last few years, mobile robotic controllers have been getting some attention as a test case for the automatic design of type-2 fuzzy logic controllers [\cite=lo2014intelligent] [\cite=martinez2014genetic] [\cite=hsu2013evolutionary].

An extensive use of expert knowledge is made in all of these approaches. In [\cite=senthilkumar2009hybrid] 360 laser sensor beams are used as input data, and are heuristically combined into 8 sectors as inputs to the learning algorithm. On the other hand, in [\cite=kondo2007_asc] [\cite=mucientes2007_asc] [\cite=mucientes2009_ijis] [\cite=Mucientes10_eswa] [\cite=kuo2009_his] [\cite=Mucientes06_sc] [\cite=juang2009_ie] [\cite=juang2011_fs] the input variables of the learning algorithm are defined by an expert. Moreover, in [\cite=mucientes2007_asc] [\cite=mucientes2009_ijis] [\cite=kuo2009_his] [\cite=Mucientes06_sc] [\cite=hsu2013evolutionary] the evaluation function of the evolutionary algorithm must be defined by an expert for each particular behavior. As in the latter case, the reinforcement learning approaches need the definition of an appropriate reward function using expert knowledge.

The approaches based on genetic fuzzy systems use different alternatives in the definition of the membership functions. In [\cite=samsudin2011_asc] [\cite=senthilkumar2009hybrid] [\cite=kuo2009_his] the membership functions are defined heuristically. In [\cite=mucientes2009_ijis] [\cite=Mucientes10_eswa] labels have been uniformly distributed, but the granularity of each input variable is defined using expert knowledge. On the other hand, in [\cite=mucientes2007_asc] [\cite=khanian2009_cira] [\cite=Mucientes06_sc] [\cite=juang2009_ie] [\cite=juang2011_fs] an approximative approach is used, i.e., different membership functions are learned for each rule, reducing the interpretability of the learned controller.

The main problem of learning behaviors using raw sensor input data is the curse of dimensionality. In [\cite=agostini2010_INSTICC], this issue has been managed from the reinforcement learning perspective, by using a probability density estimation of the joint space of states. Among all the approaches based on evolutionary algorithms, only in [\cite=bonte2010_aiai] no expert knowledge has been taken into account. In this work, the number of sensors and their position are learned from a reduced number of sensors.

In [\cite=mucientes2009_ifsa] a Genetic Cooperative-Competitive Learning (GCCL) approach was presented. The proposal learns knowledge bases without preprocessing raw data, but the rules involved approximative labels while the IQFRL proposal uses unconstrained multiple granularity. Moreover, in this approach it is difficult to adjust the balance between cooperation and competition, which is typical when learning rules in GCCL. As a result, the obtained rules where quite specific and the performance of the behavior was not comparable to other proposals based on expert knowledge.

Quantified Fuzzy Rules (QFRs)

QFRs for robotics

Machine learning techniques in mobile robotics are used to obtain the mapping from inputs to outputs (control commands). In general, two categories can be established for the input variables:

High-level input variables: variables that provide, by themselves, information that is relevant and meaningful to the expert for modeling the system (e.g. the linear velocity of the robot, or the right-hand distance from the robot to a wall).

Low-level input variables: variables that do not provide by themselves information for the expert to model the system (e.g. a single distance measure provided by a sensor). Relevance of these variables emerge when they are grouped into more significant sets of variables. For example, the control actions cannot be decided by simply analyzing the individual distance values provided by each beam of a laser range finder, since noisy measurements or gaps between objects (very frequent in cluttered environments) may occur. Instead, more significant variables and models involving complex groupings and structures are used.

Usually, high-level variables, or sectors, consisting of a set of laser beam measures instead of the beam measures themselves (e.g., right distance, frontal distance, etc.) are used in mobile robotics. The low-level input variables are transformed into high-level input variables in a preprocessing stage previous to the learning of the controller. Traditionally, this transformation and the resulting high-level input variables are defined using expert knowledge. Doing this preprocessing automatically during the learning phase demands a model that groups the low-level input variables in an expressive and meaningful way. Within this context Quantified Fuzzy Propositions (QFPs) such as "part of the distances of the frontal sector are low" are useful for representing relevant knowledge for the experts and therefore for performing intelligent control. Modeling with QFPs as in the previous example demands the definition of several elements:

part: how many distances of the frontal sector must be low?

frontal sector: which beams belong to the frontal sector?

low: what is the actual semantics of low?

This example clearly sets out the need to use propositions that are different from the conventional ones. The use of QFPs in robotics eliminates the need of expert knowledge in two ways: i) the preprocessing of the low-level variables can be embedded in the learning stage; ii) the definition of the high-level variables obtained from low-level variables is done automatically, also during the learning stage. In this paper QFPs are used for representing knowledge about high-level variables that are defined as the grouping of low-level variables. Conventional fuzzy propositions are also used to represent conventional high-level variables, i.e., high-level variables not related to low-level ones (e.g. velocity).

QFRs model

An example of a QFR is shown in Fig. [\ref=Fig:QFR], involving both QFPs ([\ref=Eq:distProp_1]) and conventional ones ([\ref=Eq:velProp]); the outputs of the rule are also fuzzy sets. In order to determine the degree to which the output of the rule will be applied, it is necessary to reason about the propositions (using, for example, the Mamdani's reasoning scheme).

The general expression for QFPs in this case is:

[formula]

where, for each i=1, ..., gmaxb (gmaxb being the maximum possible number of sectors of distances):

[formula] is the signal. In this example, it represents the distance measured by beam h.

Fid is a linguistic value for variable [formula] (e.g., "low").

Qi is a (spatial, defined in the laser beam domain) fuzzy quantifier (e.g., "part").

[formula] is a fuzzy set in the laser beam domain (e.g., the "frontal sector").

Evaluation of the Degree of Fulfillment (DOF) for QFP (Eq. [\ref=Eq:distProp]) is carried out using Zadeh's quantification model for proportional quantifiers (such as "most of", "part of", ...) [\cite=zadeh1983_cma]. This model allows to consider non-persistence, partial persistence and total persistence situations for the event "[formula] is Fid" in the range of laser beams (spatial interval [formula]). Therefore, for the considered example, it is possible to make a total or partial assessment on how many distances should be low, in order to decide the corresponding control action. This is a relevant feature of this model, since it allows to consider partial, single or total fulfillment of an event within the laser beams set.

The number of analyzed sectors of distances and their definition may vary for each of the rules. There can be very generic rules that only need to evaluate a single sector consisting of many laser beams, while other rules may need a finer granularity, with more specific laser sectors. Moreover, the rules may require a mix of QFPs and standard fuzzy propositions (for conventional high-level variables). Therefore, the automatic learning of QFRs demands an algorithm with the capability of managing rules with different structures.

Iterative Quantified Fuzzy Rule Learning of Controllers

Evolutionary learning of Knowledge Bases

Evolutionary learning methods follow two approaches in order to encode rules within a population of individuals [\cite=herrera2008_ei] [\cite=cordón2001_ws]:

Pittsburgh approach: each individual represents the entire rule base.

Michigan, IRL [\cite=cordón2001_fss], and GCCL [\cite=greene1993_ml]: each individual codifies a rule. The learned rule base is the result of combining several individuals. The way in which the individuals interact during the learning process defines these three different approaches.

The discussion is focused on those approaches for which an individual represents a rule, discarding the Michigan approach as it is used in reinforcement learning problems in which the reward from the environment needs to be maximized [\cite=Eiben03_book]. Therefore, the IRL and GCCL approaches are analyzed.

In the IRL approach, the individuals compete among them but only a single rule is learned for each run (epoch) of the evolutionary algorithm. After each sequence of iterations, the best rule is selected and added to the final rule base. The selected rule must be penalized in order to induce niche formation in the search space. A common way to penalize the obtained rules is to delete the training examples that have been covered by the set of rules in the final rule base. The final step of the IRL approach is to check whether the obtained set of rules is a complete knowledge base. In the case it is not, the process is repeated. A weak point of this approach is that the cooperation among rules is not taken into account when a rule is evaluated. For example, a new rule could be added to the final rule base, deteriorating the behavior of the whole rule base over a set of examples that were already covered. The cooperation among rules can be improved with a posterior rules selection process.

In the GCCL approach the entire population codifies the rule base. That is, rules evolve together but competing among them to obtain the higher fitness. For this type of algorithm it is fundamental to include a mechanism to maintain the diversity of the population (niche induction). This mechanism must warrant that individuals of the same niche compete among themselves, but also has to avoid deleting those weak individuals that occupy a niche that remains uncovered. This is usually done using token competition [\cite=cordón2001_ws].

Although GCCL works well for classification problems [\cite=mucientes2010_pr], the same does not occur for regression problems [\cite=mucientes2009_ifsa], mostly due to the difficulty of achieving in this realm an adequate balance between cooperation and competition. It is frequent in regression that an individual tries to capture examples seized by other individual, improving the performance on many of the examples, but decreasing the accuracy on a few ones. In subsequent iterations, new and more specific individuals replace the rule that was weakened. As a result, the individuals improve their individual fitness, but the performance of the knowledge base does not increase. In particular, for mobile robotics, the obtained knowledge bases over-fit the training data due to a polarization effect of the rule base: few very general rules and many very specific rules. Moreover, many times, the errors of the individual rules compensate each other, generating a good output of the rule base over the training data, but not on test data.

This proposal, called IQFRL (Iterative Quantified Fuzzy Rule Learning), is based on IRL. The learning process is divided into epochs (set of iterations), and at the end of each epoch a new QFR (Sec. [\ref=sec:qfr]) is obtained. The following sections describe each of the stages of the algorithm (Fig. [\ref=Alg:IQFRL]).

Examples and Grammar

The learning process is based on a set of training examples. In mobile robotics, each example can be composed of several variables that define the state of the robot (position, orientation, linear and angular velocity, etc.), and the data measured by the sensors. If the robot is equipped with laser range finders, the sensors data are vectors of distances. A laser range finder provides the distances to the closest obstacle in each direction (Fig. [\ref=Fig:beams]) with a given angular resolution (number of degrees between two consecutive beams). In this paper, each example el is represented by a tuple:

[formula]

where [formula] is the distance measured by beam h, Nb is the number of beams (e.g. 722 for a robot equipped with two Sick LMS200 laser range scanners as in Fig. [\ref=Fig:beams]), [formula] is the measured linear velocity of the robot, and [formula] and [formula] are the output variables (control commands for the linear and angular velocities respectively).

The individuals in the population include both conventional propositions and QFPs (Sec. [\ref=sec:qfr]). Also, the number of relevant inputs can be different. Therefore, genetic programming is the most appropriate approach, as each individual is a tree of variable size. In order to generate valid individuals of the population, and to produce right structures for the individuals after crossover and mutation, some constraints have to be added. With a context-free grammar all the valid structures of a tree (genotype) in the population can be defined in a compact form. A context-free grammar is a quadruple (V, Σ, P, S), where V is a finite set of variables, Σ is a finite set of terminal symbols, P is a finite set of rules or productions, and S the start symbol.

The basic grammar is described in Fig. [\ref=Fig:grammar]. As usual, different productions for the same variable are separated by symbol "|". Fig. [\ref=Fig:genotype] represents a typical chromosome generated with this context-free grammar. Terminal symbols (leaves of the tree) are represented by ellipses, and variables as rectangles. There are two different types of antecedents:

The sector antecedent. Consecutive beams are grouped into sectors in order to generate more general (high-level) variables (frontal distance, right distance, etc.). This type of antecedent is defined by the terminal symbols Fd, Fb and Q: i) the linguistic label Fd represents the measured distances (HIGH in Fig. [\ref=Fig:QFR], prop. [\ref=Eq:distProp_1]); ii) Fb is the linguistic label that defines the sector, i.e., which beams belong to the sector (FRONTAL SECTOR in Fig. [\ref=Fig:QFR], prop. [\ref=Eq:distProp_1]); iii) Q is the quantifier ([formula] in Fig. [\ref=Fig:QFR], prop. [\ref=Eq:distProp_1]).

The measured linear velocity of the antecedent is defined by the Fv linguistic label.

Finally, Flv and Fav are the linguistic labels of the linear and angular velocity control commands respectively, which are the consequents of the rule.

The linguistic labels of the antecedent (Fv, Fd, Fb) are defined using a multiple granularity approach. The universe of discourse of a variable is divided into a different number of equally spaced labels for each granularity. Specifically, a granularity givar divides the variable var in i uniformly spaced labels, i.e., Aivar  =  {Ai, 1var,...,Ai, ivar}. Fig. [\ref=Fig:multipleg] shows a partitioning of up to granularity five. On the other hand, the linguistic labels of the consequents (Flv, Fav) are defined using a single granularity approach.

Initialization

An individual (Fig. [\ref=Fig:genotype]) is generated for each example in the training set. The consequent part (Flv and Fav) is initialized as Fvar  =  Agvar, βvar where [formula], i.e., the label with the largest membership value for the example.

The initialization of the antecedent part of a rule requires obtaining the most similar linguistic label to a given fuzzy membership function (which is called mask label). As the maximum granularity of the linguistic labels in the antecedent part of a rule is not limited, the function |maskToLabel| (Fig. [\ref=Alg:mask]) is applied to obtain the most appropriate linguistic label. This function uses a similarity measure defined as [\cite=scozzafava2009_fss]:

[formula]

where Fφ and Fψ are the labels being compared and X is a finite set of points x uniformly distributed on the support of [formula].

The |maskToLabel| function (Fig. [\ref=Alg:mask]) receives a triangular membership function (maskvar) and searches for the label Ai, jvar with the highest similarity (Eq. [\ref=Eq:similarity], line 6) with less or equal support (line 5), starting from g1var (line 1).

For the initialization of the quantified propositions (sectors), the distances measured in the example are divided into groups of consecutive laser beams whose deviation does not exceed a certain threshold (σbd). Each group represents a sector that is going to be included in the individual. Afterwards, for each of the previously obtained sectors, the components (Fb, Fd and Q) are calculated:

Fb  =  maskToLabel(maskb), with [formula] where [formula] is the lower beam of the group, [formula] is the higher beam, [formula] is the middle beam and the following properties are satisfied: [formula] and [formula] as shown in Fig. [\ref=Fig:mask_beam].

Fd  =  maskToLabel(maskd), with maskd  =  (   -   σd, ,    +   σd) where [formula] is the mean of the distances measured by the beams of the group, σd is the standard deviation of these distances and the following properties are satisfied: μ(   -   σd)  =  μ(   +   σd)  =  0.5 and μ()  =  1 as shown in Fig. [\ref=Fig:mask_distance].

Q (Fig. [\ref=Fig:Q]) is calculated as the percentage of beams of the sector (h∈Fb) that fulfill Fd:

[formula]

Finally, the velocity antecedent Fv is initialized as Fv  =  Agiv, βv where β  =  argmaxj μgiv, jv (el) and giv is the granularity that satisfies that two consecutive linguistic labels have a separation of σv, where σv is a threshold of the velocity deviation.

Evaluation

The fitness of an individual of the population is calculated as follows. Firstly, it is necessary to estimate the probability that an example el matches the output (Cj) associated to the j-th individual rule:

[formula]

where [formula] is a parameter that defines the meaningful error and [formula] is the difference between output Cj and the output codified in the example:

[formula]

where ylk is the value of the k-th output variable of example el, cj, k is the output of the k-th output variable associated to individual j, and max k and min k are the maximum and minimum values of output variable k. In regression problems, there can be several consequents that are different from the one codified in the example, but that produce small errors, i.e., that are very similar to the desired output. Thus, [formula] can be interpreted as a normal distribution with covariance ME, and errorlj is the square of the difference between the mean (output codified in the example) and the output value proposed in the rule codified by the individual.

In an IRL approach, Cj  =  CRj, i.e., the output coded in individual j is the output associated to rule j. The fitness of an individual in the population is calculated as the combination of two values. On one hand, the accuracy with which the individual covers the examples, called confidence. On the other hand, the ability of generalization of the rule, called support. The confidence can be defined as:

[formula]

where DOFj(elu) is the degree of fulfillment of elu for rule j, and elu∈uncovex, where uncovex is defined as:

[formula]

i.e., the set of examples that are covered with a degree of fulfillment below DOFmin by the current final knowledge base (KBcur) (line [\ref=Eq:finalkb], Fig. [\ref=Alg:IQFRL]), and ρu can be defined as:

[formula]

where Pmin is the minimum admissible accuracy. Therefore, the higher the accuracy over the examples covered by the rule (and not covered yet by the current knowledge base), the higher the confidence. Support is calculated as:

[formula]

Thus, support measures the percentage of examples that are covered with accuracy, related to the total number of uncovered examples. Finally, fitness is defined as a linear combination of both values:

[formula]

which represents the strength of an individual over the set of examples in uncovex. αf∈[0, 1] is a parameter that codifies the trade-off between accuracy and generalization of the rule.

Crossover

The matching of the pairs of individuals that are going to be crossed is implemented following a probability distribution defined as:

[formula]

where cα, k (cβ, k) is the value of the k-th output variable of individual α (β), and Nc is the number of consequents. With this probability distribution, the algorithm selects with higher probability mates that have similar consequents. The objective is to extract information on which propositions of the antecedent part of the rules are important, and which are not. Crossover has been designed to generate more general individuals, as the initialization of the population produces very specific rules. The crossover operator generates two offsprings:

[formula]

This operator modifies a single proposition in antecedent part of the rule. As individuals have a variable number of antecedents, the total number of propositions can be different for two individuals. Moreover, the propositions can be defined using different granularities. Therefore, the first step is to select the propositions (one for each individual) to be crossed between both individuals (Fig. [\ref=Alg:crossover]) as follows:

Get the most specific granularity of the sectors of the individuals to cross (gmaxb). Then, an antecedent m∈[1, Na] is selected, where Na is gmaxb plus one, due to the velocity proposition.

Check the existence of this antecedent in both individuals, according to the following criteria:

If the antecedent m is a sector, then calculate for each proposition of each individual the similarity between the definition of the sector for the proposition and the linguistic label that defines sector m. Finally, select for each individual the proposition with the highest similarity.

If the antecedent m is the velocity, then the corresponding proposition is Fv (in case it exists).

Once the propositions to be crossed have been selected, an operation must be picked depending on the existence of the antecedent in both parents (table [\ref=Tab:crossover]):

If the proposition does not exist in the first individual but exists in the second one, then the proposition of the second individual is copied to the first one, as this proposition could be meaningful.

If the situation is the opposite to the previous one, then the proposition of the first individual is deleted, as it might be not important.

If the proposition exists in both individuals, then both propositions are combined in order to obtain a proposition that generalizes both antecedents.

In this last case, the combination of propositions is done by taking into account the degree of similarity (Eq. [\ref=Eq:similarity]) between them (Fig. [\ref=Fig:cross]). If the proposition is of type sector, the similarity takes into account both Fb and Fd labels. Only when both similarities are partial, the propositions are merged:

If there is no similarity, then the propositions correspond to different situations. For example, "the distance is high in part of the frontal sector" and "the distance is low in part of the frontal sector". This means that the proposition of the first individual might not contain meaningful information and it could be deleted to generalize the rule. For example, both individuals have the proposition "the distance is high in part of the frontal sector".

If the similarity is total, then, in order to obtain a new individual with different antecedents, the proposition is eliminated.

Finally, if the similarity is partial, then the propositions are merged in order to obtain a new one that combines the information provided by the two original propositions. For example, "the distance is high in part of the frontal sector" and "the distance is medium-high in part of the frontal sector". Therefore, the individual is generalized. The merge action is defined as the process of finding the label with the highest possible granularity that has some similarity with the labels of both original propositions. This is done for both Fb and Fd labels. Q is calculated as the minimum Q of both individuals.

Mutation

If crossover is not performed, both individuals are mutated. Mutation implements two different strategies (Fig. [\ref=Fig:mutation]): generalize or specialize a rule. The higher the value of confidence (Eq. [\ref=Eq:confidence]), the higher the probability to generalize the rule by mutation. This occurs with rules that cover their examples with high accuracy and that could be modified to cover other examples. On the contrary, when the confidence of the individual is low, this means that it is covering some of its examples with a low performance. In order to improve the rule some of the examples that are currently covered should be discarded in order to get a more specific rule.

For generalization, the following steps are performed:

Select an example esel∈uncovjex, where uncovjex  =  {elu:DOFj(elu)  <  DOFmin}, i.e. the set of examples that belong to uncovex and are not covered by individual j. The example is selected with a probability distribution given by [formula] (Eq. [\ref=Eq:probEx]). The higher the similarity between the output of the example and the consequent of rule j, the higher the probability of being selected.

The individual is modified in order to cover esel. Therefore, all the propositions that are not covering the example (those with [formula]) are selected for mutation.

For sector propositions (Eq. [\ref=Eq:distProp_1]), there are three different ways in which the proposition can be modified: Fd, Fb, and Q. The modification is selected among the three possibilities, with a probability proportional to the [formula] value after applying each one.

Fd and Fb are generalized choosing the most similar label in the adjacent partition with lower granularity. The process is repeated until [formula].

On the other hand, Q is decreased until [formula].

For velocity propositions (Eq. [\ref=Eq:velProp]), generalization is done choosing the most similar label in the adjacent partition with lower granularity until [formula].

For specialization, the process is equivalent:

Select an example esel∈covjex, where covjex  =  {elu:DOFj(elu)  >  DOFmin}, i.e. the set of examples that belong to uncovex and are covered by individual j. The example is selected with a probability distribution that is inversely proportional to [formula] (Eq. [\ref=Eq:probEx]). The higher the similarity between the output of the example and the consequent of rule j, the lower the probability of being selected.

Only one proposition needs to be modified to specialize the individual. This proposition is selected randomly.

For sector propositions there are, again, three different ways in which the proposition can be modified: Fd, Fb, and Q. The modification is selected among these three possibilities, with a probability that is inversely proportional to the [formula] value after applying each one.

Fd and Fb are specialized, choosing the most similar label in the adjacent partition with higher granularity. The process is repeated until [formula].

On the other hand, Q is increased until [formula].

For velocity propositions, specialization is done by choosing the most similar label in the adjacent partition with higher granularity until [formula].

Finally, once the antecedent is mutated, the consequent also mutates. Again, this mutation requires the selection of an example. If generalization was selected for the mutation of the antecedent, then the example will be esel. On the other hand, for specialization an example is randomly selected from those currently in covjex. For each variable in the consequent part of the rule, the label of the individual is modified selecting a label following a probability distribution (Fig. [\ref=Fig:consequent]):

[formula]

where Agvar, αvar is the label of each of the consequents of the individual, Agvar, βvar is the label with the largest membership value for esel and Agvar, γvar is a label between them. Thus, the labels closer to the label of the individual have a higher probability to be selected, while the labels closer to the example label have a lower one.

Selection and replacement

Selection has been implemented following the binary tournament strategy. Replacement follows an steady-state approach. The new individuals and those of the previous population are joined, and the best [formula] individuals are selected for the next population.

Epoch loop

An epoch is a set of iterations at the end of which a new rule is added to [formula]. The stopping criterion of each epoch (inner loop in Fig. [\ref=Alg:IQFRL]) is the number of iterations, but this limit varies according to the following criteria: once the number of iterations (it) reaches itmin, the algorithm stops if there are itcheck consecutive iterations (counted by equalind) with no change in the best individual (bestind). If the number of iterations reaches the maximum (itmax), then the algorithm stops regardless of the previous condition.

When the epoch ends, the rule defined in bestind is added to [formula]. Moreover, the examples that are covered with accuracy (according to the criterion in Eq. [\ref=Eq:accuracy_u]) are marked as covered by the algorithm (line [\ref=Eq:remained], Fig. [\ref=Alg:IQFRL]). Finally, the algorithm stops when there are no uncovered examples.

Rule subset selection

After the end of the iterative part of the algorithm, the performance of the obtained rule base can be improved selecting a subset of rules with better cooperation among them. The rule selection algorithm described in [\cite=mucientes2010_pr] has been used. The rule selection process has the following steps:

Generate #  Rgp rule bases, where #  Rgp is the number of rules of the population obtained by the IQFRL algorithm (RBgp) Each rule base is coded as: [formula], with:

[formula]

where rij indicates if the j-th rule of RBgp is included (rij  =  1) or not (rij  =  0) in RBi. With this codification, RBi will contain the best i rules of RBgp, as these rules have been ranked in decreasing order of their individual fitness. Notice that RB#  Rgp is RBgp

Evaluate all the rule bases, and select the best one, RBsel.

Execute a local search on RBsel to obtain the best rule set, RBbest.

The last step was implemented with the iterated local search (ILS) algorithm [\cite=Lourenco03].

threshold (maxRestarts).

Results

Experimental setup

The proposed algorithm has been validated with the well-known in mobile robotics wall-following behavior. The main objectives of a controller for this behavior are: to keep a suitable distance between the robot and the wall, to move at the highest possible velocity, and to implement smooth control actions. The Player/Stage robot software [\cite=PlayerStage] has been used for the tests on the simulated environments and also for the connection with the real robot Pioneer 3-AT (Fig. [\ref=Fig:3at]). This real robot was equipped with two laser range scanners with an amplitude of [formula] and a precision of [formula] (i.e. 361 measurements for each laser scan). Without loss of generality, all the examples and tests here described were made with the robot following the wall at its right.

The examples that have been used for learning were generated for three different situations (Fig. [\ref=Fig:situations]) that have been identified by an expert:

Convex corner: it is characterized by the existence of a gap in the wall (like an open door) (labeled CX in Fig. [\ref=Fig:situations]).

Concave corner: it is a situation in which the robot finds a wall in front of it (labeled CC in Fig. [\ref=Fig:situations]).

Straight wall: any other situation (labeled SW in Fig. [\ref=Fig:situations]).

For each of the above situations, the robot was placed in different positions and the associated control order was the one that minimized the error. Therefore, each example consists of 722 distances (one for each laser beam), the current linear velocity of the robot, and the control commands (linear and angular velocity). The expert always tried to follow the wall at, approximately, 50 cm and the maximum values for the linear and angular velocities were 50 cm/s and 45os- 1 respectively. 572 training examples were generated for the straight wall situation, 540 for the convex corner and 594 for the concave corner.

The IQFRL algorithm was used to learn a different controller for each of the three situations. In order to decide which knowledge base should be used at each time instant, the classification version of IQFRL (IQFRL-C, see [\ref=Sec:class]) was used. In this way, IQFRL learning could be tested with three completely different controllers.

In order to analyze the performance of the proposed learning algorithm, several tests were done in 15 simulated environments and two real ones. Table [\ref=Tab:enviroments] shows some of the characteristics of the environments: the dimensions of the environment, the path length, the number of concave (#CC) and convex (#CX) corners, and the number of times that the robot has to cross a door (#doors). The action of crossing a door represents a high difficulty as the robot has to negotiate a convex corner with a very close wall in front of it.

The simulated environments are shown in Figs. [\ref=Fig:environments1] and [\ref=Fig:environments2]. The trace of the robot is represented by marks, and the higher the concentration of marks, the lower the velocity of the robot. Furthermore, Fig. [\ref=Fig:realenvironments] shows the real environments. Each of them represents an occupancy grid map of the environment, together with the trajectory of the robot.

Algorithms and parameters

The following values were used for the parameters of the evolutionary algorithm: [formula], [formula], αf  =  0.99, Pcross  =  0.8, [formula], [formula], [formula], [formula], σbd = 0.01, σv  =  0.1 and Pmin  =  0.17. Pmin is a parameter that has a high influence in the performance of the system. A single value of Pmin was used in testing, obtained from Eqs. [\ref=Eq:probEx] and [\ref=Eq:error] for the case the error for each consequent is one label (Eq. [\ref=Eq:error]). The granularities and the universe of discourse of each output of a rule are shown in table [\ref=Tab:universes]. For the rule subset selection algorithm, the parameters have values of radiusnbhood  =  1 and maxRestarts  =  2.

The fuzzy inference system used for the learned fuzzy rule sets uses the minimum t-norm for both the implication and conjunction operators, and the weighted average method as defuzzification operator.

The IQFRL approach was compared with three different algorithms:

Methodology to Obtain Genetic fuzzy rule-based systems Under the iterative Learning approach (MOGUL): a three-stage genetic algorithm [\cite=cordón1997_ar]:

An evolutionary process for learning fuzzy rules, with two components: a fuzzy-rule generating method based on IRL, and an iterative covering method.

A genetic simplification process for selecting rules.

A genetic tuning process, that tunes the membership functions for each fuzzy rule or for the complete rule base.

The soft-constrained MOGUL was used, as it has better performance in very hard problems [\cite=cordón2001_fss].

Multilayer Perceptron Neural Network (MPNN): a single-hidden-layer neural network trained with the BFGS method [\cite=setiono1995use] with the following parameters: abstol  =  0.01, reltol  =  0.0001 and maxit  =  500. The number of neurons in the hidden layer varies from n to 2  ·  n, being n the number of inputs.

ν-Support Vector Regression (ν-SVR): a ν-SVM [\cite=schölkopf2000_nc] version for regression with a Gaussian RBF kernel. The parameter sigma is estimated based upon the 0.1 and 0.9 quantile of ||x   -   x'||2.

As mentioned before, in the IQFRL proposal the preprocessing of raw sensor data is embedded in the learning algorithm. Since the algorithms for the comparison need to preprocess the data before the learning phase, three different approaches were used for the transformation of the sensor data:

Min: the beams of the laser range finder are grouped in n equal sized sectors. For each sector, the minimum distance value is selected as input.

Sample: n equidistant beams are selected as the input data.

PCA: Principal Component Analysis computes the most meaningful basis to re-express the data. It is a simple, non-parametric method for extracting relevant information. The variances associated with the principal components can be examined in order to select only those that cover a percentage of the total variance.

Different parameters have been used for the preprocessing approaches. For Min and Sample methods, the number of obtained inputs (n) was changed. For PCA, the percentage of variance (σPCA) indicates the principal components selected as input data. Table [\ref=Tab:sampling] shows the parameters used for the preprocessing methods. Moreover, table [\ref=Tab:PCA] shows the number of inputs obtained with PCA for the three datasets with each configuration.

Comparison and statistical significance

Table [\ref=Tab:error] shows the training and test errors over a 5-fold cross-validation. For each algorithm and dataset the mean and standard deviation of the error (Eq. [\ref=Eq:error]) were calculated.

For each preprocessing technique, a 5-fold cross-validation was performed for each combination of the parameters of the algorithms. For example, for the Min preprocessing with 16 equal size sectors, a 5-fold cross-validation was run for each number of neurons between 17 and 34 for the MPNN approach. Only the configuration of the algorithm with lowest test error for each configuration of the preprocessing methods was used for comparison purposes. Moreover, only those configurations of preprocessing techniques with the best results are shown in the tables of this section. Results for PCA preprocessing have not been included, as the learning algorithms were not able to obtain adequate controllers.

Although, the MSE (Mean Squared Error) is the usual measure of the performance of the algorithms, this is not a sufficient criterion in mobile robotics. A good controller must be robust and able to provide a good and smooth output in any situation. The only way to validate the controller is to test it on environments (simulated and real) with different difficulties and assessing on these tests a number of quality parameters such as mean distance to the wall, mean velocity along the paths,

Table [\ref=Tab:results] contains the results of the execution of each of the algorithms for the different simulated environments (Figs. [\ref=Fig:environments1] and [\ref=Fig:environments2]). Furthermore, table [\ref=Tab:average_results] shows the average results for the following five different indicators: the distance to the wall at its right (Dist.), the linear velocity (Vel.), the change in the linear velocity between two consecutive cycles (Vel.ch.) --which reflects the smoothness in the control--, the time per lap, and the number of blockades of the robot along the path and cannot recover.

The robot is blocked if it hits a wall or if it does not move for 5 s. In this situation the robot is placed parallel to the wall at a distance of 0.5 m. The average values of the five indicators are calculated for each lap that the robot performs in the environment. Results presented in the table are the average and standard deviation values over five laps of the average values of the indicators over one lap. The dash symbol in the results table indicates that the controller could not complete the path. This usually occurs when the number of blockades per meter is high (greater than 5 blockades in a short period of time) or when the robot completely deviates from the path.

Moreover, in order to evaluate the performance of a controller with a numerical value a general quality measure was defined. It is based on the error measure defined in [\cite=Mucientes10_eswa], but including the number of blockades:

[formula]

where dwall is the reference distance to the wall (50 cm) and vmax is the maximum value of the velocity (50 cm/s). The higher the quality, the better the controller. This measure takes the number of blockades into account in a linear form for comparison purposes. However, it should be noted that controllers with just a single blockade are not reliable and should not be implemented on a real robot.

In general, all the algorithms except MPNN with Sample 16 preprocessing, produced a distance that is very close to the reference (between 40 cm and 60 cm to the wall at its right). Note that in cases where the best distance is very different from that obtained by IQFRL, this is because several blockades happened. Therefore, those controllers have the advantage of being continually repositioned into the perfect situation. The best results in speed are those obtained by ν-SVR and MOGUL but, in general, due to a worsening in the distance to the wall or an increase in the number of blockades. The same applies to the speed change. In those cases where it is too low, like in some cases for MOGUL or MPNN, the robot is not able to trace some curves safely. IQFRL is the approach that gets the best quality values, reflecting not only the adequate values for the distance, velocity and smoothness in all the environments but, also, its robustness: it is the unique approach that never blocked or failed to complete the laps in any of the environments.

In order to compare the experimental results, non-parametric tests of multiple comparisons have been used. Their use is recommended in those cases in which the objective is to compare the results of a new algorithm against various methods simultaneously. The Friedman test with Holm post-hoc test was selected as the method for detecting significant differences among the results. The test is performed for the quality indicator in table [\ref=Tab:results].

The statistical test (table [\ref=Tab:quality]) shows that the difference of the quality of the IQFRL approach is statistically significant. Only ν-SVR and MOGUL with sample 16 preprocessing are comparable to IQFRL, as the number of blockades is very low or null in some environments.

Additionally, table [\ref=Tab:real_results] shows the results obtained by IQFRL in two real environments. As in the previous tables, the results are the average and standard deviation over 5 laps. The distance to the wall is lower than 60 cm, showing a good behavior, although the velocity seems to be low, this is because corners are very close to each other and the robot does not have time to accelerate. Also, the velocity change reflects a very smooth movement as changes in velocity take more time in the real robot.

Finally, the IQFRL proposal was compared with the proposals presented in [\cite=Mucientes10_eswa] for learning rules for the wall-following behavior. The purpose of this comparison is to check if IQFRL is competitive against other methods which use expert knowledge for sensor data preprocessing. Four different approaches were used: the COR methodology, the weighted COR methodology (WCOR), Hierarchical Systems of Weighted Linguistic Rules (HSWLR) and a local evolutionary learning of Takagi-Sugeno rules (TSK). For these approaches, four input variables were defined by an expert: right distance, left distance, velocity, and the orientation (alignment) of the robot to the wall at its right. Moreover, the granularities of each variable were also defined by the expert. Table [\ref=Tab:eswa] presents the comparison between these approaches and the IQFRL proposal on those environments which are common.

The IQFRL approach exhibited the highest quality in the two most complex environments (office and hospital). Moreover, table [\ref=Tab:eswa_quality] shows the non-parametric tests performed over quality. The Friedman p-value is higher than in table 9, due to the low number of environments available for comparisons. As can be seen, there is no statistically significant difference regarding the quality. That is, the controllers learned with embedded preprocessing has similar performance to the methods that use expert knowledge to preprocess the data.

Complexity of the Rules

An example of a rule learned by IQFRL is presented in Fig. [\ref=Fig:rule]. The antecedent part is composed of a single QFP. The linguistic value A5, 1d indicates a low distance, while A4, 1b denotes that the beams sector of the proposition is formed by the frontal and right parts of the robot. Therefore, the rule describes a situation where the robot is too close to the wall and, if it continues, it will collide. Because of that, the consequent indicates a zero linear velocity and a turn of the robot to the left, in order to get away from the wall without getting the robot into risk.

Table [\ref=Tab:number] shows the number of rules learned for the different situations by each of the methods based on rules. MOGUL is implemented as a multiple-input single-output (MISO) algorithm, therefore for each output, different rule bases were learned. Moreover, table [\ref=Tab:gran] shows the complexity of the learned rules in terms of mean and standard deviation of the number of propositions and granularities for each input variable.

The IQFRL approach is able to learn knowledge bases with a much lower number of rules than MOGUL, even though it is learning both outputs at the same time. The learning of QFRs results in a low number of propositions per rule, thus demonstrating its generalization ability, in spite of the huge input space dimensionality. Moreover, the granularities of each of the input variables are, in general, also low. Therefore, the learned knowledge bases show a low complexity without losing accuracy.

Real World Applications

Two of the most used behaviors in mobile robotics are path and object tracking. In recent years several real applications of these behaviors have been described in the literature in different realms. For instance, in [\cite=kim2004autonomous], a tour-guide robot that can either follow a predefined route or a tour-guide person was shown. With a similar goal, an intelligent hospital service robot was presented in [\cite=shieh2004design]. In this case, the robot can improve the services provided in the hospital through autonomous navigation based on following a path. More recently, in [\cite=lopez2013watchbot] a team of robots that cooperate in a building developing maintenance and surveillance tasks was presented.

More dynamic environments were described in [\cite=gamallo2010omnivision] [\cite=kummerle2013navigation], where the robot had to operate in buildings and populated urban areas. These environments introduce numerous challenges to autonomous mobile robots as they are highly complex. Finally, in [\cite=Gonzalez-Sieira13_robot] the authors presented a motion planner that was able to generate paths taking into account the uncertainty due to controls and measurements.

In these and other real applications, the robot has to deal with static and moving objects, including the presence of people surrounding the robot, etc. All these difficulties make necessary the combination of behaviors to perform tasks like path or people tracking in real environments. In order to implement these tasks in a safe way, the robot must be endowed with the ability to avoid collisions with all the objects in the environment while implementing the tasks. These behaviors are challenging tasks that allow us to show the performance of the IQFRL-based approach in realistic conditions. The following behaviors are considered in this section, in order of increasing complexity:

Path tracking with obstacles avoidance. In this behavior, the mobile robot must follow a path with obstacles in it. A typical application of this behavior is a tour-guide robot that has to follow a predefined tour in a museum. Although in the initial path there were no obstacles in the trajectory, the modification of the environment with new exhibitors and the presence of people make it necessary that the robot modify the predefined route, avoiding the collision with the obstacles and returning to the predefined path as quickly as possible.

Object tracking with fixed obstacles avoidance. In this case, the robot has to follow the path of a moving object while being at a reference distance to the object. For instance, a tour-guide person being followed by a robot with extended information on a screen. If the followed object comes too close to an obstacle, the robot must avoid the collision while maintaining the tracking behavior.

Object tracking with moving obstacle avoidance. This behavior is a modification of the previous one, and presents a more difficult problem. In addition to the fixed obstacles avoidance, the robot has to track an object while preventing collisions with moving obstacles that are crossing between the robot and the tracked object. These moving obstacles can be persons walking around or even other mobile robots doing their own behaviors.

In order to perform these behaviors, a fusion of two different controllers has been developed. On one hand, a tracking controller [\cite=Mucientes07_tfs] was used in order to follow the path or the moving object. On the other hand, the wall-following controller learned with the IQFRL algorithm was used as the collision avoidance behavior. Section [\ref=sec:comparison] showed that this controller is robust and operates safely while performing the task. There were no blockades during the behavior in all the tests, neither from collisions nor from other reasons. The way in which the wall-following behavior is used in order to avoid collisions is: given an obstacle that is too close to the robot, it can be surrounded following the border of this obstacle in order to avoid a collision with it. The controller described in this paper follows the wall on its right, while for this task, the obstacle can be on both sides. This can easily be solved by a simple permutation of the laser beams depending on which side the obstacle is detected.

The wall-following behavior is only executed when the robot is too close to an object --a value of 0.4 m has been used as threshold. The objective of the controller is to drive the robot to a state in which there is no danger of collision --a value of 0.5 m has been established as a safe distance. As long as the robot is in a safe state the tracking behavior is resumed. This behavior controls the linear and angular velocities of the robot in order to place it at an objective point in every control cycle. This point is defined using the desired distance between the robot and the moving object. The tracking controller uses four different input variables:

The distance between the robot and the objective point:

[formula]

where (xr,yr) are the coordinates of the robot, (xobj,yobj) are the coordinates of the objective point and dref is the reference distance between the robot and the objective point.

The deviation of the robot with respect to the objective point:

[formula]

where θr is the angle of the robot. A negative value of the deviation indicates that the robot is moving in a direction to the left of the objective point, while a positive value means that it is moving to the right.

The difference of velocity between the robot and the objective point:

[formula]

where vr, vm and vmax are the linear velocities of the robot, the moving object, and the maximum velocity attainable by the robot.

The difference in angle between the object and the robot:

[formula]

where θm is the angle of the moving object.

The reference distance (dref) is different depending on the type of behavior. For the path tracking behavior, there is no moving object tracking and, therefore, the robot follows the path with dref  =  0 in order to do a perfect path tracking. In the other two behaviors the robot follows a moving object, so it is necessary to keep a safe distance --a value of dref  =  0.5 m was used in the experiments shown in this section.

The three behaviors have been validated in two different environments (M1 and Domus) which try to reproduce the plant of a museum (Fig. [\ref=Fig:real_applications]). Figs. [\ref=Fig:pt_museum] and [\ref=Fig:pt_domus] show the path tracking with obstacles avoidance behavior. The orange (medium grey) path represents the trajectory that has to be followed by the robot. This path also includes information of the velocity that the robot should have at each point. The higher the concentration of marks, the lower the linear velocity in that point of the path. Moreover, the path was generated without obstacles and, once the obstacles were added to the environment, the robot was placed at the beginning of the path in order to track it. The cyan (light grey) path indicates the trajectory implemented by the robot using the proposed combination of controllers (wall-following and tracking). It can be seen that the robot avoids successfully all the obstacles in its path, i.e., the wall following behavior deviates the robot from the predefined path when an obstacle generates a possibility of collision. When the robot overcomes the obstacle, it returns to the predefined path as quickly as possible.

In the case of the moving object tracking with fixed obstacles avoidance behavior (Figs. [\ref=Fig:off_museum] and [\ref=Fig:off_domus]), the cyan (light grey) line represents the path of the robot due to the combination of the controllers. Also, the orange (medium grey) path shows the trajectory of the moving object tracked by the robot. In this behavior, the moving object goes too close to some obstacles in several situations, forcing the controller to execute the wall following behavior in order to avoid collisions. Moreover, the wall-following controller is also executed when the moving object turns the corners very close to the obstacles, at a distance that is unsafe for the robot.

The last and most complex behavior is moving object tracking with moving obstacle avoidance (Figs. [\ref=Fig:ofm_museum] and [\ref=Fig:ofm_domus]). The cyan (light grey) path shows, once again, the path followed by the robot when it tracks the moving object (orange / medium grey path) while avoiding static and moving obstacles. Also, the path followed by the moving obstacle that should be avoided by the robot is shown in blue (dark grey). The arrows along the path indicate the places in which the obstacle interferes with the robot. This behavior shows the ability of the controller learned with the IQFRL algorithm to avoid collisions, even when the moving obstacle tries to force the robot to fail: the controller can detect the situation and perform the task safely, avoiding collisions.

Conclusions

This paper describes a new algorithm which is able to learn controllers with embedded preprocessing for mobile robotics. The transformation of the low-level variables into high-level variables is done through the use of Quantified Fuzzy Propositions and Rules. Furthermore, the algorithm involves linguistic labels defined by multiple granularity without limiting the granularity levels. The algorithm was extensively tested with the wall-following behavior both in several simulated environments and on a Pioneer 3-AT robot in two real environments. The results were compared with some of the most well-known algorithms for learning controllers in mobile robotics. Non-parametric significance tests have been performed, showing a very good and a statistically significant performance of the IQFRL approach.

Acknowledgements

This work was supported by the Spanish Ministry of Economy and Competitiveness under grants TIN2011-22935 and TIN2011-29827-C02-02. I. Rodriguez-Fdez is supported by the Spanish Ministry of Education, under the FPU national plan (AP2010-0627). M. Mucientes is supported by the Ramón y Cajal program of the Spanish Ministry of Economy and Competitiveness. This work was supported in part by the European Regional Development Fund (ERDF/FEDER) under the projects CN2012/151 and CN2011/058 of the Galician Ministry of Education.

NOTICE: this is the author’s version of a work that was accepted for publication in Applied Soft Computing. Changes resulting from the publishing process, such as peer review, editing, corrections, structural formatting, and other quality control mechanisms may not be reflected in this document. Changes may have been made to this work since it was submitted for publication. A definitive version was subsequently published in Applied Soft Computing, 26:123-142, 2015, doi:10.1016/j.asoc.2014.09.021.

IQFRL for Classification (IQFRL-C)

This section describes the modifications that are necessary to accomplish for adapting the IQFRL algorithm for classification problems.

Examples and Grammar

The structure of the examples used for classification is very similar to the one described in expression [\ref=Eq:example]:

[formula]

where class represents the class of the example.

Furthermore, the consequent production (production 3) of the grammar (Fig. [\ref=Fig:grammar]) must be modified to:

consequent →   Fc

where Fc is the linguistic label of the class. The output variable (class) has a granularity g#  classc.

Initialization

The consequent of the rules is initialized as Fc  =  Aγc where γ is the class that represents the example. Only those examples whose class is different from the default class (Afc) are used in the initialization of a new individual.

Evaluation

For each individual (rule) of the population, the following values are calculated:

True positives ([formula]):

[formula], where Cl is the class of example el, Cj is the class in the consequent of the j-th rule, and [formula] is the [formula] of the j-th rule for the example el. [formula] represents the number of examples that have been correctly classified by the rule.

[formula], i.e., the sum of the [formula]s of the examples contributing to [formula].

[formula]

False positives ([formula]):

[formula]: number of patterns that have been classified by the rule but belong to a different class.

[formula], i.e., the sum of the [formula]s of the patterns that contribute to [formula].

[formula]

False negatives ([formula]):

[formula], where [formula]. [formula] is the number of examples that have not been classified by the rule but belong to the class in the consequent of the rule.

The values of [formula] and [formula] take into account not only the number of examples that are correctly/incorrectly classified, but also the degree of fulfillment of the rule for each of the examples. In case that [formula], then [formula], while if it is high ([formula]) then [formula]. Taking into account these definitions, the accuracy of an individual of the population can be described as:

[formula]

while the ability of generalization of a rule is calculated as:

[formula]

Finally, [formula] is defined as the combination of both values:

[formula]

which represents the strength of an individual.

Mutation

For classification, the probability that an example matches the output associated to a rule (Eq. [\ref=Eq:probEx]) is binary. Therefore, in order to select the example (esel) that is going to be used for mutation, the following criteria is used:

For generalization, the probability for an example el to be selected is:

[formula]

where [formula] is the [formula] (Eq. [\ref=Eq:confidence-class]) of the j-th individual. This probability measures the accuracy with which the individuals of the population cover the example el.

For specialization, the mutated individual uncovers the example esel. The probability to select el for specialization is calculated as follow:

[formula]

Finally, the consequent is mutated considering the class of the examples covered by the individual. Thus, the probability that the consequent of the individual j change to the class Cγ is defined as:

[formula]

Performance

The parameters used for IQFRL-C are the same as for regression (Sec. [\ref=Sec:parameters]). Moreover, the default class is straight wall. Tables [\ref=Tab:number_class] and [\ref=Tab:gran_class] show the number of rules learned by the classification method IQFRL-C and the complexity of the rules learned in terms of mean and standard deviation of the number of propositions and granularities for each input variable. The number of rules for each situation is very low, resulting in very interpretable knowledge bases. Furthermore, the complexity of the rules is also low, as the number of propositions and granularities learned show that the rules are very general.

Table [\ref=Tab:confusion] shows the confusion matrix for the learned classifier. The matrix was obtained as the average of a 5-fold cross-validation over the sets. Moreover, the performance of the classifier was analyzed with the accuracy and the Cohen's κ [\cite=ben2007_eaia]. Both measures are very close to 1, showing the high performance of the classifier obtained with IQFRL-C.