Modulo Three Problem With A Cellular Automaton Solution

Cellular automaton is a simple-minded discrete dynamical system that exhibits complex behavior collectively. It has been used in the study of pattern formation [\cite=pf1] [\cite=pf2] and many other physical systems [\cite=fluid] [\cite=elchem], for example. In order to fully explore the capability of cellular automata, it is instructive to investigate if and how they can perform some "simple" tasks. It is known that cellular automata can do a number of basic computations such as finding the majority as well as the parity of an arbitrary bit string [\cite=majority] [\cite=parity], as follows. Let σ be an arbitrary bit string of length N with periodic boundary conditions, Sσ be the number of 1s in σ. The majority problem is to ask whether Sσ is greater than N / 2, while the so-called parity problem is to ask if Sσ is odd or even. It has been discovered that these two problems can be solved by applying a number of cellular automaton (CA) rules in successions. These two problems (and solutions) illustrate one important point that global properties of a bit string can be found by cellular automata, which only know the local states of the bit string and do not have any memory.

In this paper, we would like to find out if [formula]. More precisely, we would like to evolve the given input bit string with periodic boundary conditions using a sequence of translational invariant and deterministic CA rules with parallel update to 0N if [formula] and 1N otherwise, where 0N denotes a string of N consecutive zeros and 1N denotes a string of N consecutive ones.

The plan of solving this modulo three problem follows the plan of solving the parity problem. We will first evolve the bit string in O(N3) steps to put it in some standard forms. Then, we can tell apart those standard forms by a sequence of CA rules, and hence if [formula]. (In this paper, all equivalences are modulo three.) However, since there are more cases to be considered in this problem, we have to use a few more CA rules.

The first CA rule that we need is

R1:

.

The notation means that if part of the bit string is 1000, then in the next time step, the first bit of this part remains 1, the second and the third bits become 1. The outcome of the fourth bit also depends on the bit pattern on its right. Similarly, if some part of the bit string is 0001, then the fate of the first and the second bit depends on the bit pattern on their left, and the third and fourth bits are 1. If the local configuration of the bit string is neither 1000 nor 0001, the bits remain the same. For example, under this rule, 1000001 becomes 1110011, 10001 becomes 11111 and 10010101 remains unchanged. It is straight-forward to check that this is a r = 2 CA rule. That is, the step of each bit in the next time step depends on the state itself as well as its nearest and second-nearest neighbors.

The function of this rule is as follows. If the number of consecutive zeros in the string is more than three, then the rule will replace the three ending zeros, two on the left and one on the right, by ones. Since we are using periodic boundary conditions, the number of ones modulo three does not change. If we apply the rule ⌊N / 3⌋ times, then there will be no three or more consecutive zeros in a row.

This is a good time to introduce a concept we called the partition number. Apart from the configurations 0N and 1N, groups of zeros are separated by groups of ones, and the number of groups of zeros is equal to the number of groups of ones. We define the partition number of a bit string to be the number of groups of zeros, if the bit string is not 0N or 1N. The partition numbers of 0N and 1N are defined to be zero. For example, the partition number of 100111001011 is equal to 3 (because of the periodic boundary condition). The partition number will not increase after we apply the CA rule R1.

For an arbitrary bit string σ, R⌊N / 3⌋1σ could be 1N or 0N. If this is not the case, then it does not have three or more consecutive zeros in a row, but there could be single or two zeros separated by ones. The next thing that we need to do is to merge the zeros.

R2:

.

Again, it is straight-forward to check that R2 is a r = 1 CA rule. This rule moves the single zeros to the left. Hence, the number of zeros is conserved under this rule. Applying this rule N times,

[formula]

there will be either no single zeros or all the zeros are single. Similar to R1, the partition number will not increase after we apply R2.

If we repeat the whole process N times, it is straight-forward to see that the resultant bit string,

[formula]

will have the following properties:

It is equal to 1N or 0N. If not, then all the zeros are either single or in pairs. There is no three or more consecutive zeros, and there will not be both single and paired zeros at the same time.

The number of ones will be equivalent to Sσ modulo three.

The partition number of the resultant bit string will be less than or equal to the partition number of σ.

The roles of the zeros and ones could be reversed and we define the CA rules

R3:

, R4:

.

Lemma 1. Let

[formula]

then σ1 will be one of the following six cases: A. 1N; B. 0N; C. (103n + 1)m; D. (1103n + 2)m; E. (103n + 2)m; F. (1103n + 1)m.

Proof. Since R3 and R4 are obtained by interchanging the roles of 0 and 1 in R1 and R2 respectively, our earlier discussions imply that all ones in [formula] are either single or in pairs provided that σ2  ≠  1N. Besides, σ2 does not contain both single and paired ones in this case. That is to say, [formula] up to a linear translation where i = 1 or 2, jk = 0,1 or 2 and [formula] for k to run from 1 to the partition number of σ2.

It is straight-forward to check that the partition number of [formula] equals that of σ2 if and only if jk  =  jk'  ≠  0 for all k,k'. And in this case, [formula] up to a linear translation. By the same token, the partition number of [formula] equals that of σ3 if and only if nk  +  2nk + 1  +  i  ≠  0 mod 3 and nk  +  nk + 1  -  2nk + 2  =  0 mod 3 for all k. These conditions imply that nk  -  nk + 1  =  α mod 3 is a constant independent of k and α  +  i  ≠  0 mod 3. In other words, the possible values of (α,i) are (0,1), (0,2), (1,1) and (2,2). Furthermore, it is easy to see that if the partition numbers of σ3 and σ4 agree, then up to a linear translation,

[formula]

From the above discussions, we know that if the partition number of σ4 equals that of σ2 and if not all nk are equal, then the action of [formula] increases the length of at least one substring of consecutive zeros (namely, the one with the least value of nk) while at the same time decreases the length of at least one substring of consecutive zeros (namely, the one with the maximum value of nk).

At this point, we introduce the notation of minimum gap [formula]. In other words, the minimum gap of a bit string is the minimum distance in between two ones in the string σ. Clearly, this definition is well-defined provided that σ  ≠  0N or 1N. The notation of maximum gap [formula] is defined in a similar way.

The above discussions imply that if the partition numbers of σ4 and σ2 agrees, then

[formula]

provided that σ4  ≠  0N or 1N. Furthermore, it is not difficult to see that Eq. ([\ref=E:ell_inc]) also holds when the partition numbers of σ4 and σ2 disagree. In addition, since at least one substring [formula] of σ2 becomes [formula] with [formula] under the action of [formula] provided that not all nk are equal, we conclude that [formula] of a bit string increases by at least 1 under the action of m - 1 where m is the partition number until the string becomes the forms A to F in the lemma.

To reach any one of these six forms from an arbitrary bit string σ, at most k applications of [formula] is required where [formula]. Hence, the lemma is proved. [formula]

By the lemma, we can easily deduce some preliminary results, which are summarized in Table [\ref=Thetable]. If [formula], then the case E and F cannot occur, because the number of bits in case E and F are (3n + 3)m, which is equivalent to zero modulo three. Similarly, we find that the number of bits in case A is N, which is equivalent to one modulo three, hence, [formula]. For case B, [formula]; while for case C or D, [formula].

The other cases in the table can be analysed in a similar way. For example, if N = 3q where q is not divisible by three, and if [formula], then it cannot be case E. Otherwise N = (3n + 3)m = 3(n + 1)m implies that m is not divisible by three, but [formula]. We have a contradiction.

To reach our goal of determining whether [formula] is easy for [formula] or 2. Consider the r = 1 CA rule

R5:

.

By applying this rule N times, we could turn all the zeros to ones, if there is at least an one initially. In summary, we have the following.

Theorem 1. If [formula], then for any bit string σ of N bits,

[formula]

We can, in fact, completely determine Sσ modulo three, because it could be easily constructed a sequence of CA rules which keep case A and B unchanged and evolve case C and D to alternating ones and zeros. Then, we could obtain the desired result by reading any two or three consecutive bits. Details will be reported elsewhere [\cite=thesis].

For the case N = 3q or 3pq, we have to do more work. Let us first consider the case N = 3q. Define

R6:

.

Notice that this is indeed a CA rule, in the sense that the two instructions stated in the rule are consistent with each other. Apply it once, case A and B remain unchanged, and

[formula]

Applying R⌊N / 3⌋1 to the result, we can turn case C and D to 1N, while for case E and F, we have a bit sting with both ones and zeros. Therefore, we have

[formula]

for any bit string σ of length 3q. To put the resulting bit string to the final form, we need

R7:

.

Applying this rule once, 0N remains unchanged, 1N becomes 0N and a bit string with both ones and zeros will become another also with both ones and zeros. Hence, we have the following theorem.

Theorem 2. If N = 3q, where q is not divisible by three, then for any bit string σ of N bits,

[formula]

Proof. We just have to spell out the final steps,

[formula]

[formula]

Finally, we consider the most difficult case, where N = 3pq, p > 1 and q is not divisible by three. Because the proof of the theorem is not very illuminating, we will be brief here. Define σ1 by

[formula]

We will evolve σ1 to 0N or 1N if [formula] and to a bit string with both ones and zeros if [formula].

Define σ2 be R⌊N / 3⌋3R⌊N / 3⌋1R6  σ1. It could be easily checked that 1N and 0N remain unchanged. The case C and D will be turned to 1N, while case E and F will switch to each other. We have taken care of cases C and D. They will not appear again in the following discussion.

Define

R8:

, R9:

.

R9 is the so-called traffic rule, it is just the Wolfram elementary CA rule 184 [\cite=trafficrule]. Note that R8(103n + 2)m = R8(1103n + 1)m = (11103n)m. Hence, we have merged the case E and F. If n = 0, then m must be divisible by three, and after we apply R8, we have 1N. This is exactly what we want. Now, we assume n > 0 and apply R9 twice, we have R29(11103n)m  =  (1010103n - 2)m. Similar to the argument we have given in the proof of the lemma, if we apply (R⌊N / 2⌋11R⌊N / 2⌋10)⌊N / 2⌋ to (1010103n - 2)m, we get (10n)3m, where

R10:

, R11:

.

Finally, we check that

[formula]

In the first case, we are back to case F in the lemma, but now, with m replaced by 3m. While in the second case, since n + 1 is not divisible by three and N = 3m(n + 1), we have what we expected: [formula].

We have to repeat p - 2 more times to test whether the original m is divisible by three, hence we have the following theorem.

Theorem 3. If N = 3pq, where p > 1 and q is not divisible by three, then for any bit string σ of N bits, define σ1 by Eq. ([\ref=sigmatwo]), we have

[formula]

Corollary 1. If we apply RN5R7 to the resulting bit string of Theorem 3, we will have 0N if [formula] and 1N if [formula].

Together with this corollary, we have provided a solution to the problem we stated at the beginning of this paper, namely, we could evolve any given bit string with periodic boundary conditions using a sequence of translational invariant and deterministic CA rules with parallel update to 0N if [formula] and 1N otherwise, and we could do this in O(N3) time steps.

We believe that there is no difficulty, in principle, to generalize the above result to calculate Sσ modulo four, five, or other bigger integers, although we expect the actual implementation will be tedious and complicated. If we calculate Sσ modulo k, we have found that the worst case run time for our algorithms scales as O(Nk) for k = 2,3. We do not know yet if this worst case run time estimation holds for larger k, or it will saturate at O(N3). We also do not know if there is other more efficient method. Either way, we should not underestimate the full power of cellular automata. We have shown just one of their arithmetic capability and other possibilities are under investigations.