Elementary gates for quantum computation

Charles H. Bennett IBM Research

Richard Cleve University of Calgary

David P. DiVincenzo IBM [formula]   Norman Margolus MIT

Peter Shor AT&T Bell Labs

Tycho Sleator New York Univ.

John Smolin UCLA

Harald Weinfurter  Univ. of Innsbruck

Background

It has recently been recognized, after fifty years of using the paradigms of classical physics (as embodied in the Turing machine) to build a theory of computation, that quantum physics provides another paradigm with clearly different and possibly much more powerful features than established computational theory. In quantum computation, the state of the computer is described by a state vector Ψ, which is a complex linear superposition of all binary states of the bits xm∈{0,1}:

[formula]

The state's evolution in the course of time t is described by a unitary operator U on this vector space, i.e., a linear transformation which is bijective and length-preserving. This unitary evolution on a normalized state vector is known to be the correct physical description of an isolated system evolving in time according to the laws of quantum mechanics[\cite=Dira].

Historically, the idea that the quantum mechanics of isolated systems should be studied as a new formal system for computation arose from the recognition twenty years ago that computation could be made reversible within the paradigm of classical physics. It is possible to perform any computation in a way that is reversible both logically--i.e., the computation is a sequence of bijective transformations--and thermodynamically--the computation could in principle be performed by a physical apparatus dissipating arbitrarily little energy [\cite=Ben1]. A formalism for constructing reversible Turing machines and reversible gate arrays (i.e., reversible combinational logic) was developed. Fredkin and Toffoli[\cite=Fred] showed that there exists a 3-bit "universal gate" for reversible computation, that is, a gate which, when applied in succession to different triplets of bits in a gate array, could be used to simulate any arbitrary reversible computation. (Two-bit gates like NAND which are universal for ordinary computation are not reversible.) Toffoli's version[\cite=Toff] of the universal reversible gate will figure prominently in the body of this paper.

Quantum physics is also reversible, because the reverse-time evolution specified by the unitary operator [formula] always exists; as a consequence, several workers recognized that reversible computation could be executed within a quantum-mechanical system. Quantum-mechanical Turing machines [\cite=Beni] [\cite=Pere], gate arrays [\cite=Feyn], and cellular automata [\cite=Mar1] have been discussed, and physical realizations of Toffoli's[\cite=Slea] [\cite=Bar2] [\cite=Cira] and Fredkin's[\cite=Chua1] [\cite=Yama] [\cite=Lloy] universal three-bit gates within various quantum-mechanical physical systems have been proposed.

While reversible computation is contained within quantum mechanics, it is a small subset: the time evolution of a classical reversible computer is described by unitary operators whose matrix elements are only zero or one -- arbitrary complex numbers are not allowed. Unitary time evolution can of course be simulated by a classical computer (e.g., an analog optical computer governed by Maxwell's equations)[\cite=Reck], but the dimension of the unitary operator thus attainable is bounded by the number of classical degrees of freedom--i.e., roughly proportional to the size of the apparatus. By contrast a quantum computer with m physical bits (see definition of the state above) can perform unitary operations in a space of 2m dimensions, exponentially larger than its physical size.

Deutsch[\cite=Deut] introduced a quantum Turing machine intended to generate and operate on arbitrary superpositions of states, and proposed that, aside from simulating the evolution of quantum systems more economically than known classical methods, it might also be able to solve certain classical problems--i.e., problems with a classical input and output--faster than on any classical Turing machine. In a series of artificial settings, with appropriately chosen oracles, quantum computers were shown to be qualitatively stronger than classical ones [\cite=DJ] [\cite=BB2] [\cite=simon] [\cite=BV], culminating in Shor's [\cite=Shor] [\cite=RMP] discovery of quantum polynomial time algorithms for two important natural problems, viz. factoring and discrete logarithm, for which no polynomial-time classical algorithm was known. The search for other such problems, and the physical question of the feasibility of building a quantum computer, are major topics of investigation today[\cite=Bras].

The formalism we use for quantum computation, which we call a quantum "gate array" was introduced by Deutsch [\cite=Deu2], who showed that a simple generalization of the Toffoli gate (the three-bit gate [formula], in the language introduced later in this paper) suffices as a universal gate for quantum computing. The quantum gate array is the natural quantum generalization of acyclic combinational logic "circuits" studied in conventional computational complexity theory. It consists of quantum "gates", interconnected without fanout or feedback by quantum "wires". The gates have the same number of inputs as outputs, and a gate of n inputs carries a unitary operation of the group U(2n), i.e., a generalized rotation in a Hilbert space of dimension 2n. Each wire represents a quantum bit, or qubit [\cite=Schu1] [\cite=JS94], i.e., a quantum system with a 2-dimensional Hilbert space, capable of existing in a superposition of Boolean states and of being entangled with the states of other qubits. Where there is no danger of confusion, we will use the term "bit" in either the classical or quantum sense. Just as classical bit strings can represent the discrete states of arbitrary finite dimensionality, so a string of n qubits can be used to represent quantum states in any Hilbert space of dimensionality up to 2n. The analysis of quantum Turing machines [\cite=BV] is complicated by the fact that not only the data but also the control variables, e.g., head position, can exist in a superposition of classical states. Fortunately, Yao has shown [\cite=Yao] that acyclic quantum gate arrays can simulate quantum Turing machines. Gate arrays are easier to think about, since the control variables, i.e., the wiring diagram itself and the number of steps of computation executed so far, can be thought of as classical, with only the data in the wires being quantum.

Here we derive a series of results which provide new tools for the building-up of unitary transformations from simple gates. We build on other recent results which simplify and extend Deutsch's original discovery[\cite=Deu2] of a three-bit universal quantum logic gate. As a consequence of the greater power of quantum computing as a formal system, there are many more choices for the universal gate than in classical reversible computing. In particular, DiVincenzo[\cite=Divi] showed that two-bit universal quantum gates are also possible; Barenco[\cite=Bar] extended this to show than almost any two-bit gate (within a certain restricted class) is universal, and Lloyd[\cite=Llo2] and Deutsch et al.[\cite=Deu3] have shown that in fact almost any two-bit or n-bit (n  ≥  2) gate is also universal. A closely related construction for the Fredkin gate has been given[\cite=Chau]. In the present paper we take a somewhat different tack, showing that a non-universal, classical two-bit gate, in conjunction with quantum one-bit gates, is also universal; we believe that the present work along with the preceding ones cover the full range of possible repertoires for quantum gate array construction.

With our universal-gate repertoire, we also exhibit a number of efficient schemes for building up certain classes of n-bit operations with these gates. A variety of strategies for constructing gate arrays efficiently will surely be very important for understanding the full power of quantum mechanics for computation; construction of such efficient schemes have already proved very useful for understanding the scaling of Shor's prime factorization[\cite=Copp]. In the present work we in part build upon the strategy introduced by Sleator and Weinfurter[\cite=Slea], who exhibited a scheme for obtaining the Toffoli gate with a sequence of exactly five two-bit gates. We find that their approach can be generalized and extended in a number of ways to obtain more general efficient gate constructions. Some of the results presented here have no obvious connection with previous gate-assembly schemes.

We will not touch at all on the great difficulties attendant on the actual physical realization of a quantum computer -- the problems of error correction[\cite=Bert2] and quantum coherence[\cite=Unr] [\cite=Chua] are very serious ones. We refer the reader to [\cite=RL] for a comprehensive discussion of these difficulties.

Introduction

We begin by introducing some basic ideas and notation. For any unitary

[formula]

and [formula], define the (m + 1)-bit (2(m + 1)-dimensional) operator [formula] as

[formula]

for all [formula]. (In more ordinary language, [formula] denotes the AND of the boolean variables {xk}.) Note that [formula] is equated with U. The 2(m + 1)  ×  2(m + 1) matrix corresponding to [formula] is

[formula]

(where the basis states are lexicographically ordered, i.e., [formula]).

When

[formula]

[formula] is the so-called Toffoli gate[\cite=Toff] with m + 1 input bits, which maps [formula] to [formula]. For a general U, [formula] can be regarded as a generalization of the Toffoli gate, which, on input [formula], applies U to y if and only if [formula].

As shown by one of us [\cite=Deu3] [\cite=Bar], "almost any" single [formula] gate is universal in the sense that: by successive application of this gate to pairs of bits in an n-bit network, any unitary transformation may be approximated with arbitrary accuracy. (It suffices for U to be specified by Euler angles which are not a rational multiple of π.)

We show that in some sense this result can be made even simpler, in that any unitary transformation in a network can always be constructed out of only the "classical" two-bit gate [formula] along with a set of one-bit operations (of the form [formula]). This is a remarkable result from the perspective of classical reversible computation because it is well known that the classical analogue of this assertion--which is that all invertible boolean functions can be implemented with [formula] and [formula] gates[\cite=foot1] -- is false. In fact, it is well known that only a tiny fraction of Boolean functions (those which are linear with respect to modulo 2 arithmetic) can be generated with these gates[\cite=Cop2].

We will also exhibit a number of explicit constructions of [formula] using [formula], which can all be made polynomial in m. It is well known[\cite=Toff] that the analogous family of constructions in classical reversible logic which involve building [formula] from the three-bit Toffoli gate [formula], is also polynomial in m. We will exhibit one important difference between the classical and the quantum constructions, however; Toffoli showed[\cite=Toff] that the classical [formula]'s could not be built without the presence of some "work bits" to store intermediate results of the calculation. By contrast, we show that the quantum logic gates can always be constructed with the use of no workspace whatsoever. Similar computations in the classical setting (that use very few or no work bits) appeared in the work of Cleve[\cite=Clev] and Ben-Or and Cleve[\cite=BenO]. Still, the presence of a workspace plays an important role in the quantum gate constructions -- we find that to implement a family of [formula] gates exactly, the time required for our implementation can be reduced from Θ(m2) to Θ(m) merely by the introduction of one bit for workspace.

Notation

We adopt a version of Feynman's[\cite=Feyn] notation to denote [formula] gates and Toffoli gates in quantum networks as follows.

In all the gate-array diagrams shown in this paper, time proceeds from left to right The first network contains a [formula] gate and the second one contains a 3-bit Toffoli gate[\cite=foot2]. The third and fourth networks contain a [formula] and a 2-bit reversible exclusive-or (simply called XOR henceforth) gate, respectively. The XOR gate is introduced as the "measurement gate" in [\cite=Deu2], and will play a very prominent role in many of the constructions we describe below. Throughout this paper, when we refer to a basic operation, we mean either a [formula] gate or this 2-bit XOR gate.

In all the gate-array diagrams shown in this paper, we use the usual convention that time advances from left to right, so that the left-most gate operates first, etc.

Matrix Properties

Lemma 4.1:

Proof: Since a matrix is unitary if and only if its row vectors and column vectors are orthonormal, every 2  ×  2 unitary matrix is of the form

[formula]

where δ, α, θ, and β are real-valued. The first factorization above now follows immediately. In the case of special unitary matrices, the determinant of the first matrix must be 1, which implies eiδ  =    ±  1, so the first matrix in the product can be absorbed into the second one.[formula]

Definition: In view of the above lemma, we define the following.

[formula] (a rotation by θ around ŷ[\cite=Expl]).

[formula] (a rotation by α around ẑ).

[formula] (a phase-shift with respect to δ).

[formula] (a "negation", or Pauli matrix).

[formula] (the identity matrix).

Lemma 4.2:

(θ1)  ·  (θ2)  =  (θ1  +  θ2)

(α1)  ·  (α2)  =  (α1  +  α2)

(δ1)  ·  (δ2)  =  (δ1  +  δ2)

σx  ·  σx  =  I

σx  ·  (θ)  ·  σx  =  ( - θ)

σx  ·  (α)  ·  σx  =  ( - α)

Lemma 4.3:

Proof: By Lemma 4.1, there exist α, θ, and β such that W  =  (α)  ·  (θ)  ·  (β). Set [formula], [formula], and [formula]. Then

[formula]

and

[formula]

[formula]

Two-Bit Networks

Simulation of General [formula] Gates

Lemma 5.1:

where A, B, and C ∈SU(2), if and only if W∈SU(2).

Proof: For the "if" part, let A, B, and C be as in Lemma 4.3. If the value of the first (top) bit is 0 then A  ·  B  ·  C  =  I is applied to the second bit. If the value of the first bit is 1 then A  ·  σx  ·  B  ·  σx  ·  C  =  W is applied to the second bit.

For the "only if" part, note that A  ·  B  ·  C  =  I must hold if the simulation is correct when the first bit is 0. Also, if the network simulates a [formula] gate then A  ·  σx  ·  B  ·  σx  ·  C  =  W. Therefore, since  det(A  ·  σx  ·  B  ·  σx  ·  C) = 1, W must also be special unitary.[formula]

Lemma 5.2:

where E is unitary.

Proof: Let

[formula]

Then the observation is that the 4  ×  4 unitary matrix corresponding to each of the above networks is

[formula]

[formula]

Clearly, [formula] composed with [formula] yields [formula]. Thus, by noting that any unitary matrix U is of the form U  =  S  ·  W, where S  =  (δ) (for some δ) and W is ∈SU(2), we obtain the following.

Corollary 5.3:

Special Cases

In Section 5.1, we have established a general simulation of a [formula] gate for an arbitrary unitary U. For special cases of U that may be of interest, a more efficient construction than that of Corollary 5.3 is possible. Clearly, Lemma 5.1 immediately yields a more efficient simulation for all special unitary matrices. For example, the "x-axis rotation matrix" (to use the language suggested by the mapping between SU(2) and SO(3), the group of rigid-body rotations[\cite=Expl])

[formula]

is special unitary. (Rx is of special interest because [formula] is the "Deutsch gate"[\cite=Deu2], which was shown to be universal for quantum logic.) For other specific SU(2) matrices an even more efficient simulation is possible.

Lemma 5.4:

where A and B ∈SU(2) if and only if W is of the form

[formula]

where α and θ are real-valued.

Proof: For the "if" part, consider the simulation of [formula] that arises in Lemma 5.1 when W  =  (α)  ·  (θ)  ·  (α). In this case, [formula], [formula] and C  =  I. Thus, [formula] and C can be omitted.

For the "only if" part, note that [formula] must hold for the simulation to be valid when when the first bit is 0. Therefore, if the first bit is 1 then [formula] is applied to the second bit. Now, the matrix [formula] has determinant - 1 and is traceless (since its trace is the same as that of σx). By specializing the characterization of unitary matrices in Lemma 4.1 to traceless matrices with determinant - 1, we conclude that [formula] must be of the form

[formula]

Therefore,

[formula]

as required.[formula]

Examples of matrices of the form of Lemma 5.4 are (θ) itself, as well as [formula]. However, Rx(θ) is not of this form.

Finally, for certain U, we obtain an even greater simplification of the simulation of [formula] gates.

Lemma 5.5:

where A and B are unitary if and only if V is of the form

[formula]

where α and θ are real-valued.

Proof: If an additional [formula] is appended to the end of the network in Lemma 5.4 then, the network is equivalent to that above (since [formula] is an involution), and also simulates a [formula] gate (since [formula] composed with [formula] is [formula]).[formula]

Examples of matrices of the form of Lemma 5.5 are the Pauli matrices

[formula]

and

[formula]

(as well as σx itself).

Lemma 5.5 permits an immediate generalization of Corollary 5.3:

Corollary 5.6:

A particular feature of the [formula] gates is that they are symmetric with respect to their input bits. In view of this, as well as for future reference, we introduce the following special notation for [formula] gates.

Three-Bit Networks

Simulation of General [formula] Gates

Lemma 6.1:

where V is unitary.

Proof: Let V be such that V2  =  U. If the first bit or the second bit are 0 then the transformation applied to the third bit is either I or [formula]. If the first two bits are both 1 then the transformation applied to the third is V  ·  V  =  U.[formula]

Some of the intuition behind the construction in the above Lemma is that, when the first two input bits are x1 and x2, the sequence of operations performed on the third bit is: V iff x1  =  1, V iff x2  =  1, and [formula] iff [formula]. Since

[formula]

(where "+  ", "-  ", and "·  " are the ordinary arithmetic operations), the above sequence of operations is equivalent to performing V2 on the third bit iff [formula], which is the [formula] gate. (This approach generalizes to produce a simulation of [formula], for m  >  2, which is considered in Section 7.)

We can now combine Lemma 6.1 with Corollary 5.3 to obtain a simulation of [formula] using only basic gates ([formula] and [formula]). The number of these gates is reduced when it is recognized that a number of the one-bit gates can be merged and eliminated. In particular, the [formula] from the end of the simulation of the first [formula] gate, and the [formula] from the [formula] gate combine to form the identity and are eliminated entirely. This same sort of merging occurs to eliminate a [formula] gate and a [formula] gate. We arrive at the following count:

Corollary 6.2:

A noteworthy case is when U  =  σx, where we obtain a simulation of the 3-bit Toffoli gate [formula], which is the primitive gate for classical reversible logic [\cite=Toff]. Later we will use the fact that because [formula] is its own inverse, either the simulation of Lemma 6.1 or the time-reversed simulation (in which the order of the gates is reversed, and each unitary operator is replaced by its Hermitian conjugate) may be used.

Three-bit gates congruent to [formula]

We now show that more efficient simulations of three-bit gates are possible if phase shifts of the quantum states other than zero are permitted. If we define the matrix W as

[formula]

then the gates [formula] and [formula] can be regarded as being "congruent modulo phase shifts", because the latter gate differs only in that it maps |111〉 to - |110〉 (instead of |110〉). This is perfectly acceptable if the gate is part of an operation which merely mimics classical reversible computation, or if the gate is paired with another similar one to cancel out the extra phase, as is sometimes the case in reversible gate arrangements (see Corollary 7.4); however, this phase difference is dangerous in general if non-classical unitary operations appear in the computation. Gates congruent to [formula] modulo phase shifts have been previously investigated in [\cite=Smol].

The following is a more efficient simulation of a gate congruent to [formula] modulo phase shifts:

where [formula]. In the above, the "[formula]" indicates that the networks are not identical, but differ at most in the phases of their amplitudes, which are all ±  1 (the phase of the |101〉 state is reversed in this case).

An alternative simulation of a gate congruent to [formula] modulo phase shifts (whose phase shifts are identical to the previous one) is given by

where [formula].

n-Bit Networks

The technique for simulating [formula] gates in Lemma 6.1 generalizes to [formula] gates for m  >  2. For example, to simulate a [formula] gate for any unitary U, set V so that V4  =  U and then construct a network as follows.

The intuition behind this construction is similar to that behind the construction of Lemma 6.1. If the first three input bits are x1, x2, and x3 then the sequence of operations performed on the fourth bit is:

The strings on the right encode the condition for the operation V or [formula] at each step--the "1"'s indicate which input bits are involved in the condition. For an efficient implementation of [formula], these strings form a grey code sequence. Note also that the parity of each bit string determines whether to apply V or [formula]. By comparing this sequence of operations with the terms in the equation

[formula]

it can be verified that the above sequence of operations is equivalent to performing V4 on the fourth bit iff [formula], which is the [formula] gate.

The foregoing can be generalized to simulate [formula] for larger values of m.

Lemma 7.1:

We omit the proof of Lemma 7.1, but point out that it is a generalization of the n = 4 case above and based on setting V so that V2n - 2  =  U and "implementing" the identity

[formula]

with a grey-code sequence of operations.

For some specific small values of n (for n  =  ), this is the most efficient technique that we are aware of for simulating arbitrary [formula] gates as well as [formula] gates; taking account of mergers (see Corollary 6.2), the simulation requires 3  ·  2n - 1 - 4 [formula]'s and 2  ·  2n - 1 [formula]'s. However, since this number is Θ(2n), the simulation is very inefficient for large values of n. For the remainder of this section, we focus on the asymptotic growth rate of the simulations with respect to n, and show that this can be quadratic in the general case and linear in many cases of interest.

Linear Simulation of [formula] Gates on n-Bit Networks

Lemma 7.2:

(illustrated for n  =  9 and m  =  5).

Proof: Consider the group of the first 7 gates in the above network. The sixth bit (from the top) is negated iff the first two bits are 1, the seventh bit is negated iff the first three bits are 1, the eighth bit is negated iff the first four bits are 1, and the ninth bit is negated iff the first five bits are 1. Thus, the last bit is correctly set, but the three preceding bits are altered. The last 5 gates in the network reset the values of these three preceding bits.[formula]

Note that in this construction and in the ones following, although many of the bits not involved in the gate are operated upon, the gate operation is performed correctly independent of the initial state of the bits (i.e., they do not have to be "cleared" to 0 first), and they are reset to their initial values after the operations of the gate (as in the computations which occur in [\cite=BenO] and [\cite=Clev]). This fact makes constructions like the following possible.

Lemma 7.3:

(illustrated for n  =  9 and m  =  5).

Proof: By inspection.[formula]

Corollary 7.4:

Proof: First apply Lemma 7.2 with [formula] and m2  =  n  -  m1  -  1 to simulate [formula] and [formula] gates. Then combine these by Lemma 7.3 to simulate the [formula] gate. Then, each [formula] gate in the above simulation may be simulated by a set of basic operations (as in Corollary 6.2). We find that almost all of these Toffoli gates need only to be simulated modulo phase factors as in Sec. 6.2; in particular, only 4 of the Toffoli gates, the ones which involve the last bit in the diagram above, need to be simulated exactly according to the construction of Corollary 6.2. Thus these 4 gates are simulated by 16 basic operations, while the other 8n - 36 Toffoli gates are simulated in just 6 basic operations. A careful accounting of the mergers of [formula] gates which are then possible leads to the total count of basic operations given above. [formula]

The above constructions, though asymptotically efficient, requires at least one "extra" bit, in that an n-bit network is required to simulate the (n - 1)-bit gate [formula]. In the next subsection, we shall show how to construct [formula] for an arbitrary unitary U using a quadratic number of basic operations on an n-bit network, which includes the n-bit Toffoli gate [formula] as a special case.

Quadratic Simulation of General [formula] Gates on n-Bit Networks

Lemma 7.5:

(illustrated for n  =  9), where V is unitary.

Proof: The proof is very similar to that of Lemma 6.1, setting V so that V2  =  U.[formula]

Corollary 7.6:

Proof: This is a recursive application of Lemma 7.5. Let Cn - 1 denote the cost of simulating a [formula] (for an arbitrary U). Consider the simulation in Lemma 7.5. The cost of simulating the [formula] and [formula] gates is Θ(1) (by Corollary 5.3). The cost of simulating the two [formula] gates is Θ(n) (by Corollary 7.4). The cost of simulating the [formula] gate (by a recursive application of Lemma 7.5) is Cn - 2. Therefore, Cn - 1 satisfies a recurrence of the form

[formula]

which implies that Cn - 1∈Θ(n2).[formula]

In fact, we find that using the gate-counting mentioned in Corollary 7.4, the number of basic operations is 48n2 + O(n).

Although Corollary 7.6 is significant in that it permits any [formula] to be simulated with "polynomial complexity", the question remains as to whether a subquadratic simulation is possible. The following is an Ω(n) lower bound on this complexity.

Lemma 7.7:

Proof: Consider any n-bit network with arbitrarily many 1-bit gates and fewer than n - 1 [formula] gates. Call two bits adjacent if there there is a [formula] gate between them, and connected if there is a sequence of consecutively adjacent bits between them. Since there are fewer than n - 1 [formula] gates, it must be possible to partition the bits into two nonempty sets A and B such that no bit in A is connected to any bit in B. This implies that the unitary transformation associated with the network is of the form [formula], where A is 2|A|-dimensional and B is 2|B|-dimensional. Since the transformation [formula] is not of this form, the network cannot compute [formula].[formula]

It is conceivable that a linear size simulation of [formula] gates is possible. Although we cannot show this presently, in the remaining subsections, we show that something "similar" (in a number of different senses) to a linear size simulation of [formula] gates is possible.

Linear Approximate Simulation of General [formula] Gates on n-Bit Networks

Definition: We say that one network approximates another one within ε if the distance (induced by the Euclidean vector norm) between the unitary transformations associated with the two networks is at most ε.

This notion of approximation in the context of reducing the complexity of quantum computations was introduced by Coppersmith[\cite=Copp], and is useful for the following reason. Suppose that two networks that are approximately the same (in the above sense) are executed with identical inputs and their outputs are observed. Then the probability distributions of the two outcomes will be approximately the same in the sense that, for any event, its probability will differ by at most 2ε between the two networks.

Lemma 7.8:

Proof: The idea is to apply Lemma 7.5 recursively as in Corollary 7.6, but to observe that, with suitable choices for V, the recurrence can be terminated after [formula] levels.

Since U is unitary, there exist unitary matrices P and D, such that [formula] and

[formula]

where d1 and d2 are real. eid1 and eid2 are the eigenvalues of U. If Vk is the matrix used in the [formula] recursive application of Lemma 7.3 ([formula]) then it is sufficient that V2k + 1  =  Vk for each [formula]. Thus, it suffices to set [formula], where

[formula]

for each [formula]. Note that then

[formula]

Therefore, if the recursion is terminated after [formula] steps then the discrepancy between what the resulting network computes and [formula] is an (n - k)-bit transformation of the form [formula]. Since [formula], the network approximates [formula] within ε.[formula]

Linear Simulation in Special Cases

Lemma 7.9:

where A, B, and C ∈SU(2).

Proof: The proof is very similar to that of Lemma 5.1, referring to Lemma 4.3.[formula]

Combining Lemma 7.9 with Corollary 7.4, we obtain the following.

Corollary 7.10:

As in Section 5, a noteworthy example is when

[formula]

In this case, we obtain a linear simulation of a transformation congruent modulo phase shifts to the n-bit Toffoli gate [formula].

Linear Simulation of General [formula] Gates on n-Bit Networks With One Bit Fixed

Lemma 7.11:

(illustrated for n = 9), where the initial value of one bit (the second to last) is fixed at 0 (and it incurs no net change).

Proof: By inspection.[formula]

Combining Lemma 7.11 with Corollary 7.4, we obtain the following.

Corollary 7.12:

Note that the "extra" bit above may be reused in the course of several simulations of [formula] gates.

Efficient general gate constructions

In this final discussion we will change the ground rules slightly by considering the "basic operation" to be any two-bit operation. This may or may not be a physically reasonable choice in various particular implementations of quantum computing, but for the moment this should be considered as just a mathematical convenience which will permit us to address somewhat more general questions than the ones considered above. When the arbitrary two-bit gate is taken as the basic operation, then as we have seen, 5 operations suffice to produce the Toffoli gate (recall Lemma 6.1), 3 produce the Toffoli gate modulo phases (we permit a merging of the operations in the construction of Sec. 6.2), and 13 can be used to produce the 4-bit Toffoli gate (see Lemma 7.1). In no case do we have a proof that this is the most economical method for producing each of these functions; however, for most of these examples we have compelling evidence from numerical study that these are in fact minimal[\cite=Smol].

In the course of doing these numerical investigations we discovered a number of interesting additional facts about two-bit gate constructions. It is natural to ask, how many two-bit gates are required to perform any arbitrary three-bit unitary operation, if the two-bit gates were permitted to implement any member of U(4)? The answer is six, as in the gate arrangement shown here.

We find an interesting regularity in how the U(8) operation is built up by this sequence of gates, which is summarized by the "dimensionalities" shown in the diagram. The first U(4) operation has 42 = 16 free angle parameters; this is the dimensionality of the space accessible with a single gate, as indicated. With the second gate, this dimensionality increases only by 12, to 28. It does not double to 32, for two reasons. First, there is a single global phase shared by the two gates. Second, there is a set of operations acting only on the bit shared by the two gates, which accounts for the additional reduction of 3. Formally, this is summarized by noting that 12 is the dimension of the coset space SU(4)/SU(2). The action of the third gate increases the dimensionality by another 9 = 16 - 1 - 3 - 3. 9 is the dimension of the coset space SU(4)/SU(2)×  SU(2). The further subtraction by 3 results from the duplication of one-bit operations on both bits of the added gate. At this point the dimensionality increases by nine for each succeeding gate, until the dimensionality reaches exactly 64, the dimension of U(8), at the sixth gate. In preliminary tests on four-bit operations, we found that the same rules for the increase of dimensionality applied. This permits us to make a conjecture, just based on dimension counting, of a lower bound on the number of two-bit gates required to produce an arbitrary n-bit unitary transformation: [formula]. It is clear that "almost all" unitary transformations will be computationally uninteresting, since they will require exponentially many operations to implement.

Finally, we mention that by combining the quantum gate constructions introduced here with the decomposition formulas for unitary matrices as used by Reck al.[\cite=Reck], an explicit, exact simulation of any unitary operator on n bits can be constructed using a finite number (Θ(n34n)) of two-bit gates, and using no work bits. In outline, the procedure is as follows: Reck et al.[\cite=Reck] note that a formula exists for the decomposition of any unitary matrix into matrices only involving a U(2) operation acting in the space of pairs of states (not bits):

[formula]

T(x1,x2) performs a U(2) rotation involving the two basis states x1 and x2, and leaves all other states unchanged; D is a diagonal matrix involving only phase factors, and thus can also be thought of as a product of 2n - 1 matrices which perform rotations in two-dimensional subspaces. Using the methods introduced above, each T(x1,x2) can be simulated in polynomial time, as follows: write a grey code connecting x1 and x2; for example, if n = 8, x1 = 00111010, and x2 = 00100111:

Operations involving adjacent steps in this grey code require a simple modification of the [formula] gates introduced earlier. The (n - 1) control bits which remain unchanged are not all 1 as in our earlier constructions, but they can be made so temporarily by the appropriate use of "NOT" gates ([formula]) before and after the application of the [formula] operation. Now, the desired T(x1,x2) operation is constructed as follows: first, permute states down through the grey code, performing the permutations (1,2), (2,3), (3,4), ... (m-2,m-1). These numbers refer to the grey code elements as in the table above, where m, the number of elements in the grey code, is 5 in the example. Each of these permutations is accomplished by a modified [formula]. Second, the desired U(2) rotation is performed by applying a modified [formula] involving the states (m - 1) and (m). Third, the permutations are undone in reverse order: (m-2,m-1), (m-3,m-2), ... (2,3), (1,2).

The number of basic operations to perform all these steps may be easily estimated. Each T(x1,x2) involves 2m - 3 (modified) [formula] gates, each of which can be done in Θ(n2) operations. Since m, the number of elements in the grey code sequence, cannot exceed n + 1, the number of operations to simulate T(x1,x2) is Θ(n3). There are O(4n) T's in the product above, so the total number of basic operations to simulate any U(2n) matrix exactly is Θ(n34n). (The number of steps to simulate the D matrix is smaller and does not affect the count.) So, we see that this strict upper bound differs only by a polynomial factor (which likely can be made better than n3) from the expected lower bound quoted earlier, so this Reck procedure is relatively "efficient" (if something which scales exponentially may be termed so). A serious problem with this procedure is that it is extremely unlikely, so far as we can tell, to provide a polynomial-time simulation of those special U(2n) which permit it, which of course are exactly the ones which are of most interest in quantum computation. It still remains to find a truly efficient and useful design methodology for quantum gate construction.

Acknowledgments

We are very grateful to H.-F. Chau, D. Coppersmith, D. Deutsch, A. Ekert and T. Toffoli for helpful discussions. We are also most happy to thank the Institute for Scientific Interchange in Torino, and its director Professor Mario Rasetti, for making possible the workshop on quantum computation in October, 1994, at which much of this work was performed. A. B. thanks the financial support of the Berrow's fund in Lincoln College (Oxford).