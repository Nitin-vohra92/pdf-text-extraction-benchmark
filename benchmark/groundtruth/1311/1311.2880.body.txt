Aircraft Landing Problem:Efficient Algorithm for a Given Landing Sequence

Introduction

Prior to landing, an aircraft must go through an approaching stage directed by the air traffic control (ATC) tower. The ATC gives instructions to the aircraft regarding to the runway, speed and altitude of the aircraft in order to align it with the allocated runway and maintain the safety distance with its preceding aircraft. During peak hours, controllers must handle safely and effectively landings of a continuous flow of aircraft entering the radar range onto the assigned runway(s). The capacity of runways is highly constrained and this makes the scheduling of landings a difficult task to perform effectively. Increasing the capacity of an airport by building new runways is an expensive and difficult affair. Hence, the air traffic controllers face the problem of allocating a landing sequence and landing times to the aircraft in the radar range. Additionally, in case of airports with multiple runways, they have to take a decision on the runway allotment too, i.e. which aircraft lands on which runway. These decisions are made with the availability of certain information about the aircraft in the radar range [\cite=krishna] [\cite=earnst] [\cite=pinol]. A target landing time is defined as the time at which an aircraft can land if it flies straight to the runway at its cruise speed (most economical). This target landing time is bounded by an earliest landing time and a latest landing time known as the time window. The earliest landing time is determined as the time at which an aircraft can land if it flies straight to the runway at its fastest speed with no holding, and the latest landing time is determined as the time at which an aircraft can land after it is held for its maximal allowable time before landing. All the aircraft have to land within their time window and there are asymmetric penalties associated with each aircraft for landing earlier or later than its target landing time. Besides, there is another constraint of the safety distance that has to be maintained by any aircraft with its preceding aircraft. This separation is necessary as every aircraft creates a wake vortices at its rear and can cause a serious aerodynamic instability to a closely following aircraft. There are several types of planes which land on a runway hence the safety distance between any two aircraft depends on their types. This safety distance between any two aircraft can be easily converted to a safety time by considering the required separation and their relative speeds. If several runways are available for landing, the application of this constraint for aircraft landing on different runways usually depends upon the relative positions of the runways [\cite=krishna] [\cite=earnst] [\cite=pinol]. A formal definition of the ALP is given in Section [\ref=probform].

The objective of the ALP is to minimize the total penalty incurred due to the deviation of the scheduled landing times of all the aircraft with their target landing times. Hence, the air traffic controllers not only have to find suitable landing times for all the aircraft but also a landing sequence so as to reduce the total penalty. This work considers the static case of the aircraft landing problem where the set of aircraft that are waiting to land is already known. For a special but practically very common case of the safety constraint, we present a polynomially bound exact algorithm for optimizing any given feasible landing sequence for the single runway case and an effective strategy for the multiple runway case. In the later part of the paper we present our results for all the benchmark instances provided by Beasley [\cite=beasley1] and compare the results with previous work on this problem.

Related Work

The aircraft landing problem described in this paper was first introduced and studied by Beasley in the mid-nineties [\cite=firstalp]. Since then, it has been studied by several researchers using different metaheuristics, hybrid metaheuristics, linear programming, variants of exact branch and bound algorithms etc., for both the static and dynamic cases of the problem. In 1995, Beasley et al. presented a mixed-integer zero-one formulation of the problem for the single runway case and later extended it to the multiple runway case [\cite=firstalp]. The ALP was studied for up to 50 aircraft with multiple runways using linear programming based tree search and an effective heuristic algorithm for the problem. Again in 1995, Abela et al. [\cite=abela] proposed a genetic algorithm and a branch and bound algorithm to solve the problem of scheduling aircraft landings. Ernst et al. presented a simplex algorithm which evaluated the landing times based on some partial ordering information. This method was used in a problem space search heuristic as well as a branch-and-bound method for both, the single and multiple runway case, for again up to 50 aircraft [\cite=earnst]. Beasley et al. adopted similar methodologies and presented extended results [\cite=krishna]. In 1998, Ciesielski et al. developed a real time algorithm for the aircraft landings using a genetic algorithm and performed experiments on landing data for the Sydney airport on the busiest day of the year [\cite=paul]. In 2001, Beasley et al. developed a population heuristic and implemented it on actual operational data related to aircraft landings at the London Heathrow airport [\cite=beasley]. The dynamic case of the ALP was studied again by Beasley et al. by expressing it as a displacement problem and using heuristics and linear programming [\cite=beasleyDis]. In 2006, Pinol and Beasley presented two heuristic techniques, Scatter Search and the Bionomic Algorithm and published results for the available test problems involving up to 500 aircraft and 5 runways [\cite=pinol]. The dynamic case of the problem for the single-runway case was again studied by Moser et al. in 2007 [\cite=moser]. They used extremal optimization along with a deterministic algorithm to optimize a landing sequence. In 2008 Tang et al. implemented a multi-objective evolutionary approach to simultaneously minimize the total scheduled time of arrival and the total cost incurred [\cite=tang]. In 2009, Bencheikh et al. approached the ALP using hybrid methods combining genetic algorithms and ant colony optimization by formulating the problem as a job shop scheduling problem [\cite=bencheikh2]. The same authors presented an ant colony algorithm along with a new heuristic to adjust the landing times of the aircraft in a given landing sequence in order to reduce the total penalty cost, in 2011 [\cite=bencheikh]. In 2012, a hybrid meta-heuristic algorithm was suggested using simulated annealing with variable neighbourhood search and variable neighbourhood descent [\cite=salehipour].

Problem Formulation

In this section we give the mathematical formulation of the static aircraft landing problem based on [\cite=pinol]. We also define some new parameters which are later used in the presented algorithm in the next sections.

Let, N = the number of aircraft, Ei = the earliest landing time for aircraft i, [formula], Li = the latest landing time for aircraft i, [formula], Ti = the target landing time for aircraft i, [formula], STi = the scheduled landing time for aircraft i, Si,j = the required separation time between planes i and j, where plane i lands before plane j on the same runway, i  ≠  j, si,j = the required separation time between planes i and j, where plane i lands before plane j on different runways, i  ≠  j, gi = the penalty cost per time unit associated with plane i for landing before Ti, hi = the penalty cost per time unit associated with plane i for landing after Ti, αi = earliness (time) of plane i from Ti, αi  =   max {0,Ti - STi}, [formula], βi = tardiness (time) of plane i from Ti, βi  =   max {0,STi - Ti}, [formula] .

The total penalty corresponding to any aircraft i is then expressed as αigi  +  βihi. If aircraft i lands at its target landing time then both αi and βi are equal to zero and the cost incurred by its landing is equal to zero. However, if aircraft i does not land at Ti, either αi or βi is non-zero and there is a strictly positive cost incurred. The objective function of the problem can now be defined as

[formula]

The Exact Algorithm

In this section we present our exact polynomial algorithm for the aircraft landing problem with a special case of the safety constraint for the single runway case. Before stating the algorithm we first present some new parameters, definitions and lemmas which are useful for its explanation. We first define Di as the algebraic deviation of the scheduled landing time of plane i from its target landing time, Di  =  STi - Ti, [formula]. We also define ESi as the minimum of extra separation times maintained between plane i and all its preceding planes, and the deviation from its earliest landing time, for i > 1. For i = 1 we define ESi as the deviation of its scheduled landing time with its earliest landing time, as there are no planes landing before the first plane. Mathematically, ESi can be written as

[formula]

where,

[formula]

Here, SPi is the time at which an aircraft i can land maintaining the safety constraint with all its preceding planes. Let P be a given landing sequence of the planes where the ith plane in this sequence is denoted by i, [formula]. Note that without loss of any generality we can assume this, since the planes can be ranked in any sequence as per their order of landing.

If the initial assignment of the landing times of all the aircraft in any landing sequence for a single runway is done according to STi, where

[formula]

where,

[formula]

then the optimal solution can be obtained only by reducing the landing times of the aircraft while respecting the constraints or leaving the landing times unchanged.

Equation [\eqref=lemma1] schedules the landing times of the aircraft in the reverse order starting from the last plane to the first plane in the landing sequence. The last plane is assigned a landing at its latest landing time LN and any of the preceding planes are assigned as late as possible from their target landing time, while maintaining the safety distance constraint. This is ensured by min {PSi,Li}, where Li is the latest landing time of aircraft i and PSi is the closet landing time possible for aircraft i to all its following aircraft. We define PSi as [formula] where any plane i maintains the safety distance with all its following planes.

If any of the aircraft lands outside its time window with this assignment, then it shows that this landing sequence in infeasible. Since the landings times are assigned as close as possible to their latest landing times, increasing the landing time of any aircraft will cause infeasibility as the last aircraft is landing at its latest landing time and all the preceding planes are scheduled as close as possible. Hence, the optimal solution can be obtained only by decreasing the landing times or leaving them unchanged if there is no reduction possible.

Given this initialization, it is possible to reduce the landing times straight away to improve the solution as is depicted in Algorithm [\ref=improve]. Let the initial landing times of the aircraft be assigned according to Equation [\eqref=lemma1] for any given feasible landing sequence. If any aircraft i with [formula], has a positive deviation Di from its target landing time and maintains a positive extra safety separation ESi, then we can decrease the landing time STi by min {Di,ESi}. The reason is, this reduction of the landing time is independent of other aircraft as we do not disturb the safety constraint and reduce the landing time of i only to bring it closer to its target landing time, which is the requirement of Equation [\eqref=ob]. If Di > ESi then we reduce the landing time by ESi so as to maintain the safety constraint and if Di < ESi then we reduce the landing time to its target landing time.

However, if the value of Di  ≤  0 for all the aircraft, then there is no improvement possible and Equation [\eqref=lemma1] is the optimal assignment for this landing sequence with respect to Equation [\eqref=ob]. Note that ESi  ≥  0 [formula] i, since the safety distance constraint is always maintained. We present this improvement of the initial landing times for the single runway case in Algorithm [\ref=improve]. We would like to point out that Algorithm [\ref=improve] will not necessarily return the optimal solution but only fetch an improvement to the initial assignment of the landing times.

Implementation of Algorithm [\ref=improve] will yield either one of the below mentioned cases for any aircraft [formula]:

[formula]

The initialization of the landing times using Equation [\eqref=lemma1] can assign the landing time to any aircraft i anywhere in its time window, if the landing sequence is feasible. Hence, we have the following five cases:

Case 1: STi  =  Ei  . If i = 1, then Di < 0 and ESi = 0 from Equation [\eqref=est]. If i > 1 then Di < 0 but we need to check for the value of ESi. According to Equation [\eqref=est], we have ESi←STi  -   max {SPi,Ei}. Note that STi  ≥  SPi, [formula] since the safety separation is always maintained between any two aircraft landing consecutively. This implies that we can write max {SPi,Ei} = STi due to the case constraint, i.e. Ei = STi. Hence, we have ESi = 0 from its definition. Since a reduction in the landing time is possible only if Di  >  0, the values of Di and ESi will remain unchanged by the implementation of Algorithm [\ref=improve], satisfying Case d.

Case 2: Ei  <  STi  <  Ti  . Di < 0 for any i, which means that the landing time for aircraft i will remain unchanged. If i = 1, then ESi > 0 from Equation [\eqref=est]. If i > 1 then again from Equation [\eqref=est] we can deduce that ESi  ≥  0 because STi  ≥  SPi (safety constraint) and STi > Ei (case constraint). This proves that if the initial landing time for any aircraft lies between Ei and Ti then Algorithm [\ref=improve] will not fetch any reduction hence satisfying Case d or e of Lemma [\ref=2lemma].

Case 3: STi  =  Ti  . Di = 0 for any i since the landing occurs at the target landing time. And ESi  ≥  0 for any i, by the same reasons as in Case 2. In this case as well there will be no reduction and Case b or c of Lemma [\ref=2lemma] is satisfied.

Case 4: Ti  <  STi  <  Li  . If the initial landing time for any aircraft i lies between Ti and Li, then Di > 0 by definition and ESi  ≥  0 because STi > Ei and STi  ≥  SPi. Hence, Algorithm [\ref=improve] will reduce the landing time of plane i by min {Di,ESi}. If min {Di,ESi} = Di then the reduction in the landing time will fetch Di = 0 and ESi > 0, satisfying Case b. If min {Di,ESi} = ESi then the reduction in the landing time will fetch Di > 0 and ESi = 0, satisfying Case a. However, if after the initialization the values of Di and ESi are equal then the implementation of Algorithm [\ref=improve] will fetch Di = 0 and ESi = 0, satisfying Case c. Finally, if ESi = 0 then there will be effectively no reduction because min {Di,ESi} will be equal to zero and Case a of Lemma [\ref=2lemma] will be satisfied.

Case 5: STi  =  Li  . Di > 0 and ESi > 0 after the initialization and yet again the Algorithm [\ref=improve] will fetch either one of Case a, b or c, with the same arguments as in Case 4.

We now give some additional definitions necessary for the understanding of our main algorithm.

PL is a vector of length N and any element of PL (PLi) is the net penalty possessed by any aircraft i, [formula]. We define PLi, [formula], as

[formula]

With the above definition we can now express the objective function stated in Equation [\eqref=ob] in a compact form as

[formula]

Let i be any aircraft landing at STi then we define σ(i) as the algebraic deviation of the landing time of aircraft i from its earliest landing time Ei. Mathematically, σ(i) = STi - Ei, [formula].

Let aircraft [formula] be the aircraft in any given sequence which land consecutively in this order on the same runway, we define μ such that μ is the last plane in [formula] with Dμ  ≤  0.

We define [formula] as the sets of aircraft which land consecutively, where c is the total number of sets in [formula] and [formula]. And for any set [formula], where the aircraft [formula] land one after another consecutively on the same runway, the following properties hold:

[formula]

We define SNG(Xi:j) as the smallest non-negative number in vector X from elements Xi to Xj, (i < j).

With the above concepts and definitions we present our main algorithm (Algorithm [\ref=main]) for optimizing a given landing sequence P on a single runway for the special case of the ALP when the safety constraint for any aircraft is to be maintained only with its preceding plane. In other words, when SPi = STi - 1 + Si - 1,i and PSi = STi + 1 - Si,i + 1. For the general case of the safety constraint the algorithm still returns a feasible solution but not necessarily optimal. Later we show with our results that this special case of the safety constraint holds for several instances and we obtain optimum results for many instances. Moreover we also obtain better results than the best known solutions for several instances.

Proof of Optimality

Algorithm [\ref=main] returns the optimal value for Equation [\eqref=obn] for any given feasible landing sequence on a single runway when SPi = STi - 1 + Si - 1,i for [formula] and PSi = STi + 1 - Si,i + 1 for [formula].

The initialization of the landing times for any sequence is done according to Lemma [\ref=1lemma]. It allocates the landing times as late as possible, hence the solution can be improved only by reducing the landing times. Thereafter we show that for any aircraft i we can reduce its landing time straight away, independent of other aircraft, if Di > 0 and ESi > 0. The reason is, if there is an extra safety separation between i  -  1 and i as well as a positive deviation from the target landing time, then the reduction of STi by min {Di,ESi} will bring aircraft i closer to Ti and hence yield an overall reduction in the total weighted tardiness thereby improving the overall solution. Note that this reduction will neither cause any aircraft to land earlier than its target landing time nor will it disrupt the safety separation. The implementation of Algorithm [\ref=improve] will fetch one of the five possibilities to all the aircraft, mentioned and proved in Lemma [\ref=2lemma].

The next step is to prove that a further improvement to the solution is possible iff [formula]. If [formula], then we have ESik > 0, [formula], [formula], σ(ρ) > 0 where ρ are all the planes in the set [formula] and [formula], if μ exists. We have ESik > 0 and [formula]. Reducing the landing time of any aircraft in m will cause infeasibility as it will disrupt the safety constraint since ESm = 0. But reducing the landing times of all the aircraft from ik to jk by [formula] will not cause any infeasibility for two reasons. First, the definition of [formula] ensures that all the planes have a positive deviation from their earliest landing times since σ(ρ) > 0 and the reduction of the landing times by pos will not cause any infeasibility since all the aircraft in set [formula] will be allocated a landing time within their time window since pos  ≤  γ. Second, we would reduce all the landing times by the same amount and not more than ESik. This will maintain the safety separation between all the aircraft in [formula] and also the required separation between aircraft ik  -  1 and ik.

Notice that PLρ is the net penalty of aircraft ρ as stated in Definition [\ref=pl]. Hence a positive value for the summation of the net penalties of aircraft ik to jk landing consecutively means, that the total tardiness penalty is higher than the total earliness penalty and an increase in the landing times of all the aircraft in [formula] by the same amount is only going to worsen the solution. As for μ, let's say there exists a μ for the set [formula] such that [formula]. This shows that aircraft μ to jk already possess a net earliness penalty and further reducing their landing times will fetch an increase in the overall penalty. However, [formula] means that [formula] which implies that aircraft ik to μ  -  1 possess a net positive tardiness penalty. Thus, a reduction in landing times by min (SNG(Dik:μ  -  1),ESik,γ) will reduce the total weighted tardiness as well as ensure that the increase in the earliness penalty (if any) of aircraft ik to μ  -  1 does not exceed the reduction in the net tardiness penalty and thereby reducing the overall penalty. In such a case [formula] will become (ik:μ  -  1).

Conversely, if [formula], then either one of the cases will not hold in Definition [\ref=rsa]. We prove this by contradiction for all these cases:

Case 1: ESik  >  0  . If ESik  =  0 and all the other conditions hold then there is no scope of reduction and an increase in the landing times will only worsen the solution. Note that ESik will never be negative, for any ik, [formula].

Case 2: [formula] If [formula] then we have two cases. One, if for some m, ESm < 0, then the solution is infeasible. Second, if for some m, ESm > 0 then it contradicts the definition of [formula].

Case 3: [formula] If the value of σ(ρ)  =  0, then a reduction of the landing times for all the planes in the set [formula] by any positive value will make the solution infeasible since the aircraft ρ is already landing at its earliest landing time. Note that the value of σ(ρ) cannot be negative for any aircraft ρ at any stage.

Case 4: [formula] If [formula] for any plane ρ, then any change to the landing times of all the aircraft in [formula] will only worsen the solution by increasing the total lateness penalty or the total earliness penalty. If [formula], then the reduction of landing times is again going to worsen the solution as the total earliness penalty is already higher than the total lateness penalty. Moreover, an increase in the landing time is not good either, because it will only take us back to an earlier step where [formula].

If [formula] then pos exists and pos > 0.

From Algorithm [\ref=main] we have, [formula]. So pos will exist with a positive value only if [formula], ESik > 0 and γ > 0. Clearly, ESik > 0 from the definition of [formula]. Besides, ESm  =  0 for [formula] and [formula] again from Equation [\eqref=rsa]. Note that we proved in Lemma [\ref=2lemma] that if ESi = 0 for any [formula] then Di  ≤  0. Moreover, [formula] shows that for at least one aircraft m in the [formula] has PLm > 0. Recall from Equation [\eqref=pl] that for any aircraft m, PLm > 0 only if Dm > 0. Thus we have ESik > 0 and Dm > 0 at least for one aircraft m, where [formula]. Furthermore, if [formula] then obviously γ > 0 since the [formula] and σ(ρ) > 0 for all the aircraft in the set [formula] from Equation [\eqref=eqrsa]. Hence, this proves that pos will exist and will be greater than zero if [formula].

We reduce the landing times by [formula] because this will neither disrupt the safety constraint nor cause infeasibility. Besides, this will not alter the number of planes arriving early (Dm < 0). If we reduce the landing times by a greater quantity we will certainly reduce the lateness penalty but we might as well end up increasing the earliness penalty by a greater amount. Hence we do not want to change the number of planes arriving early. Notice that a reduction in the landing time for aircraft jk by pos means that it will increase the extra safety separation between jk and jk  +  1, which is why we have line 14 in Algorithm [\ref=main]. Hence, to summarize, Algorithm [\ref=main] allocates the latest possible initial landing times to all the aircraft and then makes improvements to the solution at every step until there is no improvement possible.

Multiple Runways

In this section we propose an effective approach for allocating the runways to all the aircraft in a given landing sequence. We do not prove the optimality of this approach but our results show that it is an effective strategy and performs better than other approaches mentioned in the literature. In the multiple runway case the only difference is the initial assignment of the runways to all the aircraft in a given sequence. We propose an initialization algorithm for the multiple runway case which again takes the input as a landing sequence of planes waiting to land and the number of runways R at the airport. We make an assumption as in [\cite=pinol], that if aircraft i and j land on different runways then Si,j = 0. Proposition [\eqref=prop] assigns the appropriate runway to all the aircraft and the landing sequence on each runway. Let [formula] be the sequence of planes on runway [formula] and nr be the number of planes landing on runway r.

Assign the first R air planes [formula], one on each runway at their respective target landing times. For any following aircraft [formula] assign the same runway as i  -  1 at a landing time of Ti if Ti is greater than or equal to the allowed landing time for plane i by maintaining the safety distance constraint with all the preceding aircraft on the same runway. Otherwise, assign a runway r at Ti which offers zero deviation from Ti. If none of the above two conditions hold then select a runway which gives the least feasible positive deviation to plane i from its target landing time.

Here we make an obvious assumption that the number of air planes waiting to land is more than the number of runways present at the airport. The landing sequence in this proposition is maintained in the sense that any aircraft i does not land before i  -  1 lands. Once we have this assignment of aircraft to runways, each runway has a fixed number of planes landing in a known sequence. Using this to our benefit, we can now apply Algorithm [\ref=main] to each runway separately. We would mention here that in this work we assume the safety separation time between aircraft landing on different runways to be equal to zero, i.e. [formula], where r and [formula] are two different runways. This assumption was also considered by Pinol et al. in [\cite=pinol].

Algorithm Run-Time Complexity

The run-time complexity of Algorithm [\ref=main] is O(N3) where N is the total number of aircraft.

Calculation of [formula] requires finding all the sets of planes landing consecutively, such that they hold certain properties as mentioned in Equation [\eqref=eqrsa]. The worst case scenario for the calculation of [formula] will occur when every aircraft lies in one of the sets of [formula]. Let any set [formula] has xk aircraft where [formula], then we have, [formula], since all the sets of [formula] are disjoint. The run-time for the calculating and checking the first four properties of any set [formula] is O(xk). However the computation of μ and checking [formula] requires a computation of all the prior properties, if μ exists. In the worst case the value of jk will drop down to ik + 1 and this would require a total run-time of O(x2k) where xk is the number of aircraft in the set [formula] obtained initially by the computation of the first four properties in Equation [\eqref=eqrsa]. Let T be the run-time of the computation of all the sets of [formula]. Since all the properties are calculated in a sequential manner, we have, [formula]. Besides, xk > 0 for [formula], we can write [formula]. Now using [formula] we get T = O(N2). It is straight forward to observe that the complexity of Algorithm [\ref=improve] is O(N2) due to the calculations of ST and ES. The computation of PL and Sol in Algorithm [\ref=main] are both of O(N) each. The while loop in line 4 involves several iterations so we first study the run-time of a single iteration of the while loop. The for loop in line 5 is run for the number of sets in [formula]. Hence, the total run-time of the for loop is [formula], which is again equal to O(N). The next steps inside the while loop involve the computation of Sol with a run-time of O(N) and all the sets of [formula] which requires O(N2) run-time each at every iteration. Since the computation of Sol and [formula] is carried out sequentially, the total run-time complexity of the algorithm is basically equal to O(λN2), where λ is the number of times the while loop is iterated. Clearly, the maximum value of λ can be equal to the maximum number of aircraft in any set [formula], which is equal to the total number of aircraft N. Hence the run-time complexity of Algorithm [\ref=main] is O(N3).

Results

We now present our results for the aircraft landing problem with single and multiple runways for the benchmark instances provided by Beasley [\cite=beasley1]. We implement the algorithm as described above to find the optimal solution for the special case of the ALP in conjunction with Simulated Annealing (SA). We use a slightly modified Simulated Annealing algorithm to generate the landing sequences and Algorithm [\ref=main] to optimize each sequence to its minimum penalty. The ensemble size for SA is taken to be 20 for all the instances. The initial temperature is kept as twice the standard deviation of the energy at infinite temperature: [formula]. We estimate this quantity by randomly sampling the configuration space [\cite=salamon]. An exponential schedule for cooling is adopted with a cooling rate of 0.999. One of the modifications from the standard SA is in the acceptance criterion. We implement two acceptance criteria: the Metropolis acceptance probability, [formula] [\cite=salamon] and a constant acceptance probability of 0.07. A solution is accepted with this constant probability if it is rejected by the Metropolis criterion. This concept of a constant probability is useful when the SA is run for many iterations and the metropolis acceptance probability is almost zero, since the temperature would become infinitesimally small.

Apart from this, we also incorporate elitism in our modified SA. Elitism has been successfully adopted in evolutionary algorithms for several complex optimization problems [\cite=elitist1] [\cite=elitist2]. As for the perturbation rule, we first randomly select a certain number of aircraft in any given landing sequence and permute them randomly to create a new sequence. The number of planes selected for this permutation is taken as [formula], where N is the number of aircraft. For large instances the size of this permutation is quite small but we have observed that it works well with our modified simulated annealing algorithm. We take the initial landing sequence for our algorithm as the sequence as per their target landing times.

All the computations were carried out in MATLAB on a 1.73 GHz machine with 2 GB RAM. To better explain and compare our results we first define some new parameters used in Table [\ref=result1] and [\ref=result2]. Most of these parameters are derived from Pinol et al. [\cite=pinol] with slight changes as explained below.

Let, [formula] = the value of the optimal solution, [formula] = the best known solutions for ALP provided in [\cite=pinol], [formula] = the best solutions obtained in [\cite=pinol] using Scatter Search (SCS), [formula] = the best solutions obtained in [\cite=pinol] using the Bionomic Algorithm (BA), [formula] = the best solutions obtained in this work, [formula] = the average run-time in seconds over 10 replications, [formula] = percentage gap between the best obtained results and [formula] if the optimal solution known and [formula] if the optimal solution is not known.

[formula] is defined as [formula] =   100 ·   ([formula]; if the optimal solution is known then [formula]. However, if [formula] we follow the same notation as assumed in [\cite=pinol]. If [formula], then the value of [formula] if the best solution obtained is also zero and n/d (not defined) if the best solution obtained is greater than zero. This definition of [formula] is the same as explained by Pinol et al. [\cite=pinol]. If for any instance the result obtained by us is better than the best known solution then we denote [formula] by an asterisk (*). The values of [formula] are the best results obtained by Pinol et al. [\cite=pinol] during the course of their work. The results shown in Table [\ref=result1] and [\ref=result2] are obtained by using Algorithm [\ref=main], Proposition [\ref=prop] and simulated annealing depending on single or multiple runways. For the single runway case we use simulated annealing to generate the landing sequences and Algorithm [\ref=main] to optimize each sequence. For the multiple runway case we first generate a complete landing sequence of all the aircraft using simulated annealing, allocate the aircraft and their landing sequence to each runway using Proposition [\ref=prop] and then apply Algorithm [\ref=main] to each runway separately for optimization. For brevity we call this approach PSA. It is clear from Table [\ref=result1] that our approach is much faster and finds the optimal solution for all benchmark instances except for one. The reason that the optimum is found for all other instances is that the optimal sequences for all the remaining instances hold the special case of the safety constraint, i.e., the safety constraint for any aircraft depends only on its preceding plane. However for the instance 'airland8' with 50 aircraft and a single runway, our algorithm does not return the optimal solution as the optimal landing sequence does not satisfy the special case of the safety constraint.

Nevertheless, our approach still achieves a better result than Scatter Search and the Bionomic Algorithm, with a percentage gap of just 2.31 percent from the optimal value in less than 4 seconds. The average percentage gap for our approach on all the benchmark instances is 0.09 percent as opposed to 2.1 percent and 1.7 percent for Scatter Search and the Bionomic Algorithm, respectively. Moreover the average run-time for PSA is just 0.75 seconds, which is 8 times faster than Scatter Search with 6.0 seconds and more than 12 times faster than the Bionomic Algorithm with an average run-time of 9.6 seconds. Note that Pinol et al. [\cite=pinol] implemented their algorithms using C++ on a 2 GHz Pentium PC with 512 MB memory.

Table [\ref=result2] presents our results for the large instances. The optimal solutions of these instances are unknown and hence we compare our results with the best known solutions. Not only do we obtain better results than the previous approaches, we also achieve better results than the best known values for 13 out of 24 instances. We are unable to reach the best known solutions for four instances but in general we perform much better than Scatter Search and the Bionomic Algorithm. The maximum percentage gap for any of these instances with the best known solutions is 9.62 percent as opposed to a percentage gap of 44.96 percent with Scatter Search and 33.90 percent with the Bionomic Algorithm, for the same set of instances. Again, the average percentage gap for our approach is 1.091 percent as opposed to 22.0 percent and 1936.5 percent for Scatter Search and the Bionomic Algorithm, respectively. Moreover, the average run-time for PSA is just 20.263 seconds which is again much faster than Scatter Search with 135.5 seconds and the Bionomic Algorithm with an average run-time of 197.8 seconds, for all the instances in Table [\ref=result2]. Hence, we show that the use of our polynomial algorithm fetches faster and better results than previous approaches. We would like to mention here that although we do not prove that Proposition [\eqref=prop] returns optimal results, nevertheless we obtain optimal solutions for all the small instances in much less time. For the large instances, the results again show that it is an effective approach and yields better and faster results for all the instances.

Conclusion

The Aircraft landing problem has mostly been approached using linear programming, meta-heuristic approaches or branch and bound algorithms in the last two decades [\cite=krishna] [\cite=earnst] [\cite=beasley] [\cite=salehipour]. This paper is the first attempt to schedule the landings of the aircraft for a given feasible landing sequence using a polynomially bound algorithm. We have tested our approach over all the benchmark instances which have been applied in major previous research and our results show that we are able to find better solutions than the best known solutions for many instances. In future we intend to optimize our algorithm for the general case of the safety constraint for all the benchmark instances accordingly. The authors are willing to provide the extended results for the results obtained in this work for any (or all) instance(s) via email.

Acknowledgement

The research project was promoted and funded by the European Union and the Free State of Saxony. The authors take the responsibility for the content of this publication.