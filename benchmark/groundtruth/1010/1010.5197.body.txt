Lemma Corollary Conjecture Fact Proposition Observation

Multicut is FPT

Introduction

The study of cuts and flows is one of the most active field in combinatorial optimization. However, if the simplest case involving one source and one sink is algorithmically tractable, the problem becomes hard as soon as one deals with multiple terminals. For instance, given two requests (x1,y1) and (x2,y2) in a directed graph D, it is NP-complete to decide if there exist two disjoint directed paths, respectively from x1 to y1 and from x2 to y2 [\cite=2dirNPhard]. In fact, even deciding if two given vertices belong to a directed circuit is already hard. The picture changes when considering undirected graphs, in which case the celebrated result of Robertson and Seymour [\cite=GM13] asserts that given k requests [formula], one can decide in cubic time if there exists k disjoint paths connecting all pairs xi,yi. The catch is of course that cubic time refers to the instance size, which we generally denote by n. From their work, the complexity of the k-path problem is O(f(k)n3), where f is by no mean polynomial, since the question is NP-complete when k is part of the input.

This result received considerable attention, both since this is the key tool for computing a given minor in a graph, but also because it has opened a breach in the classical NP-complete/P duality. Indeed, the difficulty of the k-path problem does not depend on the size of the instance, but rather on the number of paths we are looking for. In other words, the parameter containing the hardness of the problem is the number k of paths. In a more general way, a problem is fixed parameter tractable (FPT) with respect to the parameter k (e.g. solution size, treewidth, ...) if for any instance of size n it can be solved in time O(f(k)nc) for some fixed c. The reader is invited to refer to now classical books by Downey and Fellows [\cite=DF99], Flum and Grohe [\cite=FG06] and Niedermeier [\cite=Nie06].

The dual problem of finding disjoint paths from a source s to a sink t is the cut problem where one asks for a set of vertices or edges which deletion separates s from t. Menger's theorem, or more generally LP-duality, asserts that the maximum number of disjoint st-paths is equal to the minimum size of a cut. This property no longer holds when considering multiple requests, where the maximum number of disjoint paths connecting requests is only an obvious lower bound for the size of a multicut, i.e. a set of vertices or edges which deletion separates xi from yi for every request xiyi. Formally, we have the following problem:

M: Input: A graph G, a set of requests R, an integer k. Parameter: k. Output: TRUE if there is a multicut of size at most k, otherwise FALSE.

The status of this problem is one of the long standing open problems in parameterized complexity. The main result of this paper is to provide an FPT algorithm for M. The proofs being slightly less cumbersome in the edge case, we present our work in terms of edge-multicut rather than vertex-multicut. Our last section shows how to translate the algorithm to deal with vertices. Let us now give some formal definitions. Given a graph G and a set R of pairs of distinct vertices called requests, a multicut is a subset F of edges of G such that every xy-path, where xy is a request, contains an edge of F. Equivalently, the two endpoints (or terminals) of every request of R belong to different connected components of [formula].

The M problem is already hard on trees since V C is equivalent to M in stars. Hence M is NP-complete and Max-SNP hard. M and its variants have raised an extensive literature. These problems play an important role in network issues, such as routing and telecommunication (see [\cite=CLR05]).

M I T was already a challenging problem. Garg et. al.  [\cite=GVY97] proved that it admits a factor 2 approximation algorithm. Guo and Niedermeier [\cite=GN05] proved that M I T is FPT with respect to the solution size. Bousquet et. al.  [\cite=BDTY09] provided a polynomial kernel.

Another variant is the M C problem in which a set of (non-paired) terminals has to be pairwise separated. When parameterized by the solution size, M C has been proved FPT by Marx [\cite=marxmultiwaycut]. A faster [formula] algorithm is due to Chen et. al.  [\cite=chenmultiwaycut].

On general instances, Garg et. al.  gave an approximation algorithm for M within a logarithmic factor in [\cite=GVY93]. However M has no constant factor approximation algorithm if Khot's Unique Games Conjecture holds [\cite=MCnonapprox]. This fact is a further motivation to the study of the fixed parameterized tractability of M. Guo et. al.  showed in [\cite=GHKNU06] that M is FPT when parameterized by both the treewidth of the graph and the number of requests. Gottlob and Lee in [\cite=GL07] proved a stronger result: M is FPT when parameterized by the treewidth of the input structure, namely the input graph whose edge set is completed by the set of request pairs. Recently, Daligault et. al.  [\cite=DPPT09] proved that M can be reduced to instances in which the graph G has treewidth bounded in terms of k.

The graph minor theorem of Roberston and Seymour implies that M is non-uniformly FPT when parameterized by the solution size and the number of requests. Marx proved that M is (uniformly) FPT for this latter parameterization [\cite=marxmultiwaycut]. A faster algorithm running in time [formula] was given by Guillemot [\cite=GuillemotIWPEC]. Marx et. al.  [\cite=MarxTwReduc] obtained FPT results for more general types of constrained M problems through treewidth reduction results. However their treewidth reduction techniques do not yield the tractability of M when parameterized only by the solution size. Recently, Marx and Razgon obtained a factor 2 Fixed-Parameter-Approximation for M in [\cite=MulticutFPTapprox].

Marx and Razgon independently found a proof of the fact that M is FPT, with a rather different approach, see [\cite=MR10].

The outline of our proof is quite pedestrian, even if some of the partial results are still a bit technical. Informally, our goal is to reduce our input graph to a subdivision of a graph with a bounded number of edges. The crucial tool for this reduction is to find a partition of the set of all "reasonable" solutions of the M problem into a bounded number of subsets, in which the multicuts are "totally ordered" (this will be formalized in Subsection [\ref=dilworth]). This application of Dilworth's Theorem is maybe the most interesting aspect of our proof. However, it requires an important cleaning of our instance before being applied. It would be interesting to find an adequate partial order on multicuts at an earlier stage of our proof to shorten the argument and get more insight in the structure of multicuts.

In Section [\ref=sectionconnectivity] we develop some connectivity tools which are used to certify that some requests are irrelevant. In Section [\ref=CM], we first compute a vertex-multicut Y of size k + 1 by iterative compression. We then reduce to the case where each component of [formula] has one or two attachment vertices in Y. We show that components with one attachment vertex have only a bounded (in k) number of terminals. For components with two attachment vertices, we identify one path (called backbone) where only one edge is chosen in the multicut. In Section [\ref=trlemon], we reduce to the case where the backbone is the only path connecting the two attachment vertices. Finally, we show that M can be reduced to an instance which is a subdivision of a graph with a bounded number of edges and where the multicut selects a single edge in each of the paths corresponding to the subdivided edges. This case can easily be coded by a 2-SAT instance, which is solvable in polynomial time. In the Appendix (Section [\ref=time]) we improve the running time of our algorithm to a single exponential in terms of k, and in Section [\ref=vertex] we sketch how to adapt our proof to the case of vertex-multicuts.

Acknowledgments. This proof was a long process in which several researchers gave us advice or participated in some of the partial results. One of our important tools, Lemma [\ref=extractright], is the crucial result of the reduction of M to bounded treewidth, and was obtained in collaboration with Christophe Paul and Anthony Perez [\cite=DPPT09]. The fact that a vertex cutset Y could be obtained by iterative compression, a tool of [\cite=MulticutFPTapprox], was brought to our attention by Sylvain Guillemot. Finally, we would like to thank Valentin Garnero who worked on this project as a part of his graduate research experience in June 2010.

Preliminaries

A vertex which sends a request is called a terminal. The number of requests sent by a terminal is its request degree. We study M variants with additional contraints on the deleted edges. In the original M problem, we can delete any set of k edges, but in some more constrained versions we must delete a prescribed number of edges on some particular paths. The total number of deleted edges is called deletion allowance of the multicut problem. We will make extensive use of the term bounded which always implicitely means bounded in terms of the deletion allowance. Also, when speaking of FPT time, we always mean O(f(d)nc) where c is a fixed constant and d is the deletion allowance. Let us discuss further some of the operations we will often perform.

Reductions. These are computations where the output is a new instance which is equivalent to the original instance with respect to the existence of a solution. One of the most natural reductions concerns irrelevant requests, i.e. a request xy such that every multicut of [formula] actually cuts x from y, where R is the set of requests. If one can certify that a request xy is irrelevant, the reduction just consists in replacing R by [formula]. The difficulty is obviously to certify that a request is irrelevant. Another easy reduction is obtained if we can certify that there exists a multicut which does not separate two given vertices u and v. In this case we simply contract u and v. Reductions are easy to control since we can perform them freely provided that some invariant polynomial in n decreases. For instance, request deletions can be performed at most n2 times, and vertex contractions at most n times.

Branchings. In our algorithm, we often have to decide if the multicut we are looking for is of a particular type, where the number of types is bounded. We will then say that we branch over all the possible cases. This means that to compute the result of the current instance, we run our algorithm on each case, in which we force the solution to be of each given type. The output is TRUE if at least one of the outputs returns TRUE. To illustrate this, in the case of a graph G with two connected components G1 and G2, both containing requests, we would branch over k - 1 instances, depending of the number of edges (between 1 and k - 1) that we delete from G1. This simple branching explains why we can focus on connected graphs.

Invariants. To prove that the number of branchings is bounded, we show that some invariant is modified at each branching step, and that the number of times that this invariant can be modified is bounded. We usually have several invariants ordered lexicographically. In other words, we have different invariants which we want to increase or decrease and can take a bounded number of values. These invariants are ordered, there is a primary invariant, a secondary, etc. Each branching must improve our invariant, i.e. the first invariant (with respect to priority order) which is changed by the branching must be modified according to the preference, increase or decrease, that we specified for it. For instance the primary invariant could be the number of deleted edges, which we want to decrease and the secondary invariant could be the connectivity of G, which we want to increase. If we can decrease the number of deleted edges we do so even if the connectivity of the graph decreases. Also, if a branching increases connectivity and leaves the number of deleted edges unchanged, we improve our invariant.

Connectivity in FPT time.

Dealing with minimum cuts can be done in polynomial time with usual flow techniques. However, dealing with k-edge cuts when k is some fixed value larger than the optimum is more difficult. We develop here some tools to deal in FPT time with bounded cuts, of the same flavour as in [\cite=DFVS], [\cite=DPPT09] and [\cite=marxmultiwaycut].

Enumerating cuts in FPT time

Let G be a connected graph on n vertices with a particular vertex x called root. We deal in this part with cuts, i.e. bipartitions of the vertex set of G. To fix one side of our cuts, we define a cut as a subset of vertices S containing x. The border of S is the set of edges of G with exactly one endpoint in S. We denote it by Δ(S). Its cardinality is denoted by δ(S). Recall that the function δ is submodular, i.e. [formula]. Given a subset Y of vertices of V(G), we denote its complement [formula] by [formula]. A cut S is a left cut if every cut [formula] satisfies δ(T) > δ(S). Note that every cut S contains a left cut S' with δ(S')  ≤  δ(S).

Left cuts are closed under union.

Let [formula] be the union of two left cuts. Let [formula] be a cut with minimum border. Without loss of generality, we assume that S1 is not included in S3. Since S1 is a left cut, [formula]. Since [formula], we obtain [formula]. Furthermore [formula]. Since S3 has minimum border among strict subsets of [formula], we have [formula]. Finally [formula], thus [formula] is a left cut.

If S1,S2 are distinct left cuts, [formula].

Since [formula] or [formula], we assume without loss of generality [formula]. By Lemma [\ref=unioncut], [formula].

A cut S is indivisible if [formula] is connected, otherwise it is divisible.

If S is a divisible left cut and Y is a connected component of [formula], the cut [formula] is an indivisible left cut with [formula].

The cut [formula] is indivisible by construction and [formula], so we just have to prove that [formula] is a left cut. Consider a left cut [formula] which minimizes δ(T). By Lemma [\ref=unioncut], [formula] is a left cut. Moreover [formula] by minimality of δ(T), hence [formula]. In particular S  ⊆  T. Since every edge of [formula] joins S to Y, we have [formula]. Therefore by minimality of δ(T), we have [formula]. Thus [formula] is a left cut.

Every indivisible cut S contains an indivisible left cut S' with δ(S')  ≤  δ(S).

Let S'' be a left cut contained in S such that δ(S'')  ≤  δ(S). We assume that S'' is divisible, otherwise S': = S''. Let Y be the component of [formula] which contains [formula]. By Lemma [\ref=divind], [formula] is an indivisible left cut with δ(S') < δ(S'')  ≤  δ(S). Moreover S'  ⊆  S since [formula].

Given a vertex y, an xy-cut is a cut S such that y∉S. We denote by Cyk the set of indivisible left xy-cuts with border k. We also denote by Cy< k (resp. Cy≤  k) the union of Cyi for i < k (resp. for i  ≤  k).

The set Cy≤  k has size at most k! and can be computed in FPT time.

We prove this result by induction on k. Let us start our induction with k = λ, the first value such that Cy≤  λ is non empty. In other words, λ is the edge-connectivity between x and y.

The set Cy≤  λ has only one element Sλ. It can be computed in polynomial time. Moreover Sλ contains all left xy-cuts.

The δ function is modular on xy-cuts of size λ. In particular, Cy≤  λ is closed under intersection, hence Sλ is just the intersection of all xy-cuts with border λ. It is indivisible by minimality of λ and can be computed in polynomial time. Now, if T is a left xy-cut, we have [formula]. By minimality of λ, [formula]. Thus [formula]. The set T being a left cut, we have [formula], thus T  ⊆  Sλ.

Let S∈Cyk with k > λ. Let T∈Cy< k, minimal with respect to inclusion which contains S. Such a cut T exists since by Claim [\ref=init], the cut Sλ contains S. Since S is indivisible, there exists an edge e in [formula].

If S'∈Cy≤  k is included in T and e∉Δ(S'), then S' = S.

Assume for contradiction that S' is different from S. By Lemma [\ref=unioncut], [formula] is a left xy-cut, and by Lemma [\ref=smallsizecut], we have [formula]. Let Y be the component of [formula] which contains [formula]. By Lemma [\ref=divind], the cut [formula] belongs to Cy< k. Therefore [formula], and by minimality of T, we have [formula]. But this would mean [formula], which is a contradiction.

Now we turn Claim [\ref=unicity] into an algorithm. For every cut T in Cy< k and every edge e∈Δ(T), we contract [formula] to a single vertex still called y. We call this graph G'. If the xy-edge connectivity of G' is not equal to k, the search stops. Otherwise, we compute the unique indivisible left xy-cut S with border k. This cut S in G is an element of Cyk. By Claim [\ref=unicity], all the elements of Cyk can be computed in this way. This algorithm gives the upper bound |Cy≤  k|  ≤  |Cy< k| + (k - 1)|Cy< k|, hence |Cy≤  k|  ≤  k!. This concludes the proof of Theorem [\ref=boundsize].

The value k! in Theorem [\ref=boundsize] can actually be improved to 4k [\cite=MarxSlides].

Irrelevant requests

We denote by Ck the union of Cyk for all y, by C< k the union of Cy< k for all vertices y of G, and by C≤  k the union of Cy≤  k for all vertices y of G. A collection of sets is called a Δ-system if every two distinct sets have the same intersection. Erds and Rado [\cite=ER] proved that there exists a function er such that any collection of er(k,r) sets with size at most k contains a Δ-system consisting of r sets. The bound in the next result will be improved in Section [\ref=time].

Every set K with at least er(k!,k') vertices of G contains a subset K' of size k' such that every left cut S with δ(S)  ≤  k satisfies either [formula] or [formula]. The set K' can be computed in FPT time.

In other words, every left cut with border at most k isolates either all the elements of K', or at most k elements of K'. Let us consider the collection C of sets Cy≤  k, for all y∈K. By Theorem [\ref=boundsize], the collection C has size bounded in terms of k and k' and can be computed in FPT time. Since the sets Cy≤  k have size at most k! and the set K has size er(k!,k'), there exists a Δ-system of size k', i.e. a subset K' of k' vertices of K such that for all y,y'∈K', we have [formula] equal to some fixed set C of C≤  k. This set K' is computable in bounded time. Every cut S in C satisfies [formula], i.e. the cuts in C isolate K'. Moreover, if a cut S in C≤  k does not belong to C, then S belongs to at most one Cy≤  k, hence isolates at most one vertex of K'.

Thus we have proved so far that the conclusion of Theorem [\ref=extractleft] holds if S is an indivisible left cut with border or size at most k, with the stronger conclusion that S isolates at most one vertex of K' when it does not completely cut K'. To obtain our conclusion, let us observe that if S is divisible and Z is a component of [formula], then by Lemma [\ref=divind] the cut [formula] belongs to C≤  k. Hence either [formula] isolates K', or [formula] isolates at most one vertex of K'. Since the number of components of [formula] is at most k, we have our conclusion.

The next result is our key tool in reducing M to graphs of bounded treewidth in [\cite=DPPT09], but the following easy argument is more straightforward. The proof of Theorem 4 of [\cite=DPPT09] implies that the following result holds with [formula], and can be computed in time [formula].

Every set K with at least [formula] vertices of G contains a vertex y such that every cut S with [formula] is such that y∉S. Moreover, y is computed in FPT time.

In other words, whenever the deletion of a set of a edges isolates x from all but b elements of K, with [formula], then the vertex y is also isolated from x. We create a new vertex z joined to all the vertices of K to form a new graph G'. In this proof we change our point of view and consider that z is our root vertex for G', i.e. z plays for G' the same role as x plays for G. In G', the set C of indivisible left zx-cuts with border at most [formula] has size at most [formula] by Theorem [\ref=boundsize]. Hence, since the size of K is at least [formula], there exists a subset T of K of size at least [formula] such that for every cut S in C, we have either T  ⊆  S or [formula]. We compute such a set T in FPT time. We then pick y in T. Let us prove that y satisfies the conclusion of Theorem [\ref=extractright].

In the graph G, consider a set A of a edges which isolates x from all the elements of K save a subset B of size b with [formula]. Let F be the set of edges [formula] of G'. Note that F is a zx-edge cut. We denote by X the component of x in [formula]. Since [formula] is an indivisible zx-cut with border at most [formula], it contains by Corollary [\ref=indlef] a indivisible left zx-cut S with border at most [formula], in other words S belongs to C.

Let us first observe that the set T cannot be disjoint from S. Indeed T has size [formula] and each of its elements is joined to z, thus the border of S would exceed [formula]. Hence T is included in S, thus the set of edges A isolates T from x, and in particular y from x. This concludes our proof.

In a multicut problem instance with deletion allowance k, the maximum request degree can be reduced to at most h(k + 1) in FPT time.

Let x be a vertex which sends requests to all vertices of K, where |K|  ≥  h(k + 1). By Theorem [\ref=extractright], there is a vertex y of K such that every subset S containing x such that [formula] is such that y∉S. We simply delete the request xy from the set of requests. Indeed, let F be a multicut with size at most k of this reduced instance. Let S be the component of x in [formula]. Since F is a multicut, no element of [formula] belongs to S. Moreover δ(S)  ≤  k since at most k edges are deleted. Thus [formula] is at most k + 1, hence this implies that y∉S. In other words, even if we do not require to cut x from y, any multicut of the reduced instance will cut the request xy. Therefore the request xy can be deleted from R.

Cherry reduction

An x-cherry, or simply cherry is a connected induced subgraph C of G with a particular vertex x called attachment vertex of C such that there is no edge from [formula] to [formula] and no request has its two terminals in [formula]. In other words the only requests inside an x-cherry have origin x. Note that we can always assume that the restriction of a multicut to an x-cherry C is the border of a left cut of C. If [formula], a request uv∈R is irrelevant if every multicut F with at most k edges of the reduced instance on [formula] and such that [formula] is the border of a left cut in C actually separates u from v.

Let C be an x-cherry of a instance with deletion allowance k. We can find in FPT time a set K(C) of at most b(k): = h(k + 1).er(k!,h(2k + 1)) terminals in [formula], such that if F is a set of at most k edges which cuts all requests with one endpoint in K(C) and such that [formula] is the border of a left cut, then F actually cuts all requests with an endpoint in [formula].

By Corollary [\ref=boundeddegree], we can assume that all terminals have request degree at most h(k + 1). Let L be the subset of terminals of [formula]. We assume |L| > b(k). Our goal is to show that there exists an irrelevant request with one endpoint in L. Let us consider the bipartite graph formed by the set of requests with one endpoint in L. It is bipartite since [formula] has no internal requests. Recall that if a bipartite graph (X,Y) has maximum degree d and minimum degree one, there exists a matching with at least |X| / d edges. To see this, observe that the edges of (X,Y) can be partitioned into d matchings and that the graph contains at least |X| edges.

The request graph thus contains a matching M of size at least er(k!,h(2k + 1)) such that each request in M has one endpoint in L and the other endpoint out of [formula]. Let [formula]. We first only consider the cherry C where x is the root. Since the size of K is at least er(k!,h(2k + 1)), the set K contains by Theorem [\ref=extractleft] a subset K' of size h(2k + 1) such that every left cut S with border at most k verifies [formula] or [formula]. Let M' be the set of edges of M having an endpoint in K'. We denote by L' the set of vertices [formula], i.e. the endpoints of edges in M' which do not belong to [formula]. Now let us consider the graph [formula] with root x. The set L' has size at least h(2k + 1), thus by Theorem [\ref=extractright] there is a vertex y in L' such that whenever we delete k edges in G such that at most k vertices of L' belong to the component of x, then y does not belong to the component of x. The vertex y being an element of L', we consider the request zy∈M', where z belongs to [formula].

We claim that the request zy is irrelevant. Indeed, let F be a multicut of [formula] with at most k edges such that [formula] is the border of a left cut. Let S be the component of x in [formula]. The set S is a left cut and has border of size at most k, hence either S completely isolates x from K' or S isolates at most k vertices of K' from x. If K' is isolated from x, we have in particular that x is disconnected from y, hence the request zy is cut by F. So we assume that a subset K'' containing all but at most k vertices of K' is included in S. Hence, denoting by L'' the other endpoints of the edges of M' intersecting K'', this means that F must disconnect x from L''. Therefore the set F of at most k edges disconnects x from at most k + 1 elements of L' (the k elements of L'' and possibly y), so by definition of y, the set F disconnects x from y. In particular zy is cut by F. Thus the request zy is indeed irrelevant. All the computations so far are FPT.

We repeat this process, removing irrelevant requests until the size of L does not exceed b(k). We then set K(C): = L, and the conclusion of Theorem [\ref=cherryrequestreduction] holds.

Let C be a cherry of a graph G with deletion allowance k. A subset L of the edges of C is active when, if a multicut F of size at most k exists, then there exists a multicut F' of size at most |F| such that [formula] and [formula]. When the set L is clear from the context, we say by extension that edges of L are active.

Let C be an x-cherry of a graph G with deletion allowance k, and let K be the set of all terminals of [formula]. Let L(C) be the union of all borders of cuts of Cy≤  k, where y∈K. Then L(C) is active, and has size at most k|K|k!.

Assume that F is a multicut with size at most k. Let S be the component of x in [formula]. Let T be a left cut with T  ⊆  S and δ(T)  ≤  δ(S). If a component U of [formula] does not intersect K, the set [formula] is still a multicut. Finally, we can assume that all components U of [formula] intersect K, in which case Δ(U)∈Cy≤  k for some y in K, hence Δ(T) is included in L. The set [formula] is a multicut, and the size bound for L follows from Theorem [\ref=boundsize].

Let [formula] be x-cherries of a graph G with deletion allowance k such that [formula] are pairwise disjoint. Assume that for every i, [formula] is a cherry. Then every Ui has a bounded active set Li such that [formula] whenever i  ≤  j.

By Theorem [\ref=cherryrequestreduction], we can reduce the set of terminals in U1 to a bounded set K1. The set L1  =  L(U1) is bounded and active by Lemma [\ref=finitelycut]. The requests of [formula] are irrelevant in U2 since they are irrelevant in U1, hence we can assume that Theorem [\ref=cherryrequestreduction] applied to U2 yields a set of terminals [formula]. Let L2 be the active edges associated to K2. Note that if an edge e∈L2 is in U1, it must belong to some Cy≤  k for some [formula]. Since [formula], we have y∈K1, hence e∈L1, which is the property we are looking for. We extract K3 from [formula], and iterate our process to form the sequence Li.

Reducing M to C M

Let G = (V,E) be a connected graph, and R be a set of requests. A vertex-multicut Y is a subset of V such that every xy-path of G where xy∈R contains an element of Y. Let A be a connected component of [formula]. We call Y-component, or component, the union of A and its set of neighbors in Y. Let C be a component, the vertices of [formula] are the attachment vertices of C.

Component Multicut

Here is our first intermediate problem.

C M: Input: A connected graph G = (V,E), a vertex-multicut Y, a set of requests R, a set I of q integers such that:

There are q Y-components [formula] with two attachment vertices xi,yi. The other components have only one attachment vertex.

Every Gi has a xiyi-path Pi called backbone of Gi. Moreover, the deletion of every edge of Pi decreases the edge connectivity in Gi between xi and yi.

The set I consists of q non negative integers [formula] such that [formula].

Parameter: k. Output: TRUE if there exists a multicut F such that:

every path Pi contains exactly one edge of F,

every Gi contains exactly 1 + fi edges of F,

the solution F splits Y, i.e. the connected components of [formula] contain at most one vertex of Y.

Otherwise, the output is FALSE.

We call Y a cutset, i.e. a vertex-multicut which must be split by the solution F. The edges of G which do not belong to the backbones are called free edges. The backbone Pi, in which only one edge is deleted, is the crucial structure of Gi. Indeed, the whole proof consists of modifying Gi step by step to finally completely reduce it to the backbone Pi. Here fi is the number of free edges one can delete in Gi. Observe that [formula] free edges can be deleted in components with one attachment vertex. Our first reduction is the following:

M can be reduced to C M in FPT time.

The remaining of Section [\ref=CM] is devoted to the proof of Theorem [\ref=multitomultiwithback]. We first construct a cutset Y. Then we prove that we can reduce to Y-components with one or two attachment vertices. Finally, we show that we can assume that every component with two attachment vertices has a path in which exactly one edge is chosen in the solution. This is our backbone.

The cutset Y.

We use iterative compression to prove the existence of a vertex-multicut of size k + 1, as was done in [\cite=MulticutFPTapprox].

M can be solved in time O(f(k)nc)) if M given a vertex multicut of size at most k + 1 can be solved in time O(f(k)nc - 1).

By induction on n, we solve M in time f(k)(n - 1)c on G - v where v∈V(G). If the output is FALSE, we return it, otherwise the output is a multicut F of size at most k. Let X be a vertex cover of F of size at most k. Thus [formula] is a vertex-multicut of our instance, so we solve M in time f(k)nc - 1 + f(k)(n - 1)c which is at most f(k)nc.

So we can assume that we have a vertex-multicut Y of size at most k + 1.

We can assume that the solution F splits Y.

To any solution F is associated the partition of [formula] into connected components. In particular this induces a partition of Y. We branch over all possible partitions of Y. In a given branch, we simply contract the elements of Y belonging to the same part of the partition corresponding to the branch.

During the following reduction proof, the set Y will never decrease. Since one needs k + 1 edges to separate k + 2 vertices, the size of Y cannot exceed k + 1, otherwise we return FALSE. Hence our primary invariant is the size of Y, and we immediately conclude if we can make it increase.

Reducing attachment vertices.

Our second invariant, which we intend to maximize, is the number of Y-components with at least two attachment vertices. This number cannot exceed k, since any solution splits Y. Our third invariant is the sum of the edge connectivity between all pairs of vertices of Y, which we want to increase. This invariant is bounded by [formula] since the connectivity between two elements of Y is at most k. Note that this invariant never decreases when we contract vertices.

If C is a Y-component with at least three attachment vertices, we improve our invariant.

Let x,y,z be attachment vertices of C. Let λ be the edge-connectivity between x and y in C. Let [formula] be a set of edge-disjoint xy-paths. A critical edge is an edge which belongs to some xy-edge cut of size λ. Note that every critical edge belongs to some path Pi. A slice of C is a connected component of C minus the critical edges. Given a vertex v of C, the slice of v, denoted by SL(v), is the slice of C containing v. Let B(z) be the border of SL(z), i.e. the set of vertices of SL(z) which are incident to a critical edge. Note that B(z) intersects every path Pi on at most two vertices, namely the leftmost vertex of Pi belonging to SL(z) and the rightmost vertex of Pi belonging to SL(z). In particular, B(z) has b vertices, where b  ≤  2λ.

We branch over b + 1 choices to decide whether one of the b vertices of B(z) belongs to a component of [formula] (where F is our solution) which does not contain a vertex of Y. When this is the case, the vertex is added to Y, hence we increase our primary invariant. In the last branch, all the vertices of B(z) are connected to a vertex of Y in [formula]. We branch again over all mappings f from B(z) into Y. In each branch, the vertex v∈B(z) is connected to f(v)∈Y in [formula]. Hence we can contract every vertex v∈B(z) to the vertex f(v) of Y. This gives a new graph G'. We denote by S' the subgraph SL(z) after contraction of the vertices of B(z). Observe that S' is a Y-component of G'.

If x and y belong to S', the edge connectivity between x and y has increased. Indeed, there is now a path P joining x to y inside S', in particular P has no critical edge. Thus the connectivity between x and y has increased, so our invariant has improved. We assume without loss of generality that x does not belong to S'.

If S' contains an element of Y distinct from z, then S' is a Y-component with at least two attachment vertices. Moreover, there exists a path P in [formula] from x to B(z). Hence we have created an extra Y-component with at least two attachment vertices in G', which improves our second invariant.

In our last case, S' only intersects Y on z. Therefore B(z) is entirely contracted to z. In particular z is now incident to a critical edge e. So there exists an xy-cut A with δ(A) = λ and e∈Δ(A). Without loss of generality, we assume that z∉A (otherwise we consider the yx-cut [formula]). We denote by B the vertices of [formula] with a neighbor in A. In particular, B contains z, has size at most λ, and every xy-path in C contains a vertex of B. Let us denote by L the set [formula] and by R the set [formula]. Note that [formula]. We now branch to decide in which components of [formula] the elements of B are partitioned. If an element of B is not connected to Y in [formula], we improve our invariant. If each element of B is contracted to a vertex of Y, both L and R in the contracted graph are Y-components with at least two attachment vertices (respectively {x,z} and {y,z}). We again improve our invariant.

Backbones.

We now assume that every component has at most two attachment vertices. Let [formula] be the components of G with two attachment vertices. We denote by λi the edge connectivity of Gi between its two attachment vertices xi,yi. Recall that our third invariant is just the sum of the λi.

We can assume that xi and yi have degree λi in Gi.

Let A be the unique left xiyi-cut with δ(A) = λi in the graph Gi rooted in xi. Let B be the set of vertices of A with a neighbor in [formula]. We now branch to decide how the components of [formula] partition B. If an element of B is not connected to Y in [formula], we improve our invariant. If an element of B is contracted to yi, we increase λi. Hence all elements of B are contracted to xi. Therefore A becomes an xi-cherry, hence [formula] is removed from Gi. The degree of xi inside Gi is now exactly λi. We apply the same argument to reduce the degree of yi to λi.

We now branch over all partitions of k into [formula], where ki is the number of edges of our solution chosen in Gi when i > 0, and k0 is the number of edges chosen in the y-components for y∈Y.

Every component Gi can be deleted or has a backbone.

If ki  ≥  2λi, we simply delete in Gi the edges incident to xi and yi, reduce our parameter, and improve our invariant. So we can assume that ki  ≤  2λi - 1. Let [formula] be some edge-disjoint xiyi-paths. Our algorithm now branches 2λi times, where the branches are called Bj and B'j for [formula]. In the branch Bj, we assume that there is only one edge of our solution selected in Pj, and this edge belongs to an xiyi-cut of size λi. In the branch B'j, we assume that all the edges of our solution selected in Pj are not critical. Let us show that any solution F belongs to one of these branches. If F does not belong to any branch B'j, this means that F uses at least one critical edge in each Pj. But since ki  ≤  2λi - 1 some Pj only intersects F on one edge, which is therefore critical. Hence F is a solution in the branch Bj. Thus this branching process is valid. In the branch Bj, we contract all non critical edges of Pj, therefore Pj is the backbone we are looking for. In the branch B'j, we contract all critical edges of Pj, hence the connectivity λi increases. We thus improve our invariant.

This concludes the proof of Theorem [\ref=multitomultiwithback].

B M is FPT

Backbone Multicut

We introduce here the problem B M, which is a generalization of C M. Our goal is to show that B M is solvable in FPT time, which implies that C M is FPT, which in turns implies that M is FPT thanks to Theorem [\ref=multitomultiwithback].

B M: Input: A connected graph G = (V,E), a set of half-requests R, a set Y of vertices, a set B of q variables, a set C of clauses, a set I of q integers such that:

G has q Y-components called Gi with two attachment vertices xi,yi∈Y, with [formula]. Moreover,Gi has a backbone Pi and the xi,yi-connectivity in Gi is λi. Recall that the edges of G which are not in backbones are called free edges.

The set R contains half-requests, i.e. sets of triples (u,y,v), informally meaning that vertex u sends a request to vertex v via y, where y∈Y. Also, Y is a u,v-cut for every half-request (u,y,v)∈R.

The set B contains q integer-valued variables [formula]. Each variable ci corresponds to the deletion of one edge in the backbone Pi. Formally, if the edges of Pi are [formula], ordered from xi to yi, the variable ci can take all possible values from 1 to [formula], and ci = r means that we delete the edge er in Pi.

The clauses in C have four possible types: (ci  ≤  a  ⇒  cj  ≤  b), or (ci  ≤  a  ⇒  cj  ≥  b), or (ci  ≥  a  ⇒  cj  ≥  b), or (ci  ≥  a  ⇒  cj  ≤  b).

The set I consists of q non negative integers [formula] summing to a value at most k. Each integer fi corresponds to the number of free edges of the solution which are chosen in Gi.

Parameter: k. Output: TRUE if:

there exists an assignment of the variables of B which satisfies C,

there exists a subset F of at most k free edges of G,

for each [formula], the set F contains fi free edges in Gi,

the union F' of F and the backbone edges corresponding to the variables of B splits Y and intersects every half-request of R, i.e. for every half-request (u,y,v)∈R every path between u and v containing y intersects F'.

Otherwise, the output is FALSE.

Note that the deletion allowance of B M is k + q. C M directly translates into B M with an empty set of clauses, and where each request is simulated by one or two half-requests. This section is devoted to the proof of the following result.

B M can be solved in FPT time.

Invariants

Our primary invariant is the sum of the fi, which starts with value at most k and is nonnegative. Any branch in which we can decrease it will be considered solved. Our secondary invariant is the sum of the λi - 1, called the free connectivity, which we try to increase. Observe that this invariant is bounded above by k. For our last invariant, recall that the slice SL(v) of some vertex v in a component Gi is the connected component containing v of Gi minus its critical edges, i.e. edges of λi-cuts. Observe that since the edges of Pi are critical, the slices of distinct vertices in Pi do not intersect. The slice connectivity of a vertex v in Pi is the xiyi-edge-connectivity of [formula]. We denote it by sc(v). For instance, if the set of neighbors of v intersect every xiyi-path in [formula] then we have sc(v) = 0. Conversely, if v∈Pi has only neighbors in Pi, we have sc(v) = λi - 1. The slice connectivity sci of Gi is the maximum of sc(v), where v∈Pi. Our third invariant is the sum sc of the sci, for [formula], and we try to minimize this invariant. Observe that at any step, sc is at most k.

Our goal is to show that we can always improve our invariant, or conclude that λi = 1 for all i. We consider a component Gi with λi > 1, say G1. To avoid cumbersome indices, we assume that the attachment vertices of G1 are x and y, and that their edge-connectivity is denoted by λ instead of λ1. Moreover, we still denote by P1 the backbone of G1, but we assume (against our previous notations) that [formula] is a set of edge-disjoint xy-paths in G1. We visualize x to the left and y to the right (see Figure [\ref=lemon]). Hence when we say that a vertex u∈Pi is to the left of some v∈Pi, we mean that u is between x and v on Pi.

Contracting edges

In our proof, we contract edges of the backbone and free edges which are not critical. At any step, we always preserve the fact that the edges of the backbone are critical.

When contracting an edge of the backbone P1, we need to modify several parameters. Assume that the edges of P1 are [formula]. The variable c1 represents the edge of P1 which is deleted in our multicut. Now assume that the edge ei = vivi + 1 is contracted. All the indices of the edges which are at least i + 1 are decreased by one. All the constraints associated to the other backbones are not affected by the transformation. However, each time a clause contains a litteral c1  ≥  j, where j > i, this litteral must be replaced by c1  ≥  j - 1. Similarly each occurence of c1  ≤  j' for j'  ≥  i must be replaced by c1  ≤  j' - 1. If a set of edges is contracted, we perform the contractions one by one.

The collection of paths [formula] can be affected during our contractions since it can happen that a path Pi with i  ≥  2 contains both endpoints of a contracted edge uv. In such a case, we remove from Pi the loop formed by the contraction, i.e. the subpath of Pi between u and v. We thus preserve our path collection.

Choosing a stable edge

Let v be a vertex of P1. The tag of v is the subset [formula], i.e. the set of indices of the paths intersecting the slice of v. Note that t(v) contains 1. Observe also that the slice connectivity of G1 is the maximum of λ - |t(v)|, where v belongs to P1. By extension, the tag of an edge vivi + 1 of the backbone P1 is the ordered pair (t(vi),t(vi + 1)). When speaking of an XY-edge, we implicitely mean that its tag is (X,Y). In particular, the edge of P1 which is selected in our solution has a given tag. We branch over the possible choices for the tag XY of the deleted edge of P1. Let us assume that the chosen edge has tag XY.

If X  ≠  Y, we improve our invariant.

Since only one edge is cut in the backbone, we can contract all the edges of P1 with tags different from XY. Observe that when contracting some UV-edge of P1, the tag of the resulting vertex contains [formula] since the slice of the resulting vertex contains the union of both slices (it can actually be larger). After our contraction, all the edges of P1 between two consecutive occurences of XY-edges are contracted, hence the tag of every vertex of P1 now contains [formula]. In particular, the slice connectivity of G1 decreases while the free connectivity is unchanged. Thus our invariant improved.

Therefore we may assume that we choose an XX-edge in our solution. Let us contract all the edges of P1 which are not XX-edges. By doing so, we now have that the tag of every vertex of P1 contains X. After this contraction, our instance is modified, hence we have to branch again over the choice of the tag of the edge chosen in our solution. Any choice different from XX increases the slice connectivity. Hence we can still assume that the tag of the chosen edge is XX.

The slice connectivity of G1 is λ - |X|. An XX-edge uv of the backbone is unstable if, when contracting uv, the tag of the vertex u = v increases ( i.e. strictly contains X). Otherwise uv is stable. We branch on the fact that the chosen XX-edge is stable or unstable.

If the chosen XX-edge is unstable, we improve the invariant.

We enumerate the set of all unstable edges from left to right along P1, and partition them according to their index into the odd indices and the even indices. We branch according to the index of the chosen unstable edge. Assume for instance that the chosen unstable edge has odd index. We contract all the edges of P1 save the odd unstable edges. We claim that every vertex tag of backbone vertices now strictly contains X. Indeed, all edges of P1 between two consecutive odd unstable edges are contracted, in particular some even unstable edge. Thus, since this even edge is unstable, the tag now strictly contains X. Hence the slice connectivity decreases.

Contracting slices

In this part, we assume that the chosen edge of P1 is a stable XX-edge. A vertex v of P1 is full if v belongs to every Pi, where i∈X (see Figure [\ref=full]). Our goal in this subsection is to show that we can reduce to the case where [formula]. By the previous section, any branching increasing the tag of the chosen edge would improve the invariant. So we assume that in all our branchings, the chosen edge is still a stable XX-edge.

We can assume that all backbone vertices are full.

We can first assume that there are at most k vertices with tag X between two full vertices. Indeed, let us enumerate [formula] the vertices with tag X from left to right along the backbone P1. Since a solution F contains at most k free edges and the slices of the vertices of the backbone are disjoint, at most k slices of vertices wi contain an edge of F. Hence, if we partition the set of all slices SL(wi) into k + 1 classes according to their index i modulo k + 1, the solution F will not intersect one of these classes. We branch on these k + 1 choices. Assume for instance that F does not contain an edge in all SL(wi) where i divides k + 1. Therefore, we can safely contract each of such slices SL(wi) onto wi. This makes wi a full vertex.

Let us now enumerate the full vertices [formula] from left to right. Let uv be some stable XX-edge. There exists a full vertex zi to the left of u (with possibly zi = u) and a full vertex zi + 1 to the right of v. Since the number of vertices with tag X between zi and zi + 1 is at most k, the number of XX-edges between zi and zi + 1 is at most k + 1. The rank of uv is the index of uv in the enumeration of the edges between zi and zi + 1 from left to right. Every edge of P1 has some rank between 1 and k + 1. In particular, we can branch over the rank of the selected stable XX-edge. Assume for instance that the rank of our chosen edge is 1. We then contract all edges which are not stable XX-edges with rank 1. This leaves only full vertices on P1 since by construction there is a full vertex between two edges of the same rank.

Note that after performing the reduction of Lemma [\ref=seqlemons], if vivi + 1 is a stable XX-edge, then for every vertex w∈Pj, with j∈X, which lies between vi and vi + 1 in Pj, every wY-path contains vi or vi + 1. In particular, if [formula] then vi and vi + 1 are xy-cut vertices in G1.

We can assume that [formula].

In other words, we can reduce to the case where every vertex of P1 is a cutvertex of G1. Assume now that X is not equal to [formula]. We show that we can partition our component G1 into two components G11 and G21. This partition leaves the free-connectivity unchanged, but decreases the slice connectivity. A vertex vi of the backbone P1 is left clean if the edge vi - 1vi of P1 is a stable XX-edge, but the edge vivi + 1 of P1 is not. It is right clean if the edge vivi + 1 is a stable XX-edge, but the edge vi - 1vi is not. Finally, vi is clean if both vi - 1vi and vivi + 1 are stable XX-edges. When enumerating all left clean and right clean vertices from left to right, we obtain the sequence of distinct vertices [formula] where the ri are right clean and the li are left clean vertices. Observe that x and y do not appear in the sequence since their tag is [formula]. Let us consider a pair ri,li. We say that a vertex v of G1 is between ri and li if every path from v to x or y intersects {ri,li}. Let Bi be the set of vertices which are between ri and li. Let B be the union of Bi for [formula]. Let G11 be a copy of the graph induced on B by G1. Observe that G11 has p connected components, since li  ≠  ri + 1. We contract in G11 the vertices li and ri + 1, for all [formula], hence making G11 connected. We finally identify in G11 the vertex x with r1 and y with lp. The backbone P11 of G11 simply consists of the edges of the original backbone. To construct G21, we remove from G1 all the vertices of B which are not left clean or right clean vertices. Hence no stable XX-edge is left in G21. We contract all the backbone edges of G21. Formally, all the vertices between x and r1 are contracted to a vertex w1: = x, more generally all the vertices between li and ri + 1 are contracted to a new vertex called wi + 1, and finally all the vertices between lp and y are contracted to wp + 1: = y. We now add the path [formula] which is the backbone P21 of G21. We correlate the edges of the backbone of G11 and G21 by adding clauses implying that the chosen edge of P21 is wiwi + 1 if and only if the chosen edge of P11 is between ri and li. We finally branch to split the number of free edges f1 chosen in G1 into f11 + f21 = f1, the respective free edges deleted in G11 and G21. Let us call G' the graph G in which G1 is replaced by G11 and G21. Note that the free edges of G1 are partitioned into the free edges of G11 and of G21. Observe that the free-connectivity of G and G' are equal. However, the slice connectivity has decreased in G', since its value is 0 in G11 and strictly less than λ - |X| in G21. Indeed, for [formula], the edge lili + 1 is either unstable or the tag of one of its endpoints strictly contains X. Hence contracting all vertices between li and ri + 1 strictly increases the tag of the resulting vertex in G21. Hence we improve our invariant. Figure [\ref=L22] gives an example of this transformation.

We now have to prove that there exists a multicut in G' if and only if there exists one in G which uses a stable XX-edge. This comes from the following observation: Let e = vjvj + 1 be a stable XX-edge of P1 between ri and li. Let Ge be obtained from G by deleting e, contracting x to all vertices of P1 to the left of vj, and contracting y to all vertices of P1 to the right of vj + 1. Let G'e be obtained from G' by deleting e in P11, deleting the edge wiwi + 1 correlated to e in P21, contracting x to all vertices of P11 to the left of vj and all vertices of P21 to the left of wi, and contracting y to all vertices of P11 to the right of vj + 1 and all vertices of P21 to the right of wi + 1. The key fact is that Ge is equal to G'e. Hence the multicuts in G and G' selecting the edge e are in one to one correspondence.

The proof of Lemma [\ref=onlylemons] produces a new component, hence a new edge to be chosen in a backbone. This increases the deletion allowance by 1, but the number of free edges has not increased. Since our invariant improves, we can perform this operation a bounded number of times, and this is indeed enough for our proof. More accurately, this operation can be performed at most 2k times. Indeed, when X  ≠  {1}, we have f11 > 0 and f21 > 0, hence the integer partition [formula] has been refined, and this can happen at most k times. When X  =  {1}, we can have f11 = 0, but in this case, the slice connectivity in G21 is stricly less than λ - 1, hence applying Lemma [\ref=onlylemons] on G21 results in a refinement of [formula]. This can be done at most k times.

Reducing the lemons

We now assume that each vertex of the backbone P1 of G1 intersects all other paths Pi. Let vivi + 1 be an edge of the backbone P1. The vi-cherry Ci is the set of all vertices u of G1 such that every uY-path contains vi.

The lemon Mi of vivi + 1 is the set consisting of vi, vi + 1 and of all vertices u of G1 which do not belong to a cherry and such that every ux-path in G1 contains vi and every uy-path in G1 contains vi + 1. Observe that when contracting vivi + 1, the lemon Mi becomes part of the vi-cherry, where vi denotes the resulting vertex. We denote by Li the union of all Cj with j  ≤  i and all Mj with j < i. We call Li the left subgraph of vi. Similarly, the right subgraph Ri of vi is the union of all Cj with j  ≥  i and all Mj with j > i. See Figure [\ref=kiki].

If a multicut F selects the edge vivi + 1 in the backbone, then the vertices [formula] all lie in the same connected component of [formula]. When these vertices [formula] are contracted to x, the set Li becomes an x-cherry. Half-requests through y with an endpoint in Li are automatically cut since F splits Y. Consider the terminals Ti of half-requests of Li which are routed via x. By Theorem [\ref=cherryrequestreduction] we can reduce Ti to a bounded set of terminals Ki (note that these half-requests become equivalent to usual requests, since Li is now an x-cherry). This motivates the following key definition.

By Lemma [\ref=finitelycut], we define Li to be a bounded active set of edges in the x-cherry obtained from Li by contracting vertices [formula]. By Theorem [\ref=boundedcut], we can compute such sets Li so that [formula] when i  ≤  j.

Let us say that a multicut F selecting vivi + 1 in P1 is proper if [formula] is included in Li.

If there exists a multicut F of size at most k containing the backbone edge vivi + 1, then there is a proper multicut F' of size at most k containing vivi + 1.

Consider a multicut F containing vivi + 1. As the set Li is active in the cherry obtained by contracting the path [formula] in Li, there exists a multicut F' of size k such that [formula] and [formula]. Hence F' is proper and contains vivi + 1.

We denote by L the set of all subsets F of size at most k contained in some Li. We denote by c the maximum size of a set Li. Note that c is bounded in terms of k.

For two sets Fi  ⊆  Li and Fj  ⊆  Lj with j  ≥  i, let us write [formula] when [formula]. Observe that [formula] is a partial order. A subset F of L is correlated if:

elements of F have the same size, and

F is a chain for [formula], i.e. if for every Fi and Fj in F, with Fi  ⊆  Li, Fj  ⊆  Lj and j  ≥  i, we have [formula].

There is a partition [formula] of L into k(2c)k correlated sets.

Let us prove by induction on [formula] that there exists no antichain for [formula] in L consisting of [formula] sets of size at most l. This clearly holds for [formula]. Assume that this holds for [formula]. By contradiction, let [formula] be an antichain of sets of size at most [formula]. Let ti be an integer such that Fi  ⊆  Lti for [formula]. We assume that the sets Fi are enumerated in such a way that ti  ≤  tj whenever i  ≤  j. The set F1 is incomparable to all sets Fi with i > 1, hence [formula] for all i > 1. In particular it is nonempty, hence all sets Fi, for [formula], have an edge in Lt1 + 1. The sets Fi such that ti = t1 have an edge in Lt1 by definition. The sets Fi such that ti > t1 have an edge in Lt1 + 1 as [formula], by definition of the sets Li. Since the size of [formula] is at most 2c, there exists a subset B of A of size at least [formula] of sets Fi sharing a same edge [formula]. The set [formula] has size [formula] and is an antichain of sets of size at most [formula] by definition of [formula]. This contradicts the induction hypothesis.

By Dilworth's Theorem, there exists a partition of L into (2c)k sets totally ordered by [formula], which can be be refined according to the cardinality to obtain a partition into k(2c)k correlated sets. Such a partition can be found in FPT time.

Let us now consider such a partition [formula] of L into correlated sets. Observe that by Lemma [\ref=proper] we can restrict our search to multicuts of the following type in G1:

A backbone edge vivi + 1.

Other edges in the lemon Mi, which separate vi from vi + 1 in Mi.

Edges in Li.

Edges in Ri, which is defined analogously to Li, with the roles of vertices x and y reversed.

We can assume that there are no cherries Ci. Moreover, if a multicut of size at most k exists, there exists one which contains only edges in one lemon Mi.

By Lemma [\ref=proper], if there exists a multicut F containing the backbone edge vtvt + 1, then there is a proper multicut F' containing vtvt + 1. By definition [formula].

We branch over the existence of a proper solution F' such that [formula] for [formula], where t is the integer such that vtvt + 1∈F'. Let us assume that we are in the branch where [formula]. A backbone edge vivi + 1 is in the support of Fj if there is some Fi∈Fj such that Fi  ⊆  Li. When vivi + 1 is in the support we say that lemon Mi is a support lemon. In this case, there actually exists a unique set in Fj, which we denote by Fi, such that Fi  ⊆  Li, as Fj is totally ordered under [formula]. Let [formula] be the number of edges of elements of Fj.

For all Fa∈Fj, if Mi is a support lemon then [formula].

As L contains no backbone edge by definition, it is enough to show that u is not disconnected from vi in [formula]. As Mi is a support lemon, there exists a set Fi∈Fj such that Fi  ⊆  Li. Consider a set Fa∈Fj with Fa  ⊆  La. If a  ≤  i, then Fa  ⊆  La  ⊆  Li, hence [formula]. If a  ≥  i, then [formula] as Fj is correlated, hence [formula] holds as well. This completes the proof of Claim [\ref=support].

Consider now a vertex u such that either u belongs to some cherry Ci or u belongs to a lemon Mi which is not a support lemon. An edge vava + 1 in the support affects a half-request (u,x,v) if a < i or if i  ≤  a and the unique set Fa∈Fj such that Fa  ⊆  La separates u from x in G1. If vava + 1 does not affect (u,x,v), then neither does vbvb + 1 when b  ≥  a. Indeed when b  ≥  a, Fb  ⊆  Lb and Fb∈Fj, we have that [formula]. Let us now modify the instance. If no edge of the support affects a half requests (u,x,v), where u belongs to some cherry Ci or u belongs to a lemon Mi which is not a support lemon, we remove (u,x,v) from R and add the half-request (x,x,v). Otherwise we let vava + 1 be the support edge with a maximal which affects (u,x,v). We replace (u,x,v) in R by (va + 1,x,v). We call this process projecting the half-request (u,x,v). After projecting all half-requests via x with an endpoint in a cherry or in a lemon Mi which is not a support lemon, we decrease fi by [formula] and contract every edge of P1 which is not in the support of Fj. Note that if vivi + 1 is not in the support then there remains no half-request via x in Mi.

Assume that F' is a solution in this reduced instance which uses an edge vava + 1 in the support. Let Fa be the element of Fj such that Fa  ⊆  La. We have that [formula] is a solution in the original instance. Indeed the requests in the support lemons are cut in [formula] if and only if they are cut by F' since Fa does not intersect these lemons by Claim [\ref=support]. Also, the requests in the lemons which are not support lemons and in the cherries are cut in the reduced instance if and only if they are cut by Fa in the initial instance by construction. Conversely, assume that F is a proper solution in the original instance which uses the edge vava + 1 and such that [formula]. In particular [formula], hence [formula] is a solution of the reduced instance. Indeed, all half-requests (u,x,v) cut by Fa in the original instance are affected by vava + 1, hence they have been projected to (vi,x,v) with i  ≥  a + 1, hence they are cut by [formula] in the reduced instance.

The reduction, consisting in projecting all half-requests with an endpoint in a cherry or in a lemon which is not a support lemon, improves our invariant unless [formula], i.e. unless the proper solution of the original instance with backbone edge vivi + 1 does not use any edge in Li. In this case, all the requests via x of cherry Cj are projected to vj, for all j. By the same argument, we can assume that no edge in a proper solution is selected to the right of Mi and that the half-requests via y of Cj are projected to vj. Hence the cherries do not send any request, so we simply contract them. We are only left with lemons, and we moreover know that if a solution exists, then there exists one which uses only edges in a single lemon. This concludes the proof of Lemma [\ref=onlycherries].

We can assume that G1 only consists of the backbone P1.

We assume that λ > 1 and show that we can improve our invariant. Let us consider a backbone edge vivi + 1. We denote by W the multiset of vertices [formula] where wj is the vertex of the slice Si of vi in Mi which belongs to the path Pj and has a neighbor in [formula]. In other words, wj is the rightmost vertex of each path Pj in the slice of vi. These vertices wj are not necessarily distinct, for instance if vi has degree λ in Mi, the slice Si is exactly {vi} hence all wj are equal to vi for [formula]. We also denote by [formula] the multiset of vertices of the slice Ti of vi + 1 in Mi which belong respectively to the paths [formula] and have a neighbor in [formula].

A multicut F induces a partition of [formula] according to the components of [formula]. A vertex of [formula] has three possible types: it can be in the same component as x after the removal of F, in the same component as y, or in another component. Observe that if two vertices a,b of [formula] belong to components distinct from the components of x and y in [formula], then F is still a multicut after contracting a and b. Hence F induces a partition of W into three parts which can be contracted, still leaving F as a multicut. We now branch over all partitions of [formula] into three parts WZx,WZy,WZu, where WZx are vertices which are in the same component as x, WZy are vertices which are in the same component as y, and WZu are vertices of the same type, possibly disconnected from x and y (but not necessarily so). We branch over all possible partitions of W into WZx,WZy,WZu, and contract in each branch WZx to vi, WZy to vi + 1, and WZu (if not empty) is contracted to a single vertex called ui. These contractions are performed simultaneously in all Mi. We denote by G1' the resulting component, by M'i the contracted lemon Mi, and by S'i the contracted Si.

If some vertex of W belongs to WZy, or if some vertex of Z belongs to WZx, or if WZu intersects both W and Z, then the xy edge-connectivity increases in G'1 since there exists an xy-path in G'1 without edges of λ(x,y)-cut in G1. Hence, we improve our invariant, but we cannot directly conclude since the edges of the backbone may not be critical anymore. Indeed, it can happen that M'i has connectivity (between vi and vi + 1) less than the connectivity of another lemon M'j in which case the backbone edge vjvj + 1 is not critical. To get a correct instance of B M, we simply branch on the connectivity of the lemon Mi' corresponding to the chosen edge vivi + 1. In the branch corresponding to connectivity l, we contract the backbone edges vivi + 1 where Mi' has connectivity distinct from l.

Hence we can assume without loss of generality that W is partitioned into WZu and WZx, and that Z = WZy. Since we contract WZy to vi + 1, we obtain that vi + 1 has now degree λ in M'i, and Ti is a vi + 1-cherry. Let us assume that [formula]. Since we have contracted the vertices of W to vi and ui, the set S'i has exactly two vertices with a neighbour in [formula], namely vi and ui. Note that the degree of vi in [formula] is exactly the number of vertices wj chosen in WZx (with multiplicity since WZx is a multiset). We denote it by d. It does not depend on i since we have chosen in every Mi the same subset WZx inside [formula].

Let λS be the viui edge-connectivity in S'i. If λS  >  f1, we simply contract vi and ui since one cannot separate vi from ui. We branch in order to assume that λS is some fixed value. In the branch corresponding to connectivity λS, we contract backbone edges vivi + 1 where Si has connectivity distinct from λS. Let [formula] be a collection of edge disjoint paths from vi to ui in S'i. We denote by S' the slice of vi in S'i, and again consider the rightmost vertices [formula] of S' in the paths P'j. We branch again over all possible partitions of W' into W'x,W'y,W'u. Again if W'y is not empty, we increase the connectivity between x and y. Observe that W'u can be contracted to WZu, hence to ui. In particular if W'u is not empty, we increase the connectivity between vi and ui in Si'. We iterate this process in S'i until either W'u is empty in which case vi has degree λS in S'i, or λS exceeds f1 in which case we contract vi and ui.

We apply Lemma [\ref=onlycherries] on G'1. Therefore, we can assume that no cherries are left and that if a solution exists, one multicut is contained in some M'i. Two cases can happen:

If f1  ≥  d + λS  +  λ - 1, and vivi + 1 is chosen, then we can assume that the restriction of the multicut to M'i simply consists of all the edges incident to vi and vi + 1 in M'i. Indeed vi is incident to d + λS free edges, and vi + 1 is incident to λ - 1 free edges. This is clearly the best solution since it separates all vertices of [formula] from vi and vi + 1. Therefore, we project every request (u,x,v) where u∈M'i to (vi + 1,x,v) and project every request (u,y,v) where u∈M'i to (vi,y,v). Finally we reduce f1 to 0 and we delete all vertices of G'1 which are not in P1.

Assume now that f1  <  d + λS  +  λ - 1. We branch over 2(λ - 1) choices, where the branches are named Bj and B'j for all [formula]. In the branch Bj, we assume that only one edge of our solution is selected in Pj, and this edge is critical. In the branch B'j, we assume that all the edges of our solution selected in Pj are not critical. Observe that in B'j, we contract non critical edges of Pj and improve our invariant. In the branch Bj, we find a new backbone Pj. In this last case, we delete the edges of P1 and reduce the number of free edges to f1 - 1. We also translate the clauses in terms of edges of the new backbone Pj. Indeed the number of edges in the backbone of G1 has changed. Clauses of the form c1  ≤  i become c1  ≤  ε(i) where ε(i) denotes the index of the rightmost edge of Pj in the lemon M'i.

This branching process covers all the cases where vi = ui since in this case f1 < 2λ - 2 and therefore one path Pj contains only one edge of the multicut. In the case vi  ≠  ui, assume that a multicut F is not of a type treated in one of our branches. In other words, F contains at least two edges in each path Pj for [formula], and at least one of them is critical. Then F contains two edges in each of the d paths Pj not containing ui since F does not respect the branches Bj for [formula]. Also, F contains one edge outside S'i in each path Pj containing ui since edges in S'i are not critical and F is not treated in the branches B'j. Thus F contains at least 2d + (λ - d - 1) free edges outside S'i. Hence less than λS edges of F lie in S'i, thus vi and ui belong to the same component in G - F. This case is covered in another branch in which vi and ui are contracted. Hence this branching process is exhaustive, and this completes the proof of Theorem [\ref=newbackbone].

Reducing to 2-SAT

We are left with instances in which the Y-components with two attachment vertices consist of backbones. We now reduce the last components.

We can assume that there is no component with one attachment vertex.

Let [formula] and k be the number of free edges in our multicut. A vertex yi∈Y is safe if for each pair of components attached only to yi there are no internal requests. If yi is not safe then there is a request (u,yi,v) in the union of the two components attached to yi, hence yi must be disconnected from u or from v by the solution. We explore one branch where u is added to Y, and one branch where v is added to Y. This creates a component with two attachment vertices. This component has a backbone, and then the number of free edges decreases.

Hence we can assume that all the vertices of Y are safe. The yi-cherry is the union of all the components attached to yi. We branch over all possible integer partitions of k into a sum [formula]. In each branch, we require that ki edges are deleted in the yi-cherry for [formula]. By Lemma [\ref=finitelycut], the yi-cherry has a bounded active set Li, hence in the yi-cherry we can consider only a bounded number of cuts of size ki: all subsets of Li of size ki. We then branch over these different choices. In a given branch, we delete a particular set of edges Fi in the yi-cherry. Thus, we delete the vertices of the yi-cherry isolated from yi by Fi, and contract the other vertices of the yi-cherry to yi. Finally, no Y-cherry remains.

Multicut is FPT.

By Lemma [\ref=Ycherry], we are only left with a graph G which is a subdivision of a graph with at most k edges, and a multicut must consist of exactly one edge in each subdivided edge. Let us consider a half-request (vi,x,v'j). Assume without loss of generality that vi∈G1, v'j∈G2, and x belongs to G1 and G2 (if x does not belong to G1 or G2, then splitting Y automatically results in cutting the half-request (vi,x,v'j)). For simplicity, we assume that the edges of both P1 and P2 are enumerated in increasing order from x. We add to C the clauses x1  ≥  i  ⇒  x2  ≤  j - 1 and x2  ≥  j  ⇒  x1  ≤  i - 1. We transform all the half requests in this way. Hence we are only left with a set of clauses which we have to satisfy.

We add all the relations xi  ≥  a  ⇒  xi  ≥  a - 1 and xi  ≤  a  ⇒  xi  ≤  a + 1 and [formula] and [formula]. We now have a 2-SAT instance which is equivalent to the original multicut instance. As 2-SAT is solvable in polynomial time, this shows that B M is FPT. Hence the simpler C M problem is FPT. Together with Theorem [\ref=multitomultiwithback] which reduces M to C M, this concludes the proof of Theorem [\ref=subdividedFPT].

Improving the running time to single exponential

The main problem to get a single exponential bound for our FPT algorithm is Theorem [\ref=extractleft] which uses Δ-systems. Let us improve this bound by the following result.

Every set K with at least [formula] vertices of G contains a subset K' of size k' such that every left cut S with δ(S)  ≤  k satisfies either [formula] or [formula]. The set K' can be computed in FPT single exponential time.

Observe that the result trivially holds when k'  ≤  k. So we can assume k' > k. Recall that G is rooted at x. We prove the result by induction on k. This is clear for k = 1 since the complement of left cuts forms a collection of disjoint sets, hence inducing a partition of K. We have either a class K' of this partition containing at least [formula] elements, or one can find a set K' of size at least [formula] which elements are chosen in different classes. In both cases K' satisfies the induction hypothesis. Assuming k > 1, two cases can happen:

There exists a left indivisible cut S with δ(S)  ≤  k and [formula]. By induction, we extract from [formula] a subset K' with size k' such that every left cut S with δ(S)  ≤  k - 1 satisfies either [formula] or [formula]. To conclude, let us consider a left cut S' with δ(S') = k. If S' = S, S' isolates K', hence we assume that S' is distinct from S. Observe that [formula] is equal to [formula]. Since [formula] is a left cut with border at most k - 1, we then have [formula] is either K' or has size at most k - 1. Hence our conclusion holds.

Assume that all left indivisible cuts S with δ(S)  ≤  k satisfy [formula]. Let us form a graph H with vertex set K and where vv' is an edge when there exists a left indivisible cut S with δ(S)  ≤  k such that [formula]. The degree of a vertex v of H is less than [formula] since the number of left indivisible xv-cuts with border at most k is at most k!. Note that d is less than [formula] since k'  ≥  k. So there is a stable set K' in H of size at least |K| / d, i.e. at least k' since [formula]. Observe that every indivisible left cut S with δ(S)  ≤  k isolates at most one vertex of K'. Hence every left cut S with δ(S)  ≤  k isolates at most k vertices of K'.

The function h of Theorem [\ref=extractright] is at most [formula], so the function b in Theorem [\ref=cherryrequestreduction] is at most kO(k).(kO(k))k2 = kO(k3). So each node of our branching algorithm is computed in FPT time with a single exponent. The depth being polynomial, the overall complexity has a single exponent.

Vertex Multicut is FPT

We propose here a sketch of a translation of our proof for edge-multicut in terms of vertex-multicut. The proof has the same outline, hence we just explain how the notions introduced for edge-multicut can be transferred to the vertex-multicut setting. We prove that the following version of Multicut is FPT.

V M: Input: A graph G, a set of requests R, a subset of vertices S, an integer k. Parameter: k. Output: TRUE if there is a vertex-multicut of size at most k which does not intersect S, otherwise FALSE.

Observe that this is equivalent to the standard version of V M when the set S is empty. Let us now explain how we can translate the results of the previous sections for V M.

For Section [\ref=sectionconnectivity], the results are based on the submodularity of edge cuts. The vertex cuts being also submodular, we can transfer the results for vertices. Here an indivisible xy-cut is a set of vertices K which deletion separates x from y such that no strict subset of K separates x from y. For the reduction from V M to C M, the proof is essentially the same. One particularity of V M is the following. When we contract vertices, we have to add the resulting vertex to S, the set of non deletable vertices. Let Y be the vertex-multicut of size k + 1 given by iterative compression. We can branch to decide which vertices of Y belong to the solution and then branch over the possible contractions of the set Y. Hence we can assume that Y  ⊆  S. Notice that we have to replace "we add a vertex to Y" by "we branch to know if the vertex is added to Y or if it belongs to the solution". The connectivity between x and y is the maximum number of paths between x and y which are disjoint on the set of deletable vertices. The connectivity can be calculated by flows with weight 1 for deletable vertices and ∞   for non-deletable vertices. A vertex of λ-cut is a deletable vertex which deletion decreases the connectivity. In the vertex-multicut context, a backbone is a path in which only one vertex is deleted and where every odd vertex belongs to the set S. In addition all the vertices of the backbone are vertices of λ-cut.

To prove the existence of a backbone, we have to generalize Lemma [\ref=degreexy]. The border of the slice of xi has size at most k but the number of vertices which touch this border can be arbitrarily large. We can branch to know if a vertex is deleted in the slice. If this is not the case then the slice can be contracted to xi, hence xi has only λ neighbours. Otherwise we can branch to know if each vertex in the border is in the component of yi or a new component. In each of these case the invariant improves. Hence the only case which is uncovered is the case when all the vertices are with x. We can contract x with the border of its slice and we have a cherry in which we have to delete vertices. By Lemma [\ref=finitelycut], we can bound the number of possible cuts. We can branch over these cuts and decrease the deletion allowance.

Let us now explain how we can prove that the B M problem is FPT. A key notion of Section [\ref=trlemon] is the notion of full vertex. We have to modify this notion since contracted vertices are not deletable. Hence all the vertices of the backbone cannot be full as for Edge-Multicut. Actually, we transform the instance into an instance where the non-deletable vertices are full (see Figure [\ref=vertexlemons]). The slice S(v) of a non-deletable vertex v is the connected component of v in G minus the vertices of λ-cut. We define the tag as for edge-multicut. A vertex v of the backbone is X-stable if it can be deleted, and the tags of its two neighbours are X and the tag after the contraction of v with its two neighbors is still X. As for edge-multicut, we can assume that we delete an X-stable vertex in the backbone. We can similarly define classes for Lemma [\ref=seqlemons], and remark that one class does not intersect the solution. All the vertices of each slice in this class can be contracted. This ensures that we can assume that all the vertices which are non deletable are full. We can write as in Lemma [\ref=onlylemons] that a non-deletable vertex is left (resp. right) clean if the vertex to its left (resp. right) is X-stable and then we can assume that X = {1,...,λ} as for edge-multicut.

In the reduction of the lemons for Vertex-Multicut, we cannot contract x with the border of its slice since it does not ensure that the degree of x is λ. Hence we have to contract x with vertices of its slice which touch the vertices of the border. The set of such vertices can be restricted to a bounded size with Lemma [\ref=finitelycut]. Hence the same inductive method used for edge-multicut also holds.