Kitaev's [formula]-Codes Threshold Estimates

Kitaev's topological code (KTC) [\cite=K03a] on qubits is the archetypical topological code and has been extensively studied. As explained in Kitaev's original paper [\cite=K03a], this construction applies to any group. Much less is known about these generalizations, and in this paper we investigate the quantum error correction (QEC) thresholds of the KTCs built with the groups [formula], where [formula]. We label these as [formula]-KTC, so the original code on qubits corresponds to [formula]-KTC.

As explained in [\cite=DKLP02a], [formula]-KTC can be decoded by a binary perfect matching algorithm [\cite=E65a], since every particle is its own anti-particle in this model. Because this is not the case for d  >  2, other techniques are required and for this purpose we generalize the renormalization group (RG) soft decoder that we introduced in [\cite=DP09a] [\cite=DP10a]. Our numerical simulations show that the threshold increases monotonically with d and appears to follow the general trend of the qudit hashing bound.

This paper is organized as follows. First, we introduce a generalized Pauli group (see [\cite=K96a] [\cite=G99a] for more details), stabilizer codes, and [formula]-Kitaev's toric code. Next, we briefly review the decoding problem of these systems and show how the RG decoder applies in this case. Finally, we present the numerical results and close with a discussion.

[formula] generalization of Kitaev's toric code

In this section, we review the definition of [formula]-KTC and show that many features of KTC on qubits extend to them. Since we will be working with qudits, we introduce a generalized Pauli group. The Hilbert space of a qudit, Hd, is spanned by the states [formula]. We define the operators X and Z such that

[formula]

where 0  ≤  g < d, "[formula]" denotes addition modulo d, and [formula]. The generalized Pauli group is generated by X, Z, and a phase, i.e., Pd  =  〈ω,X,Z〉 if d is odd and Pd  =  〈ω1 / 2,X,Z〉 if d is even (XZ has order 2d in this case). From the definitions of Eq. [\eqref=eq:defXZ], we deduce the following properties

[formula]

Lastly, we define the n-qudit Pauli group [formula] as the n-fold tensor product of Pd.

The stabilizer group S is an ablian subgroup of Pnd. The code is defined as the simultaneous +1 eigenspace of all stabilizers. Note that even though the generalized Pauli operators are unitary, they are not hermitian in general so do not correspond to physical observables. However, the operator [formula] is hermitian and can be measured. Since s has eigenvalues ωa, [formula] has eigenvalues [formula] which are in one-to-one correspondence with the eigenvalues of s.

With these definitions in place, we present a generalization of KTC on qudits, which we call [formula]-KTC, using Kitaev's original construction [\cite=K03a] on the cyclic groups [formula] with [formula]. The system is a square lattice of linear size L with periodic boundary conditions. Each edge is occupied by a qudit, so there are in total n  =  2L2 qudits. We define vertex operators Av and plaquette operators Bp as shown in Fig. [\ref=fig:stab_gen]. There is one such operator for each vertex and each plaquette. We verify that they commute using the last line of Eq. [\eqref=eq:properties]. These operators generate the stabilizer group S  =  〈Av,Bp〉 and the code is spanned by the simultaneous +1 eigenstates of the stabilizer generators.

Figure [\ref=fig:charges] illustrates how applying some power of X on a codestate creates defects on the lattice. Indeed, Xa applied on some qudit does not commute with the two plaquette operators involving that qudit. The eigenvalues of the plaquettes to the north or east of the error will change from 1 to ωa, and those of the plaquettes to the south or west will change from 1 to ω- a. One can show that the defects thus created are topological charges; we associate the charge a to a plaquette defect corresponding to an eigenvalue ωa of that plaquette. With this choice of labeling, the charge group restricted to plaquettes is [formula] with addition.

From these simple facts, it follows that string operators can be built with defects attached only to their endpoints (these strings actually live on the dual lattice, just like in KTC). This requires a careful choice of the powers of X on the qudits along the string such that the total charge in each plaquette is 0 except on its endpoints. For instance, one can adopt the convention that power a is used when heading north or east, and - a when heading south or west. Moreover, we can verify that non-trivial cocycles (loops on the dual lattice, see Fig. [\ref=fig:charges]) of any power of X obeying this convention commute with the stabilizer. These operators are not in the stabilizer as all the vertex generators of Fig. [\ref=fig:stab_gen] are trivial cocyles. It follows that such operators, e.g. the one found at the bottom of Fig. [\ref=fig:charges], are logical operators (for any value of a).

A similar analysis holds for defects created by powers of Z operators. In this case, the defects live on vertices and string operators, on the direct lattice. Also, non-trivial cycles of any power of Z are logical operators. From the form of the logical operators, we directly deduce that there are two qudits encoded in the code space. Again, this is analogous to the case of KTC.

[formula]-KTC decoding

We are now interested in the problem of error correcting [formula]-KTCs for d > 2. In our study, we consider a simple noise model that generalizes the independent symmetric bit-flip channel to qudits: with probability 1 - pphys, the qudit remains unaffected and with probability pphys, we apply at random (uniformely distributed) one of [formula]. Suppose an error E∈Pnd occurs on a code state. It creates defects on the lattice and by measuring the eigenvalues of every [formula] and [formula] we can learn the position and charge of each defect. The role of the decoder is to bring the system back in the code space by applying a correcting Pauli operator, C∈Pnd. However, care must be taken in choosing an appropriate correcting operation. Indeed, if the operator CE resulting from the combination of the error and the recovery is an element of S, the state is unaffected. However, if CE is a non-trivial logical operator, then the system is returned to the code space but potentially in a different code state, so the information is corrupted.

Any operator E∈Pnd creating the measured configuration of defects is a potential error. However, we classify these operators by their logical effect on the code space: two operators E1,E2 with the same configuration of defects are equivalent iff [formula] has a trivial effect on the code, i.e. E1  ~  E2 iff [formula]. Note that since E1 and E2 lead to the same defect configuration, [formula] creates no defect, or equivalently, E1 creates some defects that [formula] annihilates.

Given a measured defect configuration, the decoder seeks for the best correction among the set of all errors which would lead to this defect configuration. One strategy would be to identify the error from this set that has the largest probability P(E), where the probability of an error is specified by the physical noise model, in our case the symmetric bit-flip channel. This turns out not to be optimal however, because some errors have equivalent effects on all code states. Thus, the decoder should instead seek for the most likely equivalence class of errors. The probability of an equivalence class of errors is obtained by summing over the probability of each error within a class. Given these probabilities, the optimal correction consists in applying the adjoint of any representative of the class with maximal probability.

RG decoder generalization to [formula]-KTC

Unfortunately, the above procedure cannot be realized efficiently in general since the number of errors in each equivalence class scales exponentially with the system size. In [\cite=DP09a] [\cite=DP10a], we introduced a renormalization group soft decoder (RG decoder) that efficiently approximates the exact calculation (see [\cite=BH11a] for a related scheme). The general idea is to cut the lattice into small unit cells (e.g. [formula] sub-lattices) and to "distill" from each cell an effective two-qubit noise model, c.f. Fig. [\ref=fig:UCRG](a). This is realized by keeping track of the flow of charges through the cell and summing over the microscopic details leading to this flow. This has the effect of shrinking the lattice linear size by a constant factor (k for cells of size k  ×  k). Recursing on this process, one can shrink the lattice to a constant, manageable, size where the exact decoding can be performed. With appropriate simple modifications, this method can be used for charges over [formula].

There are two technical difficulties in realizing the above heuristic description, which are both caused by charge conservation. First, because the unit cells share boundaries, the flow of charge through one boundary of a cell should be equal and opposite to the flow of charge of the corresponding boundary of the neighbouring cell. Thus, the variable corresponding to charge flows in each cell are highly constrained. This problem is easily circumvented by keeping only track of the flow of charge through the northern and the western boundary of each cell, i.e. by eliminating this redundancy.

Second, the sum of the charge flow through the boundaries of a cell must be equal to its total charge, revealed by the syndrome measurement. This once again sets a hard constraint between the variables corresponding to the charge flows, which would in principle require a probability distribution that correlates all the variables of the system. This cannot be realized efficiently, so we must resort to some approximation. As a first approximation, we choose to ignore the cross-cell correlations, and keep only marginal probabilities on the flows associated to a given cell (we keep a probability distribution that involves the northern and western boundary only). To diminish the effect of these correlations we are neglecting, we let the charge inside a unit cell fluctuate. For each unit cell, we measure all but one of the plaquettes it encloses. This remaining plaquette thus determines the total charge of the unit cell, and indeed we can substitute the corresponding stabilizer generator by a plaquette enclosing the entire unit cell (obtained by multiplying all the plaquette operators contained in the unit cell). This new stabilizer generator represents a renormalized charge.

This procedure is illustrated on Fig. [\ref=fig:UCRG](a) where green disks represent plaquettes that are measured and the green circle represents the plaquette that is left fluctuating. This green circle is replaced by the larger, renormalized green disk (on the right) that is used in the next RG step. The white disks on this figure each represent a probability distribution on charge flow, or equivalently a two-qudit probability distribution. Thus, after one round of RG, we are left with a smaller lattice and both renormalized charges and renormalized noise models.

Equation ([\ref=eq:UCRGbasis]) lists a set of generators for all X operators living on a unit cell (see Fig. [\ref=fig:UCRG](b) for labelling). This basis will be used to decompose any X-type error contained on the unit cell. These operators are defined in accordance to the renormalization process itself as we now explain. The Ti operators are used to build a representative error with the appropriate defect configuration. Indeed, only the Ti operators of Eq. [\eqref=eq:UCRGbasis] do not commute with all three plaquette operators in the unit cell (green disks of Fig. [\ref=fig:UCRG](a)). Label the defect configuration on a unit cell as [formula], where a0 is the charge of the north-west plaquette, a1 is the charge of the north-east one, and a2 is the charge of the south-west one. Then, the Pauli operator [formula] creates the defect configuration [formula]. Moreover, given a defect configuration [formula], every potential error has to contain this product in its decomposition on basis Eq. [\eqref=eq:UCRGbasis] since only the Ti operators do not commute with plaquettes. The Li operators characterize the flow of charge through the northen and western boundaries, so the two-qudit ouput distribution of a RG round is precisely the probability distribution over these two operators. The Si operators are stabilizer operators (or parts of stabilizer generators supported on the unit cell). They only deform strings without changing their defect configuration or their associated charge flow. Lastly, the Ei operators correspond to charge flowing through the southern and eastern boundaries into the plaquette operator that is left out. Thus, they are responsible for the charge fluctuation inside the unit cell and they are summed over.

[formula]

With these definitions, we can formally describe a RG round that starts with a defect configuration [formula], and computes the marginal probability of each l∈〈L0,L1〉 conditioned on the measured defect configuration,

[formula]

where t = Ta0Ta1Ta2 is given by the defect configuration and P(tles) is the probability assigned to the error E = tles by the noise model. The complexity of decoding a unit cell is given by the number of operators that are considered in Eq. [\eqref=eq:RG]: |〈L0,L1〉|  ·  |〈E0,E1〉|  ·  |〈S0,S1,S2〉|. Since all Li, Ei and Si have order d, the complexity is the constant d7. For different unit cell sizes, the complexity is still a power of d, but with a different exponent which depends on the number of qudits in the cell and the number of measured stabilizer generators. Moreover, the number of unit cells to decode in a given round of RG is given by (L / k)2 where k and L are the linear sizes of the unit cell and the global lattice, respectively. Thus, the complexity of a step of RG goes as dc(L / k)2 for some constants c and k that depend on the choice of unit cell. Of course, the RG calculations on different cells can be executed in parallel.

The procedure we have described above to evade the correlations caused by local charge conservation is only a heuristic, and can be improved using belief propagation (BP). Roughly, the role of BP is to ensure consistency between the marginal probability of qubits located at the boundary of two or more unit cells, e.g. qudits 0, 1, 8 and 9 (see Fig. [\ref=fig:UCRG](b) for labeling). First, given a defect configuration inside a unit cell, one can compute the marginal error probability Pq(tles|q) for each qudit q, obtained by taking a marginal of P(tles). These are called messages and denoted moutq(p), where q labels a qudit and p is a one-qudit Pauli operator. These outgoing messages are then exchanged between neighbouring cells, and become incoming messages, e.g. a cell c sends to its northern neighbour c' the message mout0 that becomes min9 in c', and receives from c' the message mout9 that becomes min0 in c. Subsequent rounds of messages can be calculated using the received messages, following the prescription

[formula]

Here, q,q'∈{0,1,8,9}, tles|q is the restriction to qudit q of the Pauli operator tles and Pq is the marginal on qudit q of the noise model as above. BP can be iterated a few times (e.g. three rounds) before executing a RG step. This has the effect of replacing Eq. [\eqref=eq:RG] by

[formula]

Numerical results

In this section, we present our numerical estimates of the thresholds of [formula]-KTCs for [formula] subject to the generalized bit-flip noise model introduced in the previous section. The threshold is defined as the value of the physical noise rate pphys below which the decoding error probability pdec can be made arbitrarily small by increasing the lattice size L.

The simulations were performed as follows. For various values of d, L and pphys, specifiying a [formula]-KTC of linear size L subject to a noise of parameter pphys, we performed a Monte Carlo simulation to estimate the decoding error probability pdec. We used sample sizes of the order of 104. For a fixed value of d, we plotted estimates of pdec vs pphys for different values of L. We then used the fitting model pdec = (pphys - pth)L1 / ν (see [\cite=DKLP02a] [\cite=H04a] for more details) to estimate the value of the threshold. As an example, we plotted the results and the fits for [formula]-KTC on Fig. [\ref=fig:Z3_pth].

Repeating this for [formula] (2 was studied in [\cite=DP09a] [\cite=DP10a]), Fig. [\ref=fig:HB_Results] shows pth as a function of d. Heuristically, we did expect that the value of pth increases with d. Indeed, if we imagine simulating a qudit using log 2d qubits, a fixed noise rate for increasing values of d translates into a decreased noise rate per qubit. Moreover, it was reported in [\cite=AMT12a] that the performance of BP for [formula]-KTC, which is very poor in the qubit case, is greatly increased as d grows.

It is intringuing to note that for [formula]-KTC subject to bit-flip or depolarizing noise, pth is numerically very close to the hashing bound [\cite=DKLP02a] [\cite=H04a] [\cite=BAOKM12a]. The hashing bound, obtained by a simple packing argument [\cite=EM96a], states that for non-degenerate CSS codes,

[formula]

where H2 is the binary entropy: H2(p) = (1 - p) log 2(1 - p) + p log 2p. From Eq. [\eqref=eq:HB2], one can calculate the saturating point [formula] which is indeed quite close to the optimal threshold of the [formula]-KTC subject to independent bit-flip and phase-flip errors, [formula] [\cite=DKLP02a] [\cite=H04a]. This near coincidence is intriguing given that topological codes are highly degenerate, so there is no reason they should obey the hashing bound. Of course, the decoder we are using here is sub-optimal, so the threshold we find [formula] is a smaller fraction α  =  pth(2) / C2  ≈  0.81(4) of the hashing bound.

For qudits, the hashing bound is

[formula]

In this case, we find [formula] and so on. Figure [\ref=fig:HB_Results] shows the threshold pth(d) obtained with the RG decoder as well as a rescaled hashing bound αCd where α is determined by the [formula] fit. The agreement is both unexplained and surprisingly good. Note also that even though our decoder is sub-optimal, pth(d + 1) > Cd for all d we have studied, which strongly support the claim that the threshold increases with d.

Conclusion

In this paper, we presented a generalization of the renormalization group decoder of [\cite=DP09a] [\cite=DP10a] to Kitaev topological codes built with the groups [formula]. Our numerical results show that the threshold value increases as a function of the local dimension d. Moreover, its behaviour is in very good agreement with a scaling predicted by the hashing bound. This trend could be confirmed by more accurate numerical estimates using a mapping to a statistical mechanics model, which does not require solving the decoding problem [\cite=DKLP02a] [\cite=BAOKM12a]. A theoretical understanding of this behavior is also desirable. Lastly, estimating the threshold in the presence of measurement error and detailed syndrome measurement circuits on qudits remains an interesting open question.

Acknowledgements

We would like to thank Jonas Anderson for useful discussions regarding the generalized hashing bound. We also thank Simon Burton, Courtney Brell and Stephen Bartlett for enlightening discussions of Kitaev's construction [\cite=K03a]. Computational resources were provided by Calcul Québec and Compute Canada. This work was partially funded by NSERC and by Intelligence Advanced Research Projects Activity (IARPA) via Department of Interior National Business Center contract D11PC20167. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright annotation thereon. Disclaimer: The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of IARPA, DoI/NBC, or the U.S. Government.