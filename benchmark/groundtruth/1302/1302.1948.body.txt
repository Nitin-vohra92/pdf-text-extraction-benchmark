Lemma Corollary Claim Definition

Randomized partition trees for exact nearest neighbor search

Introduction

The problem of nearest neighbor search has engendered a vast body of algorithmic work. In the most basic formulation, there is a set S of n points, typically in an Euclidean space [formula], and any subsequent query point must be answered by its nearest neighbor (NN) in S. A simple solution is to store S as a list, and to address queries using a linear-time scan of the list. The challenge is to achieve a substantially smaller query time than this.

We will consider a prototypical modern application in which the number of points n and the dimension d are both large. The primary resource constraints are the size of the data structure used to store S and the amount of time taken to answer queries. For practical purposes, the former must be O(n), or maybe a little more, and the latter must be o(n). Secondary constraints include the time to build the data structure and, sometimes, the time to add new points to S or to remove existing points from S.

A major finding of the past two decades has been that these resource bounds can be met if it is enough to merely return a c-approximate nearest neighbor, whose distance from the query is at most c times that of the true nearest neighbor. One such method that has been successful in practice is locality sensitive hashing (LSH), which has space requirement n1 + ρ and query time O(nρ), for ρ  ≈  1 / c2 [\citep=AI08]. Another such method is the balanced box decomposition tree, which takes O(n) space and answers queries with an approximation factor c  =  1 + ε in O((6 / ε)d log n) time [\citep=AMNSW98].

In the latter result, an exponential dependence on dimension is evident, and indeed this is a familiar blot on the nearest neighbor landscape. One way to mitigate the curse of dimensionality is to consider situations in which data have low intrinsic dimension do, even if they happen to lie in [formula] for d  ≫  do or in a general metric space. A common assumption is that the data are drawn from a doubling measure of dimension do (or equivalently, have expansion rate 2do); this is defined in Section [\ref=sec:doubling] below. Under this condition, [\citet=KR02] have a scheme that gives exact answers to nearest neighbor queries in time O(23do log n), using a data structure of size O(23don). The more recent cover tree algorithm [\citep=BKL06], which has been used quite widely, creates a data structure in space O(n) and answers queries in time O(2do log n). There is also work that combines intrinsic dimension and approximate search. The navigating net [\citep=KL04], given data from a metric space of doubling dimension do, has size O(2O(do)n) and gives a (1 + ε)-approximate answer to queries in time O(2O(do) log n  +  (1 / ε)O(do)); the crucial advantage here is that doubling dimension is a more general and robust notion than doubling measure.

Despite these and many other results, there are two significant deficiencies in the nearest neighbor literature that have motivated the present paper. First, existing analyses have succeeded at identifying, for a given data structure, highly specific families of data for which efficient exact NN search is possible--for instance, data from doubling measures--but have failed to provide a more general characterization. Second, there remains a class of nearest neighbor data structures that are popular and successful in practice, but that have not been analyzed thoroughly. These structures combine classical k-d tree partitioning with randomization and overlapping cells, and are the subject of this paper.

Three randomized tree structures for exact NN search

The k-d tree is a partition of [formula] into hyper-rectangular cells, based on a set of data points [\citep=B75]. The root of the tree is a single cell corresponding to the entire space. A coordinate direction is chosen, and the cell is split at the median of the data along this direction (Figure [\ref=fig:kd-vs-rp], left). The process is then recursed on the two newly created cells, and continues until all leaf cells contain at most some predetermined number no of points. When there are n data points, the depth of the tree is at most about log (n / no).

Given a k-d tree built from data points S, there are several ways to answer a nearest neighbor query q. The quickest and dirtiest of these is to move q down the tree to its appropriate leaf cell, and then return the nearest neighbor in that cell. This defeatist search takes time just O(no  +   log (n / no)), which is O( log n) for constant no. The problem is that q's nearest neighbor may well lie in a different cell, for instance when the data happen to be concentrated near cell boundaries. Consequently, the failure probability of this scheme can be unacceptably high.

Over the years, some simple tricks have emerged, from various sources, for reducing the failure probability. These are nicely laid out by [\citet=LMGY04], who show experimentally that the resulting algorithms are effective in practice.

The first trick is to introduce randomness into the tree. Drawing inspiration from locality-sensitive hashing, [\citet=LMGY04] suggest preprocessing the data set S by randomly rotating it, and then applying a k-d tree (or related tree structure). This is rather like splitting cells along random directions as opposed to coordinate axes (Figure [\ref=fig:kd-vs-rp], right). In this paper, we consider a data structure that uses random split directions as well as a second type of randomization: instead of putting the split point exactly at the median, it is placed at a fractile chosen uniformly at random from the range

[formula]

left = {x: x · U < m(C)}    right = {x: x · U ≥ m(C)}

[formula]

left = {x: x · U < r(C)}    right = {x: x · U ≥ l(C)}.

[formula]

Analysis of failure probability

Our three schemes for nearest neighbor search--the RP tree and the two spill trees--can be analyzed in a simple and unified framework. Pick any data set [formula] and any query [formula]. The probability of failure, of not finding the nearest neighbor, can be shown to be directly related to the quantity

[formula]

where [formula] denotes an ordering of the xi by increasing distance from q. For RP trees, the failure probability is proportional to Φ log (1 / Φ) (Theorem [\ref=thm:rp]); for the two spill trees, it is proportional to Φ (Theorem [\ref=thm:spill]). The results extend easily to the problem of searching for the k nearest neighbors. Moreover, these bounds are roughly tight: a failure probability proportional to Φ is inevitable unless there is a significant amount of collinearity within the data (Corollary [\ref=cor:three-points]).

Let's take a closer look at this potential function. If Φ is close to 1, then all the points are roughly the same distance from q, and so we can expect that the NN query is not easy to answer. On the other hand, if Φ is close to zero, then most of the points are much further away than the nearest neighbor, so the latter should be easy to identify. Thus the potential function is an intuitively reasonable measure of the difficulty of NN search.

This general characterization of data configurations amenable to efficient exact NN search, by the three data structures, is our main result. Earlier work has looked at other data structures, and has only provided guarantees for very specific families of data. To illustrate our theorem, we bound Φ for two commonly-studied data types. In either scenario, the queries are arbitrary.

When [formula] are drawn i.i.d. from a doubling measure (Section [\ref=sec:doubling]). As we discussed earlier, this is the assumption under which many other results for exact NN search have been obtained.

When [formula] are documents drawn from a topic model (Section [\ref=sec:topics]).

For doubling measures of intrinsic dimension do, we show that the spill tree is able to answer exact nearest neighbor queries in time O(do)do  +  O( log n), with a probability of error that is an arbitrarily small constant, while the RP tree is slower by only a logarithmic factor (Theorem [\ref=thm:failure-doubling]). These are close to the best results that have been obtained using other data structures. (The failure probability is over the randomization in the tree structure, and can be further reduced by building multiple trees.) We chose the topic model as an example of a significantly harder case: its data distribution is more concentrated, in the sense that there are a lot of data points that are only slightly further away than the nearest neighbor. The resulting savings are far more modest though non-negligible: for large n, the time to answer a query is roughly [formula], where L is the expected document length.

In some situations, the time to construct the data structure, and the ability to later add or remove data points, are significant factors. It is readily seen that the construction time for the spill tree is proportional to its size, while that of the RP tree and the virtual spill is O(n log n). Adding and removing points is also easy: all guarantees hold if these are performed locally, while rebuilding the entire data structure after every O(n) such operations.

A potential function for point configurations

To motivate the potential function Φ, we start by considering what happens when there are just two data points and one query point.

How random projection affects the relative placement of three points

Consider any three points [formula], such that x is closer to q than is y; that is, [formula].

Now suppose that a random direction U is chosen from the unit sphere Sd - 1, and that the points are projected onto this direction. What is the probability that y falls between q and x on this line? The following lemma answers this question exactly. An approximate solution, with different proof method, was given earlier by [\citet=K97].

Pick any [formula] with [formula]. Pick a random unit direction U. Then

[formula]

We may assume that U is drawn from N(0,Id), the d-dimensional Gaussian with mean zero and unit covariance. This gives exactly the right distribution if we scale U to unit length, but we can skip this last step since it has no effect on the question we are considering.

We can also assume, without loss of generality, that q lies at the origin and that x lies along the (positive) x1-axis: that is, q  =  0 and [formula]. It will then be helpful to split the direction U into two pieces, its component U1 in the x1-direction, and the remaining d - 1 coordinates UR. Likewise, we will write y  =  (y1,yR).

If yR  =  0 then x, y, and q are collinear, and the projection of y cannot possibly fall between those of x and q. In what follows, we assume yR  ≠  0.

Let E denote the event of interest:

[formula]

The interval of interest is either [formula], if U1  ≥  0, or [formula], if U1  <  0. To simplify things, yR  ·  UR is independent of U1 and is distributed as [formula], which is symmetric and thus assigns the same probability mass to the two intervals. We can therefore write

[formula]

Let Z and Z' be independent standard normals N(0,1). Since U1 is distributed as Z and yR  ·  UR is distributed as [formula],

[formula]

Now Z' / |Z| is the ratio of two standard normals, which has a standard Cauchy distribution. Using the formula for a Cauchy density,

[formula]

which is exactly the expression in the lemma statement once we invoke [formula] and factor in our assumption that q = 0.

To simplify the expression, define an index of the collinearity of q,x,y to be

[formula]

This value, in the range

[formula]

≤   Pr(y  ·  U falls between q  ·  U and x  ·  U)  ≤   .

[formula]

By how much does random projection separate nearest neighbors?

For a query q and data points [formula], let [formula] denote a re-ordering of the points by increasing distance from q. Consider the potential function

[formula]

Pick any points [formula]. If these points are projected to a direction U chosen at random from the unit sphere, then

[formula]

Let Zi be the event that x(i) falls between q and x(1) in the projection. By Corollary [\ref=cor:three-points],

[formula]

The lemma now follows by linearity of expectation.

The upper bound of Theorem [\ref=thm:insertion] is fairly tight, as can be seen from Corollary [\ref=cor:three-points], unless there is a high degree of collinearity between the points.

In the tree data structures we analyze, most cells contain only a subset of the data [formula]. For a cell that contains m of these points, the appropriate variant of Φ is

[formula]

Pick any points [formula] and let S denote any subset of the xi that includes x(1). If q and the points in S are projected to a direction U chosen at random from the unit sphere, then for any 0  <  α  <  1,

[formula]

This follows immediately by applying Theorem [\ref=thm:insertion] to S, noting that the corresponding value of Φ is maximized when S consists of the points closest to q, and then applying Markov's inequality.

Extension to k nearest neighbors

If we are interested in finding the k nearest neighbors, a suitable generalization of Φm is

[formula]

Pick any points [formula] and let S denote any subset of the xi that includes [formula]. Suppose q and the points in S are projected to a direction U chosen at random from the unit sphere. Then, for any 0  <  α  <  1, the probability (over U) that in the projection, there is some 1  ≤  j  ≤  k for which ≥  αm points lie between x(j) and q is at most

[formula]

provided k  <  α|S|  +  1.

Set m  =  |S|. As in Corollary [\ref=cor:insertion], the probability of the bad event is maximized when [formula], so we will assume as much.

For any 1  ≤  j  ≤  k, let Nj denote the number of points in [formula] that fall (strictly) between q and x(j) in the projection. Reasoning as in Theorem [\ref=thm:insertion], we have

[formula]

Taking a union bound over all 1  ≤  j  ≤  k,

[formula]

as claimed.

Bounds on Φ

The results so far suggest that Φ is closely related to the failure probabilities of the randomized search trees we have described. In the next section, we will make this relationship precise. We will then give bounds on Φ for various types of data. Here is a brief preview: for large enough m, very roughly,

[formula]

Randomized partition trees

We'll now see that the failure probability of the random projection tree is proportional to Φ ln (1 / Φ), while that of the two spill trees is proportional to Φ. We start with the second result, since it is the more straightforward of the two.

Randomized spill trees

In a randomized spill tree, each cell is split along a direction chosen uniformly at random from the unit sphere. Two kinds of splits are simultaneously considered: (1) a split at the median (along the random direction), and (2) an overlapping split with one part containing the bottom 1 / 2  +  α fraction of the cell's points, and the other part containing the top 1 / 2  +  α fraction, where 0  <  α  <  1 / 2 (recall Figure [\ref=fig:splits]).

We consider two data structures that use these splits in different ways. The spill tree stores each data point in (possibly) multiple leaves, using overlapping splits. The tree is grown until each leaf contains at most no points. A query is answered by routing it to a single leaf, using median splits, and returning the NN in that leaf.

The time to answer a query is just O(no  +   log (n / no)), but the space requirement of this data structure is super-linear. Its depth is [formula] levels, where β  =  (1 / 2)  +  α, and thus the total size is

[formula]

We will take no to be a constant independent of n, so this size is O(nlog 1 / β2). When α  =  0.05, for instance, the size is O(n1.159). When α  =  0.1, it is O(n1.357).

A virtual spill tree stores each data point in a single leaf, using median splits, once again growing the tree until each leaf has no or fewer points. Thus the total size is just O(n) and the depth is log 2(n / no). However, a query is answered by routing it to multiple leaves using overlapping splits, and then returning the NN in the union of these leaves.

Suppose a randomized spill tree is built using data points [formula], to depth [formula], where β  =  (1 / 2)  +  α for regular spill trees and β  =  1 / 2 for virtual spill trees. If this tree is used to answer a query q, then the probability (over randomization in the construction of the tree) that it fails to return x(1) is at most

[formula]

The probability that it fails to return the k  >  1 nearest neighbors [formula] is at most

[formula]

provided k  ≤  αno / 2.

Let's start with the regular spill tree. Consider the internal node at depth i on the root-to-leaf path of query q; this node contains βin data points, for β  =  (1 / 2)  +  α. What is the probability that q gets separated from x(1) when the node is split? This bad event can only happen if q and x(1) lie on opposite sides of the median and if x(1) is transmitted only to one side of the split, that is, if at least α fraction of the points lie between x(1) and the median. This means that at least an α fraction of the cell's projected points must fall between q and x(1), which occurs with probability at most [formula] by Corollary [\ref=cor:insertion]. The lemma follows by summing over all levels i.

The argument for the virtual spill tree is identical, except that we use β  =  1 / 2 and we swap the roles of q and x(1); for instance, we consider the root-to-leaf path of x(1).

The generalization to k nearest neighbors is immediate for spill trees. The probability of something going wrong at level i of the tree is, by Theorem [\ref=thm:insertion-k], at most

[formula]

Virtual spill trees require a slightly more careful argument. If the root-to-leaf path of each x(j), for 1  ≤  j  ≤  k, is considered separately, it can be shown that the total probability of failure at level i is again bounded by the same expression.

As we mentioned earlier, we will encounter two functional forms of Φm: either 1 / m1 / do, where do is a notion of intrinsic dimension, or a small constant [formula]. In the former case, the failure probability of the spill tree is roughly 1 / (αn1 / doo), and in the latter case it is [formula]. Further details are in Sections [\ref=sec:doubling] and [\ref=sec:topics].

Random projection trees

In an RP tree, a cell is split by choosing a direction uniformly at random from the unit sphere Sd - 1, projecting the points in the cell onto that direction, and then splitting at the β fractile, for β chosen uniformly at random from

[formula]

Φ ln ,

[formula]

( 2k Φ ln ) + .

[formula]

Is randomization necessary?

The tree data structures we have studied make crucial use of random projection for splitting cells. It would not suffice to use coordinate directions, as in k-d trees.

To see this, consider a simple example. Let q, the query point, be the origin, and suppose the data points [formula] are chosen as follows:

x1 is the all-ones vector.

Each xi,i  >  1, is chosen by picking a coordinate at random, setting its value to M, and then setting all remaining coordinates to uniform-random numbers in the range (0,1). Here M is some very large constant.

For large enough M, the nearest neighbor of q is x1. By letting M grow further, we can let [formula] get arbitrarily close to zero, which means that our random projection methods will work admirably. However, any coordinate projection will create a disastrously large separation between q and x1: on average, a (1 - 1 / d) fraction of the data points will fall between them.

Bounding Φ

The exact nearest neighbor schemes we analyze have error probabilities related to Φ, which lies in the range

[formula]

Data drawn from a doubling measure

Suppose the data points are drawn from a distribution μ on [formula] which is a doubling measure: that is, there exist a constant C  >  0 and a subset [formula] such that

[formula]

Here B(x,r) is the closed Euclidean ball of radius r centered at x. To understand this condition, it is helpful to also look at an alternative formulation that is essentially equivalent: there exist a constant do  >  0 and a subset [formula] such that for all x∈X, all r  >  0, and all α  ≥  1,

[formula]

In other words, the probability mass of a ball grows polynomially in the radius. Comparing this to the standard formula for the volume of a ball, we see that the degree of this polynomial, do (which is log 2C), can reasonably be thought of as the "dimension" of the measure μ.

Suppose μ is continuous on [formula] and is a doubling measure with dimension do  ≥  2. Pick any q∈X and draw [formula] independently at random from μ. Pick any 0  <  δ  <  1 / 2. Then with probability at least 1 - 3δ over the choice of the xi, for all 2  ≤  m  ≤  n,

[formula]

We will consider a collection of balls [formula] centered at q, with geometrically increasing radii [formula], respectively. For i  ≥  1, we will take ri  =  2iro. Thus by the doubling condition, μ(Bi)  ≤  Ciμ(Bo), where C  =  2do  ≥  4.

Define ro to be the radius for which μ(B(q,ro))  =  (1 / n) ln (1 / δ). This choice implies that x(1) is likely to fall in Bo: when points [formula] are drawn randomly from μ,

[formula]

Next, for i  ≥  1, the expected number of points falling in ball Bi is at most nCiμ(Bo)  =  Ci ln (1 / δ), and by a multiplicative Chernoff bound,

[formula]

Summing over all i, we get

[formula]

We will henceforth assume that x(1) lies in Bo and that each Bi has at most 2nμ(Bo)Ci  =  2Ci ln (1 / δ) points.

Pick any 2  ≤  m  ≤  n, and recall the expression for Φ:

[formula]

Once x(1) is fixed, moving other points closer to q can only increase Φ. Therefore, the maximizing configuration has 2nμ(Bo)C points in B1, followed by 2nμ(Bo)C2 points in B2, and then 2nμ(Bo)C3 points in B3, and so on. Each point in [formula] contributes at most 1 / 2j - 1 to the Φ summation.

Under the worst-case configuration, points [formula] lie within [formula], for [formula] such that

[formula]

We then have

[formula]

where the last inequality comes from (*). To lower-bound [formula], we again use (*) to get [formula], whereupon

[formula]

and we're done.

This extends easily to the potential function for k nearest neighbors.

Under the same conditions as Theorem [\ref=thm:phi-doubling], for any k  ≥  1, we have

[formula]

The only big change is in the definition of ro; it is now the radius for which

[formula]

Thus, when [formula] are drawn independently at random from μ, the expected number of them that fall in Bo is at least 4k, and by a multiplicative Chernoff bound is at least k with probability ≥  1 - δ.

The balls [formula] are defined as before, and once again, we can conclude that with probability ≥  1 - 2δ, each Bi contains at most 2nCiμ(Bo) of the data points.

Any point [formula] lies in some annulus [formula], and its contribution to the summation in Φk,m is

[formula]

The relationship (*) and the remainder of the argument are exactly as before.

We can now give bounds on the failure probabilities of the three tree data structures.

There is an absolute constant co for which the following holds. Suppose μ is a doubling measure on [formula] of intrinsic dimension do  ≥  2. Pick any query q∈X and draw [formula] independently from μ. Then with probability at least 1 - 3δ over the choice of data:

For either variant of the spill tree, if k  ≤  αno / 2,

[formula]

For the RP tree with no  ≥  co(3k)do max (k, ln 1 / δ),

[formula]

These probabilities are over the randomness in tree construction.

These bounds follow immediately from Theorems [\ref=thm:spill], [\ref=thm:rp], and [\ref=thm:phi-doubling-k], using Lemma [\ref=lemma:bounding-summation] from the appendix to bound the summation.

In order to make the failure probability an arbitrarily small constant, it is sufficient to take no  =  O(dok)do max (k, ln 1 / δ) for spill trees and no  =  O(dok ln (dok))do max (k, ln 1 / δ) for RP trees.

A document model

In a bag-of-words model, a document is represented as a binary vector in {0,1}N, where N is the size of the vocabulary and the ith coordinate is 1 if the document happens to contain the corresponding word. This is a sparse representation in which the number of nonzero positions is typically much smaller than N.

Pick any query document q∈{0,1}N, and suppose that [formula] are generated i.i.d. from a topic model μ. We will consider a simple such model with t topics, each of which follows a product distribution. The distribution μ is parametrized by the mixing weights over topics, [formula], which sum to one, and the word probabilities [formula] for each topic 1  ≤  j  ≤  t. Here is the generative process for a document x:

Pick a topic 1  ≤  j  ≤  t, where the probability of picking j is wj.

Set the coordinates of x∈{0,1}N independently; the ith coordinate is 1 with probability p(j)i.

The overall distribution is thus a mixture [formula] whose jth component is a Bernoulli product distribution [formula]. Here B(p) is a shorthand for the distribution on {0,1} with expected value p. It will simplify things to assume that 0  <  p(j)i  <  1 / 2; this is not a huge assumption if, say, stopwords have been removed.

For the purposes of bounding Φ, we are interested in the distribution of dH(q,X), where X is chosen from μ and dH denotes Hamming distance. This is a sum of small independent quantities, and it is customary to approximate such sums by a Poisson distribution. In the current context, however, this approximation is rather poor, and we instead use counting arguments to directly bound how rapidly the distribution grows. The results stand in stark contrast to those we obtained for doubling measures, and reveal this to be a substantially more difficult setting for nearest neighbor search. For a doubling measure, the probability mass of a ball B(q,r) doubles whenever r is multiplied by a constant. In our present setting, it doubles whenever r is increased by an additive constant. Specifically, it turns out (Lemma [\ref=lem:fast-growth]) that for [formula],

[formula]

Here [formula], where Lj is the expected number of words in a document drawn from μj, that is, [formula].

We start with the case of a single topic.

Growth rate for one topic

Let q∈{0,1}N be any fixed document and let X be drawn from a Bernoulli product distribution [formula]. Then the Hamming distance dH(q,X) is distributed as a sum of Bernoullis,

[formula]

where

[formula]

To understand this distribution, we start with a general result about sums of Bernoulli random variables. Notice that the result is exactly correct in the situation where all pi  =  1 / 2.

Suppose [formula] are independent, where Zi∈{0,1} is a Bernoulli random variable with mean 0  <  ai  <  1, and [formula]. Let [formula]. Then for any [formula],

[formula]

Define ri  =  ai / (1 - ai)∈(0,  ∞  ); then [formula]. Now, for any [formula],

[formula]

where the summations are over subsets [formula] of [formula] distinct elements of

[formula]

=    ≥   (r + + r),

[formula]

We now apply this result directly to the sum of Bernoulli variables Z  =  dH(q,X).

Suppose that [formula]. Pick any query q∈{0,1}N, and draw X from distribution [formula]. Then for any [formula],

[formula]

where [formula] is the expected number of words in X.

Suppose q contains ko nonzero entries. Without loss of generality, these are [formula].

As we have seen, dH(q,X) is distributed as the Bernoulli sum [formula]. Define

[formula]

Notice that ri  >  1 for i  ≤  ko, and ≤  1 for i  >  ko; and that ri  >  pi always.

By Lemma [\ref=lem:bernoulli-sum], we have that for any [formula],

[formula]

where [formula] denotes the reordering of [formula] into descending order. Since each ri  >  pi, and each pi is at most 1 / 2,

[formula]

Growth rate for multiple topics

Now let's return to the original model, in which X is chosen from a mixture of t topics [formula], with [formula]. Then for any [formula],

[formula]

Combining this relation with Lemma [\ref=lem:fast-growth], we immediately get the following.

Suppose that all p(j)i∈(0,1 / 2). Let [formula] denote the expected number of words in a document from topic j, and let [formula]. Pick any query q∈{0,1}N, and draw X  ~  μ. For any [formula],

[formula]

Bounding Φ

Fix a particular query q∈{0,1}N, and draw [formula] from distribution μ. Let the random variable [formula] denote the points at Hamming distance exactly [formula] from q, so that [formula].

There is an absolute constant co for which the following holds. Pick any 0  <  δ  <  1 and any k  ≥  1, and let v denote the smallest integer for which  PrX  ~  μ(dH(q,X)  ≤  v)  ≥  (8 / n) max (k, ln 1 / δ). Then with probability at least 1 - 3δ,

[formula].

If v  ≤  coL then [formula].

For all [formula], we have [formula].

If (a, b, c) hold, then for any m  ≤  n,

[formula]

Parts (a, b, c) are shown by applying multiplicative Chernoff bounds to the result of Corollary [\ref=cor:fast-growth]. The details are very similar to those of Theorem [\ref=thm:phi-doubling-k], and hence we omit them and turn to bounding Φ.

Suppose that for some i  >  k, point x(i) is at Hamming distance [formula] from q, that is, [formula]. Then

[formula]

since Euclidean distance is the square root of Hamming distance. In bounding Φk,m, we need to gauge the range of Hamming distances spanned by [formula].

The geometric growth rate of part (c) implies that most points lie at Hamming distance coL or greater from q. It also means that dH(q,x(m))  >  coL  -   log 2(n / m). Thus,

[formula]

where the last step follows by lower-bounding [formula] by an increasing geometric series.

The implication of this lemma is that for any of the three tree data structures, the failure probability at a single level is roughly [formula]. This means that the tree can only be grown to depth [formula], and thus the query time is dominated by [formula].

When n is large, we expect v to be small, and thus the query time improves over exhaustive search by a factor of roughly [formula].

Technical lemma

Suppose that for some constants A,B  >  0 and do  ≥  1,

[formula]

for all m  ≥  no. Pick any 0  <  β  <  1 and define [formula]. Then:

[formula]

and, if no  ≥  B(A / 2)do,

[formula]

Writing the first series in reverse,

[formula]

The last inequality is obtained by using

[formula]

to get (1  -  (1 - β) / do)do  ≥  β and thus 1 - β1 / do  ≥  (1 - β) / do.

Now we move on to the second bound. The lower bound on no implies that A(B / m)1 / do  ≤  2 for all m  ≥  no. Since x ln (2e / x) is increasing when x  ≤  2, we have

[formula]

The lemma now follows from algebraic manipulations that invoke the first bound as well as the inequality

[formula]

which in turn follows from

[formula]