Exact quantum query complexity of EXACT and THRESHOLD

for the problem EXACTnk in which we have to determine whether the sequence of input bits [formula] contains exactly k values xi = 1;

for the problem THRESHOLDnk in which we have to determine if at least k of n input bits are equal to 1.

Introduction

We consider quantum algorithms in the query model. The algorithm needs to compute a given Boolean function f:  {0,1}n  →  {0,1} by querying its input bits until it is able to produce the value of the function, either with certainty, or with some error probability. The complexity of the algorithm is measured as the number of queries it makes (other kinds of computation needed to produce the answer are disregarded).

In the bounded error setting where the algorithm is allowed to give an incorrect answer with probability not exceeding a given constant ε, [formula], many efficient quantum algorithms are known, with either a polynomial speed-up over classical algorithms (e.g., [\cite=Gro96] [\cite=Amb07] [\cite=FGG08] [\cite=RS08] [\cite=Bel12]), or, in the case of partial functions, even an exponential speed-up (e.g., [\cite=Sim97] [\cite=Shor97]).

Less studied is the exact setting where the algorithm must give the correct answer with certainty. Though for partial functions quantum algorithms with exponential speed-up are known (for instance, [\cite=DJ92] [\cite=BH97]), the results for total functions up to recently have been much less spectacular: the best known quantum speed-up was just by a factor of 2.

Even more, as remarked in [\cite=MJM11], all the known algorithms achieved this speed-up by the same trick: exploiting the fact that XOR of two bits can be computed quantumly with one query, while a classical algorithm needs two queries [\cite=DJ92] [\cite=CEMM98] [\cite=FGGS98].

A step forward was made by [\cite=MJM11] which presented a new algorithm achieving the speed-up by a factor of 2, without using the "XOR trick". The algorithm is for the Boolean function EXACT42 which is true iff exactly 2 of its 4 input bits are equal to 1. It computes this function with 2 queries, while a classical (deterministic) algorithm needs 4 queries.

This function can be generalized to EXACTnk in the obvious way. Its deterministic complexity is n (due to its sensitivity being n, see [\cite=NS94]). [\cite=MJM11] conjectured that its quantum query complexity is max {k,n  -  k}.

In this paper we prove the conjecture. We also solve the problem for a similar function, THRESHOLDnk which is true iff at least k of the input bits are equal to 1. When n = 2k - 1, this function is well-known as the MAJORITY function. The quantum query complexity of THRESHOLDnk turns out to be max {k,n  -  k  +  1}, as conjectured in [\cite=MJM11].

In a recent work [\cite=Amb12], a function [formula] with the deterministic query complexity n and the exact quantum query complexity O(n.8675...) was constructed. The quantum advantage that is achieved by our algorithms is smaller but we think that our results are still interesting, for several reasons.

First, we present quantum algorithms for computational problems that are natural and simple to describe. Second, our algorithms contain new ideas which may be useful for designing other exact algorithms. Currently, the toolbox of ideas for designing exact quantum algorithms is still quite small. Expanding it is an interesting research topic.

Technical Preliminaries

We denote [formula]. We assume familiarity with basics of quantum computation [\cite=NC00]. We now briefly describe the quantum query algorithm model.

Let f:  {0,1}n  →  {0,1} be the Boolean function to compute, with the input bit string [formula]. The quantum query algorithm works in a Hilbert space with some fixed basis states. It starts in a fixed starting state, then performs on it a sequence of unitary transformations U1, Q, U2, Q, , Ut, Q, Ut + 1. The unitary transformations Ui do not depend on the input bits, while Q, called the query transformation, does, in the following way. Each of the basis states corresponds to either one or none of the input bits. If the basis state [formula] corresponds to the i-th input bit, then [formula]. If it does not correspond to any input bit, then Q leaves it unchanged: [formula]. For convenience in computations, we denote x̂i = ( - 1)xi.

Finally, the algorithm performs a full measurement in the standard basis. Depending on the result of the measurement, it outputs either 0 or 1 which must be equal to f(x).

By the principle of delayed measurement, sometimes a measurement performed in the middle of computation is equivalent to it being performed at the end of computation [\cite=NC00]. We will use that in our algorithms, because they are most easily described as recursive algorithms with the following structure: perform unitary U1, query Q, unitary U2, then measure; depending on the result of measurement, call a smaller (by 2 input bits) instance of the algorithm. The principle of delayed measurement ensures that such recursive algorithm can be transformed by routine techniques into the commonly used query algorithm model described above.

The minimum number of queries made by any quantum algorithm computing f is denoted by QE(f). We use D(f) to denote the minimum number of queries used by a deterministic algorithm that computes f.

Algorithm for EXACT

The function EXACTnk is a Boolean function of n variables being true iff exactly k of the variables are equal to 1.

[formula]

We present a recursive algorithm. When k = 0 the algorithm returns 1 without making any queries. Suppose k = m. For the recursive step we will use basis states [formula], [formula], , [formula] and [formula] with i,j∈[2m], i < j. The i-th input bit will be queried from the state [formula]. We begin in the state [formula] and perform a unitary transformation U1:

[formula]

Next we perform a query:

[formula]

Finally, we perform a unitary transformation U2, such that

[formula]

One can verify that such a unitary transformation exists by checking the inner products:

for any i∈[2m],

[formula]

for any i,j∈[2m], i  ≠  j,

[formula]

The resulting quantum state is

[formula]

If we measure the state and get [formula], then EXACT2mm(x) = 0. If on the other hand we get [formula], then xi  ≠  xj and [formula], therefore we can use our algorithm for EXACT2m - 2m - 1.

Note that we can delay the measurements by using [formula] as a starting state for the recursive call of the algorithm.

For the sake of completeness, we include the following corollary already given in [\cite=MJM11]:

[formula]

Assume that [formula]. The other case is symmetric. Then we append the input x with n - 2k ones producing x' and call EXACT2n - 2kn - k(x'). Then concluding that there are n - k ones in x' is equivalent to there being (n - k) - (n - 2k) = k ones in the original input x.

The lower bound can be established by the following fact:

If g is a partial function such that g(x) = f(x) whenever g is defined on x, then QE(g)  ≤  QE(f).

[formula]

Assume that [formula]. The other case is symmetric. Define

[formula]

Observe that g is in fact negation of the OR function on n - k bits which we know [\cite=BBC+98] to take n - k queries to compute. Therefore by virtue of Proposition [\ref=subfun] no algorithm for EXACTnk may use less than n - k queries.

Algorithm for THRESHOLD

We will abbreviate THRESHOLD as Th.

The function Thnk is a Boolean function of n variables being true iff at least k of the variables are equal to 1.

The function Th2k + 1k + 1 is commonly referred to as MAJ2k + 1 or MAJORITY2k + 1 because it is equal to the majority of values of input variables.

Remarkably an approach similar to the one used for EXACT works in this case as well.

[formula]

Again, a recursive solution is constructed as follows. The base case k = 0 is trivial to perform with one query, because the function returns the value of the single variable. The recursive step k = m shares the states, unitary transformation U1 and the query with our algorithm for EXACT, but the unitary U2 is slightly different:

[formula]

[formula]

[formula]

The resulting state is

[formula]

We perform a complete measurement. There are two kinds of outcomes:

If we get state [formula], then either

xi is the value in the majority which according to the polynomial [formula] not being zero implies that in [formula] the number of ones is greater than the number of zeroes by at least 2; or

xi is a value in the minority.

In both of these cases, for all j:j  ≠  i it is true that [formula]. Therefore, we can solve both cases by removing xi and one other arbitrary input value and calculating majority from the remaining values.

If we get state [formula], then it is even better: we know that xi  ≠  xj and therefore [formula].

If 0  <  k  <  n, then

[formula]

Assume that [formula]. The other case is symmetric. Then we append the input x with n - 2k + 1 ones producing x' and call MAJ2n - 2k + 1(x'). Then x' containing at least n - k + 1 ones is equivalent to x containing at least (n - k + 1) - (n - 2k + 1) = k ones.

[formula]

Assume that [formula]. The other case is symmetric. Define

[formula]

Observe that g is in fact the OR function on n - k + 1 bits which we know [\cite=BBC+98] takes n - k + 1 queries to compute. Therefore by virtue of Proposition [\ref=subfun] no algorithm for Thnk may use less than n - k + 1 queries.

Conclusion

Coming up with exact quantum algorithms that are substantially better than any classical algorithm has been a difficult open problem. Until a few months ago, no example of total Boolean function with QE(f) < D(f) / 2 was known and the examples of functions with QE(f) = D(f) / 2 were almost all based on one idea: applying 1-query quantum algorithm for [formula] as a subroutine.

The first exact quantum algorithm with QE(f) < D(f) / 2 (for a total f) was constructed in [\cite=Amb12]. However, no symmetric function with QE(f) < D(f) / 2 is known. It has been proven that if f(x) is a symmetric, non-constant function of n variables, then QE(f)  ≥  n / 2 - o(n) [\cite=ZGR97] [\cite=BdW02].

In this paper, we construct exact quantum algorithms for two symmetric functions: EXACT and THRESHOLD. Both of those algorithms achieve QE(f)  =  D(f) / 2 (exactly or in the limit) and use new ideas. At the same time, our algorithms are quite simple and easy to understand.

The main open problem is to come with more algorithmic techniques for constructing exact quantum algorithms. Computer experiments via semidefinite optimization [\cite=MJM11] show that there are many functions for which exact quantum algorithms are better than deterministic algorithms. Yet, in many of those case, the only way to construct these algorithms is by searching the space of all quantum algorithms, using semidefinite optimization as the search tool.

For example, from the calculations in [\cite=MJM11] (based on semidefinite optimization) it is apparent that there are 3 symmetric functions of 6 variables for which QE(f) = 3: PARITY, EXACT63 and EXACT62,4 (exactly 2 or 4 of 6 variables are equal to 1).

Unlike for the first two functions, we are not aware of any simple quantum algorithm or lower bounds for EXACT62,4. Based on the evidence from semidefinite optimization, we conjecture that if n is even and 2k < n then the quantum query complexity of EXACTnk,n - k is n - k - 1. In particular, this would mean that the complexity of EXACTnn / 2 - 1,n / 2 + 1 is [formula] and this function also achieves a gap of QE(f) = D(f) / 2.

At the moment, we know that this conjecture is true for k = 0 and k = 1. Actually, both of those cases can be solved by a classical algorithm which uses the 1-query algorithm for [formula] as a quantum subroutine. This approach fails for k  ≥  1 and it seems that the approach in the current paper is also not sufficient -- without a substantial new component.