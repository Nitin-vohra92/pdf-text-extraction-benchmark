Efficient quantum processing of ideals in finite rings

Here we present quantum algorithms for several problems regarding finite rings. All of the algorithms run in time scaling polylogarithmically in the size of the ring. A ring is normally specified by a set of elements that generate the ring via linear combination and multiplication, and an ideal is normally specified by a set of elements that generate the ideal via linear combination and multiplication by arbitrary ring elements. To apply the known quantum techniques for Abelian groups we find sets that generate rings and ideals as Abelian groups, that is, by linear combination only. The problem of finding such a generating set for rings has been already solved by Arvind et al.[\cite=Arvind]. Our solution for ideals generalizes their result.

As shown in [\cite=Kayal], both integer factorization and graph isomorphism reduce to the problem of counting automorphisms of rings. This counting problem is contained in AM[formula]coAM. Therefore it is unlikely to be NP-hard. Integer factorization also reduces to the problem of finding nontrivial automorphisms of rings and to the problem of finding isomorphisms between two rings. Furthermore, graph ismorphism reduces to ring isomorphism for commutative rings. Thus these ring automorphism and isomorphism problems are attractive targets for quantum computation. Perhaps the quantum algorithms given in this paper can serve as steps toward efficient quantum algorithms for some of these problems.

Let R be a finite ring with identity, which need not be commutative. Let [formula] be a subset of R such that each element of R can be obtained by some sequence of additions and multiplications of elements of [formula]. We say that [formula] is a generating set for R. Let I be the left ideal in R generated by Ĩ. That is, I is the smallest subset of R containing Ĩ that is closed under addition and closed under left multiplication by elements of R. Throughout this paper we mainly discuss left ideals. One can similarly define right ideals and two-sided ideals, and the generalization of our algorithms to these cases is a straightforward generalization. Note that R is itself an ideal in R.

A left ideal I in a finite ring R forms an Abelian group (I, + ) under addition. Any generating set [formula] for an Abelian group A yields a homomorphism from [formula] to A where [formula] are the orders of [formula]. In additive notation, this homomorphism takes the integers [formula] to [formula]. The structure theorem for finite Abelian groups states that there exists a generating set for A such that this homomorphism is an isomorphism. We call this a generating set of the invariant factors, or i. f. generating set for short. The main tool in this paper is an efficient quantum algorithm to find an i. f. generating set for (I, + ). No polynomial time classical algorithm for this problem is known.

The computational difficulty of problems on rings may depend on how the algorithm is allowed to access the ring. We assume only blackbox access to the ring. That is, the ring elements are assigned arbitrary bit strings by some injective map η and we have access to blackboxes implementing f+(η(a),η(b))  =  η(a + b) and f×(η(a),η(b))  =  η(a  ×  b). The ideal I is specified by a list of generators [formula] with m  =  O( log |R|). Given these inputs, our method for finding an i. f. generating set for (I, + ) proceeds in two steps. First we find a generating set for (I, + ). Although the elements of Ĩ generate I as an ideal, they do not generate I as an Abelian group, that is, by addition only with no left-multiplication by R elements. After finding a generating set for (I, + ) we then convert it to an i. f. generating set for (I, + ) using the quantum algorithms of [\cite=Cheung_Mosca] [\cite=Watrous].

To find a generating set for (I, + ), let 1  =  Ĩ and apply the following iteration. Let Bk be the Abelian group additively generated by k. At the [formula] step we search for an element i∈I not contained in Bk. If we find one, we let [formula]. For some sufficiently large k, Bk  =  I, at which point the search for i fails and the process terminates. We now show in detail how this works and that we need at most log 2|I| iterations.

Suppose we know k. To find an element of I not contained in Bk, we choose any generator r∈ of R. Let rBk  =  {rx|x∈Bk}. We create the superpositions

[formula]

and

[formula]

Because Bk and rBk are Abelian groups whose generators we know, these states can be created efficiently to polynomial precision using the results of [\cite=Watrous] [\cite=Cheung_Mosca].

To determine the intersection of Bk and rBk we use the swap test to estimate the inner product 〈Bk|rBk〉. Polynomially many applications of the swap test yield 〈Bk|rBk〉 to [formula] precision. [formula] is a subgroup of Bk. Thus by Lagrange's theorem, either [formula] or [formula]. These two cases can be distinguished with high reliability by swap tests, because

[formula]

If we find that [formula] then we choose an element i∈rBk uniformly at random. We can do this using the techniques of [\cite=Watrous] [\cite=Cheung_Mosca] to find an i. f. generating set for Bk and then sampling uniformly from the product of cyclic groups to which Bk is isomorphic. Thus, along with i we get an expression for i as r times some linear combination of the elements of k. i is definitely contained in I, and with probability at least 1 / 2, i is not contained in Bk. If i∈Bk then 〈Bk|i + Bk〉  =  1, otherwise 〈Bk|i + Bk〉  =  0. Thus, to determine whether i∈Bk we create the states |Bk〉 and |i + Bk〉 and use the swap test. If i∈Bk we choose a different random element of rBk and try again. With probability 1 - ε, this process terminates in O( log (1 / ε)) time. Once it does, we let [formula].

If we instead find that [formula], we choose a different r∈ and swap test again. We keep repeating this process until we find some r∈ such that [formula] or we exhaust [formula]. If [formula] for all r∈ we are done, because Bk  =  I. We can prove this with the following lemma.

Let I be a left ideal generated by [formula] in a finite ring R. Let k be a subset of I containing [formula]. The set of ring elements Bk additively generated by k is equal to I if and only if rBk  ⊆  Bk [formula].

If rBk  ⊆  Bk for all r∈ then, because [formula] is a generating set for R, rBk  ⊆  Bk for all r∈R. Thus, Bk is a left ideal in R. By construction, Bk contains [formula]. By the definition of generators, I is the smallest left ideal in R containing [formula]. Bk is also contained in I. Thus Bk  =  I. The converse follows immediately from the fact that I is a left ideal.

In the above procedure, the time needed to obtain each additive generator is [formula]. Furthermore, every time we add another generator, we increase the size of the generated group by at least a factor of two. Thus, we need to perform the above iteration at most log 2|I| times. We can also in polynomial time obtain expressions for the elements of this set in terms of the original generators for I by recursively composing the expressions we obtained at each step for i in terms of the preceding generators Bk.

Once we have a set Bk of elements that generate I as an Abelian group, we can efficiently find an i. f. generating set for (I, + ), as well as expressions for the i. f. generators as linear combinations of Bk using the techniques of [\cite=Cheung_Mosca] [\cite=Watrous]. These techniques also efficiently yield the additive orders of the i. f. generators.

After finding an i. f. generating set for (I, + ), one would like to have a procedure to take a given element i∈I and decompose it as a linear combination of these generators. Note that i is given as an arbitrary bit string from the encoding η, so initially we know nothing about i. We can efficiently perform this decomposition as described below.

Let [formula], where [formula] are the orders of the i. f. generators [formula] and s is the order of i. Let

[formula]

This function hides the cyclic subgroup of G generated by

[formula]

where [formula] is the decomposition of i in terms of the i. f. generators:

[formula]

Using the polynomial time quantum algorithm for the Abelian hidden subgroup problem [\cite=Nielsen_Chuang], we thus recover this decomposition.

Let [formula] be an i. f. generating set for I. The multiplication in I can be fully specified by the tensor Mkij defined by

[formula]

We can compute all l3 of the entries of Mkij by taking each pair hi,hj, using the multiplication oracle to find the bit string encoding their product, and then using the Abelian hidden subgroup algorithm to decompose the element represented by the resulting bit string, as described above. Together, the i. f. generators for I, their orders, and the multiplication tensor are called a basis representation for I. The previous work of Arvind et al. shows how to efficiently quantum compute a basis representation in the special case that I is the entire ring R [\cite=Arvind]. The best existing classical algorithm for this problem requires order |R| queries[\cite=Zumbragel].

Given a basis representation for an ideal I it is straightforward to construct a uniform superposition |I〉 over all elements of I. By constructing the superpositions |I〉 and |J〉 for two ideals I and J we can determine whether I = J using the swap test. By Lagrange's theorem, if I  ≠  J then 〈I|J〉  ≤  1 / 2. Thus we need only use O( log (ε)) swap tests to ensure that the chance of falsely concluding I = J is at most ε. After constructing |I〉 and being given a ring element r, we can use the addition black-box to construct the coset state |r + I〉. If r∈I then the inner product of these states is one, and otherwise it is zero. Thus, the swap test on |I〉 and |r + I〉 tells us whether r∈I. Given r∈R, let Rr be the left ideal in R generated by r. Rr  =  R if and only if r is a unit. If Rr  ≠  R then Rr contains at most half the elements of R. Thus one can determine whether a given r∈R is a unit by constructing |Rr〉 and |R〉 and comparing them using the swap test. If r is a unit, then we can find its inverse using the quantum order finding algorithm[\cite=Shor_factoring]. If [formula] then r- 1  =  rc - 1.

Suppose r is contained in the ideal I. To obtain an explicit construction for r in terms of the generators of I, we can first obtain a basis representation for I. We can obtain an expression for r as a linear combination of the basis for I by solving the Abelian hidden subgroup problem. From the algorithm for obtaining a basis representation for I we also obtain expressions for the basis elements in terms of the original generators of I. Thus one can efficiently convert the expression for r as a linear combination of the basis representation for I into an expression for r in terms of the original generators for I.

Suppose we are given generating sets for two ideals I and J. We wish to find a basis for [formula]. By techniques described above, we can create the superposition |J〉 over all elements of J, and we can find a basis representation for I. A reversible circuit for addition performs the unitary transformation U+|a〉|b〉  =  |a〉|a + b〉. Thus, U+|a〉|J〉  =  U+|a〉|a + J〉, where |a + J〉 is a superposition over the coset a + J. If a∈J then 〈a + J|J〉  =  1. Otherwise 〈a + J|J〉  =  0. Hence applying addition to the state J is an operation that "hides" the subgroup [formula] of the group (I, + ) of inputs. Thus, one can use the quantum algorithms for the Abelian hidden subgroup problem[\cite=Nielsen_Chuang] to find a set of generators for [formula]. From this we easily extract a basis representation. (Typically in a hidden subgroup problem one is given a blackbox that maps group elements to classical bit strings. This map is constant and distinct on cosets of the hidden subgroup. However, examining the algorithm of [\cite=Nielsen_Chuang], one sees that it works just the same if the blackbox maps the different cosets to any set of orthogonal states, the classical bit string states being just a special case.)

If I and J are two ideals in R, one defines (I:J)  =  {x∈R|xJ  ⊆  I}. (I:J) is an ideal, and is called an ideal quotient or a colon ideal. (I:J) is a subgroup of (R, + ). Let U be the unitary transformation defined by [formula] for all [formula]. Given quantum black boxes for arithmetic on R, U can be efficiently implemented by a quantum circuit. The states [formula] and [formula] are identical if x and y belong to the same coset of (I:J) in (R, + ) and are orthogonal if x and y come from different cosets. Thus, we can efficiently find an additive generating set for (I:J) by solving the Abelian hidden subgroup problem using U to hide (I:J).

The left annihilator AS of [formula] is defined as [formula]. AS forms a subgroup of (R, + ). The function on R given by [formula] hides this subgroup. Thus, after finding an i. f. generating set for R one can use the quantum algorithm for the Abelian hidden subgroup problem to find generators for any annihilator provided S is at most polynomially large. The same method will work if S is given by a polynomially large set of additive generators.

Given generators for an ideal I in a finite ring, we can find the order of I, by finding an i. f. generating set for it and taking the product of the orders of the generators. Finding the order of a ring is a special case, as any ring is an ideal in itself.

Suppose we are given a black-box implementing a homomorphism ρ:R  →  R' between two rings. Determining whether ρ is injective is an Abelian hidden subgroup problem, where the kernel of ρ is the hidden subgroup in (R, + ). ρ is injective if and only if its kernel is {0}. We can efficiently find generators for the kernel of ρ by finding an i. f. generating set for R, and then solving the Abelian hidden subgroup problem. To determine whether ρ is surjective, we first compute the order of R'. Similarly, the image of ρ is a ring. If R is generated by [formula] then R' is generated by [formula]. After querying the homomorphism black-box to obtain the generators [formula] we can compute the order of the ring they generate (R') as described in the preceding paragraph. ρ is surjective if and only if the order of the image of ρ equals the order of R'.

Suppose we wish to solve a linear equation ax = b over R. To do this we find an i. f. generating set [formula] for R, and decompose a and b in terms of these generators

[formula]

Let

[formula]

where Mikj is the multiplication tensor from the basis representation. Parametrize x as [formula] for integers [formula]. Then, in an i. f. generating set, ax = b if and only if

[formula]

for each [formula]. (Here si is the additive order of hi.) We can introduce additional integer unknowns [formula] and rewrite this as a system of linear diophantine equations:

[formula]

A solution to a system of m diophantine equations in n variables can be found in [formula] time using the classical algorithms of [\cite=Chou]. Thus we can classically find an integer solution to equation [\ref=system], which has [formula] equations and [formula] unknowns, in [formula] time. Equation [\ref=system] is undertedermined because the original system of equations [\ref=mods] is modular.

By a similar technique, we can find the identity in R. Again suppose we have computed a basis representation for R. Since the basis representation has the following property,

[formula]

where [formula], an element [formula] is the identity if and only if

[formula]

for all [formula]. This is again a system of linear modular equations, which we can convert to a system of linear diophantine equations that we solve in polynomial time using[\cite=Chou]. Note that the quantum algorithm of [\cite=Arvind_ident] solves a very different problem although the authors refer to it as identity testing.

In a black box ring, finding the additive identity is also nontrivial. Because all ring elements have additive inverses, we can choose any r∈R, find its order c using the quantum order finding algorithm [\cite=Shor_factoring], find the additive inverse of r by computing (c - 1)r, and find the additive identity by computing cr. The computation of cr and (c - 1)r requires O( log 2c) queries to f+.

We now show how to efficiently determine whether a given two-sided ideal I is prime. Recall that an ideal I is prime if ab∈I implies that a∈I or b∈I for all a,b∈R, which is equivalent to the fact that the quotient ring S = R / I does not have any zero-divisors. This already implies that S is a division ring (i.e., each non-zero element has a multiplicative inverse) since S is finite. Wedderburn's theorem shows that all finite division rings are finite fields [\cite=Lidl_Niederreiter]. R / I a field implies I is maximal, thus I is prime implies I is maximal. The converse is also true.

Let S* denote the group of units of the quotient ring S. We choose an element r uniformly at random in R. With probability at least 1 / 2 we have [formula]. Once we obtain such r we determine the size of the (additively generated) cyclic subgroup 〈〉 of S, where [formula] denotes the image of r in S under the canonical projection. This can be done by applying Shor's period finding algorithm to the state [formula]) where q is a power of 2 with |S|2  <  q  ≤  2|S|2. This state can be prepared efficiently.

If S is a field, then with probability at least φ(|S| - 1) / |S|  ≥  Ω(1 /  log |S|) we have 〈〉  =  S* where φ denotes Euler's totient function. This follows from the fact that the group of units [formula] of an arbitrary finite field [formula] with d element is cyclic of order d - 1 and φ(m) / m  =  Ω(1 /  log m) for integers m [\cite=Hardy]. If S is not a field, then S* cannot have order |S| - 1 (otherwise every non-zero element would have a multiplicative inverse, implying that S is a field). If we find that S is a field then we know I is prime, otherwise I is not prime. The above procedure for determining whether the quotient ring S is a field can be applied to any finite blackbox ring, offering a simpler alternative to the algorithm in [\cite=Arvind].

Our quantum algorithms for rings R also extend to R-modules. Beyond this, we conjecture that our quantum algorithms apply to any category posessing a faithful functor to the category of Abelian groups.

It would be interesting to find efficient quantum algorithms for deciding whether a given ideal I is principal and computing the group of units R* of R. The quantum algorithms in [\cite=Cheung_Mosca] [\cite=Watrous] make it possible to determine the structure of any finite abelian black-box group according to the structure theorem. So, the question arises naturally whether a similar quantum algorithm exists for decomposing finite black-box rings. More precisely, is it possible to efficiently learn the structure of a finite black-box ring according to a structure theorem in ring theory such as the Wedderburn-Artin theorem [\cite=McDonald]?

It would be worthwhile to investigate whether the above algorithms extend to the case of infinite rings. It is not obvious that we can consider arbitrary infinite rings. However, it seems likely that the above algorithms could be extended to a black-box ring R which is endowed with a grading by Abelian groups [formula] and each component Rg is finite. Additionally, we would need a promise, making it possible to do all the computations in a component Rg for some g. For example, such a situation occurs for polynomial rings over a finite field when the number of indeterminates is fixed. The complexity of the algorithms would then depend on the growth of the Hilbert function, which measures the dimension of the graded components Rg as R0-modules.

P.W. and H.A. gratefully acknowledge the support of NSF grants CCF-0726771 and CCF-0746600. S.J. gratefully acknowledges support from the Sherman Fairchild foundation and the NSF under grant PHY-0803371.