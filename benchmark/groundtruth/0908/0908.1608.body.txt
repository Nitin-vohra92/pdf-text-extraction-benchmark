Lemma

Planar Drawings of Higher-Genus Graphs

Introduction

The classic way of drawing a graph G = (V,E) in [formula] involves associating each vertex v in V with a unique point (xv,yv) and associating with each edge (v,w)∈E an open Jordan curve that has (xv,yv) and (xw,yw) as its endpoints. If the curves associated with the edges in a classic drawing of G intersect only at their endpoints, then (the embedding of) G is a plane graph. Graphs that admit plane graph representations are planar graphs, and there has been a voluminous amount of work on algorithms on classic drawings of planar graphs. Most notably, planar graphs can be drawn with vertices assigned to integer coordinates in an O(n)  ×  O(n) grid, which is often a desired type of classic drawing known as a grid drawing. Moreover, there are planar graph drawings that use only straight line segments for edges [\cite=fpp-hdpgg-90].

The beauty of plane graph drawings is that, by avoiding edge crossings, confusion and clutter in the drawing is minimized. Likewise, straight-line drawings further improve graph visualization by allowing the eye to easily follow connections between adjacent vertices. In addition, grid drawings enforce a natural separation between vertices, which further improves readability. Thus, a "gold standard" in classic drawings is to produce planar straight-line grid drawings and, when that is not easily done, to produce planar grid drawings with edges drawn as simple polygonal chains.

Unfortunately, not all graphs are planar. So drawing them in the classic way requires some compromise in the gold standard for plane drawings. In particular, any classic drawing of a non-planar graph must necessarily have edge crossings, and minimizing the number of crossings is NP-hard [\cite=gj-cninc-83]. One point of hope for improved drawings of non-planar graphs is to draw them crossing-free on surfaces of higher genus, such as toruses, double toruses, or, in general, a surface topologically equivalent to a sphere with g handles, that is, a genus-g surface. Such drawings are called cellular embeddings or 2-cell embeddings, since they partition the genus-g surface into a collection of cells that are topologically equivalent to disks. As in classic drawings of planar graphs, these cells are called faces, and it is easy to see that such a drawing would avoid edge crossings.

In a fashion analogous to the case with planar graphs, cellular embeddings of graphs in a genus-g surface can be characterized combinatorially. In particular, it is enough if we just have a rotational order of the edges incident on each vertex in a graph G to determine a combinatorial embedding of G on a surface (which has that ordering of associated curves listed counterclockwise around each vertex). Such a set of orderings is called a rotation system and, since it gives us a combinatorial description of the set of faces, F, in the embedding, it gives us a way to determine the genus of the (orientable) surface that G is embedded into by using the Euler characteristic, |V| - |E| + |F|  =  2 - 2g, which also implies that |E| is O(|V| + g) [\cite=mt-gos-01].

Unfortunately, given a graph G, it is NP-hard to find the smallest g such that G has a combinatorial cellular embedding on a genus-g surface [\cite=t-ggpnp-89]. This challenge need not be a deal-breaker in practice, however, for there are heuristic algorithms for producing such combinatorial embeddings (that is, consistent rotation systems) [\cite=Chen1997317]. Moreover, higher-genus graphs often come together with combinatorial embeddings in practice, as in many computer graphics and mesh generation applications.

In this paper, we assume that we are given a combinatorial embedding of a graph G on a genus-g surface, S, and are asked to produce a geometric drawing of G that respects the given rotation system. Motivated by the gold standard for planar graph drawing and by the fact that computer screens and physical printouts are still primarily two-dimensional display surfaces, the approach we take is to draw G in the plane rather than on some embedding of S in [formula].

Making this choice of drawing paradigm, of course, requires that we "cut up" the genus-g surface, S, and "unfold" it so that the resulting sheet is topologically equivalent to a disk. The traditional method for performing such a cutting is with a canonical polygonal schema, P, which is a set of 2g cycles on S all containing a common point, p, such that cutting S along these cycles results in a topological disk. These cycles are fundamental in that each of them is a continuous closed curve on S that cannot be retracted continuously to a point. Moreover, these fundamental cycles can be paired up into complementary sets of cycles, (ai,bi), one for each handle, so that if we orient the sides of P, then a counterclockwise ordering of the sides of P can be listed as [formula] where a- 1i (b- 1i) is a reversely-oriented copy of ai, so that these two sides of P are matched in orientation on S. Thus, the canonical polygonal schema for a genus-g surface S has 4g sides that are pairwise identified.

Because we are interested in drawing the graph G and not just the topology of S, it would be preferable if the fundamental cycles are also cycles in G in the graph-theoretical sense. It would be ideal if these cycles form a canonical polygonal schema with no repeated vertices other than the common one. This is not always possible [\cite=lpvv-ccpso-01] and furthermore, as we show in [\cite=XXX], the problem of finding a set of 2g fundamental cycles with vertex-disjoint interiors in a combinatorially embedded genus-g graph is NP-complete. There are two natural choices, both of which we explore in this paper:

Draw G in a polygon P corresponding to a canonical polygonal schema, P, possibly with repeated vertices and edges on its boundary.

Draw G in a polygon P corresponding to a polygonal schema, P, that is not canonical.

In either case, the edges and vertices on the boundary of P are repeated (since we "cut" S along these edges and vertices). Thus, we need labels in our drawing of G to identify the correspondences. Such planar drawings of G inside a polygonal schema P are called polygonal-schema drawings of G. There are three natural aesthetic criteria such drawings should satisfy:

Straight-line edges: All the edges in a polygonal-schema drawing should be rendered as polygonal chains, or straight-line edges, when possible.

Straight frame: Each edge of the polygonal schema should be rendered as a straight line segment, with the vertices and edges of the corresponding fundamental cycle, placed along this segment. We refer to such a polygonal-schema drawing as having a straight frame.

Polynomial area: Drawings should have polynomial area when they are normalized to an integer grid.

It is also possible to avoid repeated vertices and instead use a classic graph drawing paradigm, by transforming the fundamental polygon rendering using polygonal-chain edges that run through "overpasses" and "underpasses" as in road networks, so as to illustrate the topological structure of G; see Fig. [\ref=fig-fund].

Our Contributions.

We provide several methods for producing planar polygonal-schema drawings of higher-genus graphs. In particular, we provide four algorithms, one for torodial (g = 1) graphs and three for non-toroidal (g > 1) graphs. Our algorithm for toroidal graphs simultaneously achieves the three aesthetic criteria for polygonal schema drawings: it uses straight-line edges, a straight frame, and polynomial area. The three algorithms for non-toroidal graphs, Peel-and-Bend, Peel-and-Stretch, and Peel-and-Place, achieve two of the tree aesthetic criteria, and differ in which criteria they fail to meet.

Finding Polygonal Schemas

Suppose we are given a graph G together with its cellular embedding in a genus-g surface, S. An important first step in all of our algorithms involves our finding a polygonal schema, P, for G, that is, a set of cycles in G such that cutting S along these cycles results in a topological disk. We refer to this as the Peel step, since it involves cutting the surface S until it becomes topologically equivalent to a disk. Since these cycles form the sides of the fundamental polygon we will be using as the outer face in our drawing of G, it is desirable that these cycles be as "nice" as possible with respect to drawing aesthetics.

Trade-offs for Finding Polygonal Schemas

Unfortunately, some desirable properties are not effectively achievable. As Lazarus et al. [\cite=lpvv-ccpso-01] show, it is not always possible to have a canonical polygonal schema P such that each fundamental cycle in P has a distinct set of vertices in its interior (recall that the interior of a fundamental cycle is the set of vertices distinct from the common vertex shared with its complementary fundamental cycle--with this vertex forming a corner of a polygonal schema). In addition, we show in [\cite=XXX] that finding a vertex-disjoint set of fundamental cycles is NP-complete. So, from a practical point of view, we have two choices with respect to methods for finding polygonal schemas.

Finding a Canonical Polygonal Schema.

As mentioned above, a canonical polygon schema of a graph G 2-cell embedded in a surface of genus g consists of 4g sides, which correspond to 2g fundamental cycles all containing a common vertex. Lazarus et al. [\cite=lpvv-ccpso-01] show that one can find such a schema for G in O(gn) time and with total size O(gn), and they show that this bound is within a constant factor of optimal in the worst case, where n is the total combinatorial complexity of G (vertices, edges, and faces), which is O(|V| + g).

Minimizing the Number of Boundary Vertices in a Polygonal Schema.

Another optimization would be to minimize the number of vertices in the boundary of a polygonal schema. Erikson and Har-Peled [\cite=eh-ocsid-02] show that this problem is NP-hard, but they provide an O( log 2g)-approximation algorithm that runs in O(g2n log n) time, and they give an exact algorithm that runs in O(nO(g)) time.

In our Peel step, we assume that we use one of these two optimization criteria to find a polygonal schema, which either optimizes its number of sides to be 4g, as in the canonical case, or optimizes the number of vertices on its boundary, which will be O(gn) in the worst case either way. Nevertheless, for the sake of concreteness, we often describe our algorithms assuming we are given a canonical polygonal schema. It is straight-forward to adapt these algorithms for non-canonical schemas.

Constructing Chord-Free Polygonal Schemas

In all of our algorithms the first step, Peel, constructs a polygonal schema of the input graph G. In fact, we need a polygonal schema, P, in which there is no chord connecting two vertices on the same side of P. Here we show how to transform any polygonal schema into a chord-free polygonal schema.

In the Peel step, we cut the graph G along a canonical set of 2g fundamental cycles getting two copies of the cycle in G*, the resulting planar graph. For each of the two pairs of every fundamental cycle there may be chords. If the chord connects two vertices that are in different copies of the cycle in G* then this is a chord that can be drawn with a straight-line edge and hence does not create a problem. However, if the chord connects two vertices in the same copy of the cycle in G*, then we will not be able to place all the vertices of that cycle on a straight-line segment; see Figure [\ref=fig:chordFree](a). We show next that a new chord-free polygonal schema can be efficiently determined from the original schema.

Given a graph G combinatorially embedded in a genus-g surface and a canonical polygonal schema P on G with a common vertex p, a chord-free polygonal schema P* can be found in O(gn) time.

We first use the polygonal schema to cut the embedding of G into a topological disk; see Fig. [\ref=fig:chordFree](a). Notice this cutting will cause certain vertices to be split into multiple vertices. For each fundamental cycle in ci∈P, we stitch the disk graph back together along this cycle forming a topological cylinder. The outer edges (left and right) of the cylinder along this stitch will have two copies of the vertex p, say p1 and p2. We perform a shortest path search from p1 to p2. This path becomes our new fundamental cycle c*i, (since p1 and p2 are the same vertex in G). Observe that this cycle must be chord-free or else the path chosen was not the shortest path; see Fig. [\ref=fig:chordFree](b). We then cut the cylinder along c*i and proceed to ci + 1. The resulting set, [formula], is therefore a collection of chord-free fundamental cycles all sharing the common vertex p.

It should be noted that, although each cycle c*i is at the time of its creation a shortest path from the two copies of p, these cycles are not the shortest fundamental cycles possible. For example, a change in the cycle of ci + 1 could introduce a shorter possible path for c*i, but not additional chords.

Straight Frame and Polynomial Area

In this section, we describe our algorithms that construct a drawing of G in a straight frame using polynomial area. Here we are given an embedded genus-g graph G = (V,E) along with a chord-free polygonal schema, P, for G from the Peel step. We rely on a modified version of the algorithm of de Fraysseix, Pach and Pollack [\cite=fpp-hdpgg-90] for the drawing. Sections [\ref=sec:embed] and [\ref=sec:embedHigher] describe the details for g = 1 and for g > 1, respectively. In the latter case we introduce up to O(k) edges with single bends where k is the number of vertices on the fundamental cycles. Thus, we refer to the algorithm for non-toroidal graphs as the Peel-and-Bend algorithm.

Grid Embedding of Toroidal Graphs

For toroidal graphs we are able to achieve all three aesthetic criteria: straight-line edges, straight frame, and polynomial area.

Let G* be an embedded planar graph and [formula] in G* be a collection of 4g paths such that each path [formula] is chord-free, the last vertex of each path matches the first vertex of the next path, and when treated as a single cycle, P forms the external face of G*. If g = 1, we can in linear time draw G* on an O(n)  ×  O(n2) grid with straight-line edges and no crossings in such a way that, for each path Pi on the external face, the vertices on that path form a straight line.

For simplicity, we assume that every face is a triangle, except for the outer face (extra edges can be added and later removed). The algorithm of de Fraysseix, Pach and Pollack (dPP) [\cite=fpp-hdpgg-90] does not directly solve our problem because of the additional requirement for the drawing of the external face. In the case of g = 1, the additional requirement is that the graph must be drawn so that the external face forms a rectangle, with P1 and P3 as the top and bottom horizontal boundaries and P2 and P4 as the right and left boundaries.

Recall that the dPP algorithm computes a canonical labeling of the vertices of the input graph and inserts them one at a time in that order while ensuring that when a new vertex is introduced it can "see" all of its already inserted neighbors. One technical difficulty lies in the proper placement of the top row of vertices. Due to the nature of the canonical order, we cannot force the top row of vertices to all be the last set of vertices inserted, unlike the bottom row which can be the first set inserted. Consequently, we propose an approach similar to that of Miura, Nakano, and Nishizeki [\cite=nakano4connected01]. First, we split the graph into two parts (not necessarily of equal size), perform a modified embedding on both pieces, invert one of the two pieces, and stitch the two pieces together.

Given an embedded plane graph G that is fully triangulated except for the external face and two edges el and er on that external face, it is possible in linear time to partition V(G) into two subsets V1 and V2 such that

the subgraphs of G induced by V1 and V2, called G1 and G2, are both connected subgraphs;

for edges el = (ul,vl) and er = (ur,vr), we have ul,ur∈V1 and vl,vr∈V2;

the union U of the set of faces in G that are not in G1 or G2 forms an outerplane graph with the property that the external face of U is a cycle with no repeated vertices.

First, we compute the dual D of G, where each face in (the primal graph) G is a node in D and there is an arc between two nodes in D if their corresponding primal faces share an edge in common. We ignore the external face in this step. For clarity we shall refer to vertices and edges in the primal and nodes and arcs in the dual; see Fig. [\ref=fig:split](a). We further augment the dual by adding an arc between two nodes in D if they also share a vertex in common. Call this augmented dual graph D*.

Let the source node s be the node corresponding to the edge el and the sink node t be the node corresponding to the edge er. We then perform a breadth-first shortest-path traversal from s to t on D*; see Fig. [\ref=fig:split](b). Let p* be a shortest (augmented) path in D* obtained by this search. We now create a (regular) path p by expanding the augmented arcs added. That is, if there is an arc (u,v)∈p* such that u and v share a common vertex in G but not a common edge in G, i.e. they are part of a fan around the common vertex, we add back the regular arcs from u to v adjacent to this common vertex. The choice of going clockwise or counter-clockwise around the common vertex depends on the previous visited arc; see Fig. [\ref=fig:split](c).

All of the steps described above can be easily implemented in linear time. The details of the proof can be found in [\cite=XXX].

Figure [\ref=fig:split](d) illustrates the result of one such partition. In some cases we might have to start and end with a set of edges rather than just the two edges el and er. The following extension of Lemma [\ref=lemma:splitA] addresses this issue; the details of the proof can be found in [\cite=XXX].

Given an embedded plane graph G that is fully triangulated, except for the external face, and given two vertex-disjoint chord-free paths L and R on that external face, it is possible in linear time to partition V(G) into two subsets V1 and V2 such that

the subgraphs of G induced by V1 and V2, called G1 and G2, are both connected subgraphs;

there exists exactly one vertex v∈V(L) (say v∈V1) with neighbors in [formula] (the opposite vertex set that are not part of V(L)), the same holds for V(R); and

the union U of the set of faces in G that are not in G1 or G2 forms an outerplane graph with the property that the external face of U is a cycle with no repeated vertices.

We can now discuss the steps for the grid drawing of the genus-1 graph G* with an external face formed by P. Using Lemma [\ref=lemma:splitB], with L = P4 and R = P2, divide G* into two subgraphs G1 and G2. We proceed to embed G1 with G2 being symmetric. Assume without loss of generality that G1 contains the bottom path, P3. Compute a canonical order of G1 so that the vertices of P3 are the last vertices removed. Place all of the vertices of P3 on a horizontal line, [formula] placed consecutively on y = 0. This is possible since there are no edges between them (because the path is chord-free). Recall that the standard dPP algorithm [\cite=fpp-hdpgg-90] maintains the invariant that at the start of each iteration, the current external face consists of the original horizontal line and a set of line segments of slope ±  1 between consecutive vertices. The algorithm also maintains a "shifting set" for each vertex. We modify this condition by requiring that the vertices on the right and left boundary that are part of P2 and P4 be aligned vertically and that the current external face might have horizontal slopes corresponding to vertices from P3; see Fig. [\ref=fig:embed](a). Upon insertion of a new vertex v, the vertex will have consecutive neighboring vertices on the external face. We label the left and rightmost neighbors [formula] and xr. To achieve our modified invariant, we insert a vertex v into the current drawing depending on its type, 0, 1, or 2, as follows:

Type 0: Vertices not belonging to a path in P are inserted as with the traditional dPP algorithm. This insertion might require up to two horizontal shifts determined by the shifting sets; see Fig. [\ref=fig:embed](a).

Type 1: Vertices belonging to P2, which must be placed vertically along the right boundary, are inserted with a line segment of slope + 1 between [formula] and v and a vertical line segment between v and xr. Notice that xr must also be in P2. And because P2 is chord-free xr is the topmost vertex on the right side of the current external face. That is, v can see xr. By Lemma [\ref=lemma:splitB] and the fact that the graph was fully triangulated, we also know that v must have a vertex [formula]. This insertion requires only 1 shift, for the visibility of [formula] and v. Again the remaining vertices [formula] are connected as usual; see Fig. [\ref=fig:embed](b).

Type 2: Vertices belonging to P4, which must be placed vertically along the left boundary, are handled similarly to Type 1. Because of Lemma [\ref=lemma:splitB], after processing both G1 and G2, we can proceed to stitch the two portions together. Shift the left wall of the narrower graph sufficiently to match the width of the other graph. For simplicity, refer to the vertices on the external face of each subgraph that are not exclusively part of the wall or bottom row as . For each subgraph, consider the point p located at the intersection of the lines of slope ±  1 extending from the left and rightmost external vertices. Flip G2 vertically placing it so that its point p lies either on or just above (in case of non-integer intersection) G1's point. Because the edges between the upper external vertices have slope |m|  ≤  1 and because of the vertical separation of the two subgraphs, every upper external vertex on G1 can directly see every upper external vertex on G2. By Lemma [\ref=lemma:splitB], we know that the set of edges removed in the separation along with the edges connecting the upper external vertices forms an outerplanar graph. Therefore, we can reconnect the removed edges, joining the two subgraphs, without introducing any crossings.

We claim that the area of this grid is O(n)  ×  O(n2). First, let us analyze the width. From our discussion, we have accounted for each insertion step using shifts. Since the maximum amount of shifting of 2 units is done with Type 0 vertices, we know that each of the two subgraphs has width at most 2n. In addition, the stitching stage only required a shifting of the smaller width subgraph. Therefore, the width of our drawing is at most 2n. Ideally, the height of our drawing would also match this bound. The stitching stage for example only adds at most W  ≤  2n units to the final height. After the insertion of each wall vertex we know that the height increases by at most W. Therefore, we know that the height is at most Wn or 2n2 and consequently we have a correct drawing using a grid of size O(n)  ×  O(n2).

Thus, we get a planar polygonal-schema drawing of a torodial graph G in a rectangle, which simultaneously achieves polynomial area, a straight frame, and straight-line edges.

The Peel-and-Bend Algorithm

The case for g > 1 is similar, but involves a few alterations. First, we use n = |V| unlike the previous sections which used n  =  |V|  +  g. The main difference, however, is that we cannot embed the outer face using only horizontal and vertical walls unless the fundamental cycles are chord-free or unless edge bends are allowed. Since we desire a straight-frame rendering of the polygonal schema P in a rectangle, we must allow some edge bends in this case. The following theorem describes our resulting drawing method, which we call the Peel-and-Bend algorithm.

Let G* be an embedded planar graph and [formula] in G* be a collection of 4g paths such that each path [formula] is chord-free, the last vertex of each path matches the first vertex of the next path, and when treated as a single cycle, P forms the external face of G*. Let [formula] be the number of vertices on the external cycle. We can draw G* on an O(n)  ×  O(n2) grid with straight-line edges and no crossings and at most k - 3 single-bend edges in such a way that for each path Pi on the external face the vertices on that path form a straight line.

First, let us assume that the entire external face, represented by P, is completely chord-free. That is, if two vertices on the external cycle share an edge then they are adjacent on the cycle. In this case we can create a new set of 4 paths, [formula] We can then use Theorem [\ref=theorem:gOneEmbed] to prove our claim using no bends.

If, however, there exist chords on the external face, embedding the graph with straight-lines becomes problematic, and in fact impossible to do using a rectangular outer face. By introducing a temporary bend vertex for each chord and retriangulating the two neighboring faces, we can make the external face chord free. Clearly this addition can be done in linear time. Since there are at most k vertices on the external face and since the graph is planar, there are no more than k - 3 such bend points to add. We then proceed as before using Theorem [\ref=theorem:gOneEmbed], subsequently replacing inserted vertices with a bend point.

Algorithms for Non-Toroidal Graphs

In this section, we describe two more algorithms for producing a planar polygonal-schema drawing of a non-toroidal graph G, which is given together with its combinatorial embedding in a genus-g surface, S, where g > 1. As mentioned above, these algorithms provide alternative trade-offs with respect to the three primary aesthetic criteria we desire for polygonal-schema drawings. For the sake of space, we describe these algorithms at a very high level and leave their details and full analysis to the final version of this paper.

The Peel-and-Stretch Algorithm.

In the Peel-and-Stretch Algorithm, we find a chord-free polygonal schema P for G and cut G along these edges to form a planar graph G*. We then layout the sides of P in a straight-frame manner as a regular convex polygon, with the vertices along each boundary edge spaced as evenly as possible. We then fix this as the outer face of G* and apply Tutte's algorithm [\cite=t-crg-60] [\cite=t-hdg-63] to construct a straight-line drawing of the rest of G*. This algorithm therefore achieves a drawing with straight-line edges in a (regular) straight frame, but it may require exponential area when normalized to an integer grid, since Tutte's drawing algorithm may generate vertices with coordinates that require Θ(n log n) bits to represent.

The Peel-and-Place Algorithm.

In the Peel-and-Place Algorithm, we start by finding a polygonal schema P for G and cut G along these edges to form a planar graph G*, as in all our algorithms. In this case, we then create a new triangular face, T, and place G* in the interior of T, and we fully triangulate this graph. We then apply the dPP algorithm [\cite=fpp-hdpgg-90] to construct a drawing of this graph in an O(n)  ×  O(n) integer grid with straight-line edges. Finally, we remove all extra edges to produce a polygonal schema drawing of G. The result will be a polygonal-schema drawing with straight-line edges having polynomial area, but there is no guarantee that it is a straight-frame drawing, since the dPP algorithm makes no collinear guarantees for vertices adjacent to the vertices on the bounding triangle.

Conclusion and Future Work

In this paper, we present several algorithms for polygonal-schema drawings of higher-genus graphs. Our method for toroidal graphs achieves drawings that simultaneously use straight-line edges in a straight frame and polynomial area. Previous algorithms for the torus were restricted to special cases or did not always produce polygonal-schema renderings [\cite=e-tbtdo-09] [\cite=kns-dgt-01] [\cite=Vodopivec20081847]. Our methods for non-toroidal graphs can achieve any two of these three criteria. It is an open problem whether it is possible to achieve all three of these aesthetic criteria for non-toroidal graphs. To the best of our knowledge, previous algorithms for general graphs in genus-g surfaces were restricted to those with "nice" polygonal schemas [\cite=z-dgs-94].