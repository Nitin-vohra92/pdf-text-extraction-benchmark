Proposition Lemma Corollary

A Bound on Rate of Codes with Locality with Sequential Recovery from Multiple Erasures

Introduction

An

[formula]

Codes with Sequential Recovery

An

[formula]

Background

In [\cite=GopHuaSimYek] P. Gopalan et al. introduced the concept of codes with locality (see also [\cite=PapDim] [\cite=OggDat]), where an erased code symbol is recovered by accessing a small subset of other code symbols. The size of this subset denoted by r is typically much smaller than the dimension of the code, making the repair process more efficient compared to MDS codes. The authors of [\cite=GopHuaSimYek] considered codes that can locally recover from single erasures (see also [\cite=GopHuaSimYek] [\cite=HuaChenLi] [\cite=KamPraLalKum] [\cite=TamBar_Optimal_LRC])

The sequential approach introduced by Prakash et al. [\cite=PraLalKum] is one of the many approaches to locally recover from multiple erasures. Codes employing this approach have been shown to be better in terms of rate and minimum distance (see [\cite=PraLalKum] [\cite=RawMazVis] [\cite=SonYue_Binary_local_repair] [\cite=BalPraKum] [\cite=balaji2016binary]). The authors of [\cite=PraLalKum] considered codes that can sequentially recover from two erasures (see also [\cite=SonYue_3_Erasure]). Codes with sequential recovery from three erasures can be found discussed in [\cite=SonYue_3_Erasure] [\cite=BalPraKum] [\cite=song2016sequential]. Here we would like to point out the fact that a bound on rate of an (n,k,r,3)seq code was derived in [\cite=song2016sequential]. Rate bounds for t = 2,4 was derived in [\cite=PraLalKum],[\cite=balaji2016binary] respectively. In this paper, we derive an upper bound on rate of a code with locality with sequential recovery from multiple erasures for any r  ≥  3 and any t > 0 . We also give a construction of codes achieving our rate bound for any r  >  0 and t > 0. Note that although our rate bound is valid only for r  ≥  3, the bound can be achieved by construction for any r  >  0.

Alternate approaches for local recovery from multiple erasures can be found in [\cite=KamPraLalKum] [\cite=SonDauYueLi] [\cite=ZhaWanGe] [\cite=HuaYaaUchSie] [\cite=TamBarFro] [\cite=KimNamSong] [\cite=SheFuGua] [\cite=WanZha_Combinatorial_Repair_locality] [\cite=TamBar_Optimal_LRC] [\cite=JuaHolOgg] [\cite=RawPapDimVis_arxiv] [\cite=WangZhang_multiple_erasure].

Our Contributions

In this paper, we derive an upper bound on rate of a code with locality with sequential recovery from multiple erasures for any r  ≥  3 and any t > 0 . We also give a construction of codes achieving our rate bound for any r  >  0 and t  >  0

Upper Bound on Rate of an (n,k,r,t)seqcode

In this section we provide an upper bound on the rate of an (n,k,r,t)seq code for r  ≥  3.

Upper Bound on Rate of an (n,k,r,t)seq Code Whenever t is a Positive Even Integer:

In this subsection we provide an upper bound on the rate of an (n,k,r,t)seq code whenever t is a positive even integer and r  ≥  3.

Let C be an (n,k,r,t)seq code. Let t be a positive even integer and r  ≥  3. Then

[formula]

[formula]

Let m be the dimension of B0. Let c1,...cm be a basis of B0 such that wH(ci)  ≤  r + 1.

[formula]

Now from the definition of an (n,k,r,t)seqcode, it can be easily seen that H1 is a parity check matrix of an (n,k,r,t)seqcode as it contains all the codewords of Hamming weight at most r + 1 which are in [formula]. Also,

[formula]

Hence we now proceed to derive an upper bound on [formula]. Without loss of generality the matrix H1, after permutation of rows and columns can be written in the following form

[formula]

where

the rows of H1 are labelled 1,2,...,m and columns are labelled 1,2,...n,

the matrices [formula] have dimensions ρi - 1  ×  ai, the matrices [formula] have dimensions ρi  ×  ai,

D0 is a ρ0  ×  a0 matrix with each column having Hamming weight 1 and each row having Hamming weight at least 1,

{Ai},{Di},[formula] are matrices such that each column of Bi has Hamming weight 2, each column of Ai has Hamming weight at least 1 and each row of Di has Hamming weight at least 1,

C is a matrix with each column having Hamming weight 2,

D is a matrix with each column having Hamming weight at least 3.

{Ai} are matrices with each column having Hamming weight 1 and {Di} are matrices with each row and each column having Hamming weight 1.

Proof is given in Appendix [\ref=AppendixA].

By Claim [\ref=claim1], after permutation of columns of H1 in [\eqref=Hform] within the columns labelled by the set [formula] for [formula], the matrix [formula] can be assumed to be a diagonal matrix with non-zero entries along the diagonal and hence ρi = ai. By counting the row weights and column weights of [formula] we get:

[formula]

For some p  ≥  0,

[formula]

Let the number of columns in matrix C be [formula]. Counting the row weights and column weights of the matrix C, we get :

[formula]

Substituting [\eqref=Ineq2] in [\eqref=Ineq3]:

[formula]

Counting the row weights and column weights of H1, we get:

[formula]

Our basic inequalities are [\eqref=Ineq1],[\eqref=Ineq3],[\eqref=Ineq2],[\eqref=Ineq5]. We manipulate these 4 inequalities to derive the bound on rate.

Substituting [\eqref=Ineq2] in [\eqref=Ineq5]:

[formula]

Substituting [\eqref=Ineq4] in [\eqref=Ineq6], we get:

[formula]

From [\eqref=Ineq2], for any [formula]:

[formula]

Subtituting [\eqref=Ineq1] for [formula] in [\eqref=Ineq10], we get:

[formula]

Let

[formula]

Let us prove the following inequality by induction for [formula],

[formula]

[\eqref=Ineq9] is true for J = 0 by [\eqref=Ineq7]. Hence [\eqref=Ineq9] is proved for t = 4 and the range of J is vacuous for t = 2. Hence assume t > 4. Hence let us assume [\eqref=Ineq9] is true for J such that [formula] and prove it for J + 1. Substituting [\eqref=Ineq11] for j = J in [\eqref=Ineq9], we get:

[formula]

Substituing [\eqref=Ineq13] in [\eqref=Ineq141], we get

[formula]

Hence [\eqref=Ineq9] is proved for any [formula] for t  ≥  4. Hence writing [\eqref=Ineq9] for [formula] for t  ≥  4, we get:

[formula]

It can be seen that δj for r  ≥  2 has a product form as:

[formula]

Hence for r  ≥  3, t  ≥  4:

[formula]

Hence we can substitute [\eqref=Ineq11] for [formula] in [\eqref=Ineq15] :

[formula]

Substituting [\eqref=Ineq13] in [\eqref=Ineq17], we get:

[formula]

Using [\eqref=Ineq16], we get:

[formula]

Hence [\eqref=Ineq18] implies:

[formula]

[\eqref=Ineq19] after some algebraic manipulations gives the required bound on [formula] and hence on [formula] as stated in the theorem. Note that although the derivation is valid for r  ≥  3, t  ≥  4, the final bound given in the theorem is correct and tight for t = 2. The bound for t = 2 can be derived specifically by substituting a0  ≤  m in [\eqref=Ineq7] and noting that p  ≥  0.

Upper Bound on Rate of an (n,k,r,t)seq Code Whenever t is a Positive Odd Integer:

In this subsection we provide an upper bound on the rate of an (n,k,r,t)seq code whenever t is a positive odd integer and r  ≥  3.

Let C be an (n,k,r,t)seq code. Let t = 2s - 1,s  ≥  1 and r  ≥  3. Then

[formula]

[formula]

Let m be the dimension of B0. Let c1,...cm be a basis of B0 such that wH(ci)  ≤  r + 1.

[formula]

Now from the definition of an (n,k,r,t)seqcode, it can be easily seen that H1 is a parity check matrix of an (n,k,r,t)seqcode as it contains all the codewords of Hamming weight at most r + 1 which are in [formula]. Also,

[formula]

Hence we now proceed to derive an upper bound on [formula]. Without loss of generality the matrix H1, after permutation of rows and columns can be written in the following form

[formula]

where

the rows of H1 are labelled 1,2,...,m and columns are labelled 1,2,...n,

the matrices {Ai,1  ≤  i  ≤  s - 1} have dimensions ρi - 1  ×  ai, the matrices {Di,0  ≤  i  ≤  s - 1} have dimensions ρi  ×  ai,

D0 is a ρ0  ×  a0 matrix with each column having Hamming weight 1 and each row having Hamming weight at least 1,

{Ai,1  ≤  i  ≤  s - 1},{Di,1  ≤  i  ≤  s - 1},[formula] are matrices such that each column of Bi has Hamming weight 2, each column of Ai has Hamming weight at least 1 and each row of Di has Hamming weight at least 1,

C is a matrix with each column having Hamming weight 2,

D is a matrix with each column having Hamming weight at least 3.

{Ai,1  ≤  i  ≤  s - 1} are matrices with each column having Hamming weight 1 and {Di,0  ≤  i  ≤  s - 2} are matrices with each row and each column having Hamming weight 1. Ds - 1 is a matrix having column weight 1.

Proof is exactly similar to the proof of claim [\ref=claim1]. So we skip to proof.

By Claim [\ref=claim2], after permutation of columns of H1 in [\eqref=Hform2] within the columns labelled by the set [formula] for 0  ≤  j  ≤  s - 2, the matrix Dj,0  ≤  j  ≤  s - 2 can be assumed to be a diagonal matrix with non-zero entries along the diagonal and hence ρi = ai, for 0  ≤  i  ≤  s - 2. By counting the row weights and column weights of Ai,1  ≤  i  ≤  s - 1 we get:

[formula]

For some p  ≥  0,

[formula]

Let the number of columns in matrix C be as. Counting the row weights and column weights of the matrix

[formula]

Construction of codes achieving the upper bound on rate

In this section we give a construction of codes with sequential recovery achieving the rate bound [\eqref=Thm1] for any r > 0,t = 2s,s  ≥  1 and also give a construction achieving [\eqref=Thm2] for any r > 0,t = 2s - 1,s  ≥  1.

Construction of codes achieving the upper bound on rate for t even:

In this subsection we give a construction of codes achieving the rate bound [\eqref=Thm1] for any r > 0 and [formula]. A construction achieving the bound [\eqref=Thm1] for the special case of t = 2 was provided in [\cite=PraLalKum], [\cite=SonYue_3_Erasure], [\cite=BalPraKum] and for the case of t  =  4 was provided in [\cite=balaji2016binary].

We give a graph-based construction. We give the general principle of the construction as follows:

Consider a regular graph G0 with L̂ nodes each of degree r and girth at least t + 1. Let the nodes of G0 be {p10,...,pL̂0}. Let L̂ be a multiple of [formula]. If not we can take disjoint copies of G0 and take disjoint union of these copies of G0 such that the resulting graph has number of nodes which is a multiple of [formula]. Partition the nodes {p10,...,pL̂0} into [formula] sets with each set containing exactly r nodes. Let us denote the partition as [formula].

Now add a set of [formula] nodes denoted by [formula] to G0. Connect the node pj1 to the nodes in Qj0 for [formula]. Let the resulting graph be G1.

Now we inductively construct the graph Gi from Gi - 1 for [formula].

Nodes are added to Gi - 1, for [formula] to form Gi as follows: partition the nodes [formula] into [formula] sets with each set containing exactly r nodes. Let the partition be [formula]. Add new nodes labelled [formula] to Gi - 1. Now connect pji to r nodes in the set Qji - 1 for [formula]. The resulting graph is denoted as Gi.

We now define our code based on [formula]. Let the edges of G0 represent information symbols and the nodes [formula] represent parity symbols. The node pj0 represents a code symbol storing the parity of the information symbols that are represented by edges incident on it in G0. For [formula], the node pji represent a code symbol storing the parity of code symbols represented by the nodes in the set Qji - 1. The resulting code C is defined by the information symbols represented by the edges in G0 and the parity symbols represented by [formula].

If we construct Gi from Gi - 1 in such a way that the girth of Gi is at least t + 1, then it is clear that the resulting code C is an (n,k,r,t)seq code with [formula] and [formula]. Hence the code C has rate achieving the upper bound given in [\eqref=Thm1].

Hence it is enough to give a construction for Gi from Gi - 1, for [formula] such that girth of Gi is at least t + 1 assuming girth of Gi - 1 is at least t + 1. We construct G0 separately as step 0.

It can be noted that the graph [formula] after removing the edges in G0 has a tree structure with nodes [formula] at level i (we represent the last level as level 0) with nodes {pj0:1  ≤  j  ≤  L̂} as leaf nodes.

Construction of Gi:

At Step 0: G0 is simply a regular graph of degree r with girth at least t + 1 which can be constructed [\cite=Furedi].

Let us assume we are given the graph Gi - 1 for some [formula] with girth at least t + 1 with nodes labelled as before constructed at step i - 1. Let us construct Gi as follows. Step i:

Take a biregular bipartite graph [formula] with V1  =  {v1,...,vm},V2  =  {w1,...,wni} and degree(vj) = r,1  ≤  j  ≤  m, [formula] with girth at least [formula]. Such a graph can be constructed [\cite=Furedi]. Now [formula].

Construct a new graph G'' as follows:

In G', replace the node wf by [formula] for 1  ≤  f  ≤  ni. If the neighbours of wf in G' are the nodes in [formula], then connect wj,f and vqj by an edge for [formula]. The resulting graph is termed as G''.

Now take ni disjoint copies of the graph Gi - 1, and form the graph G'i - 1 with the disjoint union of these ni copies of Gi - 1. Note that G'i - 1 can be constructed in exactly the same way Gi - 1 is constructed starting from ni disjoint copies of G0 and girth of G'i - 1 can be seen to be at least t + 1. Hence we take G'i - 1 as our graph construction at (i - 1)th step. Let the nodes in G'i - 1 corresponding to the ni disjoint copies of pi - 1j,[formula] in disjoint copies of Gi - 1 be labelled as p'i - 1j, for [formula] where p'i - 1j, [formula] correspond to the nodes pi - 1j,[formula] in the fth copy of Gi - 1 respectively, for 1  ≤  f  ≤  ni.

Now take disjoint union of G'' and G'i - 1. Merge the node wj,f with [formula] for [formula]. Relabel vj as p'ij. The resulting graph is our desired graph Gi.

Since the girth of G'i - 1 is at least t + 1 and girth of G' is alteast [formula], it can be easily seen that the graph Gi has girth at least t + 1.

Hence the bound given in [\eqref=Thm1] is tight and achievable for any r  >  0 and [formula].

Construction of codes achieving the upper bound on rate for t odd:

In this subsection we give a construction of codes achieving the rate bound [\eqref=Thm2] for any r > 0 and t  =  2s - 1,s  ≥  1. A construction achieving the bound [\eqref=Thm2] for t = 5 can be found in [\cite=balaji2016binary]. For t = 3, the bound [\eqref=Thm2] can achieved by taking the product of two

[formula]

Construction of Gi:

At Step 0: G0 is simply a regular bipartite graph of degree r with girth at least t + 1 which can be constructed [\cite=Furedi].

Let us assume we are given the graph Gi - 1 for some 1  ≤  i  ≤  s - 1 with girth at least t + 1 with nodes labelled as before constructed at step i - 1. Let us construct Gi as follows. Step i:

Take a biregular bipartite graph [formula] with V3  =  {v1,...,v2m} and V4  =  {w1,...,wni} and degree(vj) = r for 1  ≤  j  ≤  2m and [formula] for 1  ≤  j  ≤  ni. Let N(v) represent the neighbours of the node v. We pick G' such that [formula], for 1  ≤  j  ≤  ni. We also pick G' such that its girth is at least [formula]. We will now assume that G' with the mentioned properties can be constructed and construct Gi using G' and Gi - 1. We will separately describe the construction of G' with the mentioned properties.

Construct a new graph G'' as follows:

In G', replace the node wf by [formula] for 1  ≤  f  ≤  ni. If the neighbours of wf in G' are nodes in the set [formula] with [formula] and [formula], then connect wj,f and vqj by an edge for [formula]. The resulting graph is termed as G''.

Now take ni disjoint copies of the graph Gi - 1, and form the graph G'i - 1 with the disjoint union of these ni copies of Gi - 1. As explained in the general principle of construction, nodes in Gi - 1 are represented by [formula]. Let the nodes in G'i - 1 corresponding to the ni disjoint copies of [formula] , 1  ≤  j  ≤  i - 1 in disjoint copies of Gi - 1 be represented as [formula], 1  ≤  j  ≤  i - 1 where p'jb, [formula] correspond to the nodes pjb,[formula] in the fth copy of Gi - 1 respectively, for 1  ≤  f  ≤  ni. Similarly u'jb, [formula] correspond to the nodes ujb,[formula] in the fth copy of Gi - 1 respectively, for 1  ≤  f  ≤  ni. Note that G'i - 1 can be constructed in exactly the same way Gi - 1 is constructed starting from [formula] which is disjoint union of ni disjoint copies of G0 with V5  =  {p'01,...,p'0niL}, V6  =  {u'01,...,u'0niL} and girth of G'i - 1 can be seen to be at least t + 1. Hence we take G'i - 1 as our graph construction at (i - 1)th step.

Now take disjoint union of G'' and G'i - 1. Merge the node wj,f with [formula] for [formula]. Similarly merge the node wj,f with [formula] for [formula]. Relabel vj for 1  ≤  j  ≤  m as p'ij and relabel vj for m + 1  ≤  j  ≤  2m as u'ij. The resulting graph is our desired graph Gi.

Since the girth of G'i - 1 is at least t + 1 and girth of G' is at least [formula], it can be easily seen that the graph Gi has girth at least t + 1.

Hence the construction of Gi is done if we construct the graph G' with the mentioned properties.

Construction of G':

Consider a biregular bipartite graph [formula] with [formula], U2  =  {c1,...,cλ} with degree(bj)  =  r, for 1  ≤  j  ≤   and [formula], for 1  ≤  j  ≤  λ. Pick the graph G1 such that it has girth at least [formula]. Such a graph G1 can be constructed due to [\cite=Furedi].

Consider a regular bipartite graph [formula] with X  =  {x1,...,xl'} and Y  =  {y1,...,yl'} with each node of degree λ and girth at least [formula]. Such a graph G2 can be constructed due to [\cite=Furedi].

Take 2l' disjoint copies of G1. Let G3 be the disjoint union of the 2l' copies named G11,...,G12l' of G1. Denote the nodes bj,cj in the lth copy G1l by blj,clj respectively.

Replace the node xf in G2 by x1,f,...,xλ,f for 1  ≤  f  ≤  l'. If the neighbours of xf in G2 are the nodes in the set {yq1,...,yqλ} then connect xj,f to yqj for 1  ≤  j  ≤  λ. Now replace the node yf by y1,f,...,yλ,f for 1  ≤  f  ≤  l'. If the neighbours of yf after replacing xf were the nodes in the set {xσ1,β1,...,xσλ,βλ} then connect yj,f to xσj,βj for 1  ≤  j  ≤  λ. Denote this graph by G4. Now, if xj,f and y, are neighbours in G4 then merge the nodes cfj and [formula] in G3 and label the resulting merged node as w(f - 1)λ + j in G3. Relabel blj as v(l - 1) + j in G3. The resulting graph is named G'.

G' is a biregular bipartite graph [formula] with V3  =  {v1,...,v2m} where m  =  l' and V4  =  {w1,...,wni} where ni  =  l'λ and degree(vj) = r for 1  ≤  j  ≤  2m and [formula] for 1  ≤  j  ≤  ni. It can be seen that G' has girth at least [formula]. It can also be seen that [formula], for 1  ≤  j  ≤  ni.

A conjecture on rate of an (n,k,r,t)seq code was given in [\cite=song2016sequential].

Conjecture:

[formula]

Our rate bound satisfies the conjecture as our rate bound can be written in the form:

For t even:

[formula]

For t Odd:

[formula]

More specific conjecture was given for t = 5,6. Our bound exactly matches with their conjecture for t = 5. But for t = 6, our bound doesn't match with their conjecture.

For t = 6, Our bound takes the form:

[formula]

The conjecture for t = 6 given in [\cite=song2016sequential]:

[formula]

Hence the conjecture given in [\cite=song2016sequential] has a smaller rate than our bound for t = 6. And further our upper bound on rate for t = 6 can be achieved.

Proof of Claim [\ref=claim1]

Its enough to show that:

{Ai} are matrices with each column having Hamming weight 1.

{Di} are matrices with each row having Hamming weight 1.

As the point 1 written above combined with the fact that each column of [formula] has Hamming weight 2 implies Di,i  ≥  1 are matrices with each column having Hamming weight 1 and D0 by definition is a matrix with each column having Hamming weight 1. Let us show the claim by induction as follows: Induction Hypothesis:

Property Pi: any m  ×  1 vector having Hamming weight at most 2 with support contained in [formula] for some 0  ≤  j  ≤  i can be written as some linear combination of at most 2(i + 1) column vectors of H1 with labels in [formula].

The property Pi is true and the Claim [\ref=claim1] is true for A1,...Ai, D0,...Di.

Initial step:

We show that each row of D0 has Hamming weight exactly 1. Suppose there exists a row of D0 with Hamming weight more than 1; let the support set of the row be i1,i2,.... Then the columns labelled i1,i2 of H1 can be linearly combined to give a zero column. This contradicts the fact that dmin(C)  ≥  t + 1,t  >  0, even. Hence, all rows of D0 have Hamming weight exactly 1.

If t  =  2, then the claim is already proved. So let t  ≥  4.

We show that columns of A1 have Hamming weight exactly 1. Suppose jth column of A1 [formula] has Hamming weight 2; let the support of the column be j1,j2 in A1. Then the column labelled a0  +  j in H1 along with the 2 columns vectors of H1 with labels from the set {1,...,a0} where one of the column vector has exactly one non-zero entry in j1 and other in j2 can be linearly combined to give a zero column again leading to a contradiction on minimum distance.

The above argument also shows that any m  ×  1 vector having Hamming weight at most 2 with support contained {1,..,ρ0} can be written as some linear combination of at most 2 column vectors of H1 with labels from the set {1,...,a0}. Hence Property P0 is true.

We now show that each row of D1 has Hamming weight exactly 1. Suppose jth row of D1 has Hamming weight more than 1; let the support set of the row be l1,l2,...,lz in D1. Now there is some linear combination of columns labelled a0 + l1 and a0 + l2 in H1 that gives a zero in (ρ0 + j)th coordinate and thus the linear combination has support contained in {1,...,ρ0} with Hamming weight atmost 2. Thus by Property P0, there is a non-zero set of at most 4 linearly dependent columns in H1 leading to a contradiction on minimum distance.

Now we show that Property P1 is true: It is enough to prove that any m  ×  1 vector with weight at most 2 with support contained in {ρ0 + 1,..,ρ0  +  ρ1} can be written as linear combination of at most 2(1 + 1) = 4 vectors of H1 with labels in [formula]. This can be easily seen using arguments similar to ones presented before. Let an m  ×  1 vector have non-zero entries in coordinates ρ0 + j1,ρ0 + j2 or ρ0 + j1. Then this vector can be linearly combined with 2 atmost column vectors in H1 labelled in {a0 + 1,...,a0 + a1} to form a m  ×  1 vector with Hamming weight atmost 2 with support contained in {1,ρ0} which inturn can be written as linear combination of atmost 2 column vectors in H1 labelled in {1,...,a0} by property P0. Hence the given m  ×  1 vector is written as linear combination of atmost 2(1 + 1) = 4 column vectors in H1 labelled in [formula].

Induction step :

Let us assume by induction hypothesis that Property Pi is true and the Claim [\ref=claim1] is true for A1,...Ai, D0,...Di for some [formula] and prove the induction hypothesis for i + 1. For t = 4, the initial step of induction completes the proof of Claim [\ref=claim1]. Hence assume t > 4.

Now we show that each column of Ai + 1 has Hamming weight exactly 1: suppose jth column of Ai + 1 for some 1  ≤  j  ≤  ai + 1 has Hamming weight 2; let the support of the column be j1,j2 in Ai + 1. It is clear that the corresponding column vector in H1 is a vector with support contained in [formula]. Hence by Property Pi there is a non-zero set of at most 2(i + 1) + 1 columns in H1 which are linearly dependent; hence contradicts the minimum distance as 2(i + 1) + 1  ≤  t - 1. Hence each column of Ai + 1 has Hamming weight exactly 1.

Now we show that each row of Di + 1 has Hamming weight exactly 1: suppose jth row of Di + 1 has Hamming weight more than 1; let the support set of the row be l1,...,lz in Di + 1. Now some linear combination of columns labelled [formula] and [formula] in H1 will make the resulting vector have a 0 in [formula] coordinate and the resulting vector also has Hamming weight atmost 2 with support contained in [formula] and hence by Property Pi, there is a non-zero set of at most 2(i + 1) + 2 columns in H1 which are linearly dependent; hence contradicts the minimum distance as 2(i + 1) + 2  ≤  t; thus proving that each row of Di + 1 has Hamming weight exactly 1.

Now we show that Property Pi + 1 is true: It is enough to prove that any m  ×  1 vector with weight at most 2 with support contained in [formula] can be written as linear combination of at most 2(i + 2) vectors of H1 with labels in [formula]. This can be easily seen using arguments similar to ones presented before. Let an m  ×  1 vector have non-zero entries in coordinates [formula] or [formula]. Then this vector can be linearly combined with 2 atmost column vectors in H1 labelled in [formula] to form a m  ×  1 vector with Hamming weight atmost 2 with support contained in [formula] which inturn can be written as linear combination of atmost 2(i + 1) column vectors in H1 labelled in [formula] by property Pi. Hence the given m  ×  1 vector is written as linear combination of atmost 2(i + 2) column vectors in H1 labelled in [formula].