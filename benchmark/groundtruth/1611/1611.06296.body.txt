A Bayesian approach to type-specific conic fitting

Introduction

Linear algebraic methods for fitting conic sections to noisy data were introduced by Bookstein [\cite=bookstein1979fitting]. Subsequent work, mostly in the broad context of computer vision, has discussed topics such as iterative refinement [\cite=sampson1982fitting], type-specific normalisation [\cite=fitzgibbon1999direct] [\cite=halir1998numerically] and the correction of obvious normalisation bias [\cite=harker2008direct] or curvature bias [\cite=kanatani1994statistical] [\cite=collett2014ellipse]. However, all of these papers confine themselves to making point estimates of the set of conic coefficients, and do not quantify the expected statistical errors.

A recent series of papers by Kanatani and coworkers [\cite=kanatani2011hyper] [\cite=kanatani2011hyperls] [\cite=kanatani2015hyper] have used a perturbative treatment to predict the systematic errors introduced into the fitting process by noisy data, and hence to identify analytically (rather than merely numerically) the choices of normalisation and weighting that minimise bias and statistical error. These are forward statistical calculations, that is, the noisy data is described by a sampling distribution around the true values; the final result is an unbiased point estimate of the generic conic coefficients.

In this paper I show that we can go significantly further by also using a Bayesian (inverse) statistical treatment, that is, by considering a posterior distribution for the model parameters.

Knowing the posterior distribution has three distinct useful consequences. Firstly, and most obviously, we can place confidence intervals on the estimated fit made from any particular data set; since for the generic fit in the perturbative regime the distributions are Gaussian, equivalent results could have been obtained from the sampling statistics. Secondly, and perhaps unexpectedly, being in possession of a distribution of fitted values rather than just a point estimate allows us to include in a systematic and unbiased fashion additional constraints, such as those required to make the fit type-specific. Finally, by propagating the estimated errors in the conic coefficients, we may obtain both confidence intervals and bias corrections for estimates of other curve parameters (e.g. the location of the centre of an ellipse).

The method used has potential application to problems other than conic fitting (e.g. camera resection [\cite=collett2015self-normalising]), so is initially developed for a generic homogeneous linear model, before being applied (with numerical examples) to the conic case. The initial sampling calculations here differ in detail from those of Kanatani et al., but yield similar initial point estimates.

Errors in homogeneous model fitting

The model

Consider a system described by an M-component homogeneous linear model of the form

[formula]

where [formula] is the model vector and

[formula]

is the design vector for the Λ-dimensional data point [formula]. The elements of [formula] are known functions of [formula] (e.g. powers of the components of [formula]), and the model parameters gm are to be fitted from the data. I confine myself here to the case of scalar Z, but a multicomponent algebraic error may be treated in similar fashion. To avoid the trivial solution [formula], we impose a normalisation constraint of the form

[formula]

The M  ×  M constraint matrix [formula] may be constant or depend on the data; its rank R determines the dimension of the solution space.

An observed data point [formula] includes measurement error and other sources of noise,

[formula]

with the consequence that [\eqref=eq:exactModel] is not exactly satisfied. Given a set of N such data points that overdetermines the solution, we therefore look for the model vector [formula] that minimises

[formula]

where

[formula]

is the M  ×  M scatter matrix, and wi are statistical weights to be chosen later. We still require normalisation, so that we in fact minimise the ratio

[formula]

which we can do by solving the generalised eigenvalue problem

[formula]

We choose a basis for our model such that the constraint matrix may be partitioned into an R  ×  R upper-left corner [formula] of full rank and zeros everywhere else,

[formula]

where K = M - R. We then partition [formula] and [formula] similarly:

[formula]

The K  ×  K matrix [formula] is positive definite; the R  ×  R matrix [formula] has a zero eigenvalue in the absence of noise, but is positive definite for real data. The eigenvalue problem [\eqref=eq:fullEigen] is now equivalent to the reduced version

[formula]

where the reduced scatter matrix is the Schur complement

[formula]

and the full eigenvector can be reconstructed using

[formula]

[formula] may be expressed in diagonalised form as

[formula]

and hence [formula] as

[formula]

Perturbative treatment of errors

If there is no noise in the measured values, then the smallest eigenvalue λ0 in [\eqref=eq:fullEigen] or [\eqref=eq:reducedEigen] is zero, and the corresponding eigenvector [formula] is the exact solution to the original problem. With the inclusion of noise, the eigenvector [formula] will in general differ by both systematic bias and random error from the true solution.

Consider the effect on the nth eigenvalue λn and its associated reduced eigenvector [formula] of a small change [formula] in [formula] (and any associated change in [formula]). [\eqref=eq:reducedEigen] becomes

[formula]

Expanding and keeping only first-order changes gives

[formula]

Multiplying on the left by [formula], and using [formula] and the orthonormality of the eigenvectors,

[formula]

gives us the first-order results Thus we have an expansion of [formula] over a basis of the unperturbed eigenvectors in the form

[formula]

Apart from the [formula] terms (which are zero for fixed constraints and of little consequence otherwise), [\eqref=eq:perturbVal] and [\eqref=eq:perturbVec] are precisely the results of standard first-order perturbation theory familiar from any quantum mechanics textbook.

The starting point for our perturbation is the noise-free case, for which as previously noted λ0 = 0, and we are primarily interested in the correction to [formula], giving the simplified result that

[formula]

where

[formula]

is a generalised inverse of the noise-free reduced scatter matrix. It is not the Moore-Penrose pseudoinverse, but is closely related to it; factorising the normalisation matrix as [formula] we find that

[formula]

where superscript +   denotes the pseudoinverse.

To relate the change in [formula] to underlying changes in the data points being fitted, it will be more convenient to return to the unreduced representation. To first order,

[formula]

giving

[formula]

a corresponding result holds trivially for [formula]. So now

[formula]

where

[formula]

Again specialising to the change in [formula] from the noise-free case gives

[formula]

Dependence on measurement noise

Since the independent variables are random, a consistent calculation of the first-order change in [formula] requires us to consider not only the first-order dependence on each [formula], but also the expected value (i.e. the deterministic part) of the second-order dependence.

The former gives

[formula]

and the latter

[formula]

If the noise is homogeneous and isotropic, with [formula], this reduces to

[formula]

where

Substituting back into [\eqref=eq:perturbVal] with n = 0, most terms vanish, leaving only the term in [formula],

[formula]

if we choose our constraint matrix to be [formula] we have by [\eqref=eq:normalise] the simple result that Δλ0   =   σ2.

Similarly substituting back into [\eqref=eq:perturbVec0], some terms again vanish using the fact that the unperturbed vectors satisfy [formula]. However, we are still left with three distinct contributions to the error in the fitted parameters:

[formula]

The first term is the zero-mean random error, which will be our main interest for the remainder of this paper; the second is a normalisation bias, which vanishes by [\eqref=eq:fullY] and [\eqref=eq:orthonormal] if we choose our constraint matrix to be [formula]; the third is a curvature bias [\cite=kanatani1994statistical], which arises from the fact that [formula]. We expect the random error to scale as [formula], and the bias terms to scale as σ2 / R, where R is the minimum radius of curvature of the curve or surface to be fitted: for small noise (σ  ≪  R) and few data points the random error will dominate; for larger noise (still with σ  <  R) and many points the biases are more important.

To avoid the curvature bias, we need to correct [\eqref=eq:scatter] to

[formula]

where with the assumptions already made

[formula]

If, as will commonly but not invariably be the case, the components of [formula] can be expressed in terms of those of [formula] as

[formula]

for some constant matrix [formula], [\eqref=eq:scatterDebias] simplifies to

[formula]

This in turn implies that the generalised eigenvector of [formula] denoted [formula] is not in fact an estimator of [formula], but rather of [formula]. The corrected estimator of [formula] is accordingly

[formula]

where we can obtain a value for σ2 with the aid of [\eqref=eq:noiseVal]. Under the same conditions we have that [formula], and hence that the curvature bias term is [formula]. Combining the two, we have a corrected curvature bias

[formula]

[formula] projects onto [formula], so any remaining effect is purely a rescaling of the entire model vector, and hence irrelevant for a homogeneous model.

Clearly [formula] as given by [\eqref=eq:defCN] is to first order an optimal choice of constraint matrix: it avoids normalisation bias, and directly gives an estimate of σ2 and hence of the required curvature bias correction. This normalisation is equivalent both to Taubin's approximate mean-square distance [\cite=taubin1991estimation] and to the method advocated by Harker and O'Leary [\cite=harker2006direct]. In those cases, however, it appears as the result of an average over optimal weights--in the former case, those best approximating geometric distance, and in the latter, those giving a statistically ideal least-squares fit. By contrast, we have not yet considered the question of choice of weights (though we are about to do so), only systematic bias.

A plausible alternative choice of constraint matrix, equivalent to that made in the conic case by [\cite=kanatani2011hyper], is [formula], which would directly eliminate both bias terms and still leave Δλ0   =   σ2 to first order. The downside is that this will rarely be in the desired form [\eqref=eq:partitionC], requiring additional computation to change to a basis in which it is. If the reduction [\eqref=eq:linearLaplace] (and hence the simple curvature correction [\eqref=eq:curvCorrect]) is not available, this may nevertheless be the optimal choice. However, if the reduction [\eqref=eq:linearLaplace] does hold, then this choice gives to first order the same results as choosing [formula] and applying the curvature correction, since [\eqref=eq:fullEigen] becomes

[formula]

and hence

[formula]

From the first term in [\eqref=eq:fitErrors], the covariance matrix of the vector of coefficients is

[formula]

By differentiating with respect to wi we see that the optimal choice of weighting (i.e. the one that minimises the variances of the fitted parameters) is

[formula]

but to use this we must already have an approximate value for the model vector. It thus requires an iterative approach, in which we obtain an initial estimate for [formula] using constant weights and then refine it with the improved weights. Iteration in this fashion was suggested by Sampson [\cite=sampson1982fitting], but Sampson's weighting, based on the gradient at the measured data values, introduces bias into the fit [\cite=collett2014ellipse] and does not converge reliably for large noise [\cite=gander1994least-squares]. This weighting bias is similar in magnitude to the curvature bias, but its effects are more widespread, not confined to regions of high curvature. To avoid it, the gradient of the design vector [formula] appearing in [\eqref=eq:optimalWeight] must be evaluated not at the measured point i but instead at a nearby point consistent with (the current estimate of) the model; the best method of finding this point depends on details of the model being fitted. (Note that this is a less significant issue when calculating the constraint matrix [formula] from [\eqref=eq:defCN]; in that case we can to leading order safely evaluate [formula] at the measured points, since the summation over i averages over individual deviations.) With the optimal weighting [\eqref=eq:optimalWeight] the quantity E that the fit minimises is σ- 2 times the conventional χ2 statistic for Z(); to leading order in the size of the measurement noise, this is also equal to the geometric mean-square error. Although it is important that the reweighting process not introduce bias, it does not otherwise need to be very precise; the first reweighting may give a significant reduction in the random error, but there is typically little further gain from repeated iterations. It should be stressed (since it has not always been clear in the existing literature) that the purpose of reweighting is to improve the precision of the fit, not its accuracy; it is not an effective technique for the reduction or removal of bias.

With the weighting [\eqref=eq:optimalWeight] (or an adequate approximation to it), the resulting covariance matrix is

[formula]

for K = 1 we can equivalently write

[formula]

where ηm are independent unit-variance random variables and [formula]. Alternatively, with a Gaussian model for the errors, the sampling distribution for [formula] (or equivalently for [formula]) is

[formula]

where the delta-function enforces normalisation, ensuring that the resulting covariance matrix is proportional to the pseudoinverse of [formula], not the (divergent) full inverse. The individual point errors [formula] are not present in [\eqref=eq:sampling] other than via their contributions to the scatter matrix, which is a sufficient statistic for this problem. The curvature bias correction has not been explicitly represented: 0 here is the uncorrected vector of coefficients.

The results to this point are in practice very similar to those of [\cite=kanatani2015hyper], although there are two significant differences in approach. The first difference is that in this paper I have minimised the bias from each source separately: the normalisation matrix is chosen to remove normalisation bias; reweighting bias is minimised by evaluating the gradient at a point consistent with the current best-fit model; and the curvature bias is corrected as a separate, final step. In contrast, the method of [\cite=kanatani2015hyper] chooses the normalisation matrix to minimise all three biases simultaneously, including that from Sampson reweighting. One advantage of separate treatment is that the normalisation matrix may be calculated by the same method both before and after reweighting. The second difference is that I have taken my perturbation expansion only to the first nonvanishing order, which in some cases is first order and in others second. The consistently second-order treatment of [\cite=kanatani2011hyper] finds an additional normalisation bias term, but this is smaller than the leading term by a factor of N and hence in the perturbative regime is always smaller than the the random error and not statistically significant.

Posterior probabilities

Although sampling distributions are useful for the general comparison of fitting methods, what we really want for an individual set of real measurements is not the distribution [\eqref=eq:sampling], which presumes knowledge of the true values that we do not have, but the posterior probability [formula]. For the Gaussian case the posterior probability and the sampling distribution are to first order interchangeable for a sufficiently broad prior, leading us to estimate the former as

[formula]

In fact, noting that the optimally weighted error statistic is equivalent to the geometric mean-square error, we can obtain [\eqref=eq:optimalPosterior] directly from Bayes' theorem. With a Gaussian prior for the measurement noise we have

[formula]

The prior probability for the (unknown) true point [formula] may be factored into a delta-function ensuring the point is on the surface [formula] and the distribution [formula] of observed points over the surface,

[formula]

Now write the true point in terms of the point [formula] nearest to the measured [formula] that satisfies the model and an offset [formula],

[formula]

for [formula] to be on the surface, we must have (to second order in [formula])

[formula]

Since [formula] is parallel to [formula], we can expand

[formula]

where the elements of the matrix [formula] are

[formula]

Substituting back into [\eqref=eq:measurementNoise], and taking [formula] to be slowly varying on the typical scale of [formula], we have

[formula]

To leading order in [formula],

[formula]

giving

[formula]

We see that the density of measured points is higher on the concave side of the surface Z = 0, which is an intuitively reasonable result. It is not however directly useful. To use Bayes' theorem to interchange the roles of [formula] and [formula] we must work with probabilities, not probability densities (as Section 15.7 of [\cite=jaynes2003probability] illustrates). The relevant volume element is not [formula] but [formula], or equivalently [formula], factorised into the measured error (either geometric or algebraic) and the position on the surface, which was already integrated out in [\eqref=eq:surfaceIntegral]. We find that

[formula]

where we have expanded the gradient and again used the fact that [formula] is parallel to [formula], more specifically that

[formula]

Thus for probabilities the result of [\eqref=eq:probDensity] is reversed: for any given small area of the surface, there is a greater probability of finding a nearby point on the convex side than on the concave. This is illustrated for the 2D case in Figure [\ref=fig:curvature]. Taking the product over all sample points and using Bayes' theorem to convert [formula] to [formula] now directly yields [\eqref=eq:optimalPosterior] (including an explicit representation of the curvature correction).

While the perturbative results obtained earlier show that the method recommended in this paper is optimal among the class of linear algebraic methods, the direct derivation demonstrates the stronger result that it is globally optimal: within the small-noise approximation, no method gives a superior predictor of [formula] (though other methods may be equally good).

Since we do not know in advance the value of σ, we integrate over the Jeffreys prior [\cite=jeffreys1939theory] [\cite=jaynes2003probability] [formula] to obtain a t-distribution,

[formula]

for large N this reduces back to

[formula]

where [formula]. The corresponding covariance matrix can be found from [\eqref=eq:covariance] with the obvious substitutions of measured for true values.

These results hold for the case of a broad prior distribution for [formula], when the posterior distribution is just the normalised likelihood. If we wish to impose additional constraints on the solution, we can introduce a suitable restrictive prior and multiply it by the likelihood [\eqref=eq:measuredPosterior] to obtain the corresponding constrained posterior probability.

Application to conic sections

For conic fitting we have 2-dimensional data points [formula] (in Cartesian coordinates), with the 6-component design vector

[formula]

The self-normalising constraint matrix [formula] is of rank 5, and is already in the desired form [\eqref=eq:partitionC]; it can be constructed directly from the elements of [formula] using eqn(75) of [\cite=collett2014ellipse]. The constant rank-3 constraint matrices preferred in earlier treatments [\cite=bookstein1979fitting] [\cite=fitzgibbon1999direct] inevitably result in biased estimates, and will not be considered further in this paper; the biases are exhibited numerically in [\cite=collett2014ellipse] (note that the results therein include some for highly eccentric ellipses that are beyond the regime in which the perturbation theory used in this paper is accurate).

The curvature bias can indeed be expressed in the form [\eqref=eq:linearLaplace], with [formula] having nonzero elements only in its last row, which is [formula]. From this it follows that [formula], so the curvature bias correction does not alter the normalisation and the residual curvature bias [\eqref=eq:residCurv] vanishes completely. Furthermore, the approximate equality in [\eqref=eq:curvCorrect] is exact, so actually performing the bias correction is simply a matter of modifying the final component gn6 of each eigenvector [formula] to

[formula]

where 2  =  λ0.

For iterative reweighting according to [\eqref=eq:optimalWeight] we may evaluate the gradient [formula] at a point on the estimated curve determined with the aid of the appropriate elliptical coordinate system [\cite=collett2014ellipse] (or confocal parabolic coordinates if the curve is a parabola, but this is vanishingly likely to happen for real data unless we force it). Introduce the coordinates (η,θ) such that

[formula]

where the focal points are at [formula], with [formula]; the current estimated fit is a curve of constant η if it is an ellipse or of constant θ if it is a hyperbola. Each measured point i can be expressed in these coordinates as (i,i); the corresponding best estimate [formula] is at (η,i) for the elliptical case or (i,θ) for the hyperbolic.

Numerical comparisons

Figures [\ref=fig:generic] and [\ref=fig:generic_closeup] compare the sampling distribution predicted by [\eqref=eq:covariance] with a number of individual fits to randomly generated data. The original curve is an ellipse with semimajor axis 1.0 and semiminor axis 0.1, sampled at 20 points distributed along one quadrant, each sample point having a random error of standard deviation 0.001 in each direction. The fitting uses the self-normalising method (i.e. [formula]) with the simple curvature correction [\eqref=eq:conicCorrection]. The shaded confidence intervals are bordered by contours of

[formula]

where [formula] is the vector of coefficients corresponding to the exact curve. In the upper subfigure both the fits and the intervals are calculated using unweighted (i.e. equally weighted) data; in the lower subfigure, the fits are iterated with reweighting, and the intervals are calculated from the ideal weighting, using [\eqref=eq:optimalCovariance]. There are 50 individual sample sets, so we expect that at any given point around the ellipse, typically 2 or 3 will lie outside the 2σ confidence interval, and about 14 between 1σ and 2σ; the observed results are consistent with this expectation, for both unweighted and weighted fits. We see that both predicted and observed variability is reduced by about a factor of 2 by the reweighting; it should be stressed that this does not mean that any individual fit is guaranteed to be improved by reweighting (it is perfectly possible to find examples that are made significantly worse), only that the weighted fit is more precise on average. For these parameters, the unweighted fit changes from elliptical to hyperbolic somewhere between 2 and 3 standard deviations outside the exact result, while the weighted fit is still elliptical at 3σ.

Figure [\ref=fig:posterior] shows the best fit and confidence intervals estimated from a few individual samples using [\eqref=eq:covariance]. Again the results are consistent with expectations: for the majority of samples the true curve is within the 1σ confidence interval, and for the rest it is within the 2σ interval; most but not all individual fits are improved by iteration with reweighting.

For the parameters used for Figs [\ref=fig:generic]-[\ref=fig:posterior], the normalisation bias from a fixed normalisation leads to very obvious fitting errors, as illustrated in [\cite=collett2014ellipse]. The effects of the curvature bias and the bias from Sampson's reweighting are much smaller, but can be seen by increasing the number of sample points and the individual measurement error (still within the perturbative regime), as shown in Fig. [\ref=fig:bias].

Omitting the curvature bias correction results in fits falling outside the true curve near the tip (where the curvature is largest); reweighting using the gradient at the measured points instead of on the estimated curve results in fits that lie inside the true curve over a rather larger region. A geometric fit using a computationally expensive nonlinear least-squares method would produce results very similar to those obtained by omitting the curvature bias correction. The 'hyper-renormalised' method of [\cite=kanatani2015hyper] uses the Sampson weighting but modifies the normalisation matrix to correct for this: as Fig. [\ref=fig:bias] shows, this reduces the weighting bias but does not completely eliminate it.

Type-specific fitting

Parabolic constraint

To enforce a parabolic solution, we may use the likelihood as obtained previously in [\eqref=eq:optimalPosterior], but combine it with a prior probability that respects the type-specific constraint, giving the posterior probability with optimal weighting as

[formula]

where

[formula]

Clearly, the best estimate (both the most probable value and the posterior mean) is the value [formula] satisfying the constraint that is the shortest Mahalanobis distance from the unconstrained solution. That is, we seek the coefficient vector [formula] that minimises [formula] subject to the constraint that [formula], while also preserving the normalisation constraint that [formula]. As a first-order approximation to [formula], we have

[formula]

where [formula] is the unconstrained solution. This may be iteratively refined by alternately projecting [formula] onto the normal to the surface of constant [formula] (to ensure that the length is minimised) and reapplying [\eqref=eq:approxParabola] with the current best estimate of [formula] replacing [formula], repeating until [formula] is sufficiently close to zero.

Linearising the type-specific constraint around this best point estimate gives a residual Gaussian distribution of the form

[formula]

where

[formula]

the projectors

[formula]

ensure that only deviations respecting both the normalisation and parabolic constraints respectively are considered. The covariance matrix is proportional to the generalised inverse [formula] of the rank 4 matrix [formula], calculated in the fashion specified by [\eqref=eq:pseudoinverse]. We see that obtaining accurate confidence intervals is numerically more expensive for the parabolic fit than for the generic one.

Figure [\ref=fig:parabolic] again shows both predicted sampling distributions and a sample of individual fits to randomly generated data. The original curve is a parabola with focal length 0.01, sampled at 20 points distributed along one arm, each sample point having a random error of standard deviation 0.001 in each direction. Comparing the lefthand plots to the righthand ones, we see as previously a moderate reduction in fitting error from reweighting. A greater improvement is apparent when comparing the type-specific fits in the bottom subfigures with the corresponding generic ones in the top subfigures. In all cases there is adequate agreement between predicted and observed variability.

The 'hybrid' method (generic preliminary fit and type-specific final fit) used for the centre-right subfigure gives results that are indistinguishable from the fully type-specific method at the bottom right; that is, it does not matter whether the preliminary fit used for the weighting was type-specific or not. This is not surprising: even though the initial generic and parabolic fits are very different globally, they are close together in the region of the data points, so the resulting weights are similar; and only large changes in weighting have a detectable effect on the distribution of fitted curves.

Elliptical or hyperbolic constraint

The parabolic constraint is the equality [formula], giving a delta-function factor in [\eqref=eq:parabolicPosterior]. To enforce an elliptic or hyperbolic solution requires instead the satisfaction of the corresponding inequality, leading to

[formula]

where u is the Heaviside unit step, with the sign factor for its argument positive for the elliptic case and negative for the hyperbolic. The residual distribution is no longer locally Gaussian as [\eqref=eq:parabolicResidual] is, but is truncated along the direction normal to the surface [formula].

Thus the best estimate of [formula], given by the posterior mean, is not the most probable value, but lies on a conic pencil passing through the unconstrained solution and the nearest point on the surface (i.e. the best parabolic fit as calculated in the previous section). Perpendicular to the pencil the distribution is still locally Gaussian, but along it we must account for the truncation. Quantitatively, we have for a one-dimensional truncated Gaussian that

[formula]

The estimated posterior mean for the type-constrained conic is accordingly

[formula]

where [formula] is the unconstrained estimate, [formula] is the nearest parabola, and |x0| is the Mahalanobis distance between the two,

[formula]

There are two distinct cases. Usually, when the unconstrained solution is already of the correct type, we take the negative sign in [\eqref=eq:meanOffset], and the mean will be displaced a small distance along the pencil away from the boundary. The first-order approximation [\eqref=eq:approxParabola] for the boundary point is sufficiently accurate. But if the unconstrained solution is of the wrong type, as may sometimes occur if the noise is large or the true solution is very close to the boundary, we need the positive sign in [\eqref=eq:meanOffset], and the mean will be at a point on the pencil close to the boundary, on the far side from the unconstrained solution. In this case we may require iterative refinement of the boundary point estimate, as for the parabolic constraint itself. In neither case is the mean between the two points defining the pencil.

It would in principle be possible to calculate the covariance matrix of an elliptical or hyperbolic solution as we have done for the generic and parabolic cases. But in this case, because the distribution is not symmetric, it is both simpler and more informative to work directly with the full parameter set of the probability distribution, namely the generic solution [formula], the generic covariance matrix [formula], and the parabolic solution [formula]. The first two give the same Gaussian as the generic case, and the last the surface along which that Gaussian is truncated.

Figure [\ref=fig:elliptic] shows the results of ellipse-specific fits of the same samples as in Fig.[\ref=fig:generic]. In the unweighted case, the truncation of the sampling distribution at the parabolic solution is significant, and the resulting fits have a noticeably smaller spread than the generic ones in Fig.[\ref=fig:generic]. In the weighted case, for these parameters, the truncation occurs in the tail of the distribution, and the type-specific fits are accordingly little changed from the generic ones. This is appropriate behaviour for an unbiased type-specific method: if the generic fit is already clearly of the correct type, the type-specific requirement is redundant information and should not significantly alter the result. (For simplicity of presentation, the figure shows the distribution in [formula]-space truncated along the path of the parabola, but this is only an approximation to the actual truncation of the distribution in [formula]-space.)

Figure [\ref=fig:hyperbolic] shows what happens if the same elliptical data are erroneously forced to fit a parabola or hyperbola. As is to be expected, the parabolic solutions cluster closely around, and the hyperbolic ones closely outside of, the noise-free best-fit parabola.

Other parameterisations

So far the discussion of fitting errors has focused on the conic coefficients [formula]; the figures also use contours of the algebraic error Z, which is a linear function of [formula]. But there are other properties of the fitted curves that may be of interest, such as the location of the focal points, or the ratio of the axis lengths. The statistics of these may be estimated by standard error propagation techniques.

Consider a parameter ρ given by some function r of the components of [formula]. In the presence of noise, we obtain a estimated value

[formula]

where [formula] and [formula] are the gradient and Hessian of r. Since we have ensured that [formula] has zero mean, any bias in our estimate of ρ comes from the mean of the second-order term,

[formula]

while to leading order the variance of the estimate is

[formula]

For example, we may wish to find the centre of a fitted ellipse. In the absence of noise, the centre point is

[formula]

With noise, the bias in our estimate is

[formula]

and the covariance

[formula]

Figure [\ref=fig:centres] illustrates the results for the same data set as used in previous figures. Without correcting for the bias, the distribution of centres is not only offset from the true value, but is noticeably skewed. Correcting each value by the corresponding expected bias [\eqref=eq:centreBias] gives a distribution consistent with the spread predicted by [\eqref=eq:centreVariance].

Conclusions

The recommended algorithm for optionally type-specific conic fitting with error estimation may be summarised as follows:--

From the given data [formula], construct the design vectors [formula].

Preliminary generic fit.

From [formula], calculate the unweighted (wi = 1) scatter matrix [formula].

Construct the self-normalising constraint matrix [formula] and calculate the reduced scatter matrix [formula].

Solve the generalised eigenvalue problem [\eqref=eq:reducedEigen] to find λ0 and [formula].

Apply the curvature correction [\eqref=eq:conicCorrection] to [formula].

Reweighting. Using the elliptical coordinate system [\eqref=eq:ellipticalCoords] generated by [formula], for each data point [formula]:

find the nearest point [formula] on the curve [formula];

evaluate the gradient of [formula] at [formula]; and

calculate a new weight wi for [formula] from [\eqref=eq:optimalWeight].

Weighted generic fit, with error estimate.

Repeat step [\ref=algo:prelim], but use the weights {wi} calculated in step [\ref=algo:weight] and find all eigenvalues and corrected eigenvectors, not only [formula].

Construct the generalised inverse [formula] as given by [\eqref=eq:fullY]. The covariance matrix for the generic fit is [formula].

Type-specific fit.

Find the nearest parabolic solution [formula] using [\eqref=eq:approxParabola]. If the unconstrained result [formula] is already of the correct type, the first-order approximation will do; otherwise iterate [\eqref=eq:approxParabola] as required.

For an elliptic or hyperbolic fit, find the best point estimate of the conic parameters [formula] from [\eqref=eq:specificMean].

For the parabolic case, the covariance is [formula] where [formula] is given by the generalised inverse of [\eqref=eq:parabolicS]. For the elliptic or hyperbolic case, the probability distribution for [formula] is the same as for the generic fit (Gaussian with mean [formula], covariance [formula]), but truncated at the surface [formula].

The preliminary generic fit is the same as recommended in [\cite=collett2014ellipse], and for practical purposes equivalent to the 'semihyper-least-squares' method of [\cite=kanatani2011hyper].

This method contains exactly one reweighting. The effects of second or subsequent reweightings are much smaller, and are unlikely to justify the extra computation. Conversely, if no reweighting were performed, the generic covariance matrix would need to be calculated from [\eqref=eq:covariance] instead of [\eqref=eq:optimalCovariance]; the extra computational effort is similar to that required to calculate the weights, with less benefit. The reweighting is based on a generic fit, even if the final fit is type-specific; we saw in Section [\ref=sec:parabolic] that making the preliminary fit type-specific has no significant effect on the result.

It has been assumed throughout that the measurement noise is sufficiently small for the leading-order perturbative treatment to be valid. Specifically, σ must be smaller than the smallest radius of curvature of the curve being fitted. For example, the curvature correction [\eqref=eq:conicCorrection] is not accurate for larger noise.

Provided that this assumption is satisfied, the fitting method advocated in this paper produces an unbiased, minimal variance estimator of conic coefficients. It has the advantages over previously published methods of giving confidence intervals rather than just point estimates, and of allowing type-specific fitting while remaining unbiased. It may be possible to make some of the individual steps more efficient (for example, by finding a more elegant method of extracting the mean or the covariance for the type-specific parabolic fit), but not to improve significantly on the accuracy of the result in the small-noise regime.