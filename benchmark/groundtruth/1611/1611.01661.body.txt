Spanning Trees in Multipartite Geometric Graphs

Prosenjit Bose David Eppstein

Anil Maheshwari Pat Morin Michiel Smid

Keywords:

We present a simple algorithm that solves the minimum bichromatic spanning tree problem in O(n log 3n) time. This algorithm can easily be extended to solve the maximum bichromatic spanning tree problem within the same time bound. It also can easily be generalized to multicolored point sets.

We present Θ(n log n)-time algorithms that solve the minimum and the maximum bichromatic spanning tree problems.

We extend the bichromatic spanning tree algorithms and solve the multicolored version of these problems in O(n log n log k) time, where k is the number of different colors (or the size of the multipartition in a complete multipartite geometric graph).

Introduction

Let R and B be two disjoint sets of points in the plane, and suppose that the points of R are colored red and the points of B are colored blue. A bichromatic spanning tree on [formula] is a spanning tree in the complete bipartite geometric graph K(R,B) with bipartition (R,B). In other words, a bichromatic spanning tree is a spanning tree in which every edge has a red endpoint and a blue endpoint. The minimum bichromatic spanning tree (MinBST) problem is the problem of computing a spanning tree in K(R,B) whose total edge length is minimum. Similarly, the maximum bichromatic spanning tree (MaxBST) problem is the problem of computing a spanning tree in K(R,B) whose total edge length is maximum. A natural extension of the MinBST and MaxBST problems is to have more than two colors. In this multicolored version, the input points are colored by k colors, and we are looking for a minimum/maximum spanning tree in which the two endpoints of every edge have distinct colors. In other words, we look for a minimum/maximum spanning tree in a complete k-partite geometric graph. We call these problems Min-k-ST and Max-k-ST, respectively. See Figure [\ref=spanning-trees-fig].

The MinBST and MaxBST problems are natural extensions of the well-known Euclidean minimum and maximum spanning tree problems, which we refer to as the MinST and MaxST problem, respectively, and are defined as follows. Given a set P of n points in the plane, in the MinST (resp. MaxST) problem we seek a spanning tree of minimum (resp. maximum) edge length in the complete geometric graph K(P). It is well known that any MinST of K(P) is a subgraph of the Delaunay triangulation of P. Thus, one can compute, in O(n log n) time, a MinST by first computing the Delaunay triangulation and then running Kruskal's or Prim's algorithm on it. Monma and Paterson [\cite=Monma1990] showed that a MaxST of K(P) can also be computed in O(n log n) time. They also proved a matching lower bound for computing a MaxST in the algebraic computation-tree model.

For the MinBST and the MaxBST problems, let [formula]. Then K(R,B) has O(n2) edges. By running Prim's minimum spanning tree algorithm on K(R,B) one can solve the MinBST problem in O(n2) time. By combining Prim's algorithm with the currently best known dynamic data structure for the bichromatic closest pair problem (see Kaplan [\cite=Kaplan2016]) this problem can be solved in O(n log 7n) time. The MaxBST problem can be solved in O(n2) time by running Prim's algorithm on K(R,B) with negated edge lengths. Because of their geometric nature, we expect faster algorithms for these problems. In this paper, we will study the MinBST, MaxBST, Min-k-ST, and Max-k-ST problems.

Our contribution

The algorithms presented in this paper are base on Borvka's minimum spanning tree algorithm. In Section [\ref=bi-mst-section] we present a simple algorithm that solves the MinBST problem in O(n log 3n) time. We extend this algorithm to solve the MaxBST problem within the same time bound. Also, we extend this algorithm to solve the Min-k-ST and Max-k-ST problems in O(n log 3n log k) time. By making more use of geometry, in Section [\ref=n-1-section] we present an algorithm that solves the MinBST problem in O(n log n) time. In Section [\ref=maxbst-section] we show how to adopt the MinBST algorithm and solve the MaxBST problem also in O(n log n) time. In Section [\ref=k-color-section] we use the MinBST and MaxBST algorithms and solve the Min-k-ST and Max-k-ST problems in O(n log n log k) time.

Borvka's algorithm and binary numbering

In this section we present a simple algorithm that solves the MinBST and MaxBST problems in O(n log 3n) time, where n is the total number of input points. Moreover, we show that this algorithm can be extended to solve the Min-k-ST and Max-k-ST problems in O(n log 3n log k) time, where k is the number of colors. First, we present the algorithm for the MinBST problem, and then we will describe how to extend this algorithm to solve the other problems. Our algorithm is based on Borvka's minimum spanning tree algorithm. Recall that we are given two sets R and B of red and blue points in the plane, respectively, and we want to compute a minimum bichromatic spanning tree (MinBST) in K(R,B). Let [formula].

Borvka's algorithm maintains a forest (initially with each vertex in its own one-node tree) and at each stage of the algorithm adds a set of edges, where each edge is the shortest edge connecting a tree to a vertex outside of it. The number of trees goes down by a factor of two or more in each stage, so there are O( log n) stages. To use this algorithm for bichromatic point sets, we need to find for every tree T in the current stage, the shortest bichromatic edge that connects a point of T to an oppositely-colored point outside of T. We briefly describe how to find, for one stage of Borvka's algorithm, all these shortest bichromatic edges in O(n log 2n) time. This implies that Borvka's algorithm solve the MinBST problem in O(n log 3n) time.

To find all shortest bichromatic edges, in the current stage, it is sufficient to solve the following problem: given a partition of the points into subsets (the vertices of the current trees), find for each point p the nearest oppositely-colored point that is not in p's subset. We call this the all nearest unrelated points problem. We show how to solve the all nearest unrelated points problem in O(n log 2n) time. Number the subsets of the partition arbitrarily, as integers from 0 to one less than the number of subsets, and represent each of these numbers in binary as a sequence of O( log n) bits. Define a canonical set S(i,b,c) to be the subset of points that belong to a set whose label's ith bit is b (for b∈{0,1}) and whose color is c (for [formula]). Then for a point p, the set of points that are unrelated to p can be expressed as the union of logarithmically many canonical sets S(i,b,c), one for each possible value of i, where b is the complement of the ith bit of the label for p's subset, and c is the opposite color to p. Therefore, we can solve the all nearest unrelated points problem by computing a Voronoi diagram for each canonical set, and building a point location data structure for each Voronoi diagram. Then, for each point p we query the canonical sets whose union is the set of unrelated points to p, and combine the results of the queries to find p's nearest unrelated point. There are O( log n) Voronoi diagrams, each of which can be built in time O(n log n), after which we spend O( log 2n) time per point to query these diagrams. So the total time for computing all nearest unrelated points is O(n log 2n). (It is possible to build the Voronoi diagrams more quickly by computing a single Voronoi diagram of all of the points and using it to guide the construction of the Voronoi diagrams of the subsets--see [\cite=Chazelle2002] [\cite=Loffler2012]--but this would not speed up the overall algorithm because of the point location time.)

Since Borvka's algorithm takes logarithmically many stages, and each stage can be performed using a single computation of all nearest unrelated points, the total time to construct a bichromatic minimum spanning tree is O(n log 3n).

Extension to the MaxBST problem

The combination of Borvka's algorithm and the binary numbering method of the previous section can also be used to solve the MaxBST problem. For this problem, at each stage of Borvka's algorithm we add the longest edges connecting each tree to a vertex outside of it. Therefore, we compute the farthest-point Voronoi diagram for each canonical set, and locate each point p in these diagrams. Since the farthest-point Voronoi diagram of n points can be constructed in O(n log n) time, the above algorithm solves the MaxBST problem in O(n log 3n) time.

Extension to the Min-k-ST and Max-k-ST problems

In this section we extend the algorithm of the previous section to solve the Min-k-ST and Max-k-ST problems. We describe the algorithm for the Min-k-ST problem; the algorithm for the Max-k-ST problem is analogous.

Recall that in the Min-k-ST problem, the input points are colored by [formula] colors, and we want to compute a minimum spanning tree in which the two endpoints of every edge have distinct colors. To use Borvka's algorithm for this problem, we need to find for each point a nearest unrelated point, i.e., a nearest point of different color that is not in its own tree/component. Number the trees, and represent each of these numbers in binary as a sequence of O( log n) bits. Number the k colors by [formula], and represent each of these numbers in binary as a sequence of O( log k) bits. Define a canonical set S(i,b,j,b') to be the subset of points that (i) their color's jth bit is b', and (ii) belong to a tree whose label's ith bit is b; notice that b,b'∈{0,1}. Then, for a point p, the set of points that are unrelated to p can be expressed as the union of canonical sets S(i,b,j,b'), one for each possible pair (i,j), where b is the complement of the ith bit of the label for p's tree, and b' is the complement of the jth bit of p's color. To find a nearest unrelated point to p, we locate p in the Voronoi diagrams of the canonical sets whose union is the set of unrelated points to p. There are O( log n log k) canonical sets. It takes O(n log 2n log k) time to build the Voronoi diagrams for all these sets, and also to locate all the points in these diagrams. Thus, the total time to solve the Min-k-ST problem (and also the Max-k-ST problem) is O(n log 3n log k).

The minimum bichromatic spanning tree problem

Recall that we are given two sets R and B of red and blue points in the plane, respectively, and we want to compute a minimum spanning tree in in K(R,B). In this section, we present an algorithm that computes a MinBST in K(R,B) in O(n log n) time, where [formula]. In fact, we show how to find, for all stages of Borvka's algorithm, all shortest bichromatic edges in O(n log n) time. Our algorithm is optimal because finding the bichromatic closest pair has an Ω(n log n) lower bound (see [\cite=Avis1980]). Our algorithm is summarized below.

In any minimum bichromatic spanning tree, every point is connected to a closest point of opposite color.

The correctness of algorithm MinBST follows from Observation [\ref=closest-point-obs] and from the correctness of Borvka's algorithm. Before analyzing the running time of this algorithm we introduce some notation. For a point set Q in the plane, let [formula] denote the Delaunay triangulation of Q, and V(Q) denote the Voronoi diagram of Q. Let ν(q,Q) denote the Voronoi region/cell of a point q∈Q in V(Q). For two disjoint point sets Q1 and Q2, where each of the points in [formula] is colored either red or blue, we define the bichromatic closest pair [formula] as a closest red-blue pair between Q1 and Q2.

Step 1 in algorithm MinBST takes O(n log n) time; a straightforward solution is to locate all points of R in V(B) and all points of B in V(R). In the rest of this section we show how to run Borvka's algorithm (step 2) in O(n log n) time. Notice that, in algorithm MinBST, one can combine steps 1 and 2 and just run Borvka's algorithm on the input point set. However, having step 1 separately, will simplify the running time analysis.

Recall that Borvka's algorithm maintains a forest (a set of trees which we call components) and at each stage adds the shortest edges connecting each component to a vertex outside of it. Thus, in each stage the number of components goes down by a factor of two or more. The output of the last stage is a single component which is a minimum spanning tree. Therefore, there are O( log n) stages in total. Consider one stage of Borvka's algorithm. Let [formula] be the input components to that stage. Let [formula], and for each [formula], let Pi denote the set of points in Ci. Note that, after step 1, we have [formula]. Moreover, each point is in the same component as its closest point of opposite color. We have to find for each component Ci, the shortest edge connecting a point in Ci to an oppositely-colored point outside of Ci. In fact, we have to solve the following problem which we call "all bichromatic closest pairs":

Let Ri and Bi denote the set of red and blue points of Pi, respectively. Then, [formula] can be computed by taking the shorter of [formula] and [formula]. The following algorithm finds [formula] for all [formula]. By swapping the role of red and blue points, one can compute [formula] for all i.

We prove the correctness of algorithm All-Blue-BCP by a non-trivial extension of the proof of Theorem 3.1 in [\cite=AAggarwal1992] to our bichromatic setting. The set Ti, that is computed in line 3 in algorithm All-Blue-BCP, contains the points of [formula] that are adjacent to some point of Ri in [formula]; see Figure [\ref=Voronoi-cell-fig](a). To simplify the notation, we write [formula] for [formula]. In line 5, the algorithm computes [formula] as the endpoints of a shortest red-blue edge in [formula]. Thus, we have to prove that [formula]. Take any [formula]. Let [formula] where b∈Bi and [formula]. To prove the correctness of this algorithm, we just need to show that p is in Ti. In order to show this, we prove that for some point q∈Ri, pq is an edge of [formula]; this guarantees that algorithm All-Blue-BCP adds p to Ti in line 3.

Consider the Voronoi diagram [formula]. Because p is a point of [formula] that is closest to b, b lies in the Voronoi cell [formula]. Since [formula] is convex, the line segment bp is inside this cell; see Figure [\ref=Voronoi-cell-fig](b). Thus, no edge of [formula] crosses bp. Recall that b's closest red point in R, say r, is in the same component as b. Thus, r∈Ri and also r  ≠  p. Now, imagine the construction of V(R) by inserting the points of Ri to [formula]. Since r is the closest red point to b, b lies in ν(r,R). Because of this, and since ν(r,R) and ν(p,R) are two different cells in V(R), there are some edges of V(R) that cross bp; see Figure [\ref=Voronoi-cell-fig](b). Among those edges, consider the edge e whose intersection with bp is closest to p. Let q∈R be the point such that e is a common edge between ν(q,R) and ν(p,R); notice that q  ≠  p. By inserting the points of Ri to [formula], the Voronoi cells of [formula] do not get larger. This implies that the point q— which has e on its boundary in ν(q,R)— belongs to Ri. Therefore, in [formula], there is an edge between p and q; that edge corresponds to e in V(R). Notice however that q is not necessarily r itself. Moreover, if b is on the boundary of ν(p,R), then e passes through p, and q = r. This finishes the proof for the correctness of algorithm All-Blue-BCP.

For any k, with [formula], and any partition [formula] of R, the total size of the sets [formula], that are computed in line 3 of algorithm All-Blue-BCP, is O(|R|). Moreover, having [formula], the sets [formula] can be computed in O(|R|) time.

For each p∈R and each [formula] we define

[formula]

The number of sets Ti that a red point p belongs to is at most p's degree deg (p) in [formula]. Thus,

[formula]

where the last inequality is valid because [formula] is a planar graph and has at most 3|R| - 6 edges. Therefore, the total size of the sets [formula] is O(|R|). Moreover, these sets can be computed in O(|R|) time as follows. Take any edge pq of [formula]. If p and q belong to a same set Ri, then do nothing. If p and q belong to two different sets of the partition, say p∈Ri and q∈Rj, then add p to Tj and add q to Ti.

Now we analyze the running time of algorithm All-Blue-BCP. It takes O(|R| log |R|) time to compute [formula]. Since the total size of the sets [formula] is |B|, and, by Lemma [\ref=size-T-lemma], the total size of the sets [formula] is O(|R|), we can compute [formula] for all [formula] in O(n log n) time; recall that [formula]. Thus the total running time of algorithm All-Blue-BCP is O(n log n), and hence, the running time of algorithm MinBST is O(n log 2n). In the rest of this section, we show how to improve the running time of MinBST to O(n log n).

Kirkpatrick [\cite=Kirkpatrick1979] shows how to merge two Delaunay triangulations in linear time; that is, given [formula] and [formula], how to find [formula] in time O(|P| + |Q|). Löffler and Mulzer [\cite=Loffler2012] show that the reverse operation can also be done in linear time. That is, one can split [formula] to obtain [formula] and [formula] in time O(|P| + |Q|). We use these two results, and show how to run algorithm All-Blue-BCP during all stages of Borvka's algorithm in total O(n log n) time. In order to show this, we use the following fact: if we have [formula], [formula] and [formula] for all [formula], then one execution of algorithm All-Blue-BCP (during one stage of Borvka's algorithm) takes O(n) time; this is because the total size of the sets [formula] is |B|, and by Lemma [\ref=size-T-lemma] the sets [formula] can be computed in O(|R|) time and their total size is O(|R|), and thus, by the result of [\cite=Kirkpatrick1979] we can compute [formula] for all [formula] and also all bichromatic closest pairs in O(|R| + |B|) time.

We compute [formula] at the beginning of algorithm MinBST. As discussed earlier we can compute [formula] and [formula] for all input components of the first stage of Borvka's algorithm in O(n log n) time. Based on the discussion above, we are going to show how to retrieve all [formula] and [formula] for input components of the next stage of Borvka's algorithm from all [formula] and [formula] of input components of the current stage of Borvka's algorithm. Although for simplicity we use index i to refer to the components of both the current and the next stages, notice that the number of components and their sizes vary from one stage to another.

Consider one stage of Borvka's algorithm, and let k be the number of input components to this stage, where [formula]. Without loss of generality let [formula], with [formula], denote a subset of the input components that should be connected together and be passed to the next stage as a single component. Let C* denote the resulting component. Let R* and B* denote the sets of red and blue points of C*, respectively. Let T* be the point set that will be computed (with respect to R*) in line 3 of All-Blue-BCP in the next stage. Notice that B* is the union of the sets [formula], and R* is the union of the sets [formula]. Recall that T* contains the points of [formula] that have a Delaunay neighbor in R*. Thus, T* is the union of the sets [formula] minus the set R*.

In order to compute [formula] for the next stage, we iteratively merge the Delaunay triangulations of the two smallest sets among [formula]. A monotone priority queue (see [\cite=Cherkassky1999]) can be used to find the two smallest sets iteratively; the total time for the queue operations is proportional to the sum of the number of sets and the size of the largest set. We compute [formula] during the same merge process that we compute [formula], i.e., whenever we merge [formula] and [formula], we also merge [formula] and [formula]. Let [formula] and [formula]. Let Tij be the set that will be computed in line 3 of All-Blue-BCP with respect to Rij. By the result of [\cite=Kirkpatrick1979] we can compute [formula] in O(|Bi| + |Bj|) time by merging [formula] and [formula]. We describe in more detail how to compute Tij and also [formula]. Let [formula]. We compute [formula] as follows: take any point p∈Ri, if, in [formula], p is adjacent to a point q in Rj, then add both p and q to [formula]. Then, [formula]. By the result of [\cite=Kirkpatrick1979] we can compute [formula] in O(|Ti| + |Tj|) time by merging [formula] and [formula]. Then, by the result of [\cite=Loffler2012] we can compute [formula] (and also [formula]) in [formula] time by splitting [formula].

We analyze the total running time of step 2 of algorithm MinBST as follows. Let [formula] be the sets of blue points of components obtained in step 1 of algorithm MinBST. Imagine a binary tree T that is obtained as follows. T has k leaves that are labeled [formula]. Recall that in algorithm All-Blue-BCP, we merge the Delaunay triangulations in a binary manner. Each time we merge two Delaunay triangulations [formula] and [formula], we create a node with label [formula] in T and connect the nodes Bi and Bj as its children. The label of the root of T is B.

The height of T is O( log n).

Take any leaf Bi of T. Let P be the path from [formula] to

Bi. Partition the edges of P into {P1,P2}, where P1 is the set of edges connecting a node in one stage of Borvka's algorithm to a node in the next stage, and P2 is the set of edges connecting two nodes within one stage of Borvka's algorithm. See the figure to the right; the fat edges belong to P2, while the other edges belong to P1. Since the number of stages in Borvka's algorithm is log n, the number of edges in P1 is log n. Imagine walking up P, starting from Bi and ending at [formula]. Each time we go up P and pass two consecutive edges of P2, the size of the label of that node gets doubled. To see why this is true, consider two consecutive merges of a node a with nodes b and c, respectively; see the figure to the right. Here, we use the label of a node to refer to the size of that node as well. Recall that within each stage we iteratively merge the two smallest components, thus, the reason that a was merged with b before c is that none of a and b are bigger than c, that is [formula] and [formula]. Thus, the size of the grandparent of a, which is a + b + c, is at least 2a. Since the label of [formula] has size at most n, the doubling process won't repeat more than log n times. Thus, the number of edges in P2 is at most 2 log n +  log n (the extra log n is for the cases when the parity of the number of edges within some stages are odd). Therefore P has at most 4 log n edges. This implies that the height of T is O( log n).

By Lemma [\ref=height-lemma], T has O( log n) levels. The labels of the nodes of each level is a partition of a subset of B. Accordingly, we have a partition of a subset of R with respect to those nodes. Thus, the total number of blue points (resp. red points) in each level is at most |B| (resp. at most |R|). Therefore, the time we spend per level of T to compute all [formula] from the Delaunay triangulations of their children is O(|B|). Lemma [\ref=size-T-lemma] can easily be generalized to any partition of any subset of R. Based on this, the total size of sets Ti in each level of T is O(|R|). Therefore, the time we spend per level to compute all [formula] from the Delaunay triangulations of their children is O(|R|). It turns out that for each level of T we spend O(n) time. Therefore, the total running time of algorithm MinBST is O(n log n).

Given two disjoint sets R and B of points in the plane, a Euclidean minimum spanning tree in K(R,B) can be computed in Θ(n log n) time, where [formula].

The maximum bichromatic spanning tree problem

In this section we consider the MaxBST problem. Given R and B, we present an algorithm that computes a MaxBST, in K(R,B), in O(n log n) time, where [formula]. Our algorithm is optimal because fining the bichromatic farthest pair has an Ω(n log n) lower bound (see [\cite=Preparata1985]). Our MaxBST algorithm is the same as the MinBST algorithm that was presented in Section [\ref=n-1-section], except, in step 1 we connect each point to a farthest point of opposite color, and in step 2, at each stage of Borvka's algorithm, we add the longest red-blue edges connecting each component to a vertex outside of it. The correctness of this algorithm follows from the correctness of Borvka's algorithm and the fact that in any maximum bichromatic spanning tree, every point is connected to a farthest point of opposite color. We skip the parts of MaxBST that are similar to MinBST, but describe its core parts that lead to the same running time.

Before analyzing the running time we introduce some notation, and present a lemma that plays an important role in the analysis. For a point set Q in the plane let [formula] denote the list of the vertices of the convex hull of Q, ordered along the boundary, and let F(Q) denote the farthest point Voronoi diagram of Q. Let φ(q,Q) denote the farthest point Voronoi region/cell of a point q∈Q in F(Q); notice that q has a non-empty Voronoi cell in F(Q) if and only if q is in [formula]. For two disjoint point sets Q1 and Q2, where each of the points in [formula] is colored either red or blue, we define the bichromatic farthest pair [formula] as a farthest red-blue pair between Q1 and Q2.

Let R and B be two disjoint sets of points in the plane, and let T be a maximum spanning tree of K(R,B). Then for every edge (r,b)∈T with r∈R and b∈B, r is in the convex hull of R or b is in the convex hull of B.

The proof is by contradiction; take an edge (r,b)∈T with r∈R and b∈B, where [formula] and [formula]. Without loss of generality assume (r,b) is horizontal, and r is to the left of b.

Consider two vertical lines lr and lb that pass through r and b, respectively. Since [formula], there is a point r' that belong to R and is to the left of lr. Similarly, there is a point b' that belong to B and is to the right of lb. Observe that |rb| is smaller than each of |rb'|, |r'b|, and |r'b'|. Let Tr and Tb be the two trees obtained from T by removing (r,b). We consider two cases: (i) r' and b' are in different trees, or (ii) r' and b' are in a same tree. In case (i) we obtain a tree T' by joining Tr and Tb with (r',b'). In case (ii) without loss of generality assume that r' and b' are in Tr. Then, we obtain a tree T' by joining Tr and Tb with (r',b). In both cases, T' is a spanning tree of K(R,B) that is longer than T; this contradicts the optimality of T.

Let R and B be two sets of points in the plane. Then, the longest edge between R and B has an endpoint in [formula] and an endpoint in [formula].

Step 1 in algorithm MaxBST takes O(n log n) time; a straightforward solution is to locate all points of R in F(B) and all points of B in F(R). In the rest of this section we show how to run Borvka's algorithm (step 2) in O(n log n) time. Let [formula] be the components of the current stage of Borvka's algorithm. We have to find for each component Ci, the longest edge connecting a point in Ci to an oppositely-colored point outside of Ci. In fact, we have to solve the following problem:

The following algorithm finds [formula] for all [formula]. By swapping the role of red and blue points, one can compute [formula] for all i. For the purpose of this algorithm, by Lemma [\ref=MaxBST-lemma], we assume that R is in convex position; this can be done by setting R to be [formula]. This assumption does not violate the fact that each blue point is in the same component as its farthest red point, because the farthest red point to any blue point is in [formula]. By Observation [\ref=bfp-obs], the longest edge between Bi and [formula] has an endpoint in [formula]. Thus, to compute [formula], we maintain [formula] and compute [formula] instead.

First, we prove the correctness of algorithm All-Blue-BFP. To simplify the notation, we write [formula] for [formula]. Since R is in convex position, every point of R has a non-empty Voronoi cell in F(R). The set Ti, that is computed in line 3, contains the points of [formula] whose cell in F(R) is adjacent to the cell of a point in Ri. Then, in line 5, the algorithm computes [formula] as the endpoints of the longest red-blue edge between [formula] and [formula], i.e., [formula]. Notice that Ti is in convex position. Take any [formula]. Let [formula] where b∈Bi and [formula]. To prove the correctness of this algorithm, we only need to show that p is in Ti. In order to show this, we prove that φ(p,R) is adjacent to φ(q,R) for some point q∈Ri; this guarantees that algorithm All-Blue-BFP adds p to Ti in line 3.

Consider the farthest point Voronoi diagram [formula]. Because p is a point of [formula] that is farthest to b, b lies in [formula], which is a convex region. See Figure [\ref=fvc-fig]. Imagine the construction of F(R) by inserting the points of Ri to [formula]. By inserting these points, the Voronoi cells of [formula] do not get larger. Thus, φ(p,R) is a subset of [formula], and since R is in convex position, φ(p,R) is not empty. Recall that b's farthest red point in R, say r, is in Ri, and hence b lies in φ(r,R). Take a point p' in φ(p,R). Because of the convexity of [formula], bp' is inside this cell, and thus, no edge of [formula] crosses bp'. In F(R), b and p' belong to two different cells. This implies that some edges of F(R) cross bp'. Among those edges, consider the edge e whose intersection with bp' is closest to p'. Let q∈R be the point such that e is the common edge between φ(q,R) and φ(p,R). Since by inserting the points of Ri into [formula], the cells of the points of [formula] get smaller, the point q— which has e on its boundary in φ(q,R)— belongs to Ri. This finishes the proof for the correctness of All-Blue-BFP.

By a similar reasoning as in the proof of Lemma [\ref=size-T-lemma] we show that the total size of the sets [formula] is O(|R|). The number of sets Ti, that a red point p belongs to is at most p's degree in F(R), that is, the number of its Voronoi neighbors. The sum of the degrees, over all points of R is at most 4|R| - 6 because F(R) has at most 2|R| - 3 edges (or pairs of neighbors). Therefore, the total size of the sets [formula] is O(|R|). Moreover, having F(R), these sets can be computed in O(|R|) time by checking all edges of F(R).

The running time analysis of algorithm All-Blue-BFP is similar to the one for algorithm All-Blue-BCP that we have seen in Section [\ref=n-1-section]. Instead of maintaining Delaunay triangulations, here we maintain convex hulls and farthest point Voronoi diagrams. First, we review some known results. Let P and Q denote two convex polygons in the plane. Aggarwal  et al. [\cite=AAggarwal1989] showed how to compute the farthest point Voronoi diagram of P in O(|P|) time. Edelsbrunner [\cite=Edelsbrunner1985] showed that the two vertices that define the maximum distance between P and Q can be computed in O(|P| + |Q|) time; he also proved the lower bound of Ω(|P| + |Q|) for this problem. Assume the vertices of [formula] are in convex position. Then, having [formula] and [formula], one can merge them to compute [formula] in O(|P| + |Q|) time. The reverse operation can also be done in linear time. That is, one can split [formula] to obtain [formula] and [formula] in time O(|P| + |Q|).

Now we analyze the running time of algorithm All-Blue-BFP. It takes O(|R| log |R|) time to construct F(R). In the first stage of Borvka's algorithm we compute [formula] and [formula] for all [formula]. This takes O(n log n) time because the total size of the sets [formula] is |B|, and the total size of the sets [formula] is O(|R|). Having F(R), [formula] and [formula] for all [formula], we maintain [formula]'s and [formula]'s for the next stage of Borvka's algorithm, using similar merge and split operations as in the MinBST algorithm. This maintenance takes O(n) time per level of the imaginary tree T which has height O( log n). Therefore, in total, the algorithm All-Blue-BFP takes O(n log n) time for all stages of Borvka's algorithm.

Given two disjoint sets R and B of points in the plane, a Euclidean maximum spanning tree in K(R,B) can be computed in Θ(n log n) time, where [formula].

The Min-k-ST and Max-k-ST problems

In a multicolored version of the Euclidean minimum spanning tree problem, the input points are colored by at least two colors, and we want the colors of the two endpoints of every edge in the tree to be distinct. Formally, we are given a set P of n points in the plane that is partitioned into [formula], with [formula]. For each [formula], assume the points of Pc are colored c. In the bichromatic setting, k is 2. Also, the standard Euclidean minimum spanning tree problem can be interpreted as an instance of this multicolored version in which k = n, i.e., each point has a unique color. Let [formula] be the complete multipartite geometric graph on P, which has edges between every point of each set in the partition to all points of the other sets. The Min-k-ST problem is the problem of computing a minimum spanning tree in [formula]. We refer to its maximum counterpart as Max-k-ST. In this section we show how to solve these problems in O(n log n log k) time. We show this for the Min-k-ST problem; the solution for the Max-k-ST problem is analogous.

The algorithm is as follows. Represent each of the colors [formula] in binary as a sequence of log k bits. For each [formula], define two canonical point sets: a point set Si that contains the points whose color's ith bit is 1, and a point set [formula] that contains the points whose color's ith bit is 0. Note that [formula] is a partition of P. In order to compute a Min-k-ST in [formula], we do the following. First we compute MinBST([formula]) for all [formula]. This gives log k spanning trees, each of which has n - 1 edges (these edges are bichromatic in terms of Si and [formula]). Construct a graph G by taking the union of these spanning trees; G has (n - 1) log k edges. Then, compute a minimum spanning tree of G by Prim's algorithm, and output it as a solution.

The running time analysis of this algorithm is straightforward. Since the construction of MinBST([formula]) takes O(n log n) time for each i, the total time to compute all MinBSTs is [formula]. The running time of Prim's algorithm on G is O(n log n + n log k). Thus, the total running time of the algorithm is O(n log n log k). To prove the correctness of the algorithm, it suffices to show that G contains an optimal Min-k-ST of [formula]. We show this in the following lemma.

There exists an optimal Min-k-ST of [formula] that is a subgraph of G.

The proof is constructive.

Take an optimal Min-k-ST of [formula], say T*. Let E* be the set of edges of T* that are not in G. If E* is empty, then T* is a subgraph of G and we are done. Otherwise, we iteratively replace the edges of T*, that are in E*, by some edges of G, without increasing the weight of T*. Take any edge e* = (p,q) in E*. Assume p is colored i and q is colored j. Since i  ≠  j, the binary representations of i and j differ in at least one bit. Let d be such a bit position. Without loss of generality assume that i's dth bit is 1 and j's dth bit is 0. This implies that p∈Sd and [formula]. Let Td be the tree that is obtained by MinBST([formula]); note that Td is a spanning subgraph of G. Since e*∉G, e*∉Td. Consider the path δ between p and q in Td. Since Td is an optimal bichromatic tree between Sd and [formula], none of the edges of δ is longer than e*. Let T*p and T*q be the two trees obtained from T* by removing e*. There is an edge e in δ such that e∉T* and e connects a point p'∈T*p to a point q'∈T*q. Let T be the tree that is obtained by joining T*p and T*q with e. The tree T is a valid spanning tree of [formula] whose weight is equal or smaller than the weight of T*. Therefore, T is also an optimal Min-k-ST and the number of edges of T that do not belong to G is |E*| - 1. Set T* = T, and repeat this process until [formula].

Given a set P of n points in the plane where P is partitioned into [formula] sets [formula], a Euclidean minimum (respectively maximum) spanning tree in [formula] can be computed in O(n log n log k) time.

Open Problem

We presented O(n log n log k)-time algorithms for the Min-k-ST and Max-k-ST problems. Presenting faster algorithms for these problems or providing a matching lower bound is open. Notice that for k∈{2,n}, these problems can be solved in O(n log n) time.