Additive Collatz Trajectories

Introduction

The Collatz Conjecture

The 3x  +  1 problem is most simply stated in terms of the Collatz function C(x) defined on integers as:

[formula]

The Collatz Conjecture states that every for every [formula], there exists [formula] such that iterate T(k)(m)  =  1. [\cite=lagarias]. One natural generalization of Collatz function would be to consider an arbitrary affine linear map of x instead of 3x  +  1.

Generalization

We introduce the concept of a generalized Collatz function Ca,d,m'(x) as:

[formula]

where [formula]. For an arbitrary choice of (x,a,d,m) and for sufficient large values of [formula], we would like to explore the nature of Ca,d,m'(k)(x) [\cite=generalized]. In this paper, we look at a particular case of the generalized Collatz function, which we term as the Additive Collatz function. An additive Collatz function Ta,d(x) is defined as Ca,d,1'(x).

Terminology

We use the following definitions:

An additive Collatz trajectory Oa,d of an integer x is the infinite tuple

[formula]

A trajectory O  =  (o0,o1,o2...) is said to loop if [formula] such that [formula], on  =  on + k.

Given [formula], two natural numbers x1 and x2 are said to be equivalent under the orbit equivalence relation if [formula] such that [formula]:

[formula]

Given [formula], an orbit is an element of partition of [formula] under the orbit equivalence relation.

Analysis of Additive Collatz Trajectories

The limiting behavior of an additive Collatz trajectory is identified based on the eventual formation of loops. It is a straightforward observation that if a and d are not co-prime, then the trajectory does not necessarily loop.

For non-coprime [formula], there exists [formula] such that Oa,d(x) does not loop.

Consider [formula]. Then, Oa,d(r) does not loop. This can be proved by induction on natural numbers.

Claim: [formula]

Base Case: Trivially true for k  =  0

Induction Hypothesis: [formula]

Induction Step: Let δ  =   gcd (a,d).

[formula]

[formula]

Hence, the trajectory is an increasing progression, and does not loop.

It can be observed that if r is not a multiple of gcd (a,d), then Oa,d(r) does not loop. We would now like to analyze the converse of this statement.

Given [formula], if [formula],

[formula]

where δ  =   gcd (a,d)

If r is a multiple of gcd (a,d), then Lemma 1 permits us to reduce our analysis to a case where a and d are co-prime. We now only consider the cases where a and d are co-prime and prove that for all natural numbers x, the additive Collatz trajectory Oa,d(x) loops. This analysis is divided into three propositions.

For co-prime [formula] given [formula], there exists [formula] such that TN(x)a,d(x)  ≤  a

Consider (ni) as a sub-trajectory of Oa,d(x) such that

[formula]

[formula]

where T(zi  -  1)a,d(x)  =  dT(zi)a,d(x). As a and d are co-prime, Bézout's Lemma forces the existence of such a sub-trajectory. Let yi  =  zi + 1  -  zi  -  1. Then,

[formula]

On solving the recursion,

[formula]

By definition, yi is the least non-negative integer such that ni  +  ayi is divisible by d, and hence yi is strictly less than d. Hence,

[formula]

Which simplifies to

[formula]

For sufficiently large k, dk + 1  >  n0  -  a. Hence, there is an element in the trajectory which is less than or equal to a.

For co-prime [formula], Oa,d(x) loops for all x  ≤  a.

Equation (1) and the fact that yi  ≤  (d - 1) implies that if ni  ≤  a, then [formula] . Thus if x  =  n0  ≤  a then [formula] nj  ≤  a. As there are only finitely many natural numbers less than or equal to a, trajectory loops.

Given [formula], Oa,d(r) loops for all [formula].

By Lemma 1, Oa,d(r) loops if and only if [formula] loops where δ  =   gcd (a,d).

Let a'  =  a / δ, d'  =  d / δ and r'  =  r / δ. By Proposition 2, there exists N(r') such that T(N(r'))a,d(r')  ≤  a. Let T(N(r'))a,d(r')  =  k. As the each term of the trajectory depends only on the previous term, Oa',d'(r') is equal to Oa',d'(k). By Proposition 3, Oa',d'(k) loops, hence Oa',d'(r') loops. This implies that Oa,d(r) loops.

A straightforward implication of Proposition 4 is that if a and d are co-prime, then [formula], Oa,d(x) loops.

Orbit Counting

For co-prime a and d, we have shown that Oa,d(x) loops. We would now like to characterize the number of unique loops possible. For this, the concept of orbit equivalence relation is proposed. Two natural numbers are said to be equivalent, if their trajectories are the same, eventually. Formally speaking, given [formula], two natural numbers x1 and x2 are said to be equivalent under the orbit equivalence relation if [formula] such that [formula]:

[formula]

Under the orbit equivalence relation, the set of natural numbers can be partitioned into equivalence classes. The number of equivalence classes is the same as the number of unique loops of trajectories possible.

Proposition 3 and Proposition 4 imply that the number of unique loops formed by Oa,d(x) where [formula] is the same as the number of unique loops formed by Oa,d(x) where [formula]. In order to count the equivalence classes, we identify them with orbits of a group action and use Pólya's Enumeration Theorem to count them.

Group Action

Consider the sub-trajectory (ni) as defined in the proof of Proposition 2. We observe that given a trajectory Oa,d(x), one can construct the sub-trajectory (ni) and vice-versa. Hence, the number loops of the sub-trajectories have a one-to-one correspondence with the loops of the trajectories.

By definition of the sub-trajectory (ni)

[formula]

For some k, all elements of the sub-trajectory are eventually smaller than a. This allows us to identify the limiting behavior of the sub-trajectory with

[formula]

where nk  ≤  a. Each element of the sub-trajectory is a power of d- 1 multiplied by nk and hence, the sub-trajectory can be identified with the action of the group of negative powers of d on nk under multiplication modulo a.

Under the binary operation of multiplication modulo a natural number a, the numbers co-prime to a (modulo a) form an Abelian group denoted by [formula]. For some d in [formula], let H be the subgroup generated by d.

[formula]

Then, the number of orbits formed by quotienting natural numbers by the nature of limiting behavior of the additive Collatz trajectory Oa,d(x) is given by the number of orbits under the action of H on [formula] under the binary operation multiplication modulo a.

Computation

Let ξ(a,d) denote the number of orbits of [formula] when H acts on it. By Pólya's Enumeration Theorem, we have:

[formula]

where [formula]. |Hx| can be computed by finding the number of solutions for dt∈H in the equation:

[formula]

Let mx  =   gcd (x,a), [formula] and [formula]. On substitution in equation (2), we have:

[formula]

As gcd (px,qx)  =  1, the number of solutions to equation (3) is same as the number of solutions to :

[formula]

Let the smallest solution to equation be termed as αpx(d). Therefore the total number of solutions to equation (2) are: [formula]

Hence, we have:

[formula]

For each px, qx takes values co prime to px, hence, by counting repetitions, we get:

[formula]

where φ is the Euler-totient function.

Upper and Lower Bounds

We can set a lower bound on ξ(a,d) by considering the Carmichael function λ.

[formula]

Hence,

[formula]

One can further claim that ξinf(a) is a strong lower bound for ξ(a,d) as for every a, there exists d such that for all factors f of a, αf(d)  =  λ(f). The proof of this claim relies on the decomposition of [formula] into cyclic groups.

The strong upper bound for ξ(a,d) is a, which is attained when d is 1.

Applications

The computation of ξ(a,d) employs factorization as well as the discrete logarithm function (in computation of αf(d)). There are no known efficient algorithms to compute either of them, making computation of ξ(a,d) difficult. This difficulty can be employed for public-key cryptography. Knowing the prime factorization of a, can make the computation of ξ(a,d) easier. Consider two primes p and q. Then, for some d co-prime to pq,

[formula]

On simplification, we have:

[formula]

Computing ξ(pq,d) would be cumbersome without using equation (9), however, it is much simpler using the prime factorization. This provides much hope for the possibility of design of a public key cryptography algorithm or key exchange system using additive Collatz trajectories.

Results

This paper puts forward the concept of Additive Collatz Trajectories and provides an analysis of their limiting behavior. A necessary and sufficient condition is provided for eventual looping of the Additive Collatz trajectories, along with a formula to compute the number of unique trajectories possible up to the orbit equivalence relation.

Further Scope

Generalized Collatz Trajectories

The spirit and strategy of this paper can be used to deal with generalized Collatz trajectories. One immediate result is that if the equation:

[formula]

does not have a solution for any r, then for all [formula], the trajectory formed by iteration of Ca,d,m'(x) would not loop. Also, if [formula], then the equation will always have a solution. We can then define a sub-trajectory similar to that done in Proposition 2 as:

[formula]

[formula]

where Ca,d,m'(zi  -  1)(x)  =  dCa,d,m'(zi)(x). We will be able to show that:

If [formula]

[formula]

where [formula] and 0  <  ri  ≤  (d - 1)

else,

[formula]

Public-key Cryptography

As mentioned in subsection 3.4, there is a hope for developing a public-key cryptography system that relies on Additive Collatz Trajectories, particularly on counting the number of equivalence classes formed under the orbit equivalence relation. Much effort and study is required to design an implementable cryptography design, as there are a number of challenges. Firstly, there is no trivial characteristic that is common among the elements of an orbit equivalence class. Secondly, the formula for counting the number of orbit equivalence classes employs a number of functions, hence there is no natural way to compute the inverse for decryption. Lastly, the formula uses the discrete logarithm function which cannot practically be computed for larger cases. One must deal with these challenges in the process of an encryption algorithm design using the results proved in this paper.