Proof. [formula]

Optimizing the Number of Gates in Quantum Search

Ronald de Wolf

Introduction

One of the main successes of quantum algorithms so far is Grover's quantum algorithm for database search [\cite=grover:search] [\cite=bhmt:countingj]. Here a database of size N is modeled as a binary string x∈{0,1}N, whose bits are indexed by [formula]. A solution is an index i such that xi = 1. The goal of the search problem is to find such a solution. If our database has Hamming weight |x| = 1, we say it has a unique solution.

The standard version of Grover's algorithm finds a solution with high probability using [formula] database queries and [formula] other elementary gates. It starts from a uniform superposition over all database-indices i, and then applies [formula] identical "iterations," each of which uses one query and O( log N) other elementary gates. Together these iterations concentrate most of the amplitude on the solution(s). A measurement of the final state then yields a solution with high probability. For the special case of a database with a unique solution its number of iterations (=   number of queries) is essentially [formula], and Zalka [\cite=zalka:grover] showed that this number of queries is optimal. Grover's algorithm, in various forms and generalizations, has been applied as a subroutine in many other quantum algorithms, and is often the main source of speed-up for those. See for example [\cite=bht:collision] [\cite=BuhrmanCleveWigderson98] [\cite=betal:distinctnessj] [\cite=durr&hoyer:minimum] [\cite=dhhm:graphproblems] [\cite=dorn:thesis].

In [\cite=grover:tradeoffs], Grover gave an alternative algorithm to find a unique solution using slightly more (but still [formula]) queries, and only [formula] other elementary gates. The algorithm is more complicated than standard Grover, and no longer consists of [formula] identical iterations. Still, it acts on O( log N) qubits, so on average a unitary sitting between two queries acts on only a tiny O( log  log N  /   log N) fraction of the qubits. It is quite surprising that such mostly-very-sparse unitaries suffice for quantum search.

In this paper we show how Grover's reduction in the number of gates can be improved further: for every fixed r, and sufficiently large N, we give a quantum algorithm that finds a unique solution in a database of size N using [formula] queries and [formula] other elementary gates. To be concrete about the latter, we assume the set of elementary gates at our disposal is the Toffoli gate and all one-qubit unitary gates (including the Hadamard gate H and the Pauli X gate).

Our approach is recursive: we build a quantum search algorithm for a larger database using amplitude amplification on a search algorithm for a smaller database. Let us sketch this in a bit more detail. Suppose we have a sequence of database-sizes [formula], where [formula] (of course, N needs to be sufficiently large for such a sequence to exist). The basic Grover algorithm can search a database of size N1 using

[formula]

queries and gates, respectively. We can build a search algorithm for database-size N2 as follows. Think of the N2-sized database as consisting of N2 / N1 N1-sized databases; we can just pick one such N1-sized database at random, use the smaller algorithm to search a solution in that database, and then use [formula] rounds of amplitude amplification to boost the N1 / N2 probability that our randomly chosen N1-sized database happened to be the one containing the unique solution. Each round of amplitude amplification involves one application of the smaller algorithm, one application of its inverse, a reflection through the log N2-qubit all-0 state, and one more query. This gives a search algorithm for an N2-sized database that uses

[formula]

queries and gates respectively. Note that by our choice of N2, we have [formula], so [formula]. Repeating this construction gives a recursion

[formula]

The constant factors in the O(  ·  ) blow up by a constant in each recursion, so after r steps this unfolds to

[formula]

Here log N1 = O( log (r)N) because [formula] is (essentially) an exponentially increasing sequence.

The result we claim is stronger: it does not have the exp (r) factor. Tweaking the above idea to avoid this factor is somewhat delicate, and will take up the remainder of this paper. For instance, in order to get close to the optimal query complexity [formula], it is important that the intermediate steps do not amplify the success probability all the way to 1, since amplitude amplification is less efficient when boosting large success probabilities to 1 than when boosting small success probabilities to somewhat larger success probabilities. Our final algorithm will boost the success probability to 1 only at the very end, after all r recursion steps have been done.

Choosing [formula] in our result and being careful about the constants, we get an exact quantum algorithm for finding a unique solution using essentially the optimal [formula] queries and [formula] elementary gates. Note that for the latter algorithm, on average there are only [formula] elementary gates in between two queries, which is barely more than constant. Once in a while a unitary acts on many more qubits, but the average is only [formula].

Possible objections. To pre-empt the critical reader, let us mention two objections one may raise against the fine-grained optimization of the number of elementary gates that we do here. First, one query acts on log N qubits, and when itself implemented using elementary gates, any oracle that's worth its salt would require Ω( log N) gates. Since [formula] queries are necessary, a fair way of counting would say that just the queries themselves already have "cost" [formula], rendering our (and Grover's [\cite=grover:tradeoffs]) gate-optimizations moot. Second, to do exact amplitude amplification in our recursion steps, we allow infinite-precision single-qubit phase gates. This is not realistic, as in practice such gates would have to be approximated by more basic gates. Our reply to both would be: fair enough, but we still find it quite surprising that query-efficient search algorithms only need to act on a near-constant number of qubits in between the queries on average. It is interesting that after nearly two decades of research on quantum search, the basic search algorithm can still be improved in some ways. It may even be possible to optimize our results further to use [formula] elementary gates, which would be even more surprising.

Preliminaries

Let [formula]. We use the binary logarithm throughout this paper. We will typically assume for simplicity that the database-size N is a power of 2, N = 2n, so we can identify indices i with their binary representation [formula]. We can access the database by means of queries. A query is the following unitary map on n + 1 qubits:

[formula]

where [formula] and b∈{0,1}. Given access to an oracle of the above type, we can also make a phase query of the form Ox,  ±:|i〉  →  ( - 1)xi|i〉 by the standard "phase kickback trick."

Let [formula] be the n-qubit unitary that reflects through |0n〉. It is not hard to see that this can be implemented using O(n) elementary gates and n - 1 ancilla qubits that all start and end in |0〉 (and that we often will not even write explicitly). Specifically, one can use X gates to each of the n qubits, then use n - 1 Toffoli gates into n - 1 ancilla qubits to compute the logical AND of the first n qubits, then apply - Z to the last qubit (which negates the basis states where this AND is 0), and reverse the Toffolis and Xs.

Amplitude amplification is a technique that can be used to efficiently boost quantum search algorithms with a known success probability a to higher success probability. We will invoke the following theorem from [\cite=bhmt:countingj] in the proof of Theorem [\ref=thm:primitivealgo] later. For the sake of completeness we include a proof in the appendix.

Let N = 2n. Suppose there exists a unitary quantum algorithm A that finds a solution in database x∈{0,1}N with known probability a, in the sense that measuring A|0n〉 yields a solution with probability exactly a. Let a < a'∈[0,1] and [formula]. Then there exists a quantum algorithm B that finds a solution with probability exactly a' using w + 1 applications of algorithm A, w applications of A- 1, w additional queries, and 4w(n + 2) additional elementary gates. In total, B uses (2w + 1)Q + w queries and w(4n + 2E + 8) + E elementary gates.

Note that if [formula] and our N-bit database has a unique solution, then a = 1 / N. For k  ≥  2 and a' = 1 / k, Theorem [\ref=thm:exactamplitude] implies an algorithm C(1) that finds a solution with probability exactly 1 / k using w queries and at most O(w log N) other elementary gates, where [formula] (this upper bound on w follows because arcsin (z)  ≥  z, and [formula] since sin (z)  ≥  z - z3 / 6 for z  ≥  0).

In order to amplify the probability of an algorithm from 1 / k to 1 we use the following corollary.

Let k  ≥  2, n be integers, N = 2n. Suppose there exists a quantum algorithm D that finds a unique solution in an N-bit database with probability exactly 1 / k using [formula] queries and E elementary gates. Then there exists a quantum algorithm that finds the unique solution with probability 1 using at most [formula] queries and [formula] elementary gates.

Applying Theorem [\ref=thm:exactamplitude] to algorithm D with a = 1 / k,a' = 1, we obtain an algorithm that succeeds with probability 1 using at most w'(2Q + 1) + Q queries and O(w'(n + E)) gates, where

[formula]

using arcsin (x)  ≥  x and [formula]. Hence, the total number of queries in this new algorithm is at most

[formula]

where we used [formula] and [formula] in the first inequality. The total number of gates is [formula].

The following easy lemma will be helpful to get rid of some of the ceilings that come from Theorem [\ref=thm:exactamplitude].

If k  ≥  2 and α  ≥  k, then [formula].

Improving the gate complexity for quantum search

In this section we give our main result, which will be proved by recursively applying the following theorem.

Let k  ≥  4, n  ≥  m + 2 log k be integers, M = 2m and N = 2n. Suppose there exists a quantum algorithm G that finds a unique solution in an M-bit database with a known success probability that is at least 1 / k, using Q  ≥  k + 2 queries and E other elementary gates. Then there exists a quantum algorithm that finds a unique solution in an N-bit database with probability exactly 1 / k, using Q' queries and E' other elementary gates where,

[formula]

Consider the following algorithm A:

Start with |0n〉.

Apply a Hadamard transform to the first n - m qubits, leaving the last m qubits as |0m〉. The resulting state is a uniform superposition over the first n - m qubits [formula].

Apply the unitary G to the last m qubits (using queries to x, with the first n - m address bits fixed).

The final state of algorithm A is

[formula]

The state |y〉G|0m〉 depends on y, because here G restricts to the M-bit database that corresponds to the bits in x whose address starts with y. Let t be the n-bit address corresponding to the unique solution in the database x∈{0,1}N. Then the probability of observing [formula] in the state [formula] is at least 1 / k. Hence the probability that A finds the solution is [formula]. The total number of queries of algorithm A is Q (from Step 3) and the total number of elementary gates is n - m + E (from Steps 2 and 3).

Applying Theorem [\ref=thm:exactamplitude] to algorithm A by choosing a' = 1 / k, we obtain an algorithm B using at most w(2Q + 1) + Q queries and w(4n + 2E + 8) + E gates (from Theorem [\ref=thm:exactamplitude]), where where the first inequality follows from arcsin (z)  ≥  z and [formula] (since sin (z)  ≥  z - z3 / 6 for z  ≥  0), and the third inequality uses Lemma [\ref=lemma:ceiltononceil] ([formula] because n  ≥  m + 2 log k).

The total number of queries in algorithm B is at most

[formula]

where we used Q  ≥  k + 2 and n  ≥  m + 2 log k  ≥  4 in the second and third inequality, respectively. The number of gates in B is

[formula]

where we used n  ≥  m + 2 log k  ≥  4 and [formula] in the second inequality.

It is not hard to see that the number of gates in B is at least [formula].

Applying Theorem [\ref=thm:exactamplitude] once to an algorithm that finds the unique solution in an M-bit database with probability 1 /  log  log N, we get the following corollary, which was essentially the main result of Grover [\cite=grover:tradeoffs].

Let n  ≥  25 and N = 2n. There exists a quantum algorithm that finds a unique solution in a database of size N with probability 1, using at most [formula] queries and [formula] other elementary gates.

Let m = ⌈log (n2k3)⌉ and k =  log  log N. Let C(1) be the algorithm (described after Theorem [\ref=thm:exactamplitude]) on an M-bit database with M  =  2m that finds the solution with probability 1 / k. Observe that k  ≥  4 and m + 2 log k  ≤   log (2n2k5)  ≤  n (where the last inequality is true for n  ≥  25), hence we can apply Theorem [\ref=thm:primitivealgo] using C(1) as our base algorithm. This gives an algorithm C(2) that finds the solution with probability exactly 1 / k. The total number of queries in algorithm C(2) is at most where the expression on the left is the contribution from Theorem [\ref=thm:primitivealgo]. The first inequality above follows from Lemma [\ref=lemma:ceiltononceil] (since m  ≥  4 log k). The total number of gates in C(2) is where we used Lemma [\ref=lemma:ceiltononceil] in the first inequality, [formula] and log M = O( log  log N) in the second inequality. Applying Corollary [\ref=cor:amplify1/kto1] to algorithm C(2), we obtain an algorithm that succeeds with probability 1 using at most

[formula]

queries and

[formula]

gates, since [formula] (which is true for n  ≥  25). Since k =  log  log N, it follows that the query complexity is at most [formula] and the gate complexity is [formula].

We can now use Theorem [\ref=thm:primitivealgo] recursively by starting from the improved algorithm from Corollary [\ref=cor:grovertradeoff]. This gives query complexity [formula] and gate complexity [formula]. Doing this multiple times and being careful about the constant (which grows in each step of the recursion), we obtain the following result:

Let k be a power of 2 and N a sufficiently large power of 2. For every [formula], [formula], there exists a quantum algorithm that finds a unique solution in a database of size N with probability exactly 1 / k, using at most

[formula]

We begin by defining a sequence of integers [formula] such that nr  =   log N and ni - 1  =   max {10 log k + 2(i - 2) log k,⌈log (n2ik3)⌉} for [formula]. Note that n1  ≥  10 log k  ≥  20 (since k  ≥  4). We first prove the following claim about this sequence.

If [formula], then ni - 1 + 2 log k  ≤  ni .

We use downward induction on i. For the base case i = r, note that nr  =   log N. Since nr - 1  =   max {10 log k + 2(r - 2) log k,⌈log (n2rk3)⌉}, 10 log k + 2(r - 2) log k  ≤  ⌈log (n2rk3)⌉ for sufficiently large N and k  ≤   log  log N, we may assume nr - 1  =  ⌈log (n2rk3)⌉. Hence

[formula]

where the last inequality again assumed N sufficiently large and used k  ≤   log  log N.

For the inductive step, assume we have nj + 2 log k  ≤  nj + 1. We now prove nj - 1 + 2 log k  ≤  nj by considering the two possible values for nj - 1.

Case 1. nj - 1 = 10 log k + 2(j - 2) log k. Then we have

[formula]

using nj  =   max {10 log k + 2(j - 1) log k,⌈log (n2j  +  1k3)⌉} in the last inequality.

Case 2. nj - 1  =  ⌈log (n2jk3)⌉. We first show nj - 1  ≤  nj:

[formula]

where the first inequality uses the induction hypothesis and the second uses nj  =   max {10 log k + 2(j - 1) log k,⌈log (n2j  +  1k3)⌉}. We can now conclude the inductive step:

[formula]

In the first inequality above we use nj - 1  ≤   log (2n2jk3) and we use nj  ≥  n1  ≥  10 log k  ≥  20 (using nj - 1  ≤  nj for [formula] and k  ≥  4) to conclude 1 + 2 log nj  ≤  nj / 2 (which is true for nj  ≥  20) in the second inequality, and 5 log k  ≤  nj / 2 in the last inequality.

Using the sequence [formula], we consider r database-sizes [formula]. For each i∈[r], we will construct a quantum algorithm C(i) on a database of size Ni that finds a unique solution with probability exactly 1 / k. Qi and Ei will be the query complexity and gate complexity, respectively, of algorithm C(i). We have already constructed the required algorithm C(1) (described after Theorem [\ref=thm:exactamplitude]) on an N1-bit database using

[formula]

queries, where the inequality follows from Lemma [\ref=lemma:ceiltononceil] (since N1  ≥  k10). Also, note that

[formula]

where the first inequality used N1  ≥  k10, and the second inequality used k  ≥  4. Using Theorem [\ref=thm:exactamplitude], the number of gates E1 used by C(1) is

[formula]

where we use Lemma [\ref=lemma:ceiltononceil] (since N1  ≥  k10) in the first inequality and N1  ≥  k10 in the second and third inequality. It is not hard to see that [formula].

For [formula], we apply Theorem [\ref=thm:primitivealgo] using C(i - 1) as the base algorithm and we obtain an algorithm C(i) that succeeds with probability exactly 1 / k. We showed earlier in Claim [\ref=claim:increasingdatabases] that ni - 1 + 2 log k  ≤  ni and it also follows that [formula] (since the database-sizes [formula] are non-decreasing). Hence both assumptions of Theorem [\ref=thm:primitivealgo] are satisfied. The total number of queries used by C(i) is

[formula]

In order to analyze the number of gates used by C(i) we need the following claim

[formula] for all i∈[r].

The proof is by induction on i. For the base case, we observed earlier that [formula]. For the induction step assume [formula]. The claim follows immediately from the lower bound on E' in Theorem [\ref=thm:primitivealgo] since [formula].

Recursively it follows that the number of gates Ei used by C(i) is at most

[formula]

where we used Claim [\ref=claim:Eilowerbound] in the first inequality and [formula] in the last inequality (note that this inequality also holds if ni - 1 = 10 log k + 2(i - 2) log k  ≥  ⌈log (n2ik3)⌉). Unfolding the recursion in Equations ([\ref=eq:recursion1]) and ([\ref=eq:recursion2]), we obtain

[formula]

It remains to show that n1, which is defined to be max {10 log k,⌈log (n22k3)⌉}, is O( max { log k, log (r)N}). We first prove:

Suppose n1  =  ⌈log (n22k3)⌉. Then ni - 1  =  ⌈log (n2ik3)⌉ for all [formula].

We prove the claim by induction on i. The base case i = 2 is the assumption of the claim. For the inductive step, assume nj - 1  =  ⌈log (n2jk3)⌉. Since nj - 1  =   max {10 log k + 2(j - 2) log k,⌈log (n2jk3)⌉}, it follows that nj - 1  ≥  10 log k + 2(j - 2) log k. We want to prove nj  =  ⌈log (n2j  +  1k3)⌉. Towards a contradiction, suppose nj = 10 log k + 2(j - 1) log k  >  ⌈log (n2j  +  1k3)⌉. Since 10 log k + 2(j - 1) log k < kj + 1 for k  ≥  3 and j  ≥  2 (which holds by the assumption of the theorem and claim respectively), it follows that nj  <  kj + 1 and nj - 1  =  ⌈log (n2jk3)⌉ < 9 log k + 2(j - 2) log k. This contradicts the inductive assumption that nj - 1  =  ⌈log (n2jk3)⌉  ≥  10 log k + 2(j - 2) log k. Hence nj  =  ⌈log (n2j  +  1k3)⌉.

Hence if n1  =  ⌈log (n22k3)⌉, we can use the claim above to write

[formula]

where the last inequality follows from k  ≤  n1 / 32  ≤  n1 / 3i (using ⌈log (n22k3)⌉  ≥  10 log k to conclude k  ≤  n1 / 32 and Claim [\ref=claim:increasingdatabases]). Since nr  =   log N, it follows easily that n1 = O( log (r)N) if n1  =  ⌈log (n22k3)⌉. We conclude n1 = O( max { log k, log (r)N}).

The following is our main result:

For every constant integer r > 0 and sufficiently large N = 2n, there exist a quantum algorithm that finds a unique solution in a database of size N with probability 1, using [formula] queries and [formula] gates,

For every ε > 0 and sufficiently large N = 2n, there exist a quantum algorithm that finds a unique solution in a database of size N with probability 1, using [formula] queries and [formula] gates.

Applying Corollary [\ref=cor:amplify1/kto1] to algorithm C(r) (as described in Theorem [\ref=thm:grover-almost-opt]), with some k  ≤   log  log N to be specified later, we obtain an algorithm that succeeds with probability 1 using at most

[formula]

queries and

[formula]

gates. To obtain the two claims of the corollary we can now either pick:

[formula], where c1∈[1,2] ensures k is a power of 2. It follows that [formula]. Since [formula] for every constant r, we have max { log k, log (r)N}  =   log (r)N. Hence the query and gate complexities are [formula] and [formula], respectively.

[formula] and [formula], where we choose c2 as the smallest number that is at least 4 /  ln (1 + ε) and that makes k a power of 2. We have [formula]. Hence the query and gate complexities are [formula] and [formula], respectively.

Future work

Our work could be improved further in a number of directions:

Can we remove the [formula] factor in the gate complexity, reducing this to the optimal [formula]? This may well be possible, but requires a different idea than our roughly [formula] recursion steps, which will inevitably end up with [formula] gates.

Our construction only works for specific values of N. Can we generalize it to work for all sufficiently large N, even those that are not powers of 2, while still using close to the optimal [formula] queries?

Can we obtain a similar gate-optimized construction when the database has multiple solutions instead of one unique one? Say when the exact number of solutions is known in advance?

Most applications of Grover deal with databases with an unknown number of solutions, focus only on number of queries. Are there application where our reduction in the number of elementary gates for search with one unique solution is both applicable and significant?

Acknowledgments.

We thank Peter Hø yer and Andris Ambainis for helpful comments related to [\cite=aaronson&ambainis:searchj].

Exact amplitude amplification

For the sake of completeness we present the construction of quantum algorithm B from Theorem [\ref=thm:exactamplitude]. The idea is to lower the success probability from a in such a way that an integer number of rounds of amplitude amplification suffice to produce a solution with probability exactly a'.

Define [formula] and ã  =   sin 2(θ), where w is defined in Theorem [\ref=thm:exactamplitude]. Let Rã / a be the one-qubit rotation that maps [formula]. Call an (n + 1)-bit string i,b a "solution" if xi = 1 and b = 0. Define the (n + 1)-qubit unitary [formula]. It is easy to verify that O'x puts a -   in front of the solutions (in the new sense of the word), and a +   in front of the non-solutions.

Let [formula], and define |U〉  =  A'|0n + 1〉 to be the final state of this new algorithm. Let |G〉 be the normalized projection of |U〉 on the (new) solutions and |B〉 be the normalized projection of |U〉 on the (new) non-solutions. Measuring |U〉 results in a (new) solution with probability exactly sin 2(θ), hence we can write

[formula]

Define Q  =  A'Dn + 1(A')- 1O'x. This is a product of two reflections in the plane spanned by |G〉 and |B〉: O'x is a reflection through |G〉, and [formula] is a reflection through |U〉. As is well known in the analysis of Grover's algorithm and amplitude amplification, the product of these two reflections rotates the state over an angle 2θ. Hence after applying Q w times to |U〉 we have the state

[formula]

since [formula]. Thus the algorithm A' can be boosted to success probability a' using an integer number of applications of Q.

Our new algorithm B is now defined as QwA'. It acts on n + 1 qubits (all initially 0) and maps

[formula]

so it finds a solution with probability exactly a'. B uses w + 1 applications of algorithm A together with elementary gate Rã / a; w applications of A- 1 together with R- 1ã / a; w applications of O'x (each of which involves one query to x and two other elementary gates, counting XH as one gate); and w applications of Dn + 1 (each of which takes 4n + 3 elementary gates). Hence the total number of queries that B makes is at most (2w + 1)Q + w and the number of gates used by B is at most (2w + 1)E + 4w(n + 2).