Lemma Proposition

Exact Gift Wrapping to Prune the Tree of Edges of Newton Polytopes to Compute Pretropisms

Introduction

The input to our problem is a tuple of polytopes spanned by points with integer coordinates. Such polytopes occur regularly in algebraic geometry as Newton polytopes. The Newton polytope of a polynomial in several variables is the convex hull of the exponent tuples of those monomials that appear in the polynomial with a nonzero coefficient. Tuples of Newton polytopes arise from systems of polynomial equations in several variables.

Given a tuple of Newton polytopes, our problem is to compute all pretropisms. A pretropism for a tuple of polytopes is a vector that makes the minimal inner product with at least an edge of every polytope. In particular, every pretropism defines a perpendicular hyperplane that touches all polytopes in the tuple at an edge or at a higher dimensional face of each polytope. In the special case where all polytopes in the tuple are the same, the pretropisms are recovered from the output of a convex hull algorithm. Therefore, we assume that the polytopes in the input tuple are all distinct from each other.

Our motivation for the calculation of all pretropisms stems from the application of concepts of tropical algebraic geometry [\cite=MS15] to develop polyhedral methods to solve polynomial systems. A tropism is the vector of leading exponents in a Puiseux series expansion [\cite=Wal50] for an algebraic curve. Every tropism is a pretropism, but whether a pretropism is a tropism may depend on the particular choices of the coefficients of the polynomial system.

A straightforward algorithm to compute all pretropisms is to consider the product of all edges of the polytopes in the tuple. For each tuple in the product of all edges, we can compute the normal perpendicular to all edges and check whether this normal when oriented properly makes the minimal inner product at the edges in the tuple. The enumeration of all products is naturally organized as a tree, where the leaves of the first level are the edges of the first polytope in the tuple. The nodes at the next level are pairs of edges, the first edge from the first polytope and the second edge of the second polytope. The leaves of this tree are tuples of edges, where the i-th element of the tuple is an edge of the i-th polytope. Traversing the entire tree will give all pretropisms; however, the ratio of the number of pretropisms over the number of leaves in this tree tends to become very small as the number of polytopes in the input of our problem increases.

Therefore, we propose to prune the tree of all edge-edge combinations using the geometric tools provided by the gift wrapping algorithm [\cite=Bor97] [\cite=CK70] [\cite=PS85] [\cite=Swa85] to compute the convex hulls of polytopes. In [\cite=ABS97], the gift wrapping algorithm is classified as a graph traversal algorithm. Because the growth of the coefficients in the output vectors may grow unpredictably larger than what is available in hardware floating-point arithmetic and our input problem is defined by exact data, we perform our computations with exact arithmetic. Our practical experimentations are done in Sage [\cite=Sage], using its modules for lattice polytopes [\cite=BH11] and polyhedral cones [\cite=Nov11]. Cone intersections in Sage are computed by PPL [\cite=BHZ08].

Related Work

The problem considered in this paper is a generalization of the problem to compute the mixed volume of a tuple of Newton polytopes, for which pruning methods were first proposed in [\cite=EC95]. Further developments can be found in [\cite=GL03] and [\cite=MTK07], with corresponding free software packages MixedVol [\cite=GLW05] and DEMiCS [\cite=MT08]. A recent parallel implementation along with a complexity study appears in [\cite=Mal15]. The relationship between triangulations and the mixed subdivisions is explained and nicely illustrated in [\cite=DRS10].

The main difference between mixed volume computation and the computation of the tropical prevariety is that in a mixed volume computation the vertices of the polytopes are lifted at randomly, thus removing all degeneracies. This lifting gives the powers of an artificial parameter. In contrast, in a Puiseux series development of a space curve, the first variable is typically identified as the parameter and the powers of the first variable in the given polynomials cannot be considered as random.

A practical study on various software packages for exact volume computation of a polytope is described in [\cite=BEF00]. Exact algorithms on Newton polytopes are discussed in [\cite=EFK12]. The authors of [\cite=EF14] present an experimental study of approximate polytope volume computation. In [\cite=EFG16], a polynomial-time algorithm is presented to compute the edge skeleton of a polytope. Computing integer hulls of convex polytopes can be done with polymake [\cite=AGHJLPR15].

A tropical prevariety was introduced in [\cite=BJSST07] and Gfan [\cite=Jen08] is software to compute the common refinement of the normal fans of the Newton polytopes [\cite=Zie95]. Gfan relies on the reverse search algorithms [\cite=AF92] and calls cddlib [\cite=FP96].

Organization and Contribution of the Paper

To gain a geometric intuition, the next section starts with a description of the algorithm in three dimensions. Section three considers the case of a space curve in n-space defined by n - 1 Laurent polynomial equations, where variables may occur with negative exponents. Sections two and three define our new algorithms, and provide cost estimates on the effectiveness of the pruning. Computational experiments are in sections four and five, in particular at the end of section five where we compare our implementation with Gfan. Another contribution, in addition to the new algorithms, is our Sage code on github.

A Pair of Three Dimensional Polytopes in Generic Position

To introduce our algorithm, we start with the case of looking for a space curve in three dimensions. The space curve is defined by two polynomials in three variables and the input to our problem is a tuple of two Newton polytopes. Excluding trivial cases, each polytope must have at least one edge. We say that the two polytopes are in generic position with each other if there is no pair of edges, one from each polytope, where the edges are parallel to each other. This generic position excludes the existence of a common two dimensional factor of the two given polynomials. We assume two polytopes and not three, because three polytopes in generic position can only have isolated solutions and no solution curves.

Our algorithm takes as input a modified version of the data structure output by the gift wrapping algorithm. It conceptually exploits the connectivity between vertices, edges, and facets, but really only requires the edge skeleton of the polytope. To accomplish this, we used edge objects that had vertices, references to their neighboring edges, and the set of inner normals of all of the facets on which the edge rests.

Algorithm [\ref=alg3dgeneric] sketches the outline of the algorithm to compute all pretropisms of two polytopes in three dimensions. Along the lines of the gift wrapping algorithm, for every edge of the first polytope we take the plane that contains this edge and consider where this plane touches the second polytope. Algorithm [\ref=algedgeskeleton] starts exploring the edge skeleton defined by the edges connected to the vertices in this touching plane.

The exploration of the neighboring edges corresponds to tilting the ray r, as in rotating a hyperplane in the gift wrapping method. For every edge E for which [formula], the intersection [formula] defines a pretropism.

One may wonder why the exploration of the edge skeleton in Algorithm [\ref=algedgeskeleton] could not stop after the statement on line 4. Figure [\ref=figminksum] illustrates the justification for the length of Algorithm [\ref=algedgeskeleton] with a simple Minkowski sum. Our problem is to compute those facets of the Minkowski sum that are spanned by one edge of each polytope.

Because the emphasis in the description of Algorithm [\ref=algedgeskeleton] is on the explanation of the control flow, the return type is kept simple. In the three dimensional case, the result of the cone intersection [formula] is the same as [formula] in Algorithm [\ref=alg3dgeneric]. An optimization is for Algorithm [\ref=algedgeskeleton] to return [formula] as well.

For three dimensional polytopes P1 and P2 in generic position, any pair of edges (e1,e2), e1 of P1 and e2 of P2 that defines a unique ray [formula], [formula], we have that: if r would be normal to a hyperplane through a facet of P1 or P2, the extra point that spans the facet jointly with e1 and/or e2 would not have generic coordinates.

In the Newton-Puiseux algorithm to compute series expansions, we are interested only in the edges on the lower hull of the Newton polytope, i.e. those edges that have an upward pointing inner normal. For Puiseux for space curves, the expansions are normalized so that the first exponent in the tropism is positive. Algorithm [\ref=alg3dgeneric] is then easily adjusted so that calls to the edge skeleton computation of Algorithm [\ref=algedgeskeleton] are made with rays that have a first component that is positive.

Correctness

To see that the three dimensional generic algorithm is correct, we must define an additional term. A pretropism graph is the set of edges for a given polytope that have normal cones intersecting a given cone. We will now prove that this is the output of Algorithm [\ref=algedgeskeleton].

Let P1 and P2 be three dimensional polytopes with e1 an edge in P1 and e2,e3 edges in P2. Let C2 be the cone of the intersection of the normal cones of e1 and e2, and let C3 be the cone of the intersection of the normal cones of e1 and e3. Let dim(C2)  >  0 and dim(C3)  >  0. There exists a path between e2 and e3 that remains in the pretropism graph.

Proof. Let n2 be a normal to e2 that is also in C2 and let n3 be a normal to e3 that is also in C3. Set n  =  tn2  +  (1 - t)n3 where 0  ≤  t  ≤  1. Consider varying t from 0 to 1; this creates the cone Cn, a cone which must lie within the normal cone to e1, as both n1 and n2 lie in that cone. If we gift wrap around P2, starting with the supporting hyperplane with normal n at t  =  0, there will be some value of n that will represent the next time that the rotating hyperplane becomes a supporting hyperplane of P2. This new hyperplane will either:

rest on an edge that shares a vertex with e3 or

rest on a facet that has e3 as an edge.

In either case, e3 is connected to the new face and every edge in the new face is also in the pretropism graph.

By this method, we can iteratively construct a path. Every time we rotate the hyperplane, we find a new face that rests in the pretropism graph that is also connected to e3. After some finite number of iterations, we will eventually rotate all the way to e2. This constructs the path from e2 to e3.

Three dimensional pretropism graphs are connected graphs.

Proof. From Lemma [\ref=lemma1], we can conclude that from any edge in the pretropism graph we can create a path to any other edge in the pretropism graph where every element in the path is also in the pretropism graph. This demonstrates that the pretropism graph is connected.

Once we find every pretropism graph of P2 that corresponds to a ray from the normal cone to an edge e in P1, we can intersect the normal cone to e with every normal cone in the pretropism graph. Each resulting cone is a pretropism. If we iterate over all edges in P1, we will find all pretropisms.

Cost

In estimating the cost of our algorithm to compute all pretropisms, we consider the following primitive operation. Given a pair of edges, decide whether the pair defines a pretropism and if so, compute the vector perpendicular to this pair of edges. For a polytope P, denote by ne(P) its number of edges. The upper bound on the number of primitive operations for two polytopes P1 and P2 is the product ne(P1)  ×  ne(P2), while the lower bound equals the number of pretropisms.

Denote by EP,e the pretropism graph resting on polytope P corresponding to the ray determined by edge e. Let ne(EP,e) denote the number of edges in EP,e.

The number of primitive operations in Algorithm [\ref=alg3dgeneric] on two polytopes P1 and P2 is bounded by

[formula]

As EP,e is a subset of the edges of P: ne(EP,e)  ≤  ne(P). Therefore, the bound in ([\ref=eq3dcostbound]) is smaller than ne(P1)  ×  ne(P2).

To interpret ([\ref=eq3dcostbound]), recall that Algorithm [\ref=alg3dgeneric] takes a ray from inside a normal cone to a edge of the first polytope for the exploration of the edge graph of the second polytope. If we take a simplified view on the second polytopes as a ball, then shining a ray on that ball will illuminate at most half of its surface. If we use the estimate: ne(EP2,ei)  ≈  ne(P2) / 2, then Algorithm [\ref=alg3dgeneric] cuts the the upper bound on the number of primitive operations in half.

An (n - 1)-tuple of n Dimensional Polytopes in Generic Position

Algorithm [\ref=algndgeneric] outlines the computation of all pretropisms in dimension n, for a tuple of n - 1 polytopes in generic position. The primitive operation in Algorithm [\ref=algndgeneric] is the update [formula] of the polyhedral cone C with the normal cone to an edge Ce. The number of times this primitive is invoked is determined by the edge skeletons of the polytopes.

Correctness

Let P1 and P2 be n dimensional polytopes with e1 an edge in P1 and e2,e3 edges in P2. Let C2 be the cone of the intersection of the normal cones of e1 and e2, and let C3 be the cone of the intersection of the normal cones of e1 and e3. Let dim(C2)  >  0 and dim(C3)  >  0. There exists a path between e2 and e3 that remains in the pretropism graph.

Proof. In Lemma [\ref=lemma1], when we wrapped around P2, we had only the possibilities of wrapping onto either an edge or a two dimensional face. In the n dimensional case, we wrap onto a n - k face where [formula]. Whatever dimensional face that we wrap onto, we can continue to iterate the algorithm and construct a path just as in the style of Lemma [\ref=lemma1].

Pretropism graphs are connected graphs.

Proof. This follows from Lemma [\ref=lemma2] in conjunction with the concept of Theorem [\ref=theorem1].

Cost

Estimating the cost of the n dimensional case follows naturally from the cost analysis of the 3 dimensional case. For n - 1 polytopes, the upper bound on the number of primitive operations required is the product [formula].

The number of primitive operations in Algorithm [\ref=algndgeneric] on n - 1 polytopes P1, [formula] is bounded by

[formula]

Again, if we use the estimate that ne(EPj,ei)  ≈  ne(Pj) / 2, then Algorithm [\ref=alg3dgeneric] reduces the upper bound on the number of primitive operations by [formula].

Implementations and Computations

We have written a prototype implementation of our algorithms in Sage [\cite=Sage], a computer algebra package which facilitates exact computations with lattice polytopes [\cite=BH11], [\cite=Nov11]. Sage provides a module to work with rational polyhedral fans. In particular, the intersection of two cones given by their rays happens with a single command. In addition, Sage provides an interface to Gfan [\cite=Jen08], which proved helpful in our testing.

In this section we outline the methods that were implemented (experimental code available at https://github.com/sommars/GiftWrap).

Minkowski Sum and Cayley Embedding

Given any convex hull method, we can extract all pretropisms from the facets of the Minkowski sum of the polytopes, or alternatively via the convex hull of the Cayley embedding. The main disadvantage of those two methods is that not all facets are of interest: only those facets spanned by at least two points of each polytope are pretropisms. While the Cayley embedding is conceptually nicer, the embedding in a higher dimensional space is an additional burden on the complexity and we observed that the Cayley embedding method is slower than the Minkowski sum method. The convex hulls computed for these versions were also computed using the gift wrapping algorithm.

Pruning with Plain Cone Intersections

The intersection of cones is the main ingredient in the description of the algorithms to compute the tropical prevariety [\cite=BJSST07]. In this section we briefly describe our Sage implementation of this cone intersection algorithm to prune the tree of edge-edge combinations.

Instead of considering all possible tuples of edges and intersection their normal cones, the pruning method proceeds as follows. For example, given three Newton polytopes P1, P2, and P3 (of polynomials in four variables), if for a pair of edges of P1 and P2, the intersection of their normal comes is empty, then it is no longer necessary to intersect that pair with all cones normal to all the edges of P3. This progressive way of pruning reduces drastically the number of cone intersections.

Gift Wrap Implementation

The implementation of the gift wrapping algorithm to compute convex hull follows the text book description [\cite=PS85].

Because of concerns for possible numerical roundoff errors that would occur with wide ranges of values of the coordinates, all computations were performed in exact arithmetic in Sage, using Hermite normal forms for the coordinate transformations in the recursive dimension reductions. When the hyperplane rotates to wrap around the point set in the n-dimensional algorithm, the calculations leave [formula] and move to [formula] where [formula] for some finite [formula]. These calculations slow down the program, but they are a straightforward way to guarantee the correctness for any input.

We begin the gift wrap pretropism algorithm implementation by first calling the aforementioned gift wrapping code on the support set of every input polynomial. We input the resulting convex hulls into the gift wrap pretropism algorithm and we compute the pretropisms as previously described. The algorithm outputs a list of lists where each sublist corresponds to a pretropism.

Computational Experiments

To test the algorithms, we generate n - 1 simplices spanned by integer points with coordinates uniformly generated within the range of 0 to 30. This input corresponds to considering systems of n - 1 sparse Laurent polynomials in n variables with n + 1 monomials per equation. We can compare with the mixed volume computation if we add one extra linear equation to the Laurent polynomial system. Then the mixed volume of the n-tuple will give the sum of the degrees of all the curves represented by the Puiseux series. Assuming generic choices for the coefficients, the degrees of the curves can be computed directly from the tropisms, as used in [\cite=Ver09] and applied in [\cite=AV12] [\cite=AV13].

Denoting by MV(P) the mixed volume of an n-tuple P of Newton polytopes:

[formula]

where the sum ranges over all tropisms v.

All computations were done on a 3.5 GHz Intel Core i5 processor in a iMac Retina 5K, running version 10.10.3 of Mac OS X, with 16 GB RAM.

Benchmarking Different Approaches

Table [\ref=tabcayminkprune] shows the comparisons between various methods of computing pretropisms. The Cayley trick is most expensive not only because of the embedding in a (2n  -  1)-dimensional space, but also because of the costly exact implementation of the gift wrapping algorithm.

For dimensions five and larger, neither the Minkowski sum nor the Cayley embedding can compete with the pruning methods. Table [\ref=tabdata] continues the comparisons in higher dimensions. The mixed volume was computed with the version of MixedVol [\cite=GLW05], available in PHCpack [\cite=Ver99] since version 2.3.13. For systems with generic coefficients, the mixed volume equals the number of isolated solutions [\cite=Ber75]. While a fast multicore workstation can compute millions of solutions, a true supercomputer will be needed in the case of billions of solutions. For larger dimensions, the new pruning method dominates the plain cone intersection method.

Output Size versus Input Size

In this section we provide some experimental data on the relationship between the number of pretropisms (the size of the output) and the product of the number of edges (the size of the input). Unlike in the previous section, we generate random polytopes spanned by an variable number of edges.

In three dimensions, the relation between the input and the output size seems linear, as can be seen from the top left of Figure [\ref=figrelations]. However, as can be seen in the rest of Figure [\ref=figrelations], the relationship between the sizes of the input and the output no longer appears linear.

Number of Cone Intersections

Another way that the cone intersection algorithm can be compared to our new algorithm is through comparing the number of cone intersections required for each. Table [\ref=tabconecomparison] contains a comparison of these numbers. The cone intersection algorithm column contains precisely how many intersections are required in the simplicial case, while the new algorithm column contains the average number of cone intersections for a large number of trials.

A large number of trials were performed at each dimension so we could conclude statistically if our mean number of intersections differed from the number of intersections required by the cone intersection algorithm. To test this hypothesis, we performed t-tests using the statistical software package R [\cite=R]. At every dimension from 3 to 8, we were able to reject the null hypothesis that they had the same mean and we were able to conclude that the new algorithm has a lower mean number of intersections ([formula] for every test). We had estimated the cost to be an improvement by a factor of [formula], but experimentally we found a greater improvement as can be seen in Table [\ref=tabconecomparison].

Comparison with Gfan

Our new algorithm conceptually relies on the giftwrapping algorithm, but practically, any convex hull algorithm could be used. Because of this, we also implemented a version that used Sage's polyhedra module [\cite=BH11] instead of our own gift wrapping implementation. Using this compiled convex hull code led to large speed improvements for finding the convex hulls, which led to better overall performance. With this implementation, our code is competitive with Gfan. Table [\ref=tabgfancomparison] contains timing comparisons, with input polynomials determined as they were previously determined; the timings in the Gfan column were obtained by running the current version 0.5 of Gfan [\cite=gfan].

Conclusion

To compute all pretropisms of a Laurent polynomial system, we propose to exploit the connectivity of edge skeletons to prune the tree of combinations of edges of the tuple of Newton polytopes of the polynomials in the system. A first high level implementation in Sage provides practical evidence that shows that our new pruning method is better than the pruning method that only relies on cone intersections.