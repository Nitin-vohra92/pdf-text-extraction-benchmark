New Limits on Fault-Tolerant Quantum Computation

CWI and U of Amsterdam buhrman@cwi.nl Richard Cleve

U of Waterloo and Perimeter Institute cleve@cs.uwaterloo.ca Monique Laurent

CWI, Amsterdam M.Laurent@cwi.nl Noah Linden

U of Bristol n.linden@bristol.ac.uk Alexander Schrijver CWI and U of Amsterdam Lex.Schrijver@cwi.nl Falk Unger* CWI, Amsterdam unger@cwi.nl

Introduction

In the past decade, quantum computing has attracted much attention because of its ability to efficiently solve problems for which no efficient classical algorithms are known. Significant research efforts are dedicated to physically realizing quantum computers. A fundamental problem is to cope with noise, which creates major difficulties in storing and operating on quantum states reliably. A key advance was the realization that quantum error correcting codes [\cite=Shor95] [\cite=Steane96a] exist and fault-tolerant quantum computation [\cite=Shor96] is possible for a number of reasonable error models. Subsequent results have improved on the first fault-tolerant schemes, proving better and better bounds on the noise tolerable in quantum computation (e.g. [\cite=CS96] [\cite=AharonovB97]). Recent results suggest that fault-tolerant quantum computation is possible with gates that have as much as 3% of depolarizing errors [\cite=Knill04], but there is no rigorous proof so far.

In this paper we will concentrate on the opposite task of proving that, for certain noise levels, quantum computation is impossible. Our main result is as follows: Let [formula] be the set of all (noiseless) Clifford gates

[formula]

The Gottesman-Knill Theorem says that this set of gates can be efficiently simulated classically (see also [\cite=AaronsonGottesman04]), so they are probably not universal for quantum computation. On the other hand, it is known that [formula] together with any other one-qubit gate, not generated by the gates in [formula], form a universal set of gates for quantum computation [\cite=Solovay00] [\cite=NebeRainsSlaon01]. We show however, that such additional one-qubit gates should not be too noisy. More precisely, let [formula] be [formula] augmented with arbitrary one-qubit gates with depolarizing error at least [formula]. Then this set of gates is no longer capable of computing arbitrary functions and thus is not universal. In other words, fault-tolerant quantum computation cannot be performed if there is this level of noise. Additionally we show that, among all one-qubit gates that augment [formula], the so-called π / 8-gate (see end of Section [\ref=sec:main]) is the type of gate that requires the most noise to render it incapable of universal quantum computation by our approach. That is, for other augmenting gates (e.g., π / 16-gates), our approach will yield stronger bounds on the tolerable level. Our results also yield a simple proof that not all classical functions can be computed using Clifford gates (complementing results in [\cite=AaronsonGottesman04]). In particular, in Corollary [\ref=corParity], we show that a boolean function which can be computed by Clifford circuits can be written as the parity of a subset of input bits.

The main idea of our approach is as follows. Assume we have a Clifford circuit C with n classical input bits [formula] and one dedicated output qubit that, when measured in the computational basis, yields the output of the computation of C on x. Suppose now that the input is partitioned over two parties, Alice and Bob, such that Alice has k bits of x and Bob has n - k bits. We first show how Alice, with the help of Bob, can compute the value of C on x with just a single classical bit of communication (Lemma [\ref=lemmaMain]). From this it follows that Clifford circuits can at the very best compute only those functions that require for any partition of the inputs a single bit of communication, and it is well known that many functions require more than one bit of communication. Next, we show in Lemma [\ref=lemmaSimulate] how probabilistic mixtures of Clifford gates can be used to simulate any single qubit unitary gate, that has noise (≈  45%). The proof of our Lemma relies on solving an optimization problem related to the Clifford polytope, defined as the convex hull of the set [formula] of Clifford rotation matrices in [formula]. Here, the matrices [formula] are essentially the one-qubit Clifford gates in Bloch sphere representation.

Combining Lemmas [\ref=lemmaMain] and [\ref=lemmaSimulate], we get that all circuits with Clifford-gates and with respect to any distribution of the inputs can be computed by Alice and Bob with a single bit of communication (Lemma [\ref=lemmaqMain]). Using the fact that there are functions which require communication more than one bit, we get our main result (Theorem [\ref=theMain]): The set of gates in [formula] cannot be universal. We also generalize our result to the case that the inputs are quantum states.

The idea that a noisy 1-qubit gate can be simulated by a probabilistic mixture of Clifford appeared first in Virmani et al. [\cite=VirmaniHuelgaPlenio04]. The approach we take here though is an extension to quantum fault tolerant computation of the work by Brassard et al [\cite=BrassardBuhrmanLindenMethotTappUnger05], where they exhibit an upper bound on the noise threshold for classical fault tolerant computation, using lower bounds on quantum communication complexity and the non-local CHSH correlation.

We want to point out that section [\ref=secMain] can be read independently of the preceding section. It shows that gates from Clifford, together with all stabilizer operations and classical co-processing are classically simulatable and thus probably not quantum-universal.

Related Work

There are only a few other results concerning the limits of fault-tolerant computation. These are not all strictly comparable to each other and our result; nevertheless, we review them and make some comparisons. See the introduction of [\cite=R03] for some remarks that motivate the analysis of thresholds for fault-tolerant quantum computation.

The first results on upper bounds of the threshold decoherence rate were obtained by showing that quantum computers with faulty gates can be simulated efficiently on a classical computer. The first to prove one of these results were Aharonov and Ben-Or [\cite=AB96], with the value 97% for the noise. Later Harrow and Nielsen [\cite=HN03] showed that if 74% of depolarizing noise is applied to each output qubit of each gate, then (faulty) two-qubit gates cannot produce entanglement. They concluded that circuits containing only one- and two-qubit gates with depolarizing noise at least 74% can be simulated efficiently on a classical computer.

An improvement of this is due to Virmani et al. [\cite=VirmaniHuelgaPlenio04] who show that the set consisting of CNOT with depolarizing noise at least 67% and arbitrary 1-qubit gates is efficiently simulable classically. In this paper they also introduce the interesting idea that sufficiently noisy 1-qubit gates can be simulated by Clifford gates; we build on and extend this idea in this paper. We note however, that their strongest results are for a restricted class of gates (ones which are diagonal in the computational basis) and dephasing or worst-case noise. They prove that [formula] dephasing noise is enough to make these diagonal gates a mixture of Clifford operations. We extend their results by considering all 1-qubit gates. Note also that dephasing noise is only symmetric around the z-axis, which is natural when considering diagonal gates. Our noise bounds are with respect to depolarizing noise, which is symmetric in all directions, and hence appropriate when considering arbitrary one-qubit unitaries.

Note that all these results do not exclude the possibility that quantum circuits with high noise can still do universal classical computations; our results imply this.

The only prior result of this latter type is due to Razborov [\cite=R03], where a 50% upper bound on the noise threshold for depolarizing noise on qubits for circuits with two-qubit gates is obtained (and a weaker bound for k-qubit gates). The argument in [\cite=R03] is essentially that, at this noise level, any superlogarithmic-depth quantum circuit (with constant error rate per qubit per time step) will be overwhelmed by the noise and produce a statistically meaningless outcome. Thus, under the complexity theoretic assumption BQP  ≠  QNC1, there are sets in BQP which can be computed with this noise level. We note that it is shown in [\cite=CleveW00] that in fact log-depth quantum circuits can perform interesting feats, including efficient integer factorization (if combined by classical polynomial-time pre- and post-processing). Our error model is in most respects weaker than that of [\cite=R03] (since our qubit errors are only occurring at the completion of non-Clifford gates) and our bound of ≈  45% is below 50%. In fairness, there is a sense in which the bound in [\cite=R03] is stronger: it permits arbitrary (noisy) two-qubit gates; whereas, our only two-qubit gates are (perfect) CNOT gates.

Finally, we note that our work is related to, and partly stimulated by, the circle of ideas surrounding measurement-based quantum computation that was largely initiated by [\cite=GottesmanC99] [\cite=RaussendorfB01].

Preliminaries and Notation

Eij is the all-zero matrix, except for the entry i,j which is equal to 1. We also write +   for + 1 and -   for - 1. For matrices [formula] we define the inner product [formula] as:

[formula]

The following fact is used repeatedly: [formula] for [formula].

By [formula] we denote the conjugate transpose of matrix A.

An n-qubit state (or density matrix) ρ is a matrix [formula] with the properties tr(ρ) = 1, ρ  =  ρ* (Hermiticity) and ρ is positive semi-definite. An n-qubit operation (or gate) is a unitary matrix [formula], i.e., [formula]. For such n-qubit state ρ and n-qubit operation U the application of U to ρ results in the state UρU*.

Bloch-vector representation

In our further analysis it will be convenient to use the Bloch-sphere representation of 1-qubit states and 1-qubit operations, which we review now (see e.g. Section 4.2 and Chapter 8 in [\cite=NC00]).

For [formula] define [formula], where [formula] is the vector of Pauli matrices

[formula]

Then, all 1-qubit density matrices ρ can be uniquely written in the form

[formula]

where [formula] and [formula]. We call [formula] the Bloch vector of ρ.

For [formula] with [formula] and [formula] we define

[formula]

We first note that [formula], i.e., [formula] is unitary. Second, let the result of the quantum operation [formula] applied to state [formula] be [formula]. Then [formula] is the image of rotating [formula] around [formula] by an angle θ. Third, all 1-qubit unitaries U can be written as

[formula]

with [formula] and [formula] (ignoring an unimportant phase factor [formula] with |α| = 1).

Thus, one-qubit states and unitaries are isomorphic to vectors ,resp., rotations in [formula]. The set of all rotations in [formula] is the group SO(3). We introduce some notation reflecting this isomorphism. For unitary [formula] we let RU∈SO(3) be the corresponding rotation matrix. We get a reverse operation (up to phase factors) by fixing one mapping [formula] with the property that for all unitary [formula] it holds f(RU) = αU for some [formula], |α| = 1. We then write UR = f(R).

This can be extended to probabilistic mixtures of quantum operations. Let {pi} be a probability distribution, i.e., [formula] and 0  ≤  pi, and let [formula] be a 1-qubit unitary with corresponding Bloch representation [formula]. Then the quantum operation E in which each Ui is applied with probability pi has Bloch-representation [formula].

Noise

There are several models of noise considered in the literature. The most common one, which we consider too, is depolarizing noise. A 1-qubit state ρ to which depolarizing noise p is applied, becomes

[formula]

Thus, with probability 1 - p the state is not changed and with probability p the state is replaced with the completely mixed state.

It is not hard to see that applying depolarizing noise p to [formula] yields [formula], with [formula]. So, this noise shrinks the Bloch vector of a state to (1 - p) of its original length.

We say that a 1-qubit gate implements the unitary U with noise p if it transforms states ρ into

[formula]

This quantum operation can be seen as a two-stage process, in which first U and then depolarizing noise is applied. Let [formula] be the rotation matrix corresponding to the unitary U. Then this noisy quantum operation has Bloch-representation (1 - p)RU, i.e., it rotates a Bloch vector and scales it by a factor 1 - p.

For 1-qubit gates and depolarizing noise, the two representations are (up to unimportant global phase factors) equivalent. (See Section 8.3 in [\cite=NC00] for more details.)

Clifford group

The (n-qubit) Clifford group contains all unitary operations that can be written as a product of tensor products of S,H and CNOT (see Eq. ([\ref=Cliffords])). The Clifford group contains also all Pauli operators X,Y,Z. We let Clifford be the set of all Clifford gates. Let Clifford be the set of gates consisting of Clifford and arbitrary 1-qubit gates which have depolarizing noise at least [formula].

For a state with Bloch vector [formula] we get:

[formula]

Let RS be the Bloch representation of S. Then RS rotates Bloch vectors around the z-axis by π / 2. In particular, the x-axis is mapped to - y and y to x. For the Hadamard-gates we similarly have

[formula]

So the Bloch representation RH of H negates the y-coordinate of a Bloch vector and swaps the x and z-coordinates, i.e., it is a rotation by π around the axis [formula].

We define [formula] as the set of matrices which can be generated from RS and RH. A [formula] is called a Clifford (rotation) matrix. It is not hard to see that [formula] contains exactly those rotations which map axes to axes (or their opposite). Those C have in each row and column exactly one non-zero entry, which must be either + 1 or - 1, and det(C) = 1. Note that C, being isomorphic to the 1-qubit Clifford group, is a group under matrix multiplication. Examples of Clifford matrices are

[formula]

In Appendix [\ref=secFacets] we need (and explain) more details about Clifford rotation matrices.

Communication Complexity

The setting for this is the following: Assume two separated parties, Alice and Bob, where Alice is given x∈{0,1}mA and Bob y∈{0,1}mb, want to compute f(x,y) for some fixed function f:{0,1}mA  ×  {0,1}mB  →  {0,1}. We want that at least one party learns the result f(x,y). In order to achieve this they can communicate bits, according to a predefined protocol. The deterministic communication complexity Cf(n) of f is the smallest number c such that each protocol which always computes the correct result, needs at least c bits of communication for at least one input x,y∈{0,1}n.

It is well-known that there are functions f where Cf(n) is n, for example the inner product function (see [\cite=KN:comm]). The above can be extended to randomized communication, where the parties are additionally provided with a source which sends a sequence of random bits to Alice and the same sequence to Bob. The final result only has to be correct with some probability 1 - ε for ε < 1 / 2. The minimum number of bits needed to be communicated such that the output is correct with probability at least 1 - ε is denoted by Cεf(n). However, also in this randomized setting there are "hard" functions. For example, it is known that the inner product function has randomized communication complexity n - O( log (1 / δ)), if the outputs have to be correct with probability at least 1 / 2 - δ (see also [\cite=KN:comm]).

We will also slightly abuse notation and define communication complexity for functions f:{0,1}n  →  {0,1} which depend only on one input string. For any [formula] let Cf(n,S) be the communication complexity of f if the bits with indices in S are given to Alice and all others to Bob. We then set [formula].

The power of Clifford circuits

We are now ready to prove the main lemma, which explains the idea of simulating Clifford circuits.

We begin by noting that each qubit can be represented by two shares: a classical share consisting of two bits, and a quantum share consisting of one qubit . When the classical share is ab and the quantum share |ψ〉, then the logical qubit that the shares encode is XaZb|ψ〉.

Assuming that a set of qubits is encoded in this manner, the operations H, S, and CNOT can be applied to the logical qubits by separately performing operations on the shares that encode them (i.e., the logical qubits do not have to be reconstructed). The reason why this works is because for any Clifford operation C = H,S,12 and any tensor product of Pauli operators P1 there is a tensor product of Pauli operators P2 with CP1 = P2C. For example, to apply H to a logical qubit, the two bits that make up its classical share are swapped and H is applied to its quantum share. This works correctly because

[formula]

and [formula] is an irrelevant global phase.

To apply S to a logical qubit, the b-part of the classical share is updated to [formula] and S is applied to its quantum share. This case can be verified by noting that

[formula]

where we note that ia is a global phase.

To simulate the application of 12 gate on two logical qubits, with classical shares a1b1 and a2b2, we update [formula], [formula] and 12 is applied to the two quantum shares. In this case, we omit the details but note that the correctness can be verified using the identities

[formula]

We first describe a probabilistic communication protocol for f. Alice operates on the classical shares while Bob operates on the quantum shares. The initial shares are easy to construct: for each of Alice's input qubits |xj〉, Alice sets her classical share to aj: = xj,bj: = 0 and Bob sets his quantum share to |0〉; for each of Bob's input bits yj, Alice sets her classical share to aj = bj: = 0 and Bob sets his quantum share to |yj〉. In this manner, Alice and Bob can simulate the execution of circuit C on input [formula] without any communication to obtain the shares of the output qubits of C. For Bob to obtain the measured output qubit, Alice sends the first bit of her classical share, a1, to Bob, who applies Xa1 to his quantum share and measures it (Alice need not send b1, the second bit of the classical share, since Bob is performing a measurement in the computational basis).

Finally, to obtain a deterministic communication protocol for f, we note that Bob need not actually manipulate quantum information; rather, he can simulate his quantum registers and his operations with high enough precision on a classical computer. Then, upon receipt of the classical bit from Alice, he can exactly determine the output probabilities of his measurement to determine which outcome is more likely.

From Lemma [\ref=lemmaMain] we get that the set of functions computable with Cliffords gates is very limited and far from being universal.

Let f:{0,1}n  →  {0,1} be a function which can be computed by a Clifford circuit C. Then we can simulate this circuit as in Lemma [\ref=lemmaMain], where we give Alice the whole input, i.e., mA = n and mB = 0.

Inspecting the proof of Lemma [\ref=lemmaMain] we see that in each step Alice always updates her ai's and bi's by computing the parity of two bits. So, the final bit she sends over, say ai, is just the parity of some of the input bits. Thus we can write [formula], for some S  ⊆  [n]. Bob initializes all his quantum bits to |0〉, so he starts with the state [formula]. Further, Bob just applies the circuit C to his state and measures the i-th qubit of XaiC|ψ0〉 in the computational basis.

It is known that the probability for measuring 1 in a Clifford circuits is either 0, 1 / 2 or 1 (see [\cite=NC00] page 463). It cannot be 1 / 2 in our case, because that would mean that the circuit does not compute f. So, measuring the i-th bit of C|ψ0〉 yields a bit c∈{0,1} with certainty. But this means that [formula].

We mention that Aaronson and Gottesman proved [\cite=AaronsonGottesman04] that there is a log-space machine which transforms a Clifford circuit C into a classical circuit C' consisting only of CNOT and NOT gates, with the property that C accepts the all zero state [formula] iff C' accepts the (classical) all zero input. Our corollary extends this slightly: For every Clifford circuit C computing a boolean function, there is an equivalent (for classical inputs) classical circuit which uses only NOT- and CNOT-gates. Using the result from [\cite=AaronsonGottesman04] we see that we can compute the bit c in the proof of Corollary [\ref=corParity] in log-space and it is also clear that the circuit Alice uses to compute ai can be computed in log-space.

Quantum inputs

Lemma [\ref=lemmaMain] can actually be extended to she case where Alice and Bob get quantum states as inputs and they are provided with entanglement. It is no problem for Bob to start with a quantum state as an input. For Alice we do the following. We let her teleport her quantum input to Bob bit by bit, using the standard scheme for teleportation (see e.g. [\cite=NC00]). When Alice teleports a qubit, which corresponds to the i-th input qubit of the circuit C to be simulated, she measures two classical bits. Now, if she does not send these to Bob, but rather initializes her ai,bi with these bits, Alice and Bob obtain the correct representation for qubits of C as in Lemma [\ref=lemmaMain]. Since the inner product function has communication complexity Ω(n) even in the presence of entanglement [\cite=CDNT:InnerProduct] we see that Theorem [\ref=theMain] is also true for quantum inputs.

Note however, that now Bob can no longer compute the result of the circuit with certainty, because he does not know his input state. The correctness probability will only be the same as that of the simulated circuit C itself.

Simulating unitaries

We want to extend Lemma [\ref=lemmaMain], by replacing Clifford  with Clifford. To do that we first show how one can simulate arbitrary 1-qubit gates with depolarizing noise [formula] with a probabilistic mixture of Clifford operations.

Using Section [\ref=subsecBloch] the lemma can be reformulated equivalently in Bloch representation: For any S∈SO(3) there is a probability distribution {pC} over [formula] such that

[formula]

We will prove this latter statement. Define the Clifford polytope

[formula]

as the convex hull of the 24 Clifford rotation matrices in [formula]. We have to prove

[formula]

For this we use the fact that the Clifford polytope can be alternatively described by its facet description:

[formula]

where

[formula]

One can use the software from [\cite=KF] for computing the facet description ([\ref=eqCs]); we will give a direct proof in the Appendix. In view of ([\ref=eqCs]), our claim ([\ref=toprove]) is equivalent to

[formula]

Let F∈F of the form F = C1BC2 where [formula]. As [formula] and CT1SCT2∈SO(3), ([\ref=toprove1]) is equivalent to

[formula]

The case B = B1 is easy to handle: For S∈SO(3), [formula]. We now show ([\ref=toprove2]) for B = B2. Write [formula] as

[formula]

Well-known necessary and sufficient conditions for S∈SO(3) are

[formula]

where ×   denotes the vector product, defined as

[formula]

Recall that, for [formula] as in ([\ref=eqCond]), [formula] Using c3 = a1b2 - a2b1, we obtain [formula]. Therefore our task is now to prove that the optimum value of the program

[formula]

is at most [formula]; we in fact show that [formula]. For this, consider a global maximizer (a,b) to the program ([\ref=toprove3]). Then, the Karush-Kuhn-Tucker conditions have to be satisfied, since the gradient vectors [formula] are linearly independent; see, e.g., Theorem 12.1 in [\cite=NocedalWright]. (Here, the gradient vector [formula] consists of the partial derivatives with respect to the six variables [formula].) That is, there exist scalars λ1,λ2,λ3 for which

[formula]

Equivalently, considering the partial derivatives first with respect to (a1,a2,a3) and then with respect to (b1,b2,b3)

[formula]

Multiplying the first and the second line by [formula] (recall that [formula]) we get

[formula]

Adding (resp. subtracting) these equations yields 2c1 =  - a3 - b3 and 2c2 = a3 - b3. Squaring these two equations and then adding them gives 2a23 + 2b23 = 4c21 + 4c22. Since the rows and columns in S are normalized, we get 2(1 - c23) = 4(1 - c23), from which we conclude c23 = 1 and, therefore, a3 = b3 = c1 = c2 = 0. This implies a21 + b21 = 1 = a21 + a22 and thus |b1| = |a2|. Similarly one can establish |a1| = |b2|. On the basis of this observation we distinguish three cases.

a1 = b2 = 0. Then, |a2| = |b1| = 1 and f =  - a2 + b1 + a2b1  ≤  1.

a1  ≠  0 and a1 =  - b2. From aTb = 0 we have a1(b1 - a2) = 0, which gives a2 = b1. Then, f  =  a1 - a2 + a2 - a1 + a21 + a22 = 1.

a1  ≠  0 and a1 = b2. From aTb = 0 we have a1(b1 + a2) = 0, which gives a2 =  - b1. Then, f = a1 - a2 - a2 + a1 - a21 - a22 = 2(a1 - a2) - 1, which (under the condition a21 + a22 = 1) is clearly maximized by [formula]. Therefore, we find [formula].

Thus, we have shown that the optimum value of the program ([\ref=toprove3]) is equal to [formula], which concludes the proof.

From Lemma [\ref=lemmaMain] we know how two parties, Alice and Bob, can simulate perfect Clifford gates. From Lemma [\ref=lemmaSimulate] we know how they can jointly simulate the other noisy 1-qubit gates in [formula], where they use shared randomness to make sure that they always simulate the same Clifford gate.

We can now prove an upper bound on the noise in fault-tolerant quantum computation.

The result follows by Lemma [\ref=lemmaqMain] and the fact that there are functions with communication complexity greater than 1. In fact we have that none of the functions with unbounded error communication complexity Cunboundedf > 1 can be computed.

Discussion and extensions

Best gates

From the proof of Lemma [\ref=lemmaSimulate] we see that the rotation matrix S which achieves the optimal value, is

[formula]

Multiplying from the right by the Clifford-matrix diag(1, - 1, - 1) we get a rotation around the z-axis by π / 4. The π / 8-gate

[formula]

performs a rotation of π / 4 around the z-axis. So, the π / 8-gate and its symmetric versions are the ones which need the most depolarizing noise to be simulated by gates from Clifford.

Worst case noise

In Lemma [\ref=lemmaSimulate] we asked with how much depolarizing noise all 1-qubit unitary gates are equivalent to probabilistic mixtures of Clifford gates. Similarly to [\cite=VirmaniHuelgaPlenio04] one can also ask how much arbitrary noise is needed to make every gate a mixture of Cliffords. More precisely what is the value   =   sup U∈SU(2)pU , where pU is the infimum of all p such that there is a completely positive trace-preserving 1-qubit quantum operation EU with the property that the noisy implementation of U

[formula]

becomes a probabilistic mixture of Clifford operation.

In this section we will provide some bounds on [formula]. Let K∈SU(2) be any operation that in Bloch representation maps the state X-eigenstate vX = (1,0,0) to [formula]. Note that a probabilistic mixture of 1-qubit Clifford operations [formula] can map vX only into the octahedron O spanned by vX = (1,0,0), vY = (0,1,0) and vZ = (0,0,1) and their negatives - vX, - vY, - vZ (see also [\cite=BK:Magic]). Note that the state of O which is closest to u is [formula] and their distance is [formula]. The Bloch-state which is furthest away from u is - u. All three of these states lie on a line. With this it is clear that the state unoise which needs the smallest noise p, such that (1 - p)u + punoise is inside the octahedron is - u and the optimal p is [formula]. This implies [formula].

To get an upper bound, recall that by Lemma [\ref=lemmaSimulate] for any gate U∈SU(2) the operation

[formula]

is a Clifford operation, if [formula]. Setting [formula] and noting that for any 1-qubit density matrix it holds [formula] we can rewrite the action of U' also as

[formula]

Thus [formula]. Note that this is certainly not tight, since all gates, apart from the π / 8-gate (and its symmetric versions), need less than [formula] depolarizing noise to make it a probabilistic mix of Clifford operations, which implies they need less than [formula] worst case noise. However, as follows from [\cite=VirmaniHuelgaPlenio04], the worst case noise for the π / 8-gate(s) is only [formula].

We leave it as an interesting open question to determine the precise value of [formula].

Classical Co-processing

Theorem [\ref=theMain] states that fault tolerant quantum computing is not possible if we have depolarizing noise at least [formula] on one qubit gates even if we can use perfect gates from [formula] in our fault tolerant circuit design. Is this optimal? Could it be that with less than [formula] noise on the single qubit gates and perfect gates from [formula] still no fault tolerant circuit design is possible. We leave this as an open question, but Ben Reichardt [\cite=R:personal05] pointed out that when we allow perfect classical computation in addition to perfect gates from [formula] and perfect measurements in the computational basis, for any quantum circuit one can build a fault tolerant quantum circuit, that tolerates noise less than [formula] on single qubit gates. This fault tolerent implementation has only a constant factor slowdown in time.

The argument builds upon magic-state distillation, introduced in [\cite=BK:Magic], and goes as follows. Assume we have at our disposal noisy π / 8-gates T', with depolarizing noise strictly less than [formula], i.e. [formula] with [formula], where T is the perfect π / 8 gate. Then apply T' to the second half of an EPR-pair and measure the observable [formula], which can be implemented as a measurement in the computation basis with additional gates from [formula]. If the outcome is - 1 throw away the state and do the experiment again. If the outcome is + 1, apply a CNOT from the first to the second qubit, which gives

[formula]

Using the result from [\cite=R:Magic] an arbitrary supply of qubits in the state of the first qubit of ([\ref=magic]) can be used to distill magic states in the H-direction, which together with stabilizer operations is sufficient for quantum computation. We do not know if this also holds for other than the π / 8-gate.

Note the this is tight for the π / 8-gate, since stabilizer operations (Cliffords, measurements in the computational basis and classical co-processing)together with π / 8-gates with depolarizing noise  can be efficiently simulated classically, as follows from our Lemma [\ref=lemmaSimulate] and the Gottesman-Knill Theorem.

Allowing some perfect unitaries

Our threshold theorem says the following. Let f be a function such that it requires more than one bit of communication in order to compute it, when the input bits are partitioned over Alice and Bob. There is no quantum circuit consisting of perfect Clifford operations and single qubit gates with noise   (≈  45%) that can compute f. We can strengthen this result to allow a small amount of perfect single qubits as well. Assume that f requires m bits of communication to be computed. There is no quantum circuit that uses perfect Clifford operations, s perfect single qubit gates, and single qubit gates with noise   that computes f, for 2s + 1  <  m. The reason we get this strengthening is because in our simulation, Lemmas 1 and 2, Alice sends to Bob whenever he wants to perform a perfect single qubit gate on some qubit, her classical share a and b of that specific qubit. Bob can now perform the perfect qubit gate on that qubit and they proceed as in Lemma 1 and 2. By the end of the simulation Alice has sent 2s + 1 bits to Bob and he will be able to compute f, contradicting that the communication complexity of f is at least m > 2s + 1.

Acknowledgements

We thank Neboj sa Gvozdenovi and Hartwig Bosse and also Troy Lee, Ben Reichardt and Stephanie Wehner for useful discussions and Komei Fukuda for providing the software cdd+ [\cite=KF]. We also thank Scott Aaronson and Daniel Gottesman for discussions about their work. We are also grateful to the Newton Institute, Cambridge, where this work was started.

Computing the facets of the Clifford polytope

We give here the facet description for the Clifford polytope P defined in ([\ref=polytope]) as the convex hull of the set [formula] consisting of the 24 Clifford rotations of the 3-space. Define the polyhedron

[formula]

where F is as in ([\ref=eqFB]). Our objective is to show the equality P = Q.

To start with, let us prove the easy inclusion P  ⊆  Q. For this, let [formula] and F∈F of the form F = C1BC2 with [formula] and B∈{B1,BT1,B2}. Then, [formula]. As [formula], it suffices to verify that [formula] for any [formula] and B = B1,B2. (We have used here the fact that [formula] is a group which is closed under transposing matrices.) For [formula], the inequality [formula] is obvious and the inequality [formula] can be checked by direct inspection.

The reverse inclusion Q  ⊆  P follows from the following result.

The rest of the Appendix is devoted to the proof of this result. We first need to go in more detail into the structure of the Clifford matrices.

Preliminaries about the Clifford matrices

Each matrix [formula] corresponds to a "signed permutation" (σ,s), where σ∈Sym(3) and s∈{  ±  1}3. Namely, C has nonzero entries precisely at the (σ(i),i)-positions with Cσ(i),i = si for i = 1,2,3; we then also denote C as Cσ,s. The condition det (C) = 1 translates into s1s2s3  =  sign(σ); that is, s1s2s3  =  1 if σ is an even permutation (i.e., one of σ1: = (1,2,3), σ2: = (2,3,1), σ3: = (3,1,2)) and s1s2s3  =   - 1 if σ is an odd permutation (i.e., one of σ4: = (1,3,2), σ5: = (2,1,3), σ6: = (3,2,1)). Thus the set [formula] of Clifford matrices is naturally partitioned into six subclasses

[formula]

with [formula]. For convenience we display in the table below the six subclasses [formula]; the nonzero entries are indicated by *  .

[formula]

Table 1

The following observation can be directly verified and will be useful for the proof.

We now proceed with the proof of Theorem [\ref=theo0]. Let [formula] be an inequality defining a facet of P, where [formula] and [formula]. That is, the inequality [formula] is valid for P, which means that [formula] holds for any S∈P, and the set

[formula]

contains nine affinely independent matrices. Without loss of generality, we may assume that b = 1. Indeed, b  ≥  0 since 0∈P. Moreover, b > 0 for, otherwise, we would have Fij = 0 for all i,j = 1,2,3, implying F = 0, in view of Observation [\ref=ob0]. Thus, by rescaling, we can now assume that the facet is of the form [formula]. We sometimes speak of the "facet F" for short. Our objective is to show that F = C1BC2 for some [formula], B∈{B1,BT1,B2}.

Call [formula] equivalent if F' = C1FC2 for some [formula]. Then, as [formula] is a group, [formula] defines a facet of P if and only if [formula] does. Moreover, [formula]. This property will be used repeatedly throughout the proof as it permits to exploit symmetry and to reduce the number of case checking.

The proof is based on a detailed inspection of the structure of the set [formula]. We begin with collecting several properties of the matrix F and the set [formula].

If [formula], then [formula] for any [formula], which implies [formula], contradicting the fact that [formula] by Observation [\ref=ob0].

Let [formula] with Cij = d. There exists [formula] with C + C'  =  2dEij. Summing [formula] and [formula] yields [formula]. As [formula], we have the equalities [formula], which implies [formula].

Equality Fσ(i),i = d follows from the fact that C + C' = 2dEσ(i),i. Then, [formula] implies 0 = Fσ(j),jCσ(j),j + Fσ(k),kCσ(k),k. Using Cσ(i),iCσ(j),jCσ(k),k  =  sign(σ), we find Fσ(j),j  +  sign(σ)dFσ(k),k = 0.

Our last observation is an easy corollary of the former two observations.

One can verify that, for F = B1,BT1, [formula] for all σ∈Sym(3) while, for F = B2, [formula] for σ  =  σ1,σ5. Based on this observation we now distinguish two cases: Either, [formula] for all σ∈Sym(3) (in which case we show that F is equivalent to B1 or BT1), or [formula] for some σ∈Sym(3) (in which case we show that F is equivalent to B2).

The case [formula] for some σ∈Sym(3)

Using symmetry, we may assume that [formula] for the (odd) permutation σ  =  σ4. We prove this in detail to show how this kind of symmetry argument works. Define the matrices

[formula]

lying, resp., in [formula] [formula], [formula]. Recall that + , -  stand for 1, - 1, respectively. Our assumption is that [formula] for some [formula]; we show that one can replace F by another equivalent facet F' in such a way that i = 4 holds. For this, suppose first i = 2,3. As the mapping X  ↦  XCi maps [formula] to [formula], we can replace the facet F by F': = FCi and then we find [formula] since [formula]. Thus we may assume [formula]. As the mapping X  ↦  XC1 maps [formula] to [formula], replacing the facet F by F': = FC1, we find [formula]. Thus we can now assume [formula] for some i = 4,5,6. If i = 5, as the mapping X  ↦  XC3 maps [formula] to [formula], replace F by F': = FC3; if i = 6, the mapping X  ↦  XC2 maps [formula] to [formula] and one can replace F by F': = FC2; in both cases we get back to the case when [formula].

Thus we now assume [formula]. Moreover, we may assume that the following matrices from [formula]

[formula]

belong to [formula]. (To see this, replace if necessary F by FC, where [formula].) Using Observation [\ref=ob3], we obtain F11 =  - 1,F23 =  - 1,F32 = 1. From this we get by Observation [\ref=ob2] that also the matrices

[formula]

belong to [formula]. By Observation [\ref=ob3], we also obtain F22 = F33, F12 = F31 and F13 =  - F21.

Assume for contradiction that, for i = 1,2,3, the set [formula] contains only the respective two matrices from ([\ref=U1])-([\ref=U3]). Choose a subset [formula] consisting of nine affinely independent matrices and such that [formula]. We have [formula], since the two matrices in ([\ref=U1]) are affinely dependent with the last two matrices in ([\ref=3matrices]). Similarly, [formula], [formula]. As |B| = 9, we deduce that [formula] or [formula]. Assume first that [formula]. Say, [formula]. Then C and C' have the same nonzero entry d∈{ - 1,1} in some position (k,l). By Observation [\ref=ob3] this yields Fkl = d. Now, there is also an even permutation σ for which k = σ(l). By Observation [\ref=ob2] we then deduce that at least two matrices from [formula] must be in [formula], which contradicts our assumption. The other case [formula] goes analogously.

It is sufficient to consider the case [formula]. Indeed, if [formula], then one may replace F by C3FC4 with C3 as in ([\ref=3matC]) and

[formula]

since the mapping X  ↦  C3XC4 maps [formula] to [formula] and preserves the set of three matrices from ([\ref=3matrices]), as well as the set of 6 matrices from ([\ref=U1])-([\ref=U3]) (namely, ([\ref=U1]) →   ([\ref=U3]) →   ([\ref=U2]) →   ([\ref=U1])). One can handle the case when [formula] in the same way.

The set [formula] already contains the matrices

[formula]

from [formula] (displayed in ([\ref=U1])). The remaining two matrices of [formula] are

[formula]

If [formula], one may replace the facet F by F': = D2FD1 to obtain that [formula], since the mapping X  ↦  D2XD1 maps {D1,D2,D4} to {D1,D2,D3} and leaves the set of 3 matrices from ([\ref=3matrices]) invariant as well as the set of 6 matrices from ([\ref=U1])-([\ref=U3]). Thus we may assume that [formula].

By Observation [\ref=ob3], we find that F33 = F22 = 1. As F22 = 1, Observation [\ref=ob4] implies that F31 = F13. Similarly, F33 = 1 implies that F12 = F21. Putting all equations together we obtain F12 = F21 =  - F13 =  - F31 =  - F12, implying they are all zero. Thus

[formula]

The case [formula] for all σ∈Sym(3)

Let again [formula] consist of nine affinely independent matrices. As [formula], [formula] for at least three permutations σ. W.l.o.g. we can assume that two of those permutations are odd permutations and that they are equal, say, to σ4 and σ6 (replacing if necessary F by an equivalent facet). Further we may assume [formula] contains the following two matrices of [formula]:

[formula]

This can be seen using the following two mappings X  ↦  C2XC2 (with C2 defined as in ([\ref=3matC])) and X  ↦  CX (with [formula]) which permit to map any subset of size 2 of [formula] to any other such subset and which preserve [formula] as well. We choose the basis B containing the two matrices of ([\ref=BU1]). >From Observation [\ref=ob3] we find F11 =  - 1 and F23 =  - F32  ≠    ±  1; the latter inequality follows from the fact that [formula] combined with Observation [\ref=ob2]. As F11 =  - 1, by Observation [\ref=ob2],

[formula]

and Observation [\ref=ob3] implies F22 = F33  ≠    ±  1. At most one of the two matrices in ([\ref=BU4]) belongs to B since they are affinely dependent with the matrices in ([\ref=BU1]). Say, [formula].

Let us now examine which two matrices of [formula] belong to [formula]. Set

[formula]

The two mappings X  ↦  XC5 and X  ↦  C5X preserve the set of matrices in ([\ref=BU1]) and permit to map any other matrix of [formula] to the matrix X1. Therefore we can assume w.l.o.g. that [formula]. The second matrix of [formula] does not have entry - 1 at the position (2,2) since, otherwise, F22 =  - 1 contradicting an earlier claim. Hence the second matrix in [formula] is

[formula]

Consider first the case when [formula]. Then, F31 =  - 1 and F22 =  - F13  ≠    ±  1. As F31 =  - 1, we have

[formula]

and F12 = F23  ≠    ±  1. As B contains at most three of the matrices X1,X2 and in ([\ref=BU5]), we must have [formula] or [formula]. We obtained eralier that F33 = F22 =  - F13  ≠    ±  1 and F12 = F23 =  - F32  ≠    ±  1. In other words, the second and third columns of F contain no entry ±  1. On the other hand, the two matrices from [formula] (i = 2,5) have one common nonzero entry which therefore is located in the first column, at the position (2,1). This implies F21  =    ±  1.

If F21 = 1, then Observation [\ref=ob4] implies F12 = F33 and F13 =  - F32. Combining with the former relations on entries of F, we find

[formula]

If F21 =  - 1, then in the same way we find

[formula]

In both cases we find that F is equivalent to B1.

Consider now the case when [formula]. Then, F13 =  - 1, F22 =  - F31  ≠    ±  1,

[formula]

and F21 = F32  ≠    ±  1. In the same way as in the first case one finds that F is equivalent to BT1.

This concludes the proof of Theorem [\ref=theo0].