A Low Complexity Algorithm and Architecture for Systematic Encoding of Hermitian Codes

Introduction

Algebraic-Geometric (AG) codes [\cite=goppa] offer desirable properties such as large code lengths over small finite fields, the potential to find a large selection of codes and good error-correction at high code rates [\cite=perform]. In recent years, an important class of one-point AG codes, called Hermitian codes, has been frequently discussed [\cite=generalrs]-[\cite=structure].

For a Hermitian code defined over GF(q2), a brute-force way to design an encoder is to multiply the information vector by a generator matrix. The space complexity of a serial-in serial-out architecture for this systematic encoder is O(q5) in terms of finite field multipliers and O(q3) in terms of memory elements. The encoder requires 2n clock cycles to generate a codeword of length n, thus, the latency is n.

By considering a Hermitian code as a superposition of several generalized Reed Solomon (RS) codes, an encoding scheme is introduced in [\cite=generalrs2]. In [\cite=shen], an encoding algorithm by forming a bivariate information polynomial and evaluating this polynomial at every finite rational point on the Hermitian curve is proposed. However, both such schemes are nonsystematic and involve the evaluation of bivariate polynomials at n finite rational points, thus, they may not have efficient hardware architecture for implementations.

A computationally efficient approach for systematic encoding was proposed in [\cite=grobner]. A serial-in serial-out architecture for this approach was proposed in [\cite=serialinout]. This architecture requires n clock cycles to encode a codeword of length n. The space complexity for this architecture is O(q3), both in terms of finite field multipliers and memory elements.

In this paper, we present an algorithm for systematic encoding and syndrome computation of Hermitian codes. We give an outline for the encoder architecture, which uses q varying-rate RS encoders as main blocks and requires n2 / 3 clock cycles for encoding a codeword of length n. The space complexity of the architecture is O(q2) in terms of both, memory elements and finite field multipliers.

Hermitian Codes and Syndrome Computation

We consider codes from a Hermitian curve over a finite field [formula]. The space L(mP∞) consists of all functions on χ that have a pole of multiplicity at most m only at the unique point at infinity. For L(mP∞), we choose a basis

Let y0 be an element of [formula] such that y0  +  y0q  =  1. The affine rational points on χ are of the form where δ is the Kronecker-delta and α and β represent arbitrary elements in [formula] and [formula] respectively.

Let ε be a primitive element in [formula] and let γ be a primitive element in [formula]. We label the positions in a codeword by the corresponding elements α = εi, β = γj and we thus naturally consider a codeword as a q  ×  q2 matrix [formula]. Occasionally we will index elements in this array by elements of the fields [formula] and [formula], otherwise we index starting with 0.

A Hermitian code C(m) is defined as

For an in-depth treatment of AG codes we refer to [\cite=book1]. Throughout this paper we consider m and thus the Hermitian code as being fixed.

Given a q  ×  q2 matrix [formula] we can check if [formula] is a codematrix in a Hermitian code by computing the syndromes [formula] is a code-matrix iff [formula] is zero for all xayb∈L(mP∞). Substituting the explicit form of the points we get These equations can further be developed to give specific forms as shown in ([\ref=eqn_dbl_x]) and ([\ref=eqn_dbl_y]). From the structure of ([\ref=eqn_dbl_y]), it comes naturally to define a matrix as in ([\ref=defA]) to convert the expression into a matrix multiplication. Similarly we define a matrix A' as

For later use we give here the following Lemma.

Lemma 1

The l  ×  l submatrices of A consisting of the elements indexed by i,j and that of A' consisting of the elements indexed by j,i, [formula], [formula] are non-singular.

This lemma follows in both cases from the properties of Vandermonde matrices.

It will be convenient to define an array [formula] of matrices of type A and A'.

Given a q  ×  q2 array [formula] with columns [formula], we define a q  ×  q2 matrix [formula] with columns [formula] as

One of the main ingredients in both the syndrome calculation and a systematic encoding is the use of techniques for cyclic codes which are extended by one extra position. Let â(b)  =  ⌊(m - (q - 1 - b)(q + 1)) / q⌋  =  max(a:xayb∈L(mP∞)).

Definition 1

Let an ordered set [formula] of elements from [formula] be given. We define the code [formula] as

For the natural indexing of elements in [formula] and [formula] induced by γ and ε we have the following Lemma.

Lemma 2

Let a q  ×  q2 matrix [formula] be given. The matrix [formula] is a code matrix in the Hermitian code C(m) iff the ith row of [formula] is a codeword in [formula].

The proof follows immediately from the syndrome definition.

Codes of type [formula] will play a central roll in the sequel. We define codes Ei as

From Lemma 2 we can derive an efficient way to compute the syndrome for a Hermitian code. Given a received matrix r we obtain a matrix [formula] with columns j = [formula].

Given [formula] we can easily solve the task of computing syndromes provided we can compute the corresponding syndromes for codes [formula].

Systematic Encoding

The idea behind the systematic encoding of Hermitian codes is to use the well known techniques for the systematic encoding of cyclic codes. Lemma 2 almost immediately gives a nonsystematic encoding procedure for Hermitian codes. To this end let [formula] be a q  ×  q2 matrix such that the jth row of [formula] is a codeword in Ej. It follows from Lemma 2 that we can obtain a code-matrix for a Hermitian code by multiplying the columns of [formula] with matrices A- 1 and A'- 1 respectively. We can obtain such a matrix [formula] using eg. systematic encoding procedures for codes of type [formula]

We will need A- 1 and A'- 1.

Lemma 3

The matrices A and A' have inverses given in ([\ref=invA]) and ([\ref=invAi]).

The inverse of A' is straight forward to verify. We only show the inverse of A. The rows of A- 1 and the columns of A may be thought of as being indexed by elements of [formula]. Let C be the matrix obtained as C  =  A- 1A. The entry Ci,j is thought of as being indexed by [formula].

We note that we are entirely free to choose "virtual information symbols" in matrix [formula]. Let a sequence of information symbols be given that are to be encoded systematically in a codeword of a Hermitian code. The trick in obtaining a systematic encoding procedure is to choose the information symbols in [formula] so that the mapping with A- 1 and A'- 1 respectively, gives the primary information symbols that we really want to encode.

Before we derive a systematic encoding procedure for Hermitian codes, we treat a somewhat simpler case, which will elucidate the idea of systematic encoding. Let Ĉ be a code on a Hermitian curve defined as The code Ĉ has dimension (q2  -  â - 1)q. The following algorithm may be used for systematic encoding of code Ĉ.

Algorithm 1

Write the (q2  -  â - 1)q information symbols in an array d of size q  ×  (q2  -  â  -  1)

Compute   =  AdT

Encode the ith row of [formula] independently in a systematic way into codewords of the code Denote the resulting q  ×  q2 matrix with '.

Compute columns ci = A- 1i'i

Algorithm 1 yields a systematic encoding procedure for the code Ĉ because c is a code matrix by Lemma 2 and the first (q2  -  â  -  1)  ×  q symbols are the original information symbols. The first (q2  -  â  -  1) columns of d determine the first (q2  -  â  -  1) columns of [formula]. It is the first (q2  -  â  -  1) columns of [formula] that contain the virtual information symbols for the encoding of the cyclic codes.

The situation for Hermitian codes is complicated by the fact that the codes Ei have different rates. Thus at some instance of the algorithm we have to process the columns that are in one part determined by information symbols and the other part is determined by redundancy symbols generated by the systematic encoders of the codes Ei. For simplicity, we will restrict our attention to codes C(m) of dimension k that is less than (q3  -  g  -  q).

Let [formula] be a systematic encoder for a code Ei. The input sequence to the encoder φi are symbols from an array   =  i,j for [formula].

We want to construct an algorithm that takes as input an array d of size q  ×  q2 with arbitrarily chosen symbols in positions [formula] and zero in the remaining positions and that produces as output a code-array [formula]. Let (j) be defined as the number of information symbols in the jth column of [formula]. The columns of [formula] thus have the form [formula].

We give a systematic encoder procedure in the following algorithm. During the procedure we also construct an array [formula]. The ith row of [formula] is a codeword in Ei. Thus the first q2  -  â(i)  -  1 positions in the ith row of [formula] determine the ith row of [formula] completely.

Algorithm 2

The algorithm is shown in ([\ref=algo2]).

Algorithm 2 computes a code array c of the Hermitian code [formula].

The matrix [formula] in the algorithm satisfies the conditions j = Aj cj and the i-th row of [formula] is a codeword in Ei. Thus c is a code-array by Lemma 2.

Algorithm 2 outlines the mathematical procedure to achieve systematic encoding of a Hermitian code. The real difficulty lies in an efficient implementation of the algorithm. We give such an implementation in Section IV but before proceeding we will need a simple lemma.

Let A be any n  ×  n matrix with inverse A- 1. We assume that the submatrix of A indexed by elements [formula] is nonsingular. This will always be true for the cases that we are interested in by Lemma 1. Let Il denote the l  ×  l matrix and let D(l) be a n  ×  n matrix of the following form: such that for a l  ×  l matrix P̃. We note that D(l)T is just a systematic encoding matrix for a code which has a parity check matrix the first l rows of A- 1.

Lemma 5

Let [formula] and [formula] be given. The solution for [formula] and [formula] to the linear system of equations can be found with the following algorithm.

Algorithm 3

Algorithm 3 is given as shown in ([\ref=algo3]).

A- 1T  =  A- 1DT which proves that [formula] equal zero. Now it follows that

Efficient Implementation of a Systematic Encoder

Inspecting Algorithm 2 and Lemma 4, we see that we need modules for multiplication of an array with matrix A, A- 1, systematic encoding of codes Ej, and a systematic encoding module for codes Dl defined as Before describing the modules in detail we give a black box description and the overall description of the implementation.

Module A: Multiplication with Matrix A,A'

The module has as parallel input a vector d of length q and produces as serial output the numbers [formula] during the next q clock cycles.

Module B: Multiplication with Matrix A- 1,A'- 1

Module B has as serial input a vector d of length q. After q clock cycles the parallel output is a vector A- 1dT.

Module C: Systematic Encoding of Codes Ei

The module has a serial input of q2  -  â(i) - 1 symbols and produce one symbol per clock cycle. The clocking frequency is 1 / q of the overall clock rate.

Module D: Systematic Encoding of Codes Dl

Module D takes a serial input of length l and produces as serial output a codeword of length Dl.

Encoder

Figure [\ref=fig3] outlines the overall implementation. When the left hand input becomes valid, the output of Module A is added to the negative output of Module C, effectively implementing steps 1 and 2 of Algorithm 3. The sum is fed to Module D which implements step 3 of Algorithm 3. The output of Module D is combined with the output of Module A to implement step 4 of Algorithm 3. Simultaneously it is fed to module B of the implementation. After q clock cycles the output of Module B is added to the input thus implementing step 5 of Algorithm 3.

Module C can be implemented as an obvious modification of a systematic encoding circuits for RS codes [\cite=encode].

Module D implements systematic encoding of a code with parity check matrix given by first l rows of matrix A- 1. From the form of matrices A- 1, we see that code Dl may be defined as and we can use standard encoding techniques for shortened cyclic codes which are modified in the obvious way.

Final Remarks

A low complexity algorithm for systematic encoding and syndrome computation of Hermitian codes has been presented. The algorithm has a run time complexity of O(n2 / 3) and is suitable for VLSI implementation. We give an outline for the encoder architecture, which uses as main blocks, q varying-rate Reed Solomon encoders. The architecture achieves a much lower space complexity in terms of finite field multipliers and memory elements when compared to earlier reported works.

Acknowledgement

The authors would like to thank Science Foundation Ireland, Claude Shannon Institute and Deutsche Forschungsgemeinschaf for supporting parts of this research work.