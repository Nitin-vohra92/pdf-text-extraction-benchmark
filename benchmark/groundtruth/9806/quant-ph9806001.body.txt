Lower Bounds of Quantum Search for Extreme Point

Introduction and Background

In 1996 L.Grover has constructed quantum algorithm which finds the solution of equation f(x) = 1 in time [formula] where n is the length of word x provided this solution is unique, N = 2n, (look in [\cite=Gr] ). His algorithm is the sequential applications of the following steps:

1. - WR0W - diffusion transform.

2. Rf - rotation of the phase for solution,

where W is Walsh-Hadamard transform defined by

[formula]

R0(|0〉) =  - |0〉, R0(|e〉) = |e〉 for basic states |e〉  ≠  |0〉, and Rf(|x〉) = |x〉 for f(x) = 0 and Rf(|x〉) =  - |x〉 for f(x) = 1.

Soon after this M. Boyer, G. Brassard, P. Hoyer and A. Tapp have shown how arbitrary solution of this equation can be found in time [formula] where t is the number of all solutions which is unknown beforehand. They used iterations of Grover's algorithm and measurements which allow to determine the length of the following sequence of iterations ([\cite=BBHT]). This algorithm is referred here as G-BBHT. The problem of searching for extreme point of integer function φ: {0,1}n  →  {0,1}n was solved by C. Durr and P. Hoyer in the work [\cite=DH]. Let an oracle Oφ give a value φ(x) for every x∈{0,1}n. The aim is to find a point of maximum of φ.

Their algorithm has the following form. Put α0  =  . Sequentially for [formula] do the following. Given φ(αi) launch G-BBHT, using oracle Oφ to obtain such x' that φ(x')  ≥  φ(αi), after that put αi + 1 = x'. After that observe the final state. It is shown in [\cite=DH] that the point of maximum will be obtained with high probability for [formula].

Previously some authors found fast quantum algorithms for other particular problems: P. Shor in the work [\cite=Sh], D.Deutsch and R.Jozsa in the work [\cite=DJ], D. Simon in the work [\cite=Si], and others. Quantum speeding up of such important problem as search has assumed a new significance in the light of the following fact (look at the work [\cite=Oz]). No quantum device can predict an evolution of chosen randomly classical system even on one time step. It means that quantum computer can beat classical only with probability zero, and the problem of search turns out to be among such rare cases.

In this work we establish two lower bounds for the quantum search for extreme point. The first result (Theorem 1) says that G-BBHT is optimal in the strong sense: every faster algorithm must fail with probability converging to 1 (n  →    ∞  ). Note that our Theorem 1 may be regarded as a partial amplification of one result from the work [\cite=BBHT]. This result is that average time for the quantum search for a solution of f(x) = 1 for Boolean function f is [formula] with peculiar constant d in case when there are b such solutions. The second result (Theorem 2) says that Durr-Hoyer's method of searching for an extremum is optimal in the strong sense defined above for the functions with the single point of maximum.

The idea of such lower bounds for quantum algorithms dates back to the work [\cite=BBBV] of C. Bennett, E. Bernstein, G. Brassard and U. Vazirani. They proved that NP-type problem of computing a preimage for length preserving function f can not be solved in time [formula] for f chosen with probability 1.

In the proofs of Theorems 1 and 2 we use the approach developed in the work [\cite=Oz], the idea of Lemma 2 issues from the work [\cite=BBBV].

We assume the following basic notions of quantum computing. Each state of quantum computer with n qubits is a point [formula] in 2n dimensional Hilbert space with orthonormal basis {ej}, where λj are complex numbers called amplitudes. The probability to obtain a basic state ej as a result of observation of the state χ is |λj|2. A computation has the form [formula] where each passage χi  →  χi + 1 is unitary transform which depends on oracle. A reader can find the more extensive introduction to the quantum computations in the work [\cite=Oz].

The Effect of Change in Oracles on the Result of Quantum Computations

To establish the lower bounds for the search of extremum we need some technical notions and propositions concerning the effect of change in oracles on the result of quantum computations which will be considered in this section. We summarize here some facts from the work [\cite=Oz] which will be applied in the next section.

We shall denote the basic states by the letter e with indices. Assume that the result of oracle's action on a basic state [formula] is the state [formula] where a and b are the places for the question and answer respectively, and +   means the bitwise addition modulo 2. This is unitary transformation which is denoted by Quφ. Denote this word a by q(e).

A query state χ is querying the oracle on all the words q(e) with some amplitudes. Put [formula]. Let [formula]. Given a word a∈{0,1}n for a query state χ we define:

[formula]

It is the probability that a state χ is querying the oracle on the word a. In particular, [formula].

Each query state χ induces the metric on the set of all oracles if for functions f,g of the form {0,1}n  →  {0,1}n we define a distance between them by

[formula]

Let Quf, Qug be query transforms on quantum part of QC corresponding to functions f,g; χ be a query state. Then

[formula]

Proof

Put L  =  {j∈K | f(q(ej))  ≠  g(q(ej))}. We have: [formula] Lemma is proved.

A quantum computation has the form

[formula]

where each step χi  →  χi + 1 is the superposition of the query unitary transform and the following unitary transform Ui which depends only on i: [formula]. We shall denote Ui(Quf(χ)) by Vi,f(χ), then [formula]. Here t is the number of query transforms (or evaluations of the function f) in the computation at hand. We say that the number t is the time complexity of this computation.

Put [formula].

If [formula] is a computation with oracle for f, a function g differs from f only on one word a∈{0,1}n and [formula] is a computation on the same QC with a new oracle for g, then

[formula]

Proof

Induction on t. Basis is evident. Step. In view of that Vt - 1,g is unitary, Lemma 1 and inductive hypothesis, we have

[formula]

Lemma is proved.

In what follows we assume that all computations are performed with fixed probability of error perr. This means that if B is the set of numbers of target states then the probability [formula] to obtain one of such states as a result of observations of final state [formula] is not less than 1 - perr.

Strong Lower Bound for the Time Complexity of the Quantum Search

At first take up the problem of search for the extreme point of Boolean functions. Given an oracle for function φ: {0,1}n  →  {0,1} from some fairly wide set S, what is the lower bound for the time complexity of quantum search for its extreme point? We shall require that our algorithms give the correct answer not on all functions φ but only on the functions from some set G  ⊆  S. Suppose that we fixe two constants:

1) the maximal admitted probability of error ε > 0 (for the computations with oracles for φ∈G), and

2) the probability of applicability of the algorithm: card(G)  /  card(S) such that this ratio must be at most p for some p: 0 < p  ≤  1.

If S is the set of all Boolean functions the best possible lower bound in quantum case as well as in classical is O(1). This is because the simple classical algorithm verifying [formula] gives the correct answer for the functions chosen with probability p = 1 - 2- k.

Let S = Sb be the set of all Boolean functions with exactly b points x such that φ(x) = 1. Let further n,t(n),b(n) vary such that [formula]. A quantum algorithm with the time complexity t(n) thus is substantially faster than G-BBHT. We shall prove that if we apply such algorithm to the search for extremum of φ it must make a mistake for a bulk of φ.

Let [formula], and some quantum computer with oracle for φ with the time complexity t(n) searchs for a solution of φ(x) = 1 with fixed upper bound ε for the probability of error (0 < ε < 1). Let p(n) be the probability of that this algorithm gives the correct answer for the oracle φ chosen randomly from Sb. Then p(n)  →  0  (n  →    ∞  ).

Proof

We shall apply the idea of proof of Theorem 2 from the work [\cite=Oz] with some modifications. Fix n and put φ0(x) = 0. Let [formula] be the computation on quantum machine at hand. Define the matrix [formula] where N = 2n. Then we have [formula] because [formula].

Let Tj be the set of all such integers τ that [formula]; assume [formula]. Let j denote the cardinality of the set [formula]. Then [formula].

Choose randomly b different integers from [formula] denote this set by D and let bj be the number of such integers among them which belongs to the set Lj. Then bj is a random variable with the expectation Ebj = bj / N. Now change the values of φ0 on D to 1. We obtain a new function φ1 and correspondingly the new computation [formula] with oracle for φ1. The norm of difference between the final states [formula] will be thus a real random variable. Estimate its expectation.

For every ε > 0 P(ξ  >  ε)  →  0 if n  →    ∞  .

Proof

We need the following inequality for every random variable: Eη2  ≥  E2η.

Let i takes all values [formula]; j takes all natural values. We have:

[formula]

Now applying Chebishev inequality P(ξ  ≥  ε)  ≤  Eξ  /  ε we conclude that if ε is fixed then P(ξ  ≥  ε) may be done arbitrarily small for sufficiently large n. Lemma 3 is proved.

Turn to the proof of Theorem 1. Suppose that our computer gives the correct answer on all functions from G with probability perr of error. Without loss of generality we may assume perr = 0.0016, N > 1000. Choose a Boolean function f∈G which takes the value 1 in b points. Let the final state of computation on our computer with oracle f has the form [formula]. Let [formula] We have

[formula]

because the final observation of Xt must give the result ej, j∈B with probability of error perr. Fix such f and put [formula], [formula] where l̂ j  =  card(Lj). We have

[formula]

Now choose the second function f'∈Sb randomly. Let B' = {j | f'(ej) = 1}. Define a random variables lj depending on f':

[formula]

We have Elj = bl̂ j / N because the probability of the choice of f' is uniformly distributed over all Sb. At last define [formula]. This is also a random variable depending on f'. Its expectation is

[formula]

in view of (2). Then Chebishev inequality [formula] gives

[formula]

Now suppose that card(G) / card(Sb) = ε0  =  const.

Let [formula] be the final state of the computation with oracle for a chosen function f'. If f'∈G (e.g. with probability ε0) then we have

[formula]

Applying Lemma 3 to the random variable ξ depending on the choice of f' we have that with probability 1

[formula]

We have

[formula]

Put [formula] [formula], [formula] [formula] [formula] [formula]

Then in view of (1) q  ≤  ε0  ≤  perr and z  ≤  perr. We shall use inequality [formula] for two vectors a,b in Hilbert space. Using this inequality we conclude that the second item in (6) is not less than [formula] . The third item is not less than [formula]. Let N be sufficiently large, such that

[formula]

Such N exists by (5). Then we have q' < 4perr. Really, in opposite case: q'  ≥  4perr in view of (6) we would have [formula] which gives contradiction. Similarly, z' < 4perr. Hence asymptotically when N  →    ∞   with probability 1: [formula]. Therefore with this probability [formula]. Taking into account (4) we obtain that with probability ε0

[formula]

From the definition of Lj it follows that

[formula]

On the other hand (6) and (7) give [formula] [formula] where s is the fourth item in the sum (6). Now (9) gives [formula], and by (8) [formula] with probability ε0, which contradicts to (3). Theorem 1 is proved.

Lower Bound of the Quantum Search for the Single Extreme Point

Now we are ready to give the lower bound for the problem of search for extreme point of the integer function. We assume that φ is arbitrary integer function with the single point of maximum and there are the probability measure distributed uniformly on the set of all such functions, so that each φ can be chosen with the same probability. The set of all such functions is denoted by C.

If some quantum algorithm with the time complexity [formula] finds a point of maximum for the functions from C with probability of applicability p(n) then p(n)  →   0 (n  →    ∞  ).

Proof

Let Cl be the set of such functions from C whose maximum is N - l. It is sufficient to prove the Theorem for each Cl separately, [formula] The cases of all Cl are analogous, let, for example, l = 1.

We shall use Theorem 1. Fix some quantum algorithm. Let f be such integer function that does not take the value N - 1. The set of all such functions is denoted by H. If we redefine such f on a single point and obtain a function φ∈C1 we say that this function φ is generated by f. Denote the set of all N such functions by

[formula]

will be less than ε.

Let M be the number of all different sets

[formula]

. Now count all functions φ∈C1 for which our algorithm does not find a point of maximum by two different ways. At first count all such φ in each

[formula]

Acknowledgements

I would like to thank Lov Grover whose questions stimulated me, and who informed me about the work [\cite=DH]. I am grateful to academician Victor Maslov for his attention and support, to professor Oleg Chrustalev for discussions on quantum computers, and especially to the principal of "Stankin" Yuri Solomentsev for the financial support of my work.