Approximation of the Two-Part MDL Code

and Paul Vitányi

Introduction

In machine learning pure applications of MDL are rare, partially because of the difficulties one encounters trying to define an adequate model code and data-to-model code, and partially because of the operational difficulties that are poorly understood. We analyze aspects of both the power and the perils of MDL precisely and formally. Let us first resurrect a familiar problem from our childhood to illustrate some of the issues involved.

The process of solving a jigsaw puzzle involves an incremental reduction of entropy, and this serves to illustrate the analogous features of the learning problems which are the main issues of this work. Initially, when the pieces come out of the box they have a completely random ordering. Gradually we combine pieces, thus reducing the entropy and increasing the order until the puzzle is solved. In this last stage we have found a maximal ordering. Suppose that Alice and Bob both start to solve two versions of the same puzzle, but that they follow different strategies. Initially, Alice sorts all pieces according to color, and Bob starts by sorting the pieces according to shape. (For the sake of argument we assume that the puzzle has no recognizable edge pieces.) The crucial insight, shared by experienced puzzle aficionados, is that Alice's strategy is efficient whereas Bob's strategy is not and is in fact even worse than a random strategy. Alice's strategy is efficient, since the probability that pieces with about the same color match is much greater than the unconditional probability of a match. On the other hand the information about the shape of the pieces can only be used in a relatively late stage of the puzzle process. Bob's effort in the beginning is a waste of time, because he must reorder the pieces before he can proceed to solve the puzzle. This example shows that if the solution of a problem depends on finding a maximal reduction of entropy this does not mean that every reduction of entropy brings us closer to the solution. Consequently reduction of entropy is not in all cases a good strategy.

Entropy Versus Kolmogorov Complexity

Above we use "entropy" in the often used, but inaccurate, sense of "measure of unorderedness of an individual arrangement." However, entropy is a measure of uncertainty associated with a random variable, here a set of arrangements each of which has a certain probability of occurring. The entropy of every individual arrangement is by definition zero. To circumvent this problem, often the notion of "empirical entropy" is used, where certain features like letter frequencies of the individual object are analyzed, and the entropy is taken with respect to the set of all objects having the same features. The result obviously depends on the choice of what features to use: no features gives maximal entropy and all features (determining the individual object uniquely) gives entropy zero again. Unless one has knowledge of the characteristics of a definite random variable producing the object as a typical outcome, this procedure gives arbitrary and presumably meaningless, results. This conundrum arises since classical information theory deals with random variables and the communication of information. It does not deal with the information (and the complexity thereof) in an individual object independent of an existing (or nonexisting) random variable producing it. To capture the latter notion precisely one has to use "Kolmogorov complexity" instead of "entropy," and we will do so in our treatment. For now, the "Kolmogorov complexity" of a file is the number of bits in the ultimately compressed version of the file from which the original can still be losslessly extracted by a fixed general purpose decompression program.

Learning by MDL

Transferring the jigsaw puzzling insights to the general case of learning algorithms using the minimum description length principle (MDL), [\cite=Ri83] [\cite=BRY] [\cite=Ri07], we observe that although it may be true that the maximal compression yields the best solution, it may still not be true that every incremental compression brings us closer to the solution. Moreover, in the case of many MDL problems there is a complicating issue in the fact that the maximal compression cannot be computed.

More formally, in constrained model selection the model is taken from a given model class. Using two-part MDL codes for the given data, we assume that the shortest two-part code for the data, consisting of the model code and the data-to-model code, yields the best model for the data. To obtain the shortest code, a natural way is to approximate it by a process of finding ever shorter candidate two-part codes. Since we start with a finite two-part code, and with every new candidate two-part code we decrease the code length, eventually we must achieve the shortest two-part code (assuming that we search through all two-part codes for the data). Unfortunately, there are two problems: (i) the computation to find the next shorter two-part code may be very long, and we may not know how long; and (ii) we may not know when we have reached the shortest two-part code: with each candidate two-part code there is the possibility that further computation may yield yet a shorter one. But because of item (i) we cannot a priori bound the length of that computation. There is also the possibility that the algorithm will never yield the shortest two-part code because it considers only part of the search space or gets trapped in a nonoptimal two-part code.

Results

We show that for some MDL algorithms the sequence of ever shorter two-part codes for the data converges in a finite number of steps to the best model. However, for every MDL algorithm the intermediate models may not convergence monotonically in goodness. In fact, in the sequence of candidate two-part codes converging to a (globally or locally) shortest, it is possible that the models involved oscillate from being good to bad. Convergence is only monotone if the model-code parts in the successive two-part codes are always the shortest (most compressed) codes for the models involved. But this property cannot be guaranteed by any effective method.

It is very difficult, if not impossible, to formalize the goodness of fit of an individual model for individual data in the classic statistics setting, which is probabilistic. Therefore, it is impossible to express the practically important issue above in those terms. Fortunately, new developments in the theory of Kolmogorov complexity [\cite=Ko74] [\cite=VV02] make it possible to rigorously analyze the questions involved, possibly involving noncomputable quantities. But it is better to have a definite statement in a theory than having no definite statement at all. Moreover, for certain algorithms (like Algorithm Optimal MDL in Theorem [\ref=alg.mdl]) we can guarantee that they satisfy the conditions required, even though these are possibly noncomputable. In Section [\ref=sect.dm] we review the necessary notions from [\cite=VV02], both in order that the paper is self-contained and the definitions and notations are extended from the previously used singleton data to multiple data samples. Theorem [\ref=theo.recoding] shows that the use of MDL will be approximately invariant under recoding of the data. The next two sections contain the main results: Definition [\ref=def.MDLalg] defines the notion of an MDL algorithm. Theorem [\ref=alg.mdl] shows that there exists such an MDL algorithm that in the (finite) limit results in an optimal model. The next statements are about MDL algorithms in general, also the ones that do not necessarily result in an optimal MDL code. Theorem [\ref=theo.approxim] states a sufficient condition for improvement of the randomness deficiency (goodness of fit) of two consecutive length-decreasing MDL codes. This extends Lemma V.2 of the [\cite=VV02] (which assumes all programs are shortest) and corrects the proof concerned. The theory is applied and illustrated in Section [\ref=sect.single]: Theorem [\ref=theo.fluctuate] shows by example that a minor violation of the sufficiency condition in Theorem [\ref=theo.approxim] can result in worsening the randomness deficiency (goodness of fit) of two consecutive length-decreasing MDL codes. The special case of learning DFAs from positive examples is treated in Section [\ref=sect.multi]. The main result shows, for a concrete and computable MDL code, that a decrease in the length of the two-part MDL code does not imply a better model fit (see Section [\ref=sect.lmdl]) unless there is a sufficiently large decrease as that required in Theorem [\ref=theo.approxim] (see Remark [\ref=rem.smc]).

Data and Model

Let x,y,z∈N, where N denotes the natural numbers and we identify N and {0,1}* according to the correspondence

[formula]

Here ε denotes the empty word. The length |x| of x is the number of bits in the binary string x, not to be confused with the cardinality |S| of a finite set S. For example, |010| = 3 and |ε| = 0, while |{0,1}n| = 2n and [formula]. Below we will use the natural numbers and the binary strings interchangeably. Definitions, notations, and facts we use about prefix codes, self-delimiting codes, and Kolmogorov complexity, can be found in [\cite=LiVi97] and are briefly reviewed in Appendix [\ref=sect.prel].

The emphasis is on binary sequences only for convenience; observations in any alphabet can be encoded in binary in a way that is theory neutral. Therefore, we consider only data x in {0,1}*. In a typical statistical inference situation we are given a subset of {0,1}*, the data sample, and are required to infer a model for the data sample. Instead of {0,1}* we will consider {0,1}n for some fixed but arbitrarily large n.

A data sample D is a subset of {0,1}n. For technical convenience we want a model M for D to contain information about the cardinality of D. A model M has the form [formula], where M'  ⊆  {0,1}n and i∈{0,1}n. We can think of i as the ith binary string in {0,1}n. Denote the cardinalities by lower case letters:

[formula]

If D is a data sample and M is a model for D then D  ⊆  M'  ⊆  M, [formula], and we write [formula] or [formula].

Denote the complexity of a finite set S by K(S)--the length (number of bits) of the shortest binary program p from which the reference universal prefix machine U computes a lexicographic listing of the elements of A and then halts. That is, if [formula], the elements given in lexicographic order, then [formula]. The shortest program p, or, if there is more than one such shortest program, then the first one that halts in a standard dovetailed running of all programs, is denoted by S*.

The conditional complexity K(D|M) of [formula] is the length (number of bits) of the shortest binary program p from which the reference universal prefix machine U from input M (given as a list of elements) outputs D as a lexicographically ordered list of elements and halts. We have

[formula]

The upper bound follows by considering a self-delimiting code of D given M (including the number d of elements in D), consisting of a [formula] bit long index of D in the lexicographic ordering of the number of ways to choose d elements from M' = M - {  #  d}. This code is called the data-to-model code. Its length quantifies the maximal "typicality," or "randomness," any data sample D of d elements can have with respect to model M with [formula].

The lack of typicality of D with respect to M is measured by the amount by which K(D|M) falls short of the length of the data-to-model code. The randomness deficiency of [formula] is defined by

[formula]

for [formula], and ∞   otherwise.

The randomness deficiency can be a little smaller than 0, but not more than a constant. If the randomness deficiency is not much greater than 0, then there are no simple special properties that single D out from the majority of data samples of cardinality d to be drawn from M' = M - {  #  d}. This is not just terminology: If δ(D|M) is small enough, then D satisfies all properties of low Kolmogorov complexity that hold for the majority of subsets of cardinality d of M'. To be precise: A property P represented by M is a subset of M', and we say that D satisfies property P if D is a subset of P.

Let d,m,n be natural numbers, and let D  ⊆  M'  ⊆  {0,1}n, [formula], |D| = d,|M'| = m, and let δ be a simple function of the natural numbers to the real numbers, that is, K(δ) is a constant, for example, δ is log  or [formula].

(i) If P is a property satisfied by all [formula] with δ(D|M)  ≤  δ(n), then P holds for a fraction of at least 1 - 1 / 2δ(n) of the subsets of M'  =  M - {  #  d}.

(ii) Let P be a property that holds for a fraction of at least 1 - 1 / 2δ(n) of the subsets of M' = M - {  #  d}. There is a constant c, such that P holds for every [formula] with δ(D|M)  ≤  δ(n) - K(P|M) - c.

(i) By assumption, all data samples [formula] with

[formula]

satisfy P. There are only

[formula]

programs of length smaller than [formula], so there are at most that many [formula] that do not satisfy [\eqref=eq.fraction]. There are [formula] sets D that satisfy [formula], and hence a fraction of at least 1 - 1 / 2δ(n) of them satisfy [\eqref=eq.fraction].

(ii) Suppose P does not hold for a data sample [formula] and the randomness deficiency [\eqref=eq:randomness-deficiency] satisfies δ(D|M)  ≤  δ(n) - K(P|M) - c. Then we can reconstruct D from a description of M, and D's index j in an effective enumeration of all subsets of M of cardinality d for which P doesn't hold. There are at most [formula] such data samples by assumption, and therefore there are constants c1,c2 such that

[formula]

Hence, by the assumption on the randomness deficiency of D, we find K(P|M)  ≤  c2 - c, which contradicts the necessary nonnegativity of K(P|M) if we choose c  >  c2.

The minimal randomness deficiency function of the data sample D is defined by

[formula]

where we set [formula]. The smaller δ(D|M) is, the more D can be considered as a typical data sample from M. This means that a set M for which D incurs minimal randomness deficiency, in the model class of contemplated sets of given maximal Kolmogorov complexity, is a "best fitting" model for D in that model class--a most likely explanation, and βD(α) can be viewed as a constrained best fit estimator.

Minimum Description Length Estimator

The length of the minimal two-part code for D with model [formula] consist of the model cost K(M) plus the length of the index of D in the enumeration of choices of d elements out of m (m = |M'| and M' = M - {  #  d}). Consider the model class of M's of given maximal Kolmogorov complexity α. The MDL function or constrained MDL estimator is

[formula]

where [formula] is the total length of two-part code of D with help of the model M. This function λD(α) is the celebrated optimal two-part MDL code length as a function of α, with the model class restricted to models of code length at most α. The functions βD and λD are examples of Kolmogorov's structure functions, [\cite=Ko74] [\cite=VV02].

Indeed, consider the following two-part code for [formula]: the first part is a shortest self-delimiting program p for M and the second part is [formula] bit long index of D in the lexicographic ordering of all choices of d elements from M. Since M determines [formula] this code is self-delimiting and we obtain the two-part code, where the constant O(1) is the length of an additional program that reconstructs D from its two-part code. Trivially, λD(α)  ≥  K(D) + O(1). For those α's that have λD(α)  =  K(D) + O(1), the associated model [formula] in at most α bits (witness for λD(α)) is called a sufficient statistic for D.

If M is a sufficient statistic for D, then the randomness deficiency of D in M is O(1), that is, D is a typical data sample for M, and M is a model of best fit for D.

If M is a sufficient statistic for D, then [formula]. The left-hand side of the latter equation is a two-part description of D using the model [formula] and as data-to-model code the index of D in the enumeration of the number of choices of d elements from M in [formula] bits. This left-hand side equals the right-hand side which is the shortest one-part code of D in K(D) bits. Therefore,

[formula]

The first and second inequalities are straightforward, the third inequality states that given [formula] we can describe D in a self-delimiting manner in [formula] bits, and the final equality follows by the sufficiency property. This sequence of (in)equalities implies that [formula].

Note that the data sample D can have randomness deficiency about 0, and hence be a typical element for models M, while M is not a sufficient statistic. A sufficient statistic M for D has the additional property, apart from being a model of best fit, that K(D,M) = K(D) + O(1) and therefore by [\eqref=eq.soi] in Appendix [\ref=sect.prel] we have K(M|D*) = O(1): the sufficient statistic M is a model of best fit that is almost completely determined by D*, a shortest program for D.

The sufficient statistic associated with λD(α) with the least α is called the minimal sufficient statistic.

Reference [\cite=VV02] and this paper analyze a canonical setting where the models are finite sets. We can generalize the treatment to the case where the models are the computable probability mass functions. The computability requirement does not seem very restrictive. We cover most, if not all, probability mass functions ever considered, provided they have computable parameters. In the case of multiple data we consider probability mass functions P that map subsets B  ⊆  {0,1}n into

[formula]

}.Thegeneralmodelclassofcomputableprobabilitymassfunctionsisequivalenttothefinitesetmodelclass,uptoanadditivelogarithmicO( log dn)[formula]

The generality of the results are at the same time a restriction. In classical statistics one is commonly interested in model classes that are partially poorer and partially richer than the ones we consider. For example, the class of Bernoulli processes, or k-state Markov chains, is poorer than the class of computable probability mass functions of moderate maximal Kolmogorov complexity α, in that the latter class may contain functions that require far more complex computations than the rigid syntax of the classical classes allows. Indeed, the class of computable probability mass functions of even moderate complexity allows implementation of a function mimicking a universal Turing machine computation. On the other hand, even the simple Bernoulli process can be equipped with a noncomputable real bias in (0,1), and hence the generated probability mass function over n trials is not a computable function. This incomparability of the algorithmic model classes studied here and the traditional statistical model classes, means that the current results cannot be directly transplanted to the traditional setting. They should be regarded as pristine truths that hold in a platonic world that can be used as guideline to develop analogues in model classes that are of more traditional concern, as in [\cite=Ri07].

Essence of Model Selection

The first parameter we are interested in is the simplicity K(M) of the model M explaining the data sample D ([formula]). The second parameter is how typical the data is with respect to M, expressed by the randomness deficiency [formula]. The third parameter is how short the two part code [formula] of the data sample D using theory M with [formula] is. The second part consists of the full-length index, ignoring saving in code length using possible nontypicality of D in M (such as being the first d elements in the enumeration of M' = M - {  #  d}). These parameters induce a partial order on the contemplated set of models. We write M1  ≤  M2, if M1 scores equal or less than M2 in all three parameters. If this is the case, then we may say that M1 is at least as good as M2 as an explanation for D (although the converse need not necessarily hold, in the sense that it is possible that M1 is at least as good a model for D as M2 without scoring better than M2 in all three parameters simultaneously).

The algorithmic statistical properties of a data sample D are fully represented by the set AD of all triples

[formula]

with [formula], together with a component wise order relation on the elements of those triples. The complete characterization of this set follows from the results in [\cite=VV02], provided we generalize the singleton case treated there to the multiple data case required here.

In that reference it is shown that if we minimize the length of a two-part code for an individual data sample, the two-part code consisting of a model description and a data-to-model code over the class of all computable models of at most a given complexity, then the following is the case. With certainty and not only with high probability as in the classical case this process selects an individual model that in a rigorous sense is (almost) the best explanation for the individual data sample that occurs among the contemplated models. (In modern versions of MDL, [\cite=Gr07] [\cite=BRY] [\cite=Ri07], one selects the model that minimizes just the data-to-model code length (ignoring the model code length), or minimax and mixture MDLs. These are not treated here.) These results are exposed in the proof and analysis of the equality:

[formula]

which holds within negligible additive O( log dn) terms, in argument and value. We give the precise statement in [\eqref=eq.multipleeq] in Appendix [\ref=sect.formal].

Every model (set) M that witnesses the value λD(α), also witnesses the value βD(α) (but not vice versa). The functions λD and βD can assume all possible shapes over their full domain of definition (up to additive logarithmic precision in both argument and value). We summarize these matters in Appendix [\ref=sect.formal].

Computability

How difficult is it to compute the functions λD,βD, and the minimal sufficient statistic? To express the properties appropriately we require the notion of functions that are not computable, but can be approximated monotonically by a computable function.

A function f:N  →  R is upper semicomputable if there is a Turing machine T computing a total function φ such that φ(x,t + 1)  ≤  φ(x,t) and lim t  →    ∞φ(x,t) = f(x). This means that f can be computably approximated from above. If - f is upper semicomputable, then f is lower semicomputable. A function is called semicomputable if it is either upper semicomputable or lower semicomputable. If f is both upper semicomputable and lower semicomputable, then we call f computable (or recursive if the domain is integer or rational).

To put matters in perspective: even if a function is computable, the most feasible type identified above, this doesn't mean much in practice. Functions like f(x) of which the computation terminates in computation time of t(x)  =  xx (say measured in flops), are among the easily computable ones. But for x = 30, even a computer performing an unrealistic Teraflop per second, requires 3030  /  1012  >  1028 seconds. This is more than 3  ·  1020 years. It is out of the question to perform such computations. Thus, the fact that a function or problem solution is computable gives no insight in how feasible it is. But there are worse functions and problems possible: For example, the ones that are semicomputable but not computable. Or worse yet, functions that are not even semicomputable.

Semicomputability gives no knowledge of convergence guarantees: even though the limit value is monotonically approximated, at no stage in the process do we know how close we are to the limit value. In Section [\ref=ex.MDL], the indirect method of Algorithm Optimal MDL shows that the function λD (the MDL-estimator) can be monotonically approximated in the upper semicomputable sense. But in [\cite=VV02] it was shown for singleton data samples, and therefore a fortiori for multiple data samples D, the fitness function βD (the direct method of Remark [\ref=rem.direct]) cannot be monotonically approximated in that sense, nor in the lower semicomputable sense, in both cases not even up to any relevant precision. Let us formulate this a little more precisely:

The functions λD(α),βD(α) have a finite domain for a given D and hence can be given as a table--so formally speaking they are computable. But this evades the issue: there is no algorithm that computes these functions for given D and α. Considering them as two-argument functions it was shown (and the claimed precision quantified):

The function λD(α) is upper semicomputable but not computable up to any reasonable precision.

There is no algorithm that given D* and α finds λD(α).

The function βD(α) is not upper nor lower semicomputable, not even to any reasonable precision. To put βD(α)'s computability properties in perspective, clearly we can compute it given an oracle for the halting problem.

The halting problem is the problem whether an arbitrary Turing machine started on an initially all-0 tape will eventually terminate or compute forever. This problem was shown to be undecidable by A.M. Turing in 1937, see for example [\cite=LiVi97]. An oracle for the halting problem will, when asked, tell whether a given Turing machine computation will or will not terminate. Such a device is assumed in order to determine theoretical degrees of (non)computability, and is deemed not to exist.

But using such an oracle gives us power beyond effective (semi)computability and therefore brings us outside the concerns of this paper.

There is no algorithm that given D and K(D) finds a minimal sufficient statistic for D up to any reasonable precision.

Invariance under Recoding of Data

In what sense are the functions invariant under recoding of the data? If the functions βD and λD give us the stochastic properties of the data D, then we would not expect those properties to change under recoding of the data into another format. For convenience, let us look at a singleton example. Suppose we recode D = {x} by a shortest program x* for it. Since x* is incompressible it is a typical element of the set of all strings of length |x*| = K(x), and hence λx*(α) drops to the Kolmogorov complexity K(x) already for some α  ≤  K(K(x)), so almost immediately (and it stays within logarithmic distance of that line henceforth). That is, λx*(α)  =  K(x) up to logarithmic additive terms in argument and value, irrespective of the (possibly quite different) shape of λx. Since the Kolmogorov complexity function K(x) = |x*| is not recursive, [\cite=Ko65], the recoding function f(x)  =  x* is also not recursive. Moreover, while f is one-to-one and total it is not onto. But it is the partiality of the inverse function (not all strings are shortest programs) that causes the collapse of the structure function. If one restricts the finite sets containing x* to be subsets of {y*:y∈{0,1}n}, then the resulting function λx* is within a logarithmic strip around λx. The coding function f is upper semicomputable and deterministic. (One can consider other codes, using more powerful computability assumptions or probabilistic codes, but that is outside the scope of this paper.) However, the structure function is invariant under "proper" recoding of the data.

Let f be a recursive permutation of the set of finite binary strings in {0,1}n (one-to-one, total, and onto), and extend f to subsets D  ⊆  {0,1}n. Then, λf(D) is "close" to λD in the sense that the graph of λf(D) is situated within a strip of width K(f) + O(1) around the graph of λD.

Let [formula] be a witness of λD(α). Then, Mf  =  {f(y):y∈M} satisfies K(Mf)  ≤  α  +  K(f) + O(1) and |Mf| = |M|. Hence, λf(D)(α  +  K(f) + O(1))  ≤  λD(α). Let [formula] be a witness of λf(D)(α). Then, Mff- 1  =  {f- 1(y):y∈Mf} satisfies K(Mff- 1)  ≤  α  +  K(f) + O(1) and |Mff- 1| = |Mf|. Hence, λD(α  +  K(f) + O(1))  ≤  λf(D)(α) (since K(f- 1)  =  K(f) + O(1)).

Approximating the MDL Code

Given D  ⊆  {0,1}n, the data to explain, and the model class consisting of all models M for D that have complexity K(M) at most α. This α is the maximum complexity of an explanation we allow. As usual, we denote m = |M| - 1 (possibly indexed like mt  =  |Mt| - 1) and d = |D|. We search for programs p of length at most α that print a finite set [formula]. Such pairs (p,M) are possible explanations. The best explanation is defined to be the (p,M) for which δ(D|M) is minimal, that is, δ(D|M) = βD(α). Since the function βD(α) is not computable, there is no algorithm that halts with the best explanation. To overcome this problem we minimize the randomness deficiency by minimizing the MDL code length, justified by [\eqref=eq.eq], and thus maximize the fitness of the model for this data sample. Since [\eqref=eq.eq] holds only up to a small error we should more properly say "almost minimize the randomness deficiency" and "almost maximize the fitness of the model."

An algorithm A is an MDL algorithm if the following holds. Let D be a data sample consisting of d separated words of length n in dn + O( log dn) bits. Given inputs D and α (0  ≤  α  ≤  dn + O( log dn)), algorithm A written as A(D,α) produces a finite sequence of pairs [formula], such that every pt is a binary program of length at most α that prints a finite set Mt with [formula] and [formula] for every 1  <  t  ≤  f.

It follows that K(Mt)  ≤  |pt| for all 1  <  t  ≤  f. Note that an MDL algorithm may consider only a proper subset of all binary programs of length at most α. In particular, the final [formula] may be greater than the optimal MDL code of length [formula]. This happens when a program p printing M with [formula] and |p| = K(M)  ≤  α is not in the subset of binary programs considered by the algorithm, or the algorithm gets trapped in a suboptimal solution.

The next theorem gives an MDL algorithm that always finds the optimal MDL code and, moreover, the model concerned is shown to be an approximately best fitting model for dat D.

There exists an MDL algorithm which given D and α satisfies lim t  →    ∞(pt,Mt)  =  (p̂,), such that δ(D|)  ≤  βD(i - O( log dn)) + O( log dn).

We exhibit such an MDL algorithm:

Algorithm Optimal MDL (D,α)

In this MDL algorithm the best explanation (pt,Mt) changes from time to time due to the appearance of a strictly better explanation. Since no pair (p,M) can be elected as best explanation twice, and there are only finitely many pairs, from some moment onward the explanation (pt,Mt) which is declared best does not change anymore. Therefore the limit (p̂,) exists. The model [formula] is a witness set of λD(i). The lemma follows by ([\ref=eq.eq]) and Remark [\ref=rem.witness].

Thus, if we continue to approximate the two-part MDL code contemplating every relevant model, then we will eventually reach the optimal two-part code whose associated model is approximately the best explanation. That is the good news. The bad news is that we do not know when we have reached this optimal solution. The functions hD and λD, and their witness sets, cannot be computed within any reasonable accuracy, Section [\ref=sect.comp]. Hence, there does not exist a criterion we could use to terminate the approximation somewhere close to the optimum.

In the practice of the real-world MDL, in the process of finding the optimal two-part MDL code, or indeed a suboptimal two-part MDL code, we often have to be satisfied with running times t that are much less than the time to stabilization of the best explanation. For such small t, the model Mt has a weak guarantee of goodness, since we know that

[formula]

because K(D)  ≤  K(D,Mt)  ≤  K(Mt) + K(D|Mt) and therefore K(D) - K(D|Mt)  ≤  K(Mt)  ≤  |pt| (ignoring additive constants). That is, the randomness deficiency of D in Mt plus K(D) is less than the known value [formula]. Theorem [\ref=alg.mdl] implies that Algorithm MDL gives not only some guarantee of goodness during the approximation process (see Section [\ref=sect.comp]), but also that, in the limit, that guarantee approaches the value of its lower bound, that is, δ(D|)  +  K(D). Thus, in the limit, Algorithm Optimal MDL will yield an explanation that is only a little worse than the best explanation.

(Direct Method) Use the same dovetailing process as in Algorithm Optimal MDL, with the following addition. At every elementary computation step t, select a (p,M) for which [formula] is minimal among all programs p that up to this time have printed a set [formula]. Here Kt(D|M) is the approximation of K(D|M) from above defined by Kt(D|M) =  min {|q|: the reference universal prefix machine U outputs D on input (q,M) in at most t steps}. Hence, [formula] is an approximation from below to δ(D|M). Let (qt,Mt) denote the best explanation after t steps. We only change the best explanation at computation step t, if [formula]. This time the same explanation can be chosen as the best one twice. However, from some time t onward, the best explanation (qt,Mt) does not change anymore. In the approximation process, the model Mt has no guarantee of goodness at all: Since βD(α) is not semicomputable up to any significant precision, Section [\ref=sect.comp], we cannot know a significant upper bound neither for δ(D|Mt), nor for δ(D|Mt)  +  K(D). Hence, we must prefer the indirect method of Algorithm Optimal MDL, approximating a witness set for λD(α), instead of the direct one of approximating a witness set for βD(α).

Does Shorter MDL Code Imply Better Model?

In practice we often must terminate an MDL algorithm as in Definition [\ref=def.MDLalg] prematurely. A natural assumption is that the longer we approximate the optimal two-part MDL code the better the resulting model explains the data. Thus, it is tempting to simply assume that in the approximation every next shorter two-part MDL code also yields a better model. However, this is not true. To give an example that shows where things go wrong it is easiest to first give the conditions under which premature search termination is all right. Suppose we replace the currently best explanation (p1,M1) in an MDL algorithm with explanation (p2,M2) only if [formula] is not just less than [formula], but less by more than the excess of |p1| over K(M1). Then, it turns out that every time we change the explanation we improve its goodness.

Let D be a data sample with |D| = d (0 < d < 2n). Let (p1,M1) and (p2,M2) be sequential (not necessary consecutive ) candidate best explanations. produced by an MDL algorithm A(D,α). If

[formula]

then [formula]

For every pair of sets [formula] we have

[formula]

with Λ  =  Λ(M2)  -  Λ(M1) and

[formula]

The first inequality uses the trivial - K(M2,D)  ≥   - K(M2) - K(D|M2) and the nontrivial K(M1,D)  +  K(M*1|M1)  ≥  K(M1)  +  K(D|M1) which follows by [\eqref=eq.soi], and the second inequality uses the general property that K(a|b)  ≥  K(a) - K(b). By the assumption in the theorem,

[formula]

Since by assumption the difference in MDL codes Λ  =  Λ(M2)  -  Λ(M1)  >  0, it suffices to show that [formula] to prove the theorem. Note that (p1,M1) and (p2,M2) are in this order sequential candidate best explanations in the algorithm, and every candidate best explanation may appear only once. Hence, to identify (p1,M1) we only need to know the MDL algorithm A, the maximal complexity α of the contemplated models, the data sample D, the candidate explanation (p2,M2), and the number j of candidate best explanations in between (p1,M1) and (p2,M2). To identify M*1 from M1 we only require K(M1) bits. The program p2 can be found from M2 and the length |p2|  ≤  α, as the first program computing M2 of length |p2| in the process of running the algorithm A(D,α). Since A is an MDL algorithm we have [formula], and K(M1)  ≤  α. Therefore,

[formula]

where b is the number of bits we need to encode the description of the MDL algorithm, the descriptions of the constituent parts self-delimitingly, and the description of a program to reconstruct M*1 from M1. Since α  ≤  n + O( log n), we find

[formula]

where the last inequality follows from 0  <  d  <  2n and d being an integer.

We need an MDL algorithm in order to restrict the sequence of possible candidate models examined to at most [formula] with α  ≤  nd + O( log nd) rather than all of the 22n - d possible models M satisfying [formula].

In the sequence [formula] of candidate best explanations produced by an MDL algorithm, (pt',Mt') is actually better than (pt,Mt) (t  <  t'), if the improvement in the two-part MDL code-length is the given logarithmic term in excess of the unknown, and in general noncomputable |pt| - K(Mt). On the one hand, if |pt| = K(Mt) + O(1), and

[formula]

then Mt' is a better explanation for data sample D than Mt, in the sense that

[formula]

On the other hand, if |pt|  -  K(Mt) is large, then Mt' may be a much worse explanation than Mt. Then, it is possible that we improve the two-part MDL code-length by giving a worse model Mt' using, however, a pt' such that [formula] while δ(D|Mt')  >  δ(D|Mt).

Shorter MDL Code May Not Be Better

Assume that we want to infer a language, given a single positive example (element of the language). The positive example is D = {x} with [formula], xi∈{0,1} for 1  ≤  i  ≤  n. We restrict the question to inferring a language consisting of a set of elements of the same length as the positive example, that is, we infer a subset of {0,1}n. We can view this as inferring the slice Ln of the (possibly infinite) target language L consisting of all words of length n in the target language. We identify the singleton data sample D with its constituent data string x. For the models we always have [formula] with M'  ⊆  {0,1}n. For simplicity we delete the cardinality indicator {  #  1} since it is always 1 and write M  =  M'  ⊆  {0,1}n.

Every M  ⊆  {0,1}n can be represented by its characteristic sequence [formula] with χi = 1 if the ith element of {0,1}n is in M, and 0 otherwise. Conversely, every string of 2n bits is the characteristic sequence of a subset of {0,1}n. Most of these subsets are "random" in the sense that they cannot be represented concisely: their characteristic sequence is incompressible. Now choose some integer δ. Simple counting tells us that there are only 22n  -  δ - 1 binary strings of length < 2n  -  δ. Thus, the number of possible binary programs of length < 2n  -  δ is at most 22n  -  δ - 1. This in turn implies (since every program describes at best one such set) that the number of subsets M  ⊆  {0,1}n with K(M|n) < 2n  -  δ is at most 22n  -  δ - 1. Therefore, the number of subsets M  ⊆  {0,1}n with

[formula]

is greater than

[formula]

Now if K(M) is significantly greater than K(x), then it is impossible to learn M from x. This follows already from the fact that K(M|x)  ≥  K(M|x*) + O(1)  =  K(M) - K(x)  +  K(x|M*) + O(1) by [\eqref=eq.soi] (note that K(x|M*)  >  0). That is, we need more than K(M) - K(x) extra bits of dedicated information to deduce M from x. Almost all sets in {0,1}n have so high complexity that no effective procedure can infer this set from a single example. This holds in particular for every (even moderately) random set.

Thus, to infer such a subset M  ⊆  {0,1}n, given a sample datum x∈M, using the MDL principle is clearly out of the question. The datum x can be literally described in n bits by the trivial MDL code M = {x} with x literal at self-delimiting model cost at most n + O( log n) bits and data-to-model cost log |M| = 0. It can be concluded that the only sets M that can possibly be inferred from x (using MDL or any other effective deterministic procedure) are those that have K(M)  ≤  K(x)  ≤  n  +  O( log n). Such sets are extremely rare: only an at most

[formula]

fraction of all subsets of {0,1}n has that small prefix complexity. This negligible fraction of possibly learnable sets shows that such sets are very nonrandom; they are simple in the sense that their characteristic sequences have great regularity (otherwise the Kolmogorov complexity could not be this small). But this is all right: we do not want to learn random, meaningless, languages, but only languages that have meaning. "Meaning" is necessarily expressed in terms of regularity.

Even if we can learn the target model by an MDL algorithm in the limit, by selecting a sequence of models that decrease the MDL code with each next model, it can still be the case that a later model in this sequence is a worse model than a preceding one. Theorem [\ref=theo.approxim] showed conditions that prevent this from happening. We now show that if those conditions are not satisfied, it can indeed happen.

There is a datum x (|x| = n) with explanations (pt,Mt) and (pt',Mt') such that |pt'| +  log mt'  ≤  |pt| +  log mt  -  10 log n but δ(x|Mt')  ≫  δ(x|Mt). That is, Mt' is much worse fitting than Mt. There is an MDL algorithm A(x,n) generating (pt,Mt) and (pt',Mt') as best explanations with t'  >  t.

Note that the condition of Theorem [\ref=theo.approxim] is different from the first inequality in Theorem [\ref=theo.fluctuate] since the former required an extra - |pt| + K(Mt) term in the right-hand side.

Fix datum x of length n which can be divided in uvw with u,v,w of equal length (say n is a multiple of 3) with [formula], [formula], [formula], and [formula] (with the last four equalities holding up to additive O( log n) terms). Additionally, take n sufficiently large so that 0.1n  ≫  10 log n.

Define [formula] and an MDL algorithm A(x,n) that examines the sequence of models Mi  =  {xi}{0,1}n - i, with [formula]. The algorithm starts with candidate model M0 and switches from the current candidate to candidate Mi, [formula], if that model gives a shorter MDL code than the current candidate.

Now K(Mi) = K(xi) + O( log n) and log mi  =  n - i, so the MDL code length Λ(Mi)  =  K(xi) + n - i + O( log n). Our MDL algorithm uses a compressor that does not compress xi all the way to length K(xi), but codes xi self-delimitingly at 0.9i bits, that is, it compresses xi by 10%. Thus, the MDL code length is 0.9i +  log mi  =  0.9i + n - i  =  n - 0.1i for every contemplated model Mi ([formula]). The next equalities hold again up to O( log n) additive terms.

The MDL code length of the initial candidate model M0 is n. The randomness deficiency [formula]. The last equality holds since clearly [formula].

For the contemplated model Mn / 3 we obtain the following. The MDL code length for model Mn / 3 is n - n / 30. The randomness deficiency [formula].

For the contemplated model M2n / 3 we obtain the following. The MDL code length is n - 2n / 30. The randomness deficiency is [formula].

Thus, our MDL algorithm initializes with candidate model M0, then switches to candidate Mn / 3 since this model decreases the MDL code length by n / 30. Indeed, Mn / 3 is a much better model than M0, since it decreases the randomness deficiency by a whopping [formula]. Subsequently, however, the MDL process switches to candidate model M2n / 3 since it decreases the MDL code length greatly again, by n / 30. But M2n / 3 is a much worse model than the previous candidate Mn / 3, since it increases the randomness deficiency again greatly by [formula].

By Theorem [\ref=theo.approxim] we know that if in the process of MDL estimation by a sequence of significantly decreasing MDL codes a candidate model is represented by its shortest program, then the following candidate model which improves the MDL code is actually a model of at least as good fit as the preceding one. Thus, if in the example used in the proof above we encode the models at shortest code length, we obtain MDL code lengths n for M0, [formula] for Mn / 3, and [formula] for M2n / 3. Hence the MDL estimator using shortest model code length changes candidate model M0 for Mn / 3, improving the MDL code length by [formula] and the randomness deficiency by [formula]. However, and correctly, it does not change candidate model Mn / 3 for M2n / 3, since that would increase the MDL code length by [formula]. It so prevents, correctly, to increase the randomness deficiency by [formula]. Thus, by the cited theorem, the oscillating randomness deficiency in the MDL estimation process in the proof above can only arise in cases where the consecutive candidate models are not coded at minimum cost while the corresponding two-part MDL code lengths are decreasing.

Inferring a Grammar (DFA) From Positive Examples

Assume that we want to infer a language, given a set of positive examples (elements of the language) D. For convenience we restrict the question to inferring a language [formula] with M'  ⊆  {0,1}n. We can view this as inferring the slice Ln (corresponding to M') of the target language L consisting of all words of length n in the target language. Since D consists of a subset of positive examples of M' we have [formula]. To infer a language M from a set of positive examples [formula] is, of course, a much more natural situation than to infer a language from a singleton x as in the previous section. Note that the complexity K(x) of a singleton x of length n cannot exceed n  +  O( log n), while the complexity of a language of which x is an element can rise to 2n  +  O( log n). In the multiple data sample setting K(D) can rise to 2n  +  O( log n), just as K(M) can. That is, the description of n takes O( log n) bits and the description of the characteristic sequence of a subset of {0,1}n may take 2n bits, everything self-delimitingly. So contrary to the singleton datum case, in principle models M of every possible model complexity can be inferred depending on the data D at hand. An obvious example is D = M - {  #  d}. Note that the cardinality of D plays a role here, since the complexity [formula] with equality for certain D. A traditional and well-studied problem in this setting is to infer a grammar from a language example.

The field of grammar induction studies among other things a class of algorithms that aims at constructing a grammar by means of incremental compression of the data set represented by the digraph of a deterministic finite automaton (DFA) accepting the data set. This digraph can be seen as a model for the data set. Every word in the data set is represented as a path in the digraph with the symbols either on the edges or on the nodes. The learning process takes the form of a guided incremental compression of the data set by means of merging or clustering of the nodes in the graph. None of these algorithms explicitly makes an estimate of the data-to-model code. Instead they use heuristics to guide the model reduction. After a certain number of computational steps a proposal for a grammar can be constructed from the current state of the compressed graph. Examples of such algorithms are SP [\cite=Wolff:03-19-193] [\cite=DBLP:journals/ngc/Wolff95], EMILE [\cite=ICGI:AdrVer2002], ADIOS [\cite=solan05languageLearningPNAS], and a number of DFA induction algorithms, such as "Evidence Driven State Merging" (EDSM), [\cite=ICGI:LanPeaPri98] [\cite=ECMLPKDD/CFG03]. Related compression-based theories and applications appear in [\cite=LCLMV04] [\cite=CV07]. Our results (above and below) do not imply that compression algorithms improving the MDL code of DFAs can never work on real life data sets. There is considerable empirical evidence that there are situations in which they do work. In those cases specific properties of a restricted class of languages or data sets must be involved.

Our results are applicable to the common digraph simplification techniques used in grammar inference. The results hold equally for algorithms that use just positive examples, just negative examples, or both, using any technique (not just digraph simplification).

A DFA A = (S,Q,q0,t,F), where S is a finite set of input symbols, Q is a finite set of states, t:Q  ×  S  →  Q is the transition function, q0∈Q is the initial state, and F  ⊆  Q is a set of final states.

The DFA A is started in the initial state q0. If it is in state q∈Q and receives input symbol s∈S it changes its state to q'  =  t(q,s). If the machine after zero or more input symbols, say [formula], is driven to a state q∈F then it is said to accept the word [formula], otherwise it rejects the word w. The language accepted by A is L(A) = {w:w is accepted by A}. We denote [formula].

We can effectively enumerate the DFAs as [formula] in lexicographic length-increasing order. This enumeration we call the standard enumeration.

The first thing we need to do is to show that all laws that hold for finite-set models also hold for DFA models, so all theorems, lemmas, and remarks above, both positive and negative, apply. To do so, we show that for every data sample D  ⊆  {0,1}n and a contemplated finite set model for it, there is an almost equivalent DFA.

Let d = |D|, M' = M - {  #  d} and m = |M'|. For every D  ⊆  M'  ⊆  {0,1}n there is a DFA A with Ln(A) = M' such that K(A,n)  ≤  K(M') + O(1) (which implies K(A,d,n)  ≤  K(M) + O(1)), and δ(D|M)  ≤  δ(D|A,d,n) + O(1).

Since M' is a finite set of binary strings, there is a DFA that accepts it, by elementary formal language theory. Define DFA A such that A is the first DFA in the standard enumeration for which Ln(A) = M'. (Note that we can infer n from both M and M'.) Hence, K(A,n)  ≤  K(M') + O(1) and K(A,d,n)  ≤  K(M) + O(1). Trivially, [formula] and K(D|A,n)  ≤  K(D|M') + O(1), since A may have information about D beyond M'. This implies K(D|A,d,n)  ≤  K(D|M) + O(1), so that δ(D|M)  ≤  δ(D|A,d,n) + O(1).

Lemma [\ref=prop.2] is the converse of Lemma [\ref=prop.1]: for every data sample D and a contemplated DFA model for it, there is a finite set model for D that has no worse complexity, randomness deficiency, and worst-case data-to-model code for D, up to additive logarithmic precision.

Use the terminology of Lemma [\ref=prop.1]. For every D  ⊆  Ln(A)  ⊆  {0,1}n, there is a model [formula] such that [formula], K(M')  ≤  K(A,n) + O(1) (which implies K(M)  ≤  K(A,d,n) + O(1)), and δ(D|M)  ≤  δ(D|A,d,n) - O(1).

Choose M' = Ln(A). Then, [formula] and both K(M')  ≤  K(A,n) + O(1) and K(M)  ≤  K(A,d,n) + O(1). Since also K(D|A,d,n)  ≤  K(D|M) + O(1), since A may have information about D beyond M, we have δ(D|A,d,n)  ≥  δ(D|M) + O(1).

MDL Estimation

To analyze the MDL estimation for DFAs, given a data sample, we first fix details of the code. For the model code, the coding of the DFA, we encode as follows. Let A = (Q,S,t,q0,F) with q = |Q|, s = |S|, and f = |F|. By renaming of the states we can always take care that F  ⊆  Q are the last f states of Q. There are qsq different possibilities for t, q possibilities for q0, and q possibilities for f. Altogether, for every choice of q,s there are ≤  qqs + 2 distinct DFAs, some of which may accept the same languages.

Small Model Cost but Difficult to Decode: We can enumerate the DFAs by setting [formula] and for every i consider all partitions i = q  +  s to two positive integer summands, and for every particular choice of q,s considering every choice of final states, transition function, and initial state. This way we obtain a standard enumeration [formula] of all DFAs, and, given the index j of a DFA Aj we can retrieve the particular DFA concerned, and for every n we can find Ln(Aj).

Larger Model Cost but Easy to Decode: We encode a DFA A with q states and s symbols self-delimitingly by

The encoding of the number of symbols s in self-delimiting format in ⌈ log s⌉  +  2⌈ log  log s⌉ + 1 bits;

The encoding of the number of states q in self-delimiting format in ⌈ log q⌉  +  2⌈ log  log q⌉ + 1 bits;

The encoding of the set of final states F by indicating that all states numbered q - f,q - f + 1,q are final states, by just giving q - f in ⌈ log q⌉ bits;

The encoding of the initial state q0 by giving its index in the states [formula], in ⌈ log q⌉ bits; and

The encoding of the transition function t in lexicographic order of Q  ×  S in ⌈ log q⌉ bits per transition, which takes qs⌈ log q⌉ bits altogether.

Altogether, this encodes A in a self-delimiting format in (qs + 3)⌈ log q⌉  +  2⌈ log  log q⌉  +  ⌈ log s⌉  +  2⌈ log  log s⌉ + O(1)  ≈  (qs + 4) log q  +  2 log s bits. Thus, we reckon the model cost of a (q,s)-DFA as m(q,s) = (qs + 4) log q  +  2 log s bits. This cost has the advantage that it is easy to decode and that m(q,s) is an easy function of q,s. We will assume this model cost.

Data-to-model cost: Given a DFA model A, the word length n in log n  +  2 log  log n bits which we simplify to 2 log n bits, and the size d of the data sample D  ⊆  {0,1}n, we can describe D by its index j in the set of d choices out of l = Ln(A) items, that is, up to rounding upwards, [formula] bits. For 0  <  d  ≤  l / 2 this can be estimated by [formula], where H(p) = p log 1 / p  +  (1 - p) log 1 / (1 - p) (0  <  p  <  1) is Shannon's entropy function. For d = 1 or d = l we set the data-to-model cost to 1  +  2 log n, for 1  <  d  ≤  l / 2 we set it to 2 log n  +  lH(d / l) (ignoring the possible saving of a log l / 2 term), and for l / 2 < d < l we set it to the cost of d' = l - d. This reasoning brings us to the following MDL cost of a data sample D for DFA model A:

The MDL code length of a data sample D of d strings of length n, given d, for a DFA model A such that D  ⊆  Ln(A) denoting l = |Ln(A)|, is given by

[formula]

If d is not given we write MDL(D,A).

Randomness Deficiency Estimation

Given data sample D and DFA A with D  ⊆  Ln(A)  ⊆  {0,1}n, we can estimate the randomness deficiency. Again, use l = Ln(A) and d = |D|. By [\eqref=eq:randomness-deficiency], the randomness deficiency is

[formula]

Then, substituting the estimate for [formula] from the previous section, up to logarithmic additive terms,

[formula]

Thus, by finding a computable upper bound for K(D|A,d,n), we can obtain a computable lower bound on the randomness deficiency δ(D|A,d,n) that expresses the fitness of a DFA model A with respect to data sample D.

Less MDL Code Length Doesn't Mean Better Model

The task of finding the smallest DFA consistent with a set of positive examples is trivial. This is the universal DFA accepting every example (all of {0,1}n). Clearly, such a universal DFA will in many cases have a poor generalization error and randomness deficiency. As we have seen, optimal randomness deficiency implies an optimal fitting model to the data sample. It is to be expected that the best fitting model gives the best generalization error in the case that the future data are as typical to this model as the data sample is. We show that the randomness deficiency behaves independently of the MDL code, in the sense that the randomness deficiency can either grow or shrink with a reduction of the length of the MDL code.

We show this by example. Let the set D be a sample set consisting of 50% of all binary strings of length n with an even number of 1's. Note, that the number of strings with an even number of 1's equals the number of strings with an odd number of 1's, so d = |D| = 2n / 4. Initialize with a DFA A such that Ln(A) = D. We can obtain D directly from A,n, so we have K(D|A,n) = O(1), and since d = l (l = |Ln(A)|) we have [formula], so that altogether δ(D|A,d,n) =  - O(1), while MDL(D,A)  =  MDL(D,A|d) + O(1)  =  (qs + 4) log q  +  2 log s  +  2 log n + O(1) = (2q + 4) log q  +  2 log n + O(1), since s = 2. (The first equality follows since we can obtain d from n. We obtain a negative constant randomness deficiency which we take to be as good as 0 randomness deficiency. All arguments hold up to an O(1) additive term anyway.) Without loss of generality we can assume that the MDL algorithm involved works by splitting or merging nodes of the digraphs of the produced sequence of candidate DFAs. But the argument works for every MDL algorithm, whatever technique it uses.

Initialize: Assume that we start our MDL estimation with the trivial DFA A0 that literally encodes all d elements of D as a binary directed tree with q nodes. Then, 2n - 1  -  1  ≤  q  ≤  2n + 1 - 1, which yields

[formula]

The last approximate equality holds since d = l, and hence [formula] and K(D|A0,d,n) = O(1). Since the randomness deficiency δ(D|A0,d,n)  ≈  0, it follows that A0 is a best fitting model for D. Indeed, it represents all conceivable properties of D since it literally encodes D. However, A0 does not achieve the optimal MDL code.

Better MDL estimation: In a later MDL estimation we improve the MDL code by inferring the parity DFA A1 with two states (q = 2) that checks the parity of 1's in a sequence. Then,

[formula]

We now consider two different instantiations of D, denoted as D0 and D1. The first one is regular data, and the second one is random data.

Case 1, regular data: Suppose D = D0 consisting of the lexicographic first 50% of all n-bit strings with an even number of occurrences of 1's. Then K(D0|A1,d,n) = O(1) and

[formula]

In this case, even though DFA A1 has a much better MDL code than DFA A0 it has nonetheless a much worse fit since its randomness deficiency is far greater.

Case 2, random data: Suppose D is equal to D1, where D1 is a random subset consisting of 50% of the n-bit strings with even number of occurrences of 1's. Then, [formula], and

[formula]

In this case, DFA A1 has a much better MDL code than DFA A0, and it has equally good fit since both randomness deficiencies are about 0.

We conclude that improved MDL estimation of DFAs for multiple data samples doesn't necessarily result in better models, but can do so nonetheless.

By Theorem [\ref=theo.approxim] we know that if, in the process of MDL estimation by a sequence of significantly decreasing MDL codes, a candidate DFA is represented by its shortest program, then the following candidate DFA which improves the MDL estimation is actually a model of at least as good fit as the preceding one. Let us look at an Example: Suppose we start with DFA A2 that accepts all strings in {0,1}*. In this case we have q = 1 and

[formula]

Here [formula], since [formula]. Suppose the subsequent candidate DFA is the parity machine A1. Then,

[formula]

since K(D0|A1,d,n) = O(1). Since [formula], we have [formula], and [formula]. Therefore, the improved MDL cost from model A2 to model A1 is accompanied by an improved model fitness since the randomness deficiency decreases as well. This is forced by Theorem [\ref=theo.approxim], since both DFA A1 and DFA A2 have K(A1),K(A2) = O(1). That is, the DFAs are represented and penalized according to their shortest programs (a fortiori of length O(1)) and therefore improved MDL estimation increases the fitness of the successive DFA models significantly.

Appendix: Preliminaries

Self-delimiting Code

A binary string y is a proper prefix of a binary string x if we can write x = yz for z  ≠  ε. A set [formula] is prefix-free if for every pair of distinct elements in the set neither is a proper prefix of the other. A prefix-free set is also called a prefix code and its elements are called code words. As an example of a prefix code, encode the source word [formula] by the code word

[formula]

This prefix-free code is called self-delimiting, because there is fixed computer program associated with this code that can determine where the code word x̄ ends by reading it from left to right without backing up. This way a composite code message can be parsed in its constituent code words in one pass, by the computer program. Since we use the natural numbers and the binary strings interchangeably, the notation |x̄| where x is ostensibly an integer means the length in bits of the self-delimiting code of the xth binary string. On the other hand, the notation [formula] where x is ostensibly a binary string means the self-delimiting code of the length |x| of the binary string x. Using this code we define the standard self-delimiting code for x to be [formula]. It is easy to check that [formula] and |x'| = n + 2 log n + 1. Let 〈  ·  〉 denote a standard invertible effective one-to-one code from N  ×  N to a subset of N. For example, we can set 〈x,y〉  =  x'y or 〈x,y〉  =  x̄y. We can iterate this process to define 〈x,〈y,z〉〉, and so on.

Kolmogorov Complexity

For precise definitions, notation, and results see the textbook [\cite=LiVi97]. Informally, the Kolmogorov complexity, or algorithmic entropy, K(x) of a string x is the length (number of bits) of a shortest binary program (string) to compute x on a fixed reference universal computer (such as a particular universal Turing machine). Intuitively, K(x) represents the minimal amount of information required to generate x by any effective process. The conditional Kolmogorov complexity K(x|y) of x relative to y is defined similarly as the length of a shortest program to compute x, if y is furnished as an auxiliary input to the computation. For technical reasons we use a variant of complexity, so-called prefix complexity, which is associated with Turing machines for which the set of programs resulting in a halting computation is prefix free. We realize prefix complexity by considering a special type of Turing machine with a one-way input tape, a separate work tape, and a one-way output tape. Such Turing machines are called prefix Turing machines. If a machine T halts with output x after having scanned all of p on the input tape, but not further, then T(p) = x and we call p a program for T. It is easy to see that {p:T(p) = x,x∈{0,1}*} is a prefix code.

Let [formula] be a standard enumeration of all prefix Turing machines with a binary input tape, for example the lexicographic length-increasing ordered syntactic prefix Turing machine descriptions, and let [formula] be the enumeration of corresponding functions that are computed by the respective Turing machines (Ti computes φi). These functions are the partial recursive functions or computable functions (of effectively prefix-free encoded arguments). The prefix (Kolmogorov) complexity of x is the length of the shortest binary program from which x is computed. For the development of the theory we require the Turing machines to use auxiliary (also called conditional) information, by equipping the machine with a special read-only auxiliary tape containing this information at the outset.

One of the main achievements of the theory of computation is that the enumeration [formula] contains a machine, say U = Tu, that is computationally universal in that it can simulate the computation of every machine in the enumeration when provided with its index: U(〈y,īp)  =  Ti(〈y,p〉) for all i,p,y. We fix one such machine and designate it as the reference universal prefix Turing machine.

Using this universal machine we define the prefix (Kolmogorov) complexity

[formula]

the conditional version of the prefix Kolmogorov complexity of x given y (as auxiliary information). The unconditional version is set to K(x) = K(x|ε).

In this paper we use the prefix complexity variant of Kolmogorov complexity only for convenience; the plain Kolmogorov complexity without the prefix property would do just as well. The functions K(  ·  ) and K(  ·  |  ·  ), though defined in terms of a particular machine model, are machine-independent up to an additive constant and acquire an asymptotically universal and absolute character through Church's thesis, that is, from the ability of universal machines to simulate one another and execute any effective process. The Kolmogorov complexity of an individual object was introduced by Kolmogorov [\cite=Ko65] as an absolute and objective quantification of the amount of information in it. The information theory of Shannon [\cite=Sh48], on the other hand, deals with average information to communicate objects produced by a random source. Since the former theory is much more precise, it is surprising that analogues of theorems in information theory hold for Kolmogorov complexity, be it in somewhat weaker form. An example is the remarkable symmetry of information property. Let x* denote the shortest prefix-free program for a finite string x, or, if there are more than one of these, then x* is the first one halting in a fixed standard enumeration of all halting programs. It follows that K(x) = |x*|. Denote K(x,y) = K(〈x,y〉). Then,

[formula]

Precision

It is customary in this area to use "additive constant c" or equivalently "additive O(1) term" to mean a constant, accounting for the length of a fixed binary program, independent from every variable or parameter in the expression in which it occurs.

Appendix: Structure Functions and Model Selection

We summarize a selection of the results in [\cite=VV02]. There, the data sample D is a singleton set {x}. The results extend to the multiple data sample case in the straightforward way.

(i) The MDL code length λD(α) with D  ⊆  {0,1}n and d = |D| can assume essentially every possible relevant shape λ(α) as a function of the maximal model complexity α that is allowed up to an additive O( log dn) term in argument and value. (Actually, we can take this term as [formula], but since this is cumbersome we use the larger O( log dn) term. The difference becomes large for 2n - 1  <  d  ≤  2n.) These λ's are all integer-valued nonincreasing functions such that λ is defined on

[formula]

Biography

Pieter Adriaans received his Ph.D. from the University of Amsterdam (1992). He and his business partner, Dolf Zantinge, founded the software developer Syllogic B.V. in 1989, and sold the company to Perot Systems Corporation in 1997. Adriaans is Professor of Computer Science at the University of Amsterdam since 1997. He serves as editor of the Handbook of Philosophy of Information, a project of Elseviers Science Publishers, and is a member of the ICGI (International Conference on Grammar Induction) steering committee. He is adviser of Robosail Systems, a company that manufactures and sells self-learning autopilots, as well as senior research adviser for Perot Systems Corporation. He has worked on learning, grammar induction, philosophy of information, and information and art. He holds several patents on adaptive systems management and on a method for automatic composition of music using grammar induction techniques. Adriaans acted as project leader for various large international research and development projects: amongst others, the development of distributed database management software in cooperation with IBM and Prognostic and Health management for the Joint Strike Fighter. He wrote papers and books on topics related to both computer science and philosophy, including a book on systems analysis and books on client/server and distributed databases as well as data mining. He composes and plays rock music and is an avid painter. In 2006 he had an overview exhibition showing the harvest of forty years of painting.

Paul M.B. Vitányi received his Ph.D. from the Free University of Amsterdam (1978). He is a Fellow at the national research institute for mathematics and computer science (CWI) in the Netherlands, and Professor of Computer Science at the University of Amsterdam. He serves on the editorial boards of Distributed Computing (until 2003), Information Processing Letters, Theory of Computing Systems, Parallel Processing Letters, International journal of Foundations of Computer Science, Journal of Computer and Systems Sciences (guest editor), and elsewhere. He has worked on cellular automata, computational complexity, distributed and parallel computing, machine learning and prediction, physics of computation, Kolmogorov complexity, information theory, and quantum computing, publishing about 200 research papers and some books. He received a knighthood in 2007. Together with Ming Li they pioneered applications of Kolmogorov complexity and co-authored "An Introduction to Kolmogorov Complexity and its Applications," Springer-Verlag, New York, 1993 (second edition 1997, third edition 2008), parts of which have been translated into Chinese, Russian, and Japanese.