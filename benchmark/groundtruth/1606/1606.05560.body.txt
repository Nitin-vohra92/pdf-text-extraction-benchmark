Estimation of matrix trace using machine learning

Introduction

Many applications require the trace calculation of the matrix whose explicit form is not given but only its matrix multiplication to an arbitrary vector is available. An example is the trace calculation of the inverse of Dirac matrix in lattice quantum chromodynamics (QCD) [\cite=Bhattacharya:2015esa]. The Dirac matrix is large and sparse so that explicit matrix inversion is not feasible, but the matrix multiplication of the inverse matrix to a vector is available through iterative linear equation solvers, such as the Conjugate Gradient (CG) algorithm [\cite=Hestenes&Stiefel:1952]. In general, an exact solution can be obtained by N matrix-vector multiplications for a N  ×  N matrix. However, such an exact estimation is computationally expensive for large matrices, so stochastic approaches, such as the Hutchison estimator[\cite=Hutchinson89], are widely used. For specific structures of matrices, such as the banded matrices, improved trace estimators can be defined by exploiting the matrix structure, so that precise trace estimates are obtained by small number of matrix-vector multiplications [\cite=Bekas:2007] [\cite=Tang:2012] [\cite=Stathopoulos:2013aci]. In general, however, the matrix structure is too complicated to be exploited by human knowledge, while it can be explored by using machine learning.

Machine learning is a field of science that makes a computer to act based on the learning from data. In contrast to the specific models with small number of free parameters in conventional data analysis, machine learning uses general models with large number of free parameters, such as the artificial neural network (ANN) [\cite=McCulloch1943] [\cite=Werbos74] or the support vector machines (SVMs) [\cite=Boser:1992:TAO:130385.130401]. Based on the generality of the learning model and large number of free parameters, computer builds its own model from data.

In this paper, the idea of machine learning is applied to the trace estimation. We build a trace estimator with high degrees of freedom, and train the estimator by using large number of matrices that have similar structures. As other machine learning applications, the learning procedure is computationally expensive, but the trace estimation using the trained estimator requires only small number of matrix-vector multiplications. In section [\ref=sec:theory], we define the new trace estimator and learning procedure, and discuss the quality of the estimates and bias correction. Numerical experiments of the new trace estimator are shown in Section [\ref=sec:expt], and we conclude in Section [\ref=sec:sum].

Theory

Backgrounds

Let us consider a L  ×  L matrix A where the matrix itself is difficult to obtain, but its product to a vector is easy to evaluate. The exact trace of the matrix can be calculated by

[formula]

where [formula] is the vector whose i-th component is 1 and other components are 0. This method requires L times of matrix-vector multiplications, so it is computationally very expensive for large matrices.

The trace of the matrix can be estimated by using the stochastic estimator

[formula]

with the random noise vectors [formula] satisfying

[formula]

The uncertainty of the stochastic trace estimator depends on the structure of the matrix A and type of the random noise [formula], because some type of random noise cancel the contribution from the elements of the matrix that cannot contribute to the trace but only to noise for the matrices that have specific structure [\cite=Bhattacharya:2015gma]. One popular choice of the random noise vector is to filling the vector elements following Rademacher distribution. Corresponding trace estimator is called the Hutchinson estimator [\cite=Hutchinson89].

When structure of the matrix A is known, one could use a small number of sophisticatedly chosen probing vectors, instead of the large number of random noise vectors, for the precise trace estimation [\cite=Coleman1983EoS] [\cite=Bekas:2007] [\cite=Tang:2012]. It is called the probing method. It also can be applied to a trace estimation for the inverse of a sparse matrix M- 1 by approximating the structure of M- 1 using the sparsity pattern of the powers of the matrix, Mn [\cite=Tang:2012] [\cite=Stathopoulos:2013aci]. When structure of the matrix is unknown or too complex to be exploited, however, one cannot construct such probing vectors by hand. If there is a large set of matrices that have similar structures, one may consider to find the probing vectors by using those data set instead of constructing the probing vectors by using human knowledge.

Construction of Probing Vectors using Machine Learning

Our goal is to find a set of probing vectors [formula] for [formula] that probes the trace of a matrix A as

[formula]

for a given number of probing vectors Np, by using the machine learning. The machine learning requires input data to train the probing vectors: a set of matrices that have similar structures, and the traces of those matrices. Let us consider a set of sample matrices [formula] from a distribution. The cost function, which shows the difference between the exact answer and the probing vector estimate, is defined by

[formula]

The main idea is to find the probing vectors that minimize the cost function. In this paper, we consider the online machine learning, which updates the probing vectors using only one input training data (matrix) at each update step, as we find that the online learning is more efficient than the batch learning, which uses more than one input training data in an update step, in this application.

In the practical calculation, the trace of the matrices [formula] are estimated by using the Hutchison estimator in Eq. [\eqref=eq:tr_stoch] as we are considering matrices whose exact traces are difficult to calculate. In the numerical test given in Section [\ref=sec:expt], we find that a sloppy estimator of [formula] with relatively small number of random noise vectors can construct the probing vectors that yield precise estimates. In addition to the sloppy estimator, reusing an input matrix and its trace estimate multiple times in the training procedure can further reduce the trace estimation cost. Details are given in Section [\ref=sec:expt].

Let us define a set of probing vectors at a given training time t as [formula]. In the training process, they are updated as follows

[formula]

for [formula] with initial condition Δw0 = 0. In the numerical experiments, we fill the initial probing vectors w1 by using randomly chosen numbers following normal distribution of N(0,12), but one could use elaborately chosen initial guesses. Here [formula] is the gradient of the cost function with respect to the elements of the probing vectors, which can be calculated analytically, and γt is the parameter called the learning rate. With properly chosen learning rate, the update moves the probing vectors towards the steepest descent direction reducing the cost function. In addition to the steepest descent method, we include the momentum term ηΔwt - 1 to improve the speed of convergence [\cite=Rumelhart:1988]. In our numerical experiments, we use [formula] depending on the other parameters.

Determination of the learning rate γt is important to make sure that the probing vectors efficiently converge to the global minimum that yields the most precise trace estimate. If it is too small, it converges slowly, and if it is too large, it does not converge to the minimum but oscillate. In early stage of the training, we determine the γt by using a one-dimensional minimizer in order to maximize the training efficiency. After 100 updates, we calculate γ0 by the median of the γt values of the first 100 updates, and scale the learning rate as

[formula]

where α is the parameter that determines the speed of scaling. When [formula], the training actively updates the probing vectors to capture the structure of each input matrix, and when t  ≫  1 / α, the training fine-tunes the probing vectors to describe the general structure of input matrices.

Quality of Estimates and Bias Correction

Once the training is over, the probing vectors can be used for the estimation of trace of a matrix as Eq. [\eqref=eq:probe_est]. Naturally, the estimate may not be exact, and it could yield somewhat different value from the exact trace of the matrix. Considering a set of test matrices {Mi}, one can define the deviation of the estimate from the exact trace by

[formula]

The quality of estimates can be assessed based on two factors: (1) non-zero mean value of di, which gives the bias of estimate and (2) fluctuation (standard deviation) of di over different matrices Mi, which is related to the accuracy of the estimate.

The bias can be corrected easily by redefining the trace estimator as

[formula]

where [formula] is an average of di over a fixed number of sample matrices. In general, one needs to determine the [formula] more precise than the fluctuation of di so that we can ignore the bias in the error estimation. Since the statistical uncertainty of an average over N samples is [formula] of the standard deviation, averaging over 100 samples of di will give a precise enough estimation.

Practically, the exact value of di is very difficult to obtain because it requires the exact value of [formula]. Instead of the exact [formula] calculation, one can use the stochastic estimates of those. Due to the uncertainty of the stochastic estimation, one would need large number of samples of di to determine [formula] precisely. However, the computation cost can be negligible if one reuses the stochastic trace estimates used in the training procedure.

After the [formula] correction, uncertainty of the trace estimator Eq. [\eqref=eq:probe_est2] depends only on the fluctuation of di. If di is distributed normally, one can report the standard deviation of di from the set of test matrices {Mi} as an uncertainty of the trace estimate. Otherwise, one can devise a proper error estimation based on the distribution of di.

If one calculates an expectation value of a function of traces for a set of matrices, an unbiased estimator can be defined by applying the technique used in Refs. [\cite=Bali:2009hu] [\cite=Blum:2012uh] as

[formula]

The first term on the right hand side is the average calculated by using the probing vector trace estimator defined in Eq. [\eqref=eq:probe_est2]. The second term on the right hand side is the bias correction term that takes care of all the misestimation of the trace using the probing vectors. Here we assume that Mi are independent and identically distributed, so use only the first Nc matrices [formula] for the correction term, but they could be chosen randomly or maximally separated in the sequence of Mi. The [formula] in the equation can be any type of unbiased trace estimator, such as the exact estimator in Eq. [\eqref=eq:tr_exact] or the stochastic estimator in Eq. [\eqref=eq:tr_stoch].

The role of the second term is following. First, let us take expectation value to the right hand side of Eq. [\eqref=eq:unbiased_est]. The terms using the biased estimator [formula] cancel, and the only remaining is the term using unbiased estimator, [formula]. Hence the estimator defined in Eq. [\eqref=eq:unbiased_est] is unbiased. Second, let us take variance to the right hand side of Eq. [\eqref=eq:unbiased_est] in order to see the statistical uncertainty of the estimate. In addition to the variance of the first term, the variance of the second term and the correlation between the first and second term comes in. In this way, the correction term converts the systematic uncertainty of the trace estimator using probing vectors to the statistical uncertainty, keeping the final estimates unbiased. If one uses the unbiased estimator defined in Eq. [\eqref=eq:unbiased_est], one does not need to include the [formula] bias correction term in Eq. [\eqref=eq:probe_est2] because the bias will be corrected automatically in the new definition of the estimator. However, including the [formula] correction might reduce the statistical uncertainty in final estimation in some cases.

The size of statistical uncertainty increased by the correction term is depending on two factors: (1) the correlation between [formula] and [formula], and (2) the number of samples used in the correction term, Nc. If the trace estimate using probing vectors is good enough so that the function values from those two trace calculations [formula] and [formula] are very close, the contribution of the correction term to the overall statistical uncertainty would be small, and one could use small Nc. If the trace estimate using probing vectors is not precise and the two function values are quite different, one would need to use large Nc to suppress the increase of statistical error due to the correction term. In general, we use the unbiased estimator Eq. [\eqref=eq:unbiased_est] when we can take Nc  ≪  N.

Numerical Experiments

In this section, we demonstrate the performance of the trace estimator using probing vectors described in the previous section. For the numerical test, we train probing vectors to estimate the trace of inverse of the random L  ×  L matrix M generated by

[formula]

where ξij are independent and identically distributed random variables following normal distribution of N(0,0.12). Note that this matrix is an discrete symmetric derivative with identity: [formula], except the Gaussian noise. It has the similar form with the Dirac operator in Lattice QCD [\cite=degrand2006lattice] [\cite=gattringer2009quantum]. This is a sparse matrix whose inverse is expensive to calculate, but the matrix-vector product of the inverse matrix can be calculated by using iterative methods. In this numerical test, we use BiCGSTAB algorithm[\cite=vanderVorst:1992] to evaluate the product of the inverse matrix M- 1 and an arbitrary vector.

We test two different sizes of matrices: L = 100 and 1000. Note that the training requires input matrices that have similar structures and the traces of each matrix. Although it is possible to use the exact trace calculations on those sizes of matrices we are testing in this section, we use estimates from the Hutchison estimator Eq. [\eqref=eq:tr_stoch] for the traces of the input matrices so that the results are scalable to larger size matrices, whose exact traces are very expensive to calculate. The traces of inverse matrices are 70.92 ±   0.07 and 709.20 ±   0.22 for L = 100 and 1000, respectively. The numbers after "±  " notation are the standard deviation of the traces of random matrices. Unless explicitly noted, the discussion in this section is using the training parameters given in Table [\ref=tab:param].

In the simulation, we find that the distribution of the estimation error di, defined in Eq. [\eqref=eq:est_err], is following the normal distribution, as shown in Fig. [\ref=fig:err_hist]. Hence we use the standard deviation of di as the uncertainty of the estimates. Fig. [\ref=fig:noise-dep] shows the learning efficiency for different number of noise vectors used in the Hutchison trace estimator. It shows that the learning efficiency is saturating when the number of noise vectors is larger than 800 (1600) for L = 100 (1000). One interesting point is that the final uncertainty of the trace estimator is much smaller than the accuracy of the Hutchison stochastic estimator we used in the training. By comparing the uncertainty of the Hutchison stochastic trace estimator given in Fig. [\ref=fig:tr-noise-dep], one finds that the error of the trace estimator using probing vectors are similar to that of Hutchison stochastic estimator with about 20000 noise vectors.

Although we use relatively small number of noise vectors for the trace estimation of the input matrices for training, the most expensive part of the computation is the trace estimation. Hence we generate a finite size of pool of input matrices, and randomly pick up input matrices for the training from the pool. In the training procedure, the same matrix can be picked up multiple times. Reusing the same trace estimation calculated at the first pick-up significantly reduces the training cost. Fig. [\ref=fig:reuse-dep] shows the learning efficiency for different size of the input matrix pool. It shows that the pool size of 105 input matrices is large enough to give reasonable training results.

Another important parameter in the training is the α that determines the scheduling of the learning rate, Eq. [\eqref=eq:learning_rate]. If the α is too large, the learning rate becomes tiny in early stage of the training, and it takes very long training period to converge. If the α is too small, the trace estimator using probing vectors tends to have large bias for finite training period. Fig. [\ref=fig:alpha-dep] shows the learning efficiency and bias of the estimator for different values of α. As expected, the training is not efficient when α is too small or too large, but the bias is smaller for the trainings with smaller α values.

As discussed in the previous section, the bias can be easily corrected by using the formulae given in Eq. [\eqref=eq:probe_est2] or Eq. [\eqref=eq:unbiased_est], so the bias is not a concern in choosing a proper value of α. However, the smaller value of α needs larger number of noise vectors for the trace estimation of training input matrices, as shown in Fig. [\ref=fig:noise-dep2]. The figure shows the training efficiency for different number of noise vectors when α = 0. By comparing it with Fig. [\ref=fig:noise-dep], one finds that the training efficiency of α = 0 training is worse than that of α = 10- 5 training when the number of noise vectors is small. This is because the learning rate is relatively large when α is small. When the learning rate is large, training results are shifting for trainings of each input matrix. If the traces of input matrices are poorly determined, the training results are contaminated and fluctuating by the errors of the trace estimations of the input matrices. When learning rate is small, however, training results depend on series of input matrices, not only on the last one input matrix, so the errors of trace estimation of the input matrices are averaged out.

Fig. [\ref=fig:probe-dep] shows the training efficiency for different number of probing vectors Np. As expected, the more probing vectors give the smaller estimate uncertainty. Except the smallest number of probing vector cases, the estimation errors after the training are about 0.01  ~  0.02 for L = 100, and 0.05  ~  0.10 for L = 1000, depending on the number of probing vectors. By comparing the results with the efficiency of the Hutchison stochastic estimator, Fig. [\ref=fig:tr-noise-dep], one finds that the accuracy of the probing vector trace estimation with about 30 probing vectors is similar to that of the Hutchison estimator with 20000  ~  30000 random noise vectors.

Conclusion

We proposed a new trace estimator of the matrix whose explicit form is difficult to obtain but its matrix multiplication to a vector is easy to evaluate. The form of the estimator is similar to the Hutchison stochastic trace estimator, but instead of the random noise vectors in Hutchison estimator, we use small number of probing vectors determined by the machine learning technique. Through the training procedure, the probing vectors become probes for the trace of a matrix with given structure. Similar to other machine learning applications, the training procedure is computationally expensive, as it requires unbiased trace estimations for the input matrices, and multiple matrix-vector multiplications. Once training is over, however, it becomes an efficient trace estimator that requires only small number of matrix-vector multiplications. In the numerical experiments, it is shown that the accuracy of the trace estimator with O(10) probing vectors is similar to that of the Hutchison estimator with O(10000) random noise vectors. Comparing at the same number of vectors, the estimator with probing vectors has more than 20 times smaller uncertainty than the Hutchison estimator with random noise vectors. The error of the probing vector estimator can be further reduced if one extends the training period with retuned parameters.

The quality of estimates are evaluated by using the deviation of the estimate from the exact trace, di, defined in Eq. [\eqref=eq:est_err]. In the numerical experiments we performed, it turns out that di is following the normal distribution. Hence we use the standard deviation of di as an uncertainty of the trace estimates. The trace estimates of the probing vector estimators can be biased, but a bias correction method using di is introduced in Eq. [\eqref=eq:probe_est2]. Another unbiased estimator, which converts the systematic error of the trace estimator to a statistical uncertainty, is presented in Eq. [\eqref=eq:unbiased_est].

In this paper, we explored a general trace estimator using the machine learning idea. One might be able to define a better trace estimator by exploiting the symmetry conditions in a given system. Furthermore, the idea of exploring a matrix structure by using machine learning would be applicable to many other matrix problems.

Acknowledgements

We thank Garrett Kenyon for discussions on machine learning algorithms. This research used resources of the Institutional Computing at Los Alamos National Laboratory, and the Oak Ridge Leadership Computing Facility at the Oak Ridge National Laboratory, which is supported by the Office of Science of the U.S. Department of Energy under Contract No. DE-AC05-00OR22725. This work is supported by the U.S. Department of Energy, Office of Science, Office of High Energy Physics under Contract No. DE-KA-1401020, and the LANL LDRD program.