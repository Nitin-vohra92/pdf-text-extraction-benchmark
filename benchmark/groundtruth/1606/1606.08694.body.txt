=1

Scalable image coding based on epitomes

Introduction

The latest HEVC standard [\cite=Sullivan2012b] is among the most efficient codec for image and video compression [\cite=Ohm2012]. However, the ever increasing spatial and/or temporal resolution, bit depth, or color gamut of modern images and videos, coupled with the heterogeneity of the distribution networks, calls for scalable coding solutions. Thus, a scalable extension of HEVC named SHVC was developed [\cite=Sullivan2013a] [\cite=Ye2014], which can encode enhancement layers with the scalability features mentioned above by using the appropriate inter-layer processing. Experiments demonstrate that SHVC outperforms simulcast as well as the previous scalable standard SVC [\cite=Kessentini2015]. In this paper, we focus on spatial scalability and we propose a novel scalable coding scheme based on the concept of epitome, first introduced in [\cite=Jojic2003] [\cite=Cheung2008]. The epitome in [\cite=Jojic2003] is defined as patch-based appearance and shape probability models learned from the image patches. The authors have shown that these probability models, together with appropriate inference algorithms, are useful for content analysis, inpainting or super-resolution. A second form of epitome has been introduced in [\cite=Wang2008] which can be seen as a summary of the image. This epitome is constructed by searching for self-similarities within the image using methods such as the KLT tracking algorithm. This type of epitome has been used for still image compression in [\cite=Cherigui2011] where the authors propose a rate-distortion optimized epitome construction method. The image is represented by its epitome together with a transformation map as well as a reconstruction residue. A novel image coding architecture has also been described in [\cite=Cherigui2014] which, instead of the classical block processing in a raster scan order, inpaints the epitome with in-loop residue coding.

We describe in this paper a novel spatially scalable image coding scheme in which the enhancement layer is only composed of the input image epitome. This factorized representation of the image is then used by the decoder to reconstruct the entire enhancement layer using single-image super-resolution (SR) techniques. Single-image SR methods can be broadly classified into two main categories: the interpolation-based methods [\cite=Li2001] [\cite=Tappen2003] [\cite=Fattal2007] and the example-based methods [\cite=Freeman2000] [\cite=Freeman2002] [\cite=HongChang2004] [\cite=Fan2007] [\cite=Glasner2009] [\cite=Yang2010a] [\cite=Yang2013] [\cite=Bevilacqua2014] [\cite=Zhang2015] which we consider here, focusing on two different techniques based on neighbor embedding [\cite=HongChang2004] and linear mappings [\cite=Yang2013]. The epitome patches transmitted in the enhancement layer (EL) and the corresponding base layer (BL) patches form a dictionary of pairs of high-resolution and low-resolution patches.

The first method based on neighbor embedding assumes that the BL and EL patches lie on two low and high resolution manifolds which share a similar local geometrical structure. In order to reconstruct an EL patch not belonging to the epitome, a local model of the corresponding BL patch is learned as a weighted combination of its nearest neighbors in the dictionary. The restored EL patch is then obtained by applying this weighted combination to the corresponding EL patches in the dictionary. The second approach based on linear mappings rely on a similar assumption, but directly models a projection function between BL patches and the corresponding EL patches in the dictionary. The projection function is learned using multivariate regression and is then applied to the current BL patch in order to obtain its restored EL version. This super-resolution step reconstructs the full enhancement layer while we only transmit the epitome. The proposed scheme thus allows reaching significant bit-rate reduction compared to traditional scalable coding schemes such as SHVC.

This paper is organized as follows. In section [\ref=sota:eptm] we review the background on epitomic models. Section [\ref=sec:eptm_svc] describes the proposed scheme, the epitome generation and encoding at the encoder side, and the epitome-based restoration at the decoder side. Finally, we present in section [\ref=sec:results] the results compared with SHVC.

Background on epitomes

The concept of epitome was first introduced by N. Jojic and V. Cheung in [\cite=Jojic2003] [\cite=Cheung2008]. It is defined as the condensed representation (meaning its size is only a fraction of the original size) of an image signal containing the essence of the textural properties of this image. This original epitomic model is based on a patch-based probabilistic approach. It was shown to be of high "completeness" in [\cite=Simakov2008], but introduces undesired visual artifacts, which is defined as a lack of "coherence". In fact since the model is learned by compiling patches drawn from the input image, patches that were not in the input image can appear in the epitome. The original epitomic model was also extended into a so-called Image-Signature-Dictionary (ISD) optimized for sparse representations [\cite=Aharon2008].

The aforementioned epitomic models have been successfully applied to segmentation, de-noising, recognition, indexing or texture synthesis. The model of [\cite=Jojic2003] [\cite=Cheung2008] was also used in [\cite=Wang2012] for intra coding. However, this epitomic model is not designed for image coding applications, and thus have to be coded losslessly, which limits the compression performances.

Thus, the work presented in this paper is derived from the approach introduced in [\cite=Cherigui2011]. This epitomic model is dedicated to image coding, and was inspired by the factorized image representation of Wang et al [\cite=Wang2008]. In this approach the input image I is factored in an epitome E, which is composed of disjoint texture pieces called epitome charts (see Fig. [\ref=fig:Formean_eptm]). The input image is divided into a regular grid of non-overlapping blocks Bi (block-grid) and each block is reconstructed from an epitome patch. A so-called assignation map links the patches from the epitome to the reconstructed image blocks. This epitomic model is obtained through a two-step procedure which first searches for the self-similarities within the input image, and then iteratively grows the epitome charts. The second step for creating the epitome charts is notably based on a rate-distortion optimization (RDO) criterion, which minimizes the distortion between the input and the reconstructed image together with the rate of the epitome, evaluated as its number of pixels.

A still image coding scheme based on this epitomic model is also described in [\cite=Cherigui2011], where the epitome and its associated assignation map are encoded. The reconstructed image can thus be used as a predictor, and the corresponding prediction residue is further encoded. The results show that the scheme is efficient against H.264 Intra. However, the coding performances of the assignation map are limited, which reduces the overall rate-distortion (RD) gains.

A novel coding scheme was thus proposed in [\cite=Cherigui2014], where only the epitome is encoded. The blocks not belonging to the epitome are then predicted in an inpainting fashion, together with an in-loop encoding of the residue. The prediction tools notably include efficient template-based neighbor embedding techniques such as the Locally Linear Embedding (LLE) [\cite=Roweis2000] [\cite=Turkan2012]. The results show that significant bit-rate savings are achieved with respect to H.264 Intra.

In the next section, we describe the proposed scheme, which can be seen as an extension of the latter work to scalable coding.

Epitomic enhancement layer for scalable image coding

In this section, we describe a scalable coding scheme in which the enhancement layer consists in an epitome of the input image. Consequently, at the decoder side, the EL patches not contained in the epitome are missing, but the corresponding BL patches are known. We thus propose to restore the full enhancement layer by taking advantage of the known representative texture patches available in the EL epitome charts. The proposed scheme is shown in Fig. [\ref=fig:proposed_scheme].

We first summarize below the two-step procedure for constructing the epitome, as well as its encoding process. Then, we explain in details how to perform the restoration, using local learning-based techniques.

Epitome generation and encoding

The epitome generation method used in this paper is overall derived from [\cite=Cherigui2011], and consists first in a self-similarities search step followed by an epitome charts creation step. However, the self-similarities search step is here performed based on a fast two-step method that we proposed in [\cite=Alain2014]. Moreover, we choose here to use an error minimization criterion for the epitome chart creation instead of the RDO criterion of [\cite=Cherigui2011], as we noticed that in practice this RDO criterion has a limited impact on our application.

Self-similarities search

The goal of this step is to find for each block Bi∈I a list of matching patches ML(Bi)  =  {Mi,0,Mi,1,...}, such that the mean square error (MSE) between a block and its matching patches is below a matching threshold εM. This parameter eventually determines the size of the epitome, and several values are considered in the experiments (see Table [\ref=tab:eptm_size]). In this paper, the lists of matching patches are obtained through a two steps clustering-based approach illustrated in Fig. [\ref=fig:eptm_cluster]. The first step consists in grouping together similar blocks into clusters, so that the distance from a block to the centroid of its cluster is below an assignation threshold εA. In practice, this threshold is set to εA  =  0.5  *  εM. In the second step, a list of matching patches is computed for each cluster by finding patches whose MSE is inferior to εM with respect to the block closest to the cluster centroid. This list of matching patches is then assigned to all the blocks in the cluster.

From all the lists of matching patches ML(Bi), we can then compute reverse lists RL(Mj) = {Bj,Bl,...} which indicate the set of image blocks that can be represented by each matching patch. Next, we describe how these lists are used to build the epitome charts.

Epitome charts creation

The epitome charts are iteratively grown, and both the initialization and the iterative extension of an epitome chart are based on a criterion which minimizes the error between the input image I and the reconstructed image I'.

Formally, we denote ΔECm,m = 0,...,M - 1 a set of candidate regions to add to the epitome, where M is the number of candidates. When initializing a new epitome chart, a valid candidate region is a matching patch which is not yet in an epitome chart and is spatially disconnected from any existing epitome chart. On the contrary, when extending an epitome chart EC, a valid candidate region is a matching patch which is not yet in an epitome chart and overlaps with EC. The actual region added to the epitome ΔECopt is obtained by minimizing the following criterion:

[formula]

where I'm is the reconstructed image when the candidate region ΔECm is added to the epitome, and the MSE function computes the mean square error between I'm and the source image I. The reconstructed image I'm comprises the blocks reconstructed from the existing epitome charts and the new blocks contained in the list RL(ΔECm). During the extension of an epitome chart, additional reconstructed blocks can be obtained by considering the so-called inferred blocks, which are the potential matching patches that can overlap between the current chart EC and the extension ΔECm (see Fig. [\ref=fig:eptm_rec_im]). Note that for the pixels of I'm which are not reconstructed, the MSE can not be computed directly. In our implementation, we assign the maximal MSE value to these pixels. This tends to favor the selection of a candidate region ΔECm which reconstructs large regions in I'm, and thus speed up the epitome chart creation.

The extension of an epitome chart stops when no more valid candidate regions can be found. A new epitome chart is then initialized at a new location. The global process stops when the whole image I' is reconstructed. Note that the epitome charts in E are originally obtained at a pixel accuracy, but for coding purposes they are then padded to be aligned with the block structure of the encoder.

Epitome encoding

The epitomes are encoded with a scalable scheme as an enhancement layer. The blocks not belonging to the epitome are directly copied from the decoded base layer, thus their rate-cost is practically non-existent.

Epitome-based restoration

The non-epitome part of the enhancement layer is processed by considering N  ×  N overlapping patches, separated by a step of s pixels in both rows and columns. After restoration, when several estimates are obtained for a pixel, they are averaged in order to obtain the final estimate. Note that before performing the restoration, the BL image is up-sampled to the resolution of the EL using the inter-layer processing filter.

The restoration methods described below are derived from local learning-based SR methods [\cite=HongChang2004] [\cite=Fan2007] [\cite=Bevilacqua2014] [\cite=Yang2013] [\cite=Zhang2015], and can be summarized in the three following steps: K-NN search, learning step, and processing step. These steps are shown in Fig. [\ref=fig:KNN_eptm], and described in details below.

K-NN search

If we consider the current patch to be processed y, we first search for its K-NN BL patches, within search windows corresponding to the epitome charts locations (see Fig. [\ref=fig:KNN_eptm]). The K-NN BL patches [formula] are then stored in a matrix y which contains in its columns the vectorized patches. For each neighbor yi, we have a corresponding EL patch xi in the epitome, which is stored in a matrix x. We thus obtain BL/EL pairs of training patches. In classical SR applications, the pairs of training patches are obtained from a dictionary, which construction is a critical step [\cite=Freeman2000] [\cite=Freeman2002] [\cite=HongChang2004] [\cite=Yang2010a] [\cite=Zhang2015] [\cite=Glasner2009] [\cite=Bevilacqua2014]. Since here the patches in the epitome are representative of the full image, we can consider that they constitute a suitable dictionary to perform the local learning-based restoration.

Next, we present the learning and processing steps, which exploit the correlation between the pairs of training patches to perform learning-based restoration. We describe two methods to restore the missing EL patches, inspired by SR techniques based on neighbor embedding (NE) [\cite=HongChang2004] [\cite=Fan2007] [\cite=Bevilacqua2014] and linear mappings [\cite=Yang2013] [\cite=Bevilacqua2014] [\cite=Zhang2015], but any other learning-based method could be included in the proposed scheme. Note that many SR methods can be improved using iterative back-projection [\cite=Irani1991], which enforces the high resolution reconstructed image to be consistent with the input low resolution image. However, this technique will not be considered in the proposed scheme, as it tends to propagate quantization noise from the BL image to the EL reconstruction.

Epitome-based Locally Linear Embedding

First, we describe a method relying on LLE, denoted "epitome-based Locally Linear Embedding" (E-LLE). Similarly to other NE-based restoration techniques, we assume that the local geometry of the manifolds in which lie the BL and EL patches is similar (see Fig. [\ref=fig:E-LLE]). Using LLE, we first learn the linear combination of the K-NN BL patches which best approximate the current patch, and then apply this linear combination to the corresponding EL patches in order to obtain a good estimate of the missing EL patch.

Let W be the vector containing the combination weights [formula]. The weights are obtained by solving the following equation:

[formula]

The weights vector W is computed as:

[formula]

The term [formula] denotes the local covariance matrix (i.e., in reference to y) of the K-NN stacked in [formula], and [formula] is the column vector of ones. In practice, instead of an explicit inversion of the matrix [formula], the linear system of equations [formula] is solved, then the weights are rescaled so that they sum to one.

The restored EL patch is finally obtained as:

[formula]

In practice, several versions of this method can be derived, e.g. by using another NE-based technique such as non-negative matrix factorization [\cite=Bevilacqua2012], or by adapting the weights computation as in the non-local mean algorithm (exponential weights) [\cite=Buades2005]. However, with such methods the weights are only computed based on the BL patches. In the next section, we propose a method which aims at better exploiting the correlation between the pairs of training patches, based on linear regression.

Epitome-based Local Linear Mapping

We describe here a method based on linear regression, that we denote "epitome-based Local Linear Mapping (E-LLM)". We want to further exploit the correlation between the pairs of training patches by directly learning a function mapping the BL patches to the corresponding EL patches (see Fig. [\ref=fig:E-LLM]). This function can then be applied on the current patch to restore the EL patch.

The mapping function is learned using multivariate linear regression. The problem is then to search for the function [formula] minimizing:

[formula]

which is of the form ||  -  ||2 (corresponding to the linear regression model   =    +  ). The minimization of Eq. ([\ref=eq:LM_LSform]) gives the least squares estimator

[formula]

We finally obtain the restored EL patch as:

[formula]

Now that we have formally defined the proposed methods, we study their performances in the next section.

Simulations and results

Experimental conditions

The experiments are performed on the test images listed in Table [\ref=tab:test_im], obtained from the HEVC test sequences. The base layer images are obtained by down sampling the input image with a factor 2  ×  2, using the SHVC down-sampling filter available with the SHM software (ver. 9.0) [\cite=SHMSoft]. The BL images are encoded with HEVC, using the HM software (ver. 15.0) [\cite=HMSoft].

We then use the SHM software (ver. 9.0) [\cite=SHMSoft] to encode the corresponding enhancement layers. Thanks to the hybrid codec scalability feature of SHVC, the decoded BL images are first up-sampled using the separable 8-tap SHVC filter ( - 1,4, - 11,40,40, - 11,4, - 1), and directly used as input to the SHM software. Both layers are encoded with the following quantization steps: QP = 22, 27, 32, 37.

For each input image, 3 to 4 matching threshold values εM are selected in order to generate epitomes which sizes range from 30% to 90% of the input image sizes. The threshold values to reach such sizes vary depending on the input image, and were manually selected. The selected matching thresholds and corresponding epitome sizes are shown in Table [\ref=tab:eptm_size].

The post-processing is performed using N  ×  N  =  8  ×  8 overlapping patches, with an overlapping step s  =  3. We set the number of nearest neighbors to K  =  20.

Rate-distortion performances

We assess in this section the performances of the proposed scheme against the SHVC reference EL. The distortion is evaluated using the PSNR of the decoded EL, while the rate is calculated as the sum of both BL and EL rates. The RD performances are computed using the Bjontegaard rate gains measure (BD-rates) [\cite=G2011] over the four QP values.

We show in Fig. [\ref=fig:RD_perf_eptm_size] the BD-rates averaged over all sequences depending on the epitome size. The complete results are given in Table [\ref=tab:RD_perf]. Overall, we can see that significant bit-rate reduction can be achieved compared to SHVC, up to about 15% bit-rate reduction in average, and 20% for images like BaskballDrive, Ducks, or Tennis. The best performances are achieved with the biggest epitomes. In fact, smaller epitomes provide a reduced set of BL/EL patches, while more BL patches need to be processed. Eventually, the post-processing step can not effectively compensate for the quality loss. Overall, the E-LLE performs better than the E-LLM method, however, for the best performances (biggest epitomes), both methods perform similarly.

In order to better understand the performances of the proposed methods, we show in Fig. [\ref=fig:RD_perf_City_PSNR] the RD curve of the City image for its best performances (biggest epitome), which behavior is representative of the set of test images. We can see that at high bit-rates (QP=22), the bit-rate of the proposed scheme is especially reduced compared to the SHVC reference EL. However, even with the proposed post-processing, we observe a loss of quality. At low bit-rates (QP=37), the bit-rate of the proposed method is less reduced compared to the SHVC reference EL, but the post-processing yields a better quality. This behavior explains the overall significant bit-rate reduction we can achieve with the proposed scheme.

In addition, we show in Fig. [\ref=fig:RD_perf_City_eptm_size] the RD curves of the LLE-based restoration for the PartyScene image depending on the epitome size. We can see that for smaller epitome sizes, at high bit-rates (QP=22), even though the bit-rate is considerably reduced compared to the SHVC reference EL, the quality loss does not allow an improvement in the RD performances, which corroborates our previous analysis.

We give in Figs. [\ref=fig:City_example] and [\ref=fig:Cactus_example] visual examples of the enhancement layers for the City and Cactus images. Note that these examples were chosen for their visual clarity, and do not necessarily correspond to the best RD performances. In order to demonstrate the relevance of the post-processing step, we show on the top row the epitome EL before restoration, and on the bottom row the corresponding EL after applying the E-LLE and E-LLM methods. Before restoration, the blocks not belonging to the epitome are particularly visible, as they are directly copied from the up-sampled decoded BL, and clearly lack high frequency details. An obvious improvement of the quality can be observed after restoration for the high-frequency pseudo-periodic textures, such as the building of Fig. [\ref=fig:City_example], or the calendar of Fig. [\ref=fig:Cactus_example]. Although the E-LLM usually yields lower PSNR than the E-LLE method, we can see that it can perform visually better on high-frequency stochastic textures such as in the highlighted red rectangle of Fig. [\ref=fig:Cactus_example].

Elements of complexity

We give in this section some indications about the complexity, evaluated as the running time of the proposed methods. We evaluate the complexity depending on the epitome size and input image size. The results are averaged for each image class (which corresponds to an image size, see Table [\ref=tab:test_im]). Note that the epitome generation algorithm was implemented in C++, while the restoration methods were implemented in Matlab.

We give in Fig. [\ref=fig:time_eptm] the complexity of the epitome generation. We can see that the epitome generation running time mainly varies depending on the input image size, while the epitome size has a limited impact. For the biggest epitomes, which correspond to the best RD results, we observed that in average 50% to 90% of the complexity is dedicated to the self-similarities search step. As this step is highly parallelizable, the total running time could be reduced by using a parallel implementation, e.g. on GPU.

We show in Fig. [\ref=fig:time_proc] the complexity of the post-processing step. The processing time is similar for both E-LLE and E-LLM methods, and obviously increases with the size of the image. However, we can observe that overall the complexity is reduced for the biggest epitomes, which interestingly corresponds to the best RD performances. In fact, when transmitting bigger epitomes, less patches not belonging to the epitome have to be processed.

The simulations showed that in average, about 95% of the post-processing complexity is dedicated to the K-NN search. The K-NN search was performed with the Matlab knnsearch function, based on Kd-tree [\cite=Bentley1975] [\cite=Freidman1977a]. In order to reduce the total running time, the complexity of the K-NN search could be further reduced by using more advanced approximate nearest neighbor search [\cite=Barnes2010] [\cite=Dowson2011] [\cite=Cherian2014] [\cite=Zhu2014] or parallel implementation, possibly on GPU [\cite=Garcia2008a].

Extension to scalable video coding

The work presented in this paper is dedicated to scalable single image coding, however a straight extension to scalable video coding can be considered by applying the proposed method to each frame of the sequence. Preliminary experiments are conducted on a set of 3 test sequences, consisting of 9 frames with a CIF resolution in order to limit the computation time. The epitomes are generated using one matching threshold value εM = 7.0. In order to exploit the temporal redundancies, the K-NN search step is performed in the epitomes of the two closest frames in addition to the current one.

We show the RD performances measured with the Bjontegaard rate gains in Table [\ref=tab:RD_perf_seq]. These preliminary results indicate that the proposed scheme is also expected to bring significant bit-rate reduction when extended to full video sequences. These results are not obvious to predict, since the inter layer prediction is here also competing with inter frame prediction modes, which are much more efficient than the intra prediction modes.

Conclusion and future work

We propose in this paper a novel scheme for scalable image coding, based on an epitomic factored representation of the enhancement layer and appropriate restoration methods at the decoder side. Significant bit-rate reduction is achieved for the spatial scalable application when compared to the SHVC reference EL. These achievements were possible because of the specific epitomic model we used, which provides relevant texture information and is especially suitable for scalable encoding. Note that improvements of the standard tools have been recently proposed, such as the generalized inter-layer residual prediction [\cite=Li2013] [\cite=Laude2014] [\cite=Aminlou2014], or enhanced in-loop prediction mechanism for the EL [\cite=Hoangvan2015] [\cite=Hoangvan2016]. The proposed approach is compatible with such improvement of scalable coding schemes, as the coding of the epitome as an enhancement layer would be improved as well.

The proposed scheme could be improved by studying alternative restoration approaches. For instance, different regression could be considered for the E-LLM instead of the direct least-square approach, such as (Kernel) Ridge Regression [\cite=Bevilacqua2014] [\cite=Kim2010]. Alternatively, the restoration step at the decoder side could be considered as an inpainting problem with prior knowledge on the "holes" to be filled in the form of low resolution patches. Inpainting has been extensively studied over the last decades (see [\cite=Guillemot2014] and reference therein for more details), and the exemplar-based multi-scale approaches [\cite=Drori2003] [\cite=LeMeur2013] are well suited in our context.

Future work also includes the adaptation of the proposed scheme for scalable video coding, as preliminary results indicate promising RD performances. The epitomes were here generated separately for each frame. The RD performances would benefit from an epitomic model which takes into account the temporal redundancies. Furthermore, the image self-similarities in the current epitome are found using a single block matching algorithm, while the application at the decoder side is based on multi-patches techniques. New epitomic models have been designed to take into account the epitome application in the generation process. For example, an epitome is proposed in [\cite=Turkan2015] for multi-patches super-resolution, which showed that a more compact representation can be obtained for a similar image reconstruction quality. Such model could thus be considered in the proposed scheme in order to improve the RD performances, at the cost of an increased complexity. In addition, the distortion minimization criterion of Eq. [\ref=eq:ext_crit] used for the epitome charts creation could be changed into a rate-distortion optimization criterion, as in [\cite=Cherigui2011]. Ideally, the distortion would be directly computed on the restored EL instead of the reconstructed image, and the rate directly evaluated as the EL rate.

Finally, the proposed scheme can be extended to other scalable applications, such as color gamut or LDR/HDR scalabilities. Even though we use LLE in this paper for super-resolution, it has been proven efficient for many different applications such as de-noising [\cite=Shen2005], image prediction [\cite=Turkan2012], or inpainting [\cite=Guillemot2014]. We can thus expect the LLE-based restoration methods to be efficient for different scalable applications.