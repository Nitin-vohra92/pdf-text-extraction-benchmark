Ancestral Causal Inference

Introduction

Discovering causal relations from data is one of the foundations of the scientific method. In most cases, cause-effect relations are recovered from experimental data in which the variable of interest is perturbed, but seminal work like the do-calculus [\cite=Pearl2009] and the PC/FCI algorithms [\cite=Spirtes2000] [\cite=Zhang:2008:COR:1414091.1414237] demonstrate that, under certain assumptions (e.g., the well-known Causal Markov and Faithfulness assumptions [\cite=Spirtes2000]), it is already possible to obtain significant causal information by using only observational data.

Causal discovery methods are historically divided into two categories: constraint-based and score-based methods. Constraint-based causal discovery methods use statistical independences to express constraints over possible causal models, while score-based methods typically evaluate models using a penalized likelihood score. Compared to score-based approaches for causal discovery, constraint-based methods are able to handle latent confounders and selection bias naturally, and do not require certain parametric modeling assumptions which may not be realistic. On the other hand, constraint-based methods are more vulnerable to errors in statistical independence test results that are common in real-world applications. In this paper we propose a hybrid approach that combines the best of both worlds by solving a constrained optimization problem.

Since in practice independence tests can be unreliable, the resulting statistical errors can create conflicting constraints. Classical constraint-based algorithms are not able to resolve such conflicts, and often simply ignore, or at best try to avoid them [\cite=conf/uai/RamseyZS06]. Different approaches to resolving such conflicts have been proposed recently [\cite=BCCD] [\cite=triantafillou2015constraint] [\cite=antti]. The general idea is to assign weights to the input statements that reflect the reliability of the inputs, and then use a reasoning scheme that takes these weights into account. Several weighting schemes can be defined, from simple ways to attach weights to single independence statements [\cite=antti] to more complicated schemes to obtain weights for combinations of independence statements [\cite=triantafillou2015constraint] [\cite=BCCD]. Reasoning can then be formulated as a step-by-step approach in which the statements are processed in order of their weight and conflicts are ignored [\cite=triantafillou2015constraint] [\cite=BCCD], or as a global optimization problem as in [\cite=antti]. The latter approach has been shown to be able to actually correct errors in statistical test results.

While offering a better accuracy than greedy approaches, one major challenge for the conflict resolution methods that use a global optimization like [\cite=antti] consists in the scalability of the algorithms due to the vastness of the search space. In this work, we address the scalability issue by using a more coarse-grained, and therefore more efficient, representation of the causal structure: we only represent ancestral relations (both direct and "indirect" causal relations). This representation turns out to be coarse enough to keep the computational burden low, yet rich enough for many practical applications, since in real-world applications the distinction between direct causal relations and ancestral relations is not always clear or necessary.

Another major challenge for constraint-based methods is the estimation of the confidence in the predicted causal relations. In this paper, we propose a method to score predictions according to their confidence. The confidence score can be thought of as an approximation to the marginal probability of an ancestral relation. Scoring predictions enables one to rank them according to their reliability, allowing for higher accuracy. This is very important for practical applications, as the low reliability of the predictions of constraint-based methods has been a major impediment to their wide-spread usage. One of the most flexible formulations of constraint-based causal discovery is in logic [\cite=loci] [\cite=BCCD] [\cite=triantafillou2015constraint] [\cite=antti]. Due to its declarative nature and expressive power, logic enables an easy integration of complex background knowledge. This is not trivial in traditional constraint-based approaches like FCI that use a set of fixed rules following a strict order of execution, and even the common task of incorporating ancestral knowledge can require a complex post-processing step [\cite=borboudakis2012]. In this work, we exploit the flexibility and ease-of-implementation offered by a formulation in logic, and harness the power of general-purpose logical reasoning engines.

Here, we propose Ancestral Causal Inference (ACI), a method that combines the ideas described above in order to accurately reconstruct ancestral relations from observational (and possibly interventional) data for causal systems with possible latent variables without feedback. ACI solves an optimization problem in the spirit of [\cite=antti], but uses an entirely different encoding using novel ancestral reasoning rules that bypasses the construction of fine-grained representations and thereby can achieve speedups of several orders of magnitude over the method of [\cite=antti]. We apply our method to score confidences of ancestral relations to both ACI and the method from [\cite=antti] and show on synthetic data that it can outperform bootstrapped (C)FCI. We prove that under mild conditions on the statistical tests, the confidence scores are (asymptotically) consistent. We showcase the flexibility of logic-based approaches by integrating constraints obtained from a combination of observational data and interventional data in the form of weighted ancestral relations, substantially increasing the reliability of the predictions. We apply ACI to a challenging real-world data set [\cite=SPP05] that so far had only been addressed with score-based methods and observe that it successfully recovers from faithfulness violations. Finally, we provide an open-source version of our algorithms and the evaluation framework, which can be easily extended (a link will be added in the camera-ready version).

Preliminaries and related work

Preliminaries

We will assume that the data generating process can be modeled by a causal Directed Acyclic Graph (DAG) that may contain latent variables. Throughout the paper we represent variables with uppercase letters, while sets of variables are denoted by boldface. A directed edge X  →  Y in the causal DAG represents a direct causal relationship of cause X on effect Y. A sequence of directed edges [formula] is a directed path. If there is a directed path from X to Y (or X = Y) then X is an ancestor of Y (denoted as [formula]). For a set of variables [formula], we write [formula] if there exists a [formula] with [formula]. If there is no directed path from X to Y we denote this as [formula]. For a set of variables [formula], we write [formula] if [formula] for all [formula]. We call any relation on the observed variables that satisfies the non-strict partial order axioms:

[formula]

an ancestral structure. The underlying causal DAG induces a unique ancestral structure on the observed variables. We will assume that the Causal Markov Assumption and the Causal Faithfulness Assumption [\cite=Spirtes2000] both hold. In other words, the conditional independences in the observational distribution correspond one-to-one with the d-separations in the causal DAG. For simplicity we do not consider selection bias.

For disjoint sets [formula] we denote conditional independence of [formula] and [formula] given [formula] as [formula], and conditional dependence as [formula]. We call the cardinality [formula] the order of the conditional (in)dependence relation. Following [\cite=loci] we define a minimal conditional independence by:

[formula]

and similarly, a minimal conditional dependence by:

[formula]

The square brackets indicate that the variables in [formula] are needed for the (in)dependence to hold in the context of [formula]. Minimal conditional (in)dependences are closely related to ancestral relations, as pointed out in [\cite=loci]:

For disjoint (sets of) variables [formula]:

[formula]

(All proofs are provided in the Supplementary Material.)

Exploiting these rules (as well as others that will be introduced in Section 3) to deduce ancestral relations directly from (in)dependences is key to the greatly improved scalability of our method.

Related work on conflict resolution

One of the earliest algorithms to deal with conflicting inputs in constraint-based causal discovery is Conservative PC [\cite=conf/uai/RamseyZS06], which adds "redundant" checks to the PC algorithm that allow to detect inconsistencies in the inputs, and then makes only predictions that do not rely on the ambiguous inputs. The same idea can be applied to FCI, yielding Conservative FCI (CFCI) [\cite=Colombo++2012] [\cite=pcalg]. BCCD [\cite=BCCD] uses Bayesian confidence estimates to process information in decreasing order of reliability, discarding contradictory input as they arise. COMBINE [\cite=triantafillou2015constraint] is an algorithm that combines the output of FCI on several overlapping observational and experimental datasets into a single causal model by first pooling and recalibrating the independence test p-values, and then adding each constraint incrementally in order of reliability to a SAT instance. Any constraint that makes the problem unsatisfiable is discarded.

Our approach is inspired by recent work [\cite=antti], in which causal discovery is formulated as a constrained discrete minimization problem. Given a list of weighted independence statements, the method by [\cite=antti] searches for the optimal causal graph G that minimizes the sum of the weights of the independence statements that are violated according to G. In order to test whether a causal graph G induces a certain independence, the method makes use of an encoding DAG of d-connection graphs. D-connection graphs are graphs that can be obtained from a causal graph through a series of operations (conditioning, marginalization and interventions). An encoding DAG of d-connection graphs represents a complex structure encoding all possible d-connection graphs and the sequence of operations that generated them from a given causal graph. This approach has been shown to be able to correct errors in the inputs, but is computationally very demanding because of the huge search space.

ACI: Ancestral Causal Inference

In this paper we propose Ancestral Causal Inference (ACI), a causal discovery method that accurately reconstructs ancestral structures, also in the presence of latent variables and statistical errors. ACI builds on the work of [\cite=antti], but rather than optimizing over encoding DAGs, ACI optimizes over the much simpler (but still very expressive) ancestral structures, giving a huge computational speedup. To get an idea of the reduction of the search space: for 7 variables, there are 6  ×  106 ancestral structures but already more than 2.3  ×  1015 encoding DAGs. ACI also allows for weighted ancestral relations as inputs, which enables to take into account interventional data as illustrated in the real-world application in Section [\ref=secEval].

Ancestral Causal Inference rules

The rules from [\cite=antti] explicitly encode marginalization and conditioning operations on d-connection graphs, so they cannot be easily adapted to work directly with ancestral relations. Instead, ACI encodes the ancestral reasoning rules ([\ref=eq:reflexivity])-([\ref=eq:notcauses_rule]) and the following six novel causal reasoning rules (proofs are in the Supplementary Material):

For disjoint (sets) of variables [formula]:

[formula]

Optimization of loss function

In order to handle conflicts in the inputs, we follow [\cite=antti] and formulate the causal discovery problem as an optimization problem where a loss function is optimized over possible causal structures. Intuitively, the loss function sums the weights of all the inputs that are violated in a candidate causal structure. Given a list I of weighted input statements (li,wi), where li is the input statement and wi is the associated weight, we define the loss function as the sum of the weights of the input statements that are not satisfied in a given possible structure W∈W, where W denotes the set of all possible causal structures. Causal discovery can then be formulated as the following discrete optimization problem:

[formula]

where the loss function is defined as

[formula]

where [formula] means that li is not satisfied in structure W according to the rules R. In [\cite=antti], the possible structures W correspond with all possible causal graphs (ADMGs in the acyclic case) and the rules correspond with operations on d-connection graphs, whereas in ACI W corresponds with all ancestral structures and the rules R are rules ([\ref=eq:reflexivity])-([\ref=eq:lastrule]).

Constrained optimization in Answer Set Programming (ASP)

The constrained optimization problem in ([\ref=minimization]) can be implemented using a variety of optimization methods. Given the complexity of the rules, a formulation in an expressive logical language that supports optimization, e.g., Answer Set Programming (ASP), is very convenient and is used both in [\cite=antti] and in this paper. ASP is a widely used declarative programming language based on the stable model semantics[\cite=DBLP:conf/aaai/Lifschitz08] [\cite=DBLP:reference/fai/Gelfond08] that has successfully been applied to several NP-hard problems. To implement ACI we use the state-of-the-art ASP solver clingo [\cite=clingo]. We provide the encoding in the Supplementary Material. Here we show an example of how an ACI rule is implemented: rule [\ref=eq:entner_rule] for a single variable Z can be written: This rule states that for any disjoint variables X,Y,Z, it cannot happen that [formula], [formula] and [formula] in any model.

Weighting schemes

ACI allows for two types of input statements: conditional independences and ancestral relations. These statements can each be assigned a weight that reflect their confidence. We propose two simple approaches with the desirable properties of making ACI asymptotically consistent under mild assumptions (as described in the end of this Section), and assigning a much smaller weight to independences than to dependences (which agrees with the intuition that one is confident about a strong dependence, but not about independence vs. weak dependence). The approaches are: (1) a frequentist approach, in which one performs any appropriate frequentist statistical test with as null hypothesis independence (resp. a non-ancestral relation) and then uses as weight:

[formula]

(2) a Bayesian approach, in which one assigns a weight to each input statement l using data set D as:

[formula]

where the prior probability p(l) can be used as a tuning parameter. Furthermore, we use infinite weights when dealing with oracle inputs.

If observational and suitable interventional data is available, a simple way to obtain a weighted ancestral statement [formula] is by doing a two-sample test that tests whether the distribution of Y changes with respect to its observational distribution when intervening on X. This approach conveniently applies to various types of interventions: perfect interventions [\cite=Pearl2009], soft interventions [\cite=Markowetz++2005], mechanism changes [\cite=TianPearl2001], and activity interventions [\cite=MooijHeskes_UAI_13]. Note that the two-sample test can actually also be implemented as an independence test that tests for the independence of Y and IX, the indicator variable that has value 0 for observational samples and 1 for samples from the interventional distribution in which X has been intervened upon.

Scoring Causal Predictions

The constrained minimization ([\ref=minimization]) may produce several optimal solutions, because the underlying structure may not be identifiable from the inputs. In order to address this issue, we propose to use the loss function ([\ref=loss]) in the following way in order to score the confidence of a particular feature p (say, an ancestral relation [formula]):

[formula]

Without going into details here, we note that the confidence ([\ref=eq:confidence]) can be interpreted as a MAP approximation of the log-odds ratio of the probability that feature p is true in a Markov Logic model:

[formula]

In this paper, we will usually consider the features p to be ancestral relations between variables, but this idea is more generally applicable. For example, in combination with the method of [\cite=antti] it can be used to score direct causal relations.

Soundness and completeness

Our scoring method is sound for predicting ancestral relations:

Suppose the rules in R are sound. For any pair X,Y of variables, the confidence score [formula] of ([\ref=eq:confidence]) is sound for oracle inputs with infinite weights.

Here, soundness means that [formula] if [formula] is identifiable from the inputs, [formula] if [formula] is identifiable from the inputs, and [formula] otherwise (neither are identifiable). We conjecture that the ACI rules ([\ref=eq:reflexivity])-([\ref=eq:lastrule]) are "order-1-complete", i.e., they allow to deduce all (non)ancestral relations that are identifiable from oracle inputs for all conditional independences of order ≤  1 in observational data. For higher-order inputs additional ACI rules can be derived, however, our primary interest in this work is improving computation time and accuracy, and we are willing to sacrifice completeness for that. A more detailed theoretical study of the completeness properties is left as future work.

Asymptotic consistency

Denote the number of samples by N. For the frequentist weights in ([\ref=eq:weightFreq]), we assume that the statistical tests are consistent in the following sense:

[formula]

as N  →    ∞  , where the null hypothesis H0 is independence/nonancestral relation and the alternative hypothesis H1 is dependence/ancestral relation. Note that we need to choose a sample-size dependent threshold αN such that αN  →  0 at a suitable rate. [\cite=KalischBuehlmann2007] show how this can be done for partial correlation tests assuming the distribution is multivariate Gaussian.

For the Bayesian weighting scheme in ([\ref=eq:weightBayes]), we assume that

[formula]

This will hold (as long as there is no model misspecification) under mild technical conditions for exponential family models. In both cases, the probability of a type I or type II error will converge to 0, and in addition, the corresponding weight will converge to ∞  .

Suppose the rules in R are sound. For any pair X,Y of variables, the confidence score [formula] of ([\ref=eq:confidence]) is asymptotically consistent under assumption ([\ref=eq:weightFreqConsistency]) or ([\ref=eq:weightBayesConsistency]).

Here, "asymptotically consistent" means that the confidence score [formula] in probability if [formula] is identifiably true, [formula] in probability if [formula] is identifiably false, and [formula] in probability otherwise.

Evaluation

In this Section we report evaluations on synthetically generated data and an application on a real dataset. We perform all evaluations on a 40 core machine with 2.80GHz CPUs, and run several experiments in parallel, so each instance runs on a single core.

Synthetic data

We simulate the data using the simulator from [\cite=antti]: for each experimental condition (e.g., a given number of variables n and order c), we generate randomly M linear acyclic models with latent variables and Gaussian noise and sample N = 500 data points. We then perform independence tests up to order c and weight the (in)dependence statements using the weighting schemes described in Section ([\ref=aci]). For the frequentist weights we use tests based on partial correlations and Fisher's z-transform to obtain approximate p-values (see, e.g., [\cite=KalischBuehlmann2007]) setting the significance level to α = 0.05. For the Bayesian weights, we use the Bayesian test for conditional independence presented in [\cite=DBLP:journals/ci/MargaritisB09] as implemented by [\cite=antti] with a prior probability of 0.1 for independence. We score confidences using ([\ref=eq:confidence]) for ACI and for the acyclic causally insufficient models presented in [\cite=antti], and use the same independence tests as input, optionally up to a maximum order c.

In Figure [\ref=fig:times](a) we show the average execution times for different combinations of n and c, while in Figure [\ref=fig:times](b) we show the distribution of runtimes for different instances of randomly generated models. On 7 variables, the scoring method with ACI is almost 3 orders of magnitude faster than [\cite=antti], and the difference grows exponentially with n increases. On 8 variables the method from [\cite=antti] is able to complete only four of the first 40 simulated models before the timeout 25  ×  103 s.

In Figure [\ref=fig:accuracy] we show the accuracy of the predictions with precision-recall (PR) curves for both ancestral ([formula]) and nonancestral ([formula]) relations, in different settings. As baselines we use a bootstrapped version (which averages of the results of 100 executions using random subsets of half the data) of FCI [\cite=Zhang:2008:COR:1414091.1414237] and Conservative FCI (CFCI) [\cite=Colombo++2012], as implemented in the pcalg R package [\cite=pcalg]. The bootstrap is used to rank the predictions, which are otherwise limited to positives, negatives or unknown relations. In order to retrieve the ancestral relations from the PAGs we apply Theorem 3.1 from [\cite=ancestralFCI]. For reference we also include the (unbootstrapped) performance of COMBINE [\cite=triantafillou2015constraint], although the method is not designed for this setting with only observational data.

In the first row of Figure [\ref=fig:accuracy], we show the setting with 6 variables and frequentist weights. The performances of the scoring method with [\cite=antti] and ACI coincide, performing significantly better for nonancestral predictions and the top ancestral predictions (see zoomed-in version in Figure [\ref=fig:accuracy](b)), even when using only as inputs independence test results up to maximum order c = 1, instead of independence test results of any order as FCI, CFCI and COMBINE. Interestingly, the two global optimization algorithms do not seem to benefit much from higher order independence tests, thus we omit them from the plots (although we add the graphs in the Supplementary Material). On the other hand, bootstrapping traditional methods that are oblivious to the (in)dependence weights seems to produce surprisingly good results. Nevertheless, our scoring approach ([\ref=eq:confidence]) outperforms bootstrapped (C)FCI for both encodings [\cite=antti] and ACI, suggesting that nontrivial error-correction is going on.

In the second row of Figure [\ref=fig:accuracy], we show the setting with 8 variables and frequentist weights. In this setting the approach from [\cite=antti] is too slow. In addition to the previous plot, we plot the accuracy of ACI when there is oracle background knowledge on the descendants of one variable (i = 1). This setting simulates the effect of using interventional data, and we can see that the performance of ACI improves significantly, especially in the prediction of the ancestral relations. On the other side, FCI and CFCI cannot take advantage of this knowledge.

Application on real data

We consider the challenging task of reconstructing a signalling network from flow cytometry data [\cite=SPP05]. One of the 14 experimental conditions can be considered as the observational setting, the others as interventional settings. In contrast with likelihood-based approaches to causal discovery that have been applied in earlier work [\cite=SPP05] [\cite=EatonMurphy07] [\cite=MooijHeskes_UAI_13] [\cite=Rothenhausler++2015], in our approach we do not need to model the interventions quantitatively. We only need to know the intervention targets, whereas the intervention types do not matter. Here we used the subset of 5 experimental conditions described, along with more results, in the Table in the Supplementary Material.

We use a t-test to test for each intervention and for each variable whether its distribution changes with respect to the observational condition. We use the p-values of these tests as in ([\ref=eq:weightFreq]) in order to obtain weighted ancestral relations that are used as input (with threshold α  =  0.05). For example, if adding U0126 (a MEK inhibitor) changes the distribution of RAF significantly with respect to the observational baseline condition, we get a weighted ancestral relation MEK[formula]RAF. In addition, we use partial correlations up to first order (tested in the observational data only) to obtain weighted conditional independences used as input. We use ACI with ([\ref=eq:confidence]) to score the ancestral relations for each ordered pair of variables. The main results are illustrated in Figure [\ref=fig:Sachs]. We compare with FCI and CFCI, but those algorithms can only use the independences in the observational data as input and therefore miss the strongest signal, which is in the interventional data. We note that the method of [\cite=antti] is computationally infeasible, while COMBINE assumes perfect interventions (while here we mostly have activity interventions).

It is interesting to note that our algorithms can correctly recover from faithfulness violations like the independence between MEK and ERK, because they are taking into account the weight of the input statements (the weight of the independence is considerably smaller than that of the ancestral relation, which corresponds with a quite significant change in distribution). In contrast, methods that start by reconstructing the skeleton like (C)FCI would decide that MEK and ERK are nonadjacent, and are unable to recover from that erroneous decision. This illustrates one of the advantages of our approach.

Discussion and conclusions

As illustrated by our example, in real-world experiments finding cause-effect relations is paramount, and ancestral structures are very well-suited to that end. They also offer a natural way to incorporate background causal knowledge, e.g., from other experiments. On top of that, in the context of algorithms that aim for error-correction by exploiting redundant information, they also allow a huge computational advantage over existing edge-based representations such as [\cite=antti]. When needed, the ancestral structures are easily mapped to a more fine-grained structural representation to indicate direct and indirect causal relations, using the skeleton implied by the output independence weights.

Providing confidence estimates on causal predictions is extremely helpful in practice, and can significantly boost reliability of the output as perceived by researchers. Although standard methods to do so, like bootstrapping (C)FCI, already provide reasonable estimates, having a global optimization method that take into account all confidences in the input causal and independence statements is likely to lead to further improvements of the reliability of causal relations inferred from data.

Strangely (or fortunately) enough, neither of the global optimization methods seems to improve much with higher order independence test results. In other words: both already obtain near optimal error-correction behaviour just exploiting up to order-1 independences. We conjecture that this may happen because our loss function essentially assumes that the test results are independent from another (which is not true). Finding a way to take this into account in the loss function may further improve the achievable accuracy, but at the moment the exact relationship between test results is still unclear. Finally, we plan to explore the possibility of extending our ancestral approach to much larger models by incorporating it as a modular routine in a large-scale causal discovery method.

Appendix A: Proofs

ACI causal reasoning rules

We give a combined proof of all the ACI reasoning rules. Note that the numbering here is slightly different than in the main paper.

For X, Y, Z, U, [formula] disjoint (sets of) variables:

[formula]

[formula]

[formula]

[formula]

[formula]

[formula]

We assume a causal DAG with possible latent variables, the causal Markov assumption, and the causal faithfulness assumption.

This is a strengthened version of rule R2(i) in [\cite=conf/aistats/EntnerHS13]: note that the additional assumptions made there ([formula], [formula]) are redundant and not actually used in their proof. For completeness, we give the proof here. If [formula], then there is a directed path from X to Y. As all paths between X and Y are blocked by [formula], the directed path from X to Y must contain a node [formula]. Hence [formula], a contradiction with [formula].

If [formula] then there exists a path π between X and Y such that each noncollider on π is not in [formula], every collider on π is ancestor of [formula], and there exists a collider on π that is ancestor of Z but not of [formula]. Let C be the collider on π closest to X that is ancestor of Z but not of [formula]. Note that

The path [formula] is d-connected given [formula].

[formula] (because otherwise [formula], a contradiction).

[formula] (because otherwise the path [formula] would be d-connected given [formula], a contradiction).

Hence we conclude that [formula], [formula], [formula], and by symmetry also [formula].

Suppose [formula]. Then there exists a path π between X and Y, such that each noncollider on π is not in [formula], each collider on π is an ancestor of [formula], and Z is a noncollider on π. Note that

The subpath [formula] must be d-connected given [formula].

Z has at least one outgoing edge on π. Follow this edge further along π until reaching either X, Y, or the first collider. When a collider is reached, follow the directed path to [formula]. Hence there is a directed path from Z to X or Y or to [formula], i.e., [formula].

If in addition, [formula], then U must be a noncollider on the subpath [formula]. Therefore, [formula].

Assume that [formula] and [formula]. Then there must be paths π between Z and X and ρ between Z and Y such that each noncollider is not in [formula] and each collider is ancestor of [formula]. Let U be the node on π closest to X that is also on ρ (this could be Z). Then we have a path [formula] such that each collider (except U) is ancestor of [formula] and each noncollider (except U) is not in [formula]. This path must be blocked given [formula] as [formula]. If U would be a noncollider on this path, it would need to be in [formula] in order to block it; however, it must then also be a noncollider on π or ρ and hence cannot be in [formula]. Therefore, U must be a collider on this path and cannot be ancestor of [formula]. We have to show that U is ancestor of Z. If U were a collider on π or ρ, it would be ancestor of [formula], a contradiction. Hence U must have an outgoing arrow pointing towards Z on π and ρ. If we encounter a collider following the directed edges, we get a contradiction, as that collider, and hence U, would be ancestor of [formula]. Hence U is ancestor of Z, and therefore, [formula].

The assumptions [formula] and [formula] imply that there are paths from U to X and from X to Y that are both d-connected given [formula]. Concatenate them and construct a path π from U to Y by removing cycles, if necessary. As [formula], this path must be blocked given [formula]. The only possibility for this to happen is that X must be a collider on that path, and neither X or any of its descendants must be in [formula]. Therefore, if [formula] then there is a directed path from X to Y that cannot pass through nodes in [formula]. It also cannot pass through U as this would give a contradiction with [formula]. Therefore, this path from X to Y is d-connected given [formula]. By concatenating it with one of the paths from U to X that are d-connected given [formula] and removing cycles if necessary we obtain a path from U to Y that is d-connected given [formula]. This contradicts [formula]. Therefore, [formula].

Soundness

Suppose the rules in R are sound. For any pair X,Y of variables, the confidence score [formula] of (16) is sound for oracle inputs with infinite weights, i.e., [formula] if [formula] is identifiable from the inputs, [formula] if [formula] is identifiable from the inputs, and [formula] otherwise (neither are identifiable).

We assume that the data generating process is described by a causal DAG which may contain additional latent variables, and that the distributions are faithful to the DAG. The theorem then follows directly from the soundness of the rules and the soundness of logical reasoning.

Asymptotic consistency of scoring method

Suppose the rules in R are sound. For any pair X,Y of variables, the confidence score [formula] of (16) is asymptotically consistent under assumption (14) or (15) in the main paper, i.e.,

[formula] in probability if [formula] is identifiably true,

[formula] in probability if [formula] is identifiably false,

[formula] in probability otherwise (neither are identifiable).

As the number of statistical tests is fixed (or at least bounded from above), the probability of any error in the test results converges to 0 asymptotically. The loss function of all structures that do not correspond with the properties of the true causal DAG converges to +    ∞   in probability, whereas the loss function of all structures that are compatible with properties of the true causal DAG converges to 0 in probability.

Appendix B: Additional results on synthetic data

in Figure ([\ref=fig:bayes]) we report accuracy results on synthetic data also for the Bayesian test described in the main paper. As prior probability of independence we use p = 0.1. The overall conclusions do not change: ACI and [\cite=antti] overlap for order c = 1 and they perform better than bootstrapped (C)FCI.

In Figure ([\ref=fig:higher_order]) we show the performance of ACI and [\cite=antti] for higher order c = 4 on the same setting as Figure 2 (a-c) in the main paper. As we see, the performances of ACI and [\cite=antti] do not really improve with higher order but actually seem to deteriorate.

Appendix C: Application on real data

We provide more details and more results on the real-world dataset we describe in the main paper, the flow cytometry data [\cite=SPP05]. The data consists of simultaneous measurements of expression levels of eleven biochemical agents in individual cells of the human immune system under 14 different experimental conditions, in which different activators and inhibitors have been added to the cells. One of the 14 experimental conditions can be considered as the observational setting, the others as interventional settings.

In Table [\ref=sachsexperiments] we show the subset of interventions that we consider in our experiments. In Figure [\ref=fig:noicam_add] we show the inputs (first row) and the results for the different algorithms where we study a similar setting to the one presented in the main paper, but now always adding Intercellular Adhesion Protein-2 (ICAM-2) reagent in combination with the other reagents. The results are very similar to the results in the main paper (without ICAM present), showing that the conclusions on ancestral relations generalize. In particular it is clear that also in this setting weighted ancestral relations are a very strong signal and that methods that can exploit them (e.g., ACI) have a distinct advantage over methods that cannot (e.g., FCI and CFCI).

There appear to be various faithfulness violations. For example, it is well-known that MEK causes ERK, yet in the observational data these two variables are independent. Nevertheless, we can see in the data that an intervention on MEK leads to a change of ERK, as expected. It is interesting to note that our approach can correctly recover from this faithfulness violation because they are taking into account the weight of the input statements (note that the weight of the independence is smaller than that of the ancestral relation, which corresponds with a quite significant change in distribution). In contrast, methods that start by reconstructing the skeleton (like (C)FCI or LoCI) would decide that MEK and ERK are nonadjacent, unable to recover from that erroneous decision. This illustrates one of the advantages of our approach.