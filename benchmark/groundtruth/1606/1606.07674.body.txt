Neural Autoregressive Collaborative Filtering for Implicit Feedback

Introduction

Modern online systems rely heavily on recommender systems to help users identify items they might be interested in, from a usually massive catalog, and therefore provide personalized experience. The most popular and successful technique of building a recommender system is collaborative filtering (CF) [\cite=goldberg1992using], which predicts user preferences by analyzing past user behaviors and establishing relevance between items and also between users. There are two major types of inputs to a CF-based recommender system: 1) explicit feedback, e.g. 5-star ratings, likes/dislikes; and 2) implicit feedback e.g. watch/search/browse/purchase behaviors. Explicit feedback accurately reflects a user's preference over an item, and thus is most convenient to use. Techniques designed for explicit feedback, such as restricted Boltzmann machine (RBM) CF [\cite=salakhutdinov2007restricted], matrix factorization [\cite=mnih2007probabilistic] [\cite=salakhutdinov2008bayesian] [\cite=koren2009matrix], neural network matrix factorization[\cite=dziugaite2015neural], and recently developed neural autoregressive distribution estimator for CF tasks (CF-NADE) [\cite=zheng2016neural] have been highly successful in predicting explicit user preferences, which, to the best of our knowledge, is the state-of-the-art on MovieLens 1M, MovieLens 10M [\cite=harper2015movielens] and Netflix datasets [\cite=bennett2007netflix].

In real-world applications, only a small fraction of users actively provide explicit feedback, which restricts the application of aforementioned methods. On the other hand, implicit feedback is abundant, as long as the user interacts with the online system. Hence, building recommender system using collaborative filtering on implicit feedback has attracted increasing attention. One major characteristic of implicit feedback is that there is only positive feedback, in that one can only tell whether a user has engaged with an item for how many times. Consider the size of the catalog, the number of items a user has engaged with is tiny. So implicit feedback is inherently unbalanced and sparse. Also, a user has not engaged with an item does not necessarily mean that he/she dislikes the item or the item is irrelevant, and in most cases it is because the user is unaware of the item. Therefore in literature, collaborative filtering using implicit feedback is sometimes referred to as one-class collaborative filtering (OCCF)[\cite=pan2008one].

A natural way of building recommender system using collaborative filtering for implicit feedback is to interpret implicit feedback as explicit feedback in a proper way and apply existing successful algorithms for explicit feedback, such as [\cite=hu2008collaborative] [\cite=pan2008one]. In this paper, we describe a generalized CF-NADE for implicit feedback, which is referred to as implicit CF-NADE. Specifically, we first introduce the original CF-NADE model [\cite=zheng2016neural] for explicit feedback briefly in Section [\ref=sec:cfnade]. Then, we focus on describing implicit CF-NADE in Section [\ref=sec:implicit_cfnade]. We compare implicit CF-NADE with Implicit Matrix Factorization (IMF) approach [\cite=hu2008collaborative], and show the performance comparison in Section [\ref=sec:exp].

Related Work

Many previous works on recommender system using implicit feedback are based on matrix factorization. [\cite=hu2008collaborative] proposes to employ matrix factorization where implicit feedback is treated as binary preferences and weighted according to the number of engagements. The work of [\cite=hu2008collaborative] is quite popular and has been included into popular software libraries like MLlib of Spark [\cite=meng2015mllib]. [\cite=pan2008one] also formulates the problem as weighted matrix factorization, and proposes to use negative sampling to mitigate the unbalancedness problem. With a similar weighting strategy, inner products are replaced by logistic functions in the probabilistic model called logistic matrix factorization [\cite=johnson2014logistic]. Besides weighting, values can be imputed for unobserved examples to indicate possible feedback. This method and its combination with weighting are discussed in [\cite=yao2014dual]. In [\cite=li2010improving], multiple implicit feedback sources are considered, either by treating each source separately and combining with a linear model, or collectively embedding all feedback sources into a collective collaborative filtering model. Alternatively, SLIM [\cite=ning2011slim] formulates the CF for implicit feedback as a convex optimization problem, which is recently generalized to LRec in [\cite=AAAI1612333].

With the recent success of deep learning in computer vision and natural language processing community [\cite=krizhevsky2012imagenet] [\cite=szegedy2014going] [\cite=he2015deep] [\cite=mikolov2013distributed], neural networks have also found application in building recommender systems. For example, RBM-CF [\cite=salakhutdinov2007restricted] and AutoRec [\cite=sedhain2015autorec] are successful approaches to model the users' explicit feedback, using restricted Boltzmann machine and autoencoder respectively. The recently developed CF-NADE [\cite=zheng2016neural] models explicit feedback with a neural autoregressive architecture. In this work, we will generalize CF-NADE and propose a novel CF model for implicit feedback.

CF-NADE

We start with the description of CF-NADE, a neural autoregressive architecture for CF tasks which has proved successful in modeling explicit ratings [\cite=zheng2016neural]. A user u's explicit ratings are denoted as [formula], where D is the number of items that the user has rated, [formula] is the index of the ith rated items, M is the total number of items, o is a D-tuple in the set of permutations of [formula] which serves as an ordering of the D rated items, and [formula] denotes the rating that the user gave to item moi. For simplicity, we will omit the index u of [formula]. As discussed in [\cite=zheng2016neural], a random order of the ratings works well in practice and is the key to extend CF-NADE to a deep model.

By the chain rule, CF-NADE models the joint probability of the rating vector [formula] as a product of conditionals:

[formula]

where [formula] denotes the first i - 1 elements of [formula] indexed by o.

Each conditional in Equation [\ref=eqn:chain_rule] is modeled as:

[formula]

[formula] is the score indicating the preference that the user gave rating k for item moi given previous ratings [formula]. The score of [formula] is computed by:

[formula]

where [formula] and [formula] are the connection matrix and the bias with rating k, respectively. And

[formula]

where [formula] is the connection matrix associated with rating k, [formula] is the j column of [formula] and Wki,j is an interaction parameter between the i hidden unit and item j with rating k, [formula] is the bias term,   ·  ) is the activation function, such as [formula],

Fitting CF-NADE can be simply maximizing the joint probability [formula]. As noticed in [\cite=zheng2016neural], maximizing the conditional of Equation [\ref=eqn:cfnade_softmax] can only ensure that the probability of the true rating is the largest among all possibles, while leaving the ordinal nature of ratings disregarded. Hence, a ranking loss is proposed to be added in the objective function, and a significant improvement can be observed.

Implicit CF-NADE

As discussed in Section [\ref=sec:intro], implicit feedback is abundant and easy to obtain. In this section, we describe how to adapt CF-NADE to implicit feedback. In the implicit feedback scenario, the "rating" [formula] that a user u gives to an item i is defined as the number of times that the user interacts with the item. Inspired by [\cite=hu2008collaborative], we could define a binary scalar tui by binarizing the rui values:

[formula]

where tui = 1 indicates user u likes item i as he/she has interacted with this item before, and if user u never interacted with item i, we think that there is no preference of user u on item i. However, deciding whether a user likes or dislikes an item by binarizing rui is oversimplified and can be quite noisy. The reason is twofold: 1) in most cases, a user has not interacted with an item is because of unawareness, not dislike; and 2) the number of times the user interacts with the item can be a good indicator of how much the user likes the item, which is lost in [formula] after the binarization.

Hence, we need to formalize the confidence that a user likes or dislike an item. Generally speaking, the confidence cui should increase with rui. In this work, we follow [\cite=hu2008collaborative] and define the confidence as:

[formula]

where α is the rate of confidence, which is a hyper-parameter controlling how fast the confidence cui increases with rui. We will show the impact of α in the experiments.

A user u's implicit feedback can now be represented as [formula], with corresponding confidence levels as [formula]. In the rest of the paper, we will omit the superscript u for simplicity. Similar to CF-NADE, we model the probability of [formula] as a product of conditionals, with the addition of confidence levels in the condition as:

[formula]

where M is the number of items, and [formula] denotes preference of the previous i - 1 items. Similar to CF-NADE model, the order of the items in Equation [\ref=eqn:implicit_chain_rule] is randomly shuffled. As the confidence level ci should be paired with ti, Equation [\ref=eqn:implicit_chain_rule] can then be rewritten as:

[formula]

To define the conditionals in Equation [\ref=eqn:implicit_chain_rule_2], we first define the hidden representation given previous i - 1 ratings as:

[formula]

where   ·  ) is the activation function, [formula] is element-wise product, [formula] and [formula] are connection matrices associated with the "like" vector [formula] and the "dislike" vector [formula], [formula] is the bias vector, [formula] is the first i - 1 columns of matrix [formula], and similarly, [formula] is the first i - 1 elements of vector [formula], and [formula] is the activation function. Note that if there is no confidence vector [formula], the "dislike" connection matrix [formula] would be redundant, as the difference between the corresponding parameters W:,i and A:,i for item i would be constant, in which case we can set Ŵ:,i = W:,i - A:,i and A:,i = 0. However, as the confidence varies for each user, [formula] is required to capture the differences induced by varying confidence levels.

Then the conditionals in Equation [\ref=eqn:implicit_chain_rule_2] can be modeled as:

[formula]

where [formula] and [formula] are the connection matrix and bias, and [formula] and [formula] are the corresponding ith row and element, respectively. (x) denotes the sigmoid function: [formula].

Training an implicit CF-NADE can be done by minimizing the negative log-likelihood of Equation [\ref=eqn:implicit_chain_rule_2] directly, as the original CF-NADE. However, due to the noisiness of [formula], it would be beneficial to incorporate confidence levels [formula] to reflect the uncertainty of the elements in [formula]. Hence, we formalize the cost function as:

[formula]

In this way, fitting an element [formula] wrong with high confidence in Equation [\ref=eqn:weighted_cost] would cost more than one with low confidence. After the model is trained, we could predict the users' preference for each item as:

[formula]

Thus, the model can learn to balance the huge number of low confident items, which are unobserved or interacted few times by the user, and the items with high confidences but of small quantity. As a result, the model could predict a user's preferences on unobserved items even if the we set ti = 0 (dislike) as the input. And it might also happen that a user has interacted with an item i before (ti = 1) but for only a few time, and the model predict that he/she does not like the item much. For example, a user watches the first episode of a TV show, but he/she never starts the next episode. In this situation, the corresponding ti is 1 and ci is small. Then the model can learn to predict a higher probability for [formula].

As is noticed by [\cite=Uria2013b] [\cite=zheng15deep] [\cite=zheng2016neural], with a randomly sampled ordering (c.f. Section [\ref=sec:cfnade]), minimizing the negative log-likelihood for NADE based model is equivalent to randomly splitting the input vector into two parts, and treating the first part as the input, and optimizing to maximize the conditionals of the elements in the other part. We refer the reader to [\cite=zheng2016neural] for more details.

Thus, the training objective can be rewritten as:

[formula]

where o is a random ordering of all items that are sampled at each training update, and oi and o< i are the ith element and first i - 1 elements of o. In practice, we will adopt this training objective as it is easy to implement and can be extended to a deep version efficiently.

Experiments

In this section, we test the performance of implicit CF-NADE on a dataset extracted from a digital TV streaming service, and compare the performance of implicit CF-NADE with the widely used Implicit Matrix Factorization approach [\cite=hu2008collaborative], as implemented in Spark MLlib [\cite=meng2015mllib].

Dataset Description

Our dataset is composed of watch behaviors of 444480 randomly sampled active users on 17348 movies or TV shows. Here an item is either a movie or a TV show. For each user, we track the number of times that the user "completely" watched a movie or an episode of a TV Show during a period of 3 years from April 2013 to April 2016. We define a "complete" watch as any continuous stream of a video (episode or movie) from the start of a video to the end. For each user, the total number of watches of a TV show is the aggregation of the number of times he/she has watched any episode of that show.

As the number of episodes varies dramatically between different TV shows, and a movie usually has only one video, there would be a strong bias if we directly use the number of times for each TV shows and movie. To amend this problem, we propose to use a relative score ui as a surrogate of the "rating" rui in Equation [\ref=eqn:t] and Equation [\ref=eqn:confidence], which is the percentage of users whose watch count of item i is no larger than user u's out of all users who have watched item i. For example, if a user watched a TV show i 10 times (counting all its episodes) and 100 out of 1000 people watched this TV show more no more than 10 times, where 1000 is the total number of people who have watched it, then the relative "rating" ui will be 0.1.This method also applies for movies, as we observed that there are always users who watch a movie multiple times. Figure [\ref=fig:show_movie] shows the histograms of watch count for a TV show and a movie, respectively. We can see that there are users who have watched a movie even more than 5 times. If a user's watch count on a specific item (a TV show or a movie) is the largest among all users who have watched the item, we have a good reason to assume that the user likes this item very much. Moreover, we can also observe that most of users watch a movie only once while watch a TV show more than 1 time (namely, more than one episode). Hence, the relative "rating" of a movie watched once will be higher than a TV show also watched once by a user. This is a desirable characteristic as watching a movie entirely strongly indicates that the user likes the movie, while this does not hold if a user has watched only one episode of a TV show. Another advantage of adopting relative "ratings" is that they take values in

[formula]

Evaluation Metric

The difficulty with evaluating collaborative filtering methods in the implicit feedback scenario is that we can only test the performance of the models on items that a user has watched before, since non-engagement is noisy and does not necessarily mean negative feedback. As a result, we follow the famous work of [\cite=hu2008collaborative] and use a recall based evaluation metric mean percentage ranking (MPR).

Specifically, for each user, we randomly select 10% relative "ratings" ui on TV shows or movies he/she has watched, as the test set. The samples in the test set are denotes as γ̃ui and their counterparts ui in the training are set to 0. Thus, the training set does not contain any watch behaviors of the test samples, and the goal of the CF models is to predict the users' preference on the test samples. For each user, we generated a ranked list of all candidate items sorted by preference from Equation [\ref=eqn:test_cond]. Let ui be the percentile ranking of item i for user u in the ranked list, where ui = 0% means that i is predicted as the highest recommended item for u, and ui = 100% signifies lowest. The MPR is then defined as:

[formula]

Lower values of MPR indicate that users will watch the TV shows or movies higher in the ranked list, which is desirable in practice. As an extreme example, a randomly shuffled list would have an expected MPR of 50%.

Results

In this section, we compare implicit CF-NADE with Implicit Matrix Factorization (IMF) [\cite=hu2008collaborative]. Implicit CF-NADE is implemented using Tensorflow [\cite=abadi2016tensorflow], and IMF is implemented using Spark MLlib [\cite=meng2015mllib]. In the experiments, the implicit CF-NADE model is trained with stochastic gradient decent optimizer with learning rate set to 0.01, batch size 200 and weight decay 0.01. We use only one hidden layer and the number of hidden units is set to 256. The number of factors for IMF is also set to 256 for a fair comparison. Figure [\ref=fig:mpr] depicts MPRs on the test set for different choices of the rate of increase α in Equation [\ref=eqn:confidence]. We can see that implicit CF-NADE always outperforms IMF, and α should be set to higher than 100 for good performance for both algorithms. The best test MPR (5.2436%) of implicit CF-NADE is achieved at α = 300, and for IMF, the best test MPR is 7.362% with α = 100.

Conclusion

In this paper, we generalized the recently developed CF-NADE to implicit CF-NADE for real-world collaborative filtering tasks, using implicit feedback. Specifically, we convert a user's watch counts into implicit relative ratings, and then compute a "like" vector and a confidence vector. Implicit CF-NADE is constructed by modifying CF-NADE to be aware of the "like" and confidence vector, in the sense that the joint probability of a "like" vector conditioned on the confidence vector is decomposed into conditionals by chain rule, and the conditionals are modeled by a series of weight sharing neural networks. We augmented the training loss with the confidence vector, taking the uncertainty of ratings into consideration. Experimental results show that implicit CF-NADE outperforms implicit matrix factorization on a dataset extracted from a popular digital TV streaming service. This also indicates that implicit CF-NADE is highly effective in real-world applications.