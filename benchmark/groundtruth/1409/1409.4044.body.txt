Definition

A new approach in machine learning (Preliminary report)

Introduction

This technical report is a draft and is not intended for publication in an official venue as is. Our goal it to share preliminary results in order to obtain feedback and guidance. Before making a big move to machine learning, the author has worked on cryptography, quantum computing, and complexity theory, amongst other things. In all of these fields, boolean circuits are at the heart of many of the deepest results. For one coming from these fields, it is surprising that they do not hold a prominant place in machine learning.

In this note, we present a machine learning approach based on boolean circuits and study the characteristics of a learning algorithm that naturally fit this approach. Our original motivation was unsupervised learning and although we firmly believe this approach can lead to interesting results in that field, we have decided to concentrate first on supervised classification.

Once one is acquainted with the framework, a straightforward supervised learning algorithm for binary classification emerges naturally. Studying the properties of this simple algorithm we find its performance impressive, both in terms of efficiency and accuracy. It compares very favorably with mainstream techniques like neural nets, deep neural nets and support vector machines. This is despite the relative maturity of these established techniques, compared with our new framework.

The framework will be presented in the next section. We then present a straightforward greedy algorithm for classification. The following section adds hill climbing to the greedy algorithm, for a general learning algorithm that is our focus in this article. The conclusion contains a long list of area of improvement to the techniques presented in this note. Finally, the appendix contains detailed analysis of the behavior and performance of the algorithm on several benchmarks problems. These benchmark problems vary from numerical data to color images; of course MNIST is also part of the benchmarks. Some of those benchmarks have been used in [\cite=Larochelle:2007] and we can thus compare ourselves to the state of the art in 2007.

Once the technique is refined and especially once deep learning has been integrated into the model, we are optimistic this approach can compete with the best techniques available today. We believe the fact that we obtain such impressive results, with very varied benchmarks, and with no engineering, is outstanding; and we believe this preliminary note provides justification and motivation for the further study of this paradigm.

The framework

In this section we describe and formalize the new framework we propose. In contrast with approaches that use reals numbers, multiplication, and exponentiation, we present a framework based on binary number (bits) and boolean circuits. In short, inputs are are binary vectors of a given length, and classifiers are boolean circuits.

The input data could be images, text, lists of numbers or anything else encoded as fixed-length binary vectors. The classifier we will obtain by our algorithm will be booleen circuits, specifically tree-structured circuits. All the classifiers we present in this note are binary circuits with binary vector inputs, and output a single bit representing the classification decision.

In this note, a k-gate is a function mapping k inputs bits to an output bit. We call k the arity of the gate.

The number of possible k-gate is 22k and it can be completely specified by a look up table of 2k bits.

For example, the boolean AND, OR and XOR gate are 2-gate. There is a total of 16 boolean binary gates with 2 inputs (if one consider the input bit an order pair). The total number of possible gates for a given arity is surprisingly high. In the case of arity 8, there are

[formula]

different gates that can be computed, but each of those is uniquely define by a truth table of 256 bits.

In this note we define a Boolean circuit classifier as a Boolean circuit whose input bits are data bit and who's output bit represent the classification decision.

We often restrict the gates in a classifier to have the same arity, as a design choice. All the circuits we consider in this note will be full trees (i.e., every leaf has the same distance from the root (in edges)).

The depth of a circuit is the length of the longest path from an input bit to the output.

The depth of a circuit is an important characteristic, especially in the context of parallel computation, where it corresponds to the time neccessary to evaluate the circuit (with a sufficient number of processes).

A depth 3 clasifier F made of 7 2-gates for data [formula].

To describe this circuit we need to specify the the inputs for each gate (which may be some dimensions of the input, or outputs of other gates), as well as filling in 7 truth tables (one for each gate).

Suppose now that we wish to evaluate this classifier on 64000 different examples (10 bits each). Then the dataset can be stored as a table with 64000 rows of 10 bits each.

The first step ef every algorithm will always be to transpose the input. In this example we obtain a table with 10 lines of 64000 bits. On a 64 bit system this requires 1000 memory words per lines.

Now assume that all the gates Fi are either AND, OR, or XOR gates. Evaluating this classifier on that data will require evaluating the 7 binary gates. Since the gates we have chosen can be evaluated by any reasonable system on words of 64 bits, the evaluation will require 7 vector operations on 1000 words tables, for a total of 7000 word operations. Note that here, 7000 is significantly smaller the 640,000 bits (the total size of the data).

In general we will want to use more then 7 gates and more importantly might want to work with gates of arity larger then 2. Fortunately the AND, OR and NOT gates are more then enough to compute any computable function. We exploit this fact to develop a general technique for evaluating circuits with gates of any arity.

In this framework, we consider the input bits as (unlearned) features, and the output of the gates, Fi as learned features. For each feature, we store its negation as well, to save operations. This representation will be useful in the implementation of gates. The input bit will be the first feature and can be compute by on vector operation (NEGATION). The tensor product of a list of k bits is the list containing 2k being the product (logical AND) of all possible combination of every input and its negation.

If the truth table of a gate gives us its output for each input then the tensor product of the feature given as input to the gates have a one to one corespondent with the truth table. The output of a gate is a feature where the first bit is the OR of every element of the tensor product position where the truth table ha a value 0 and the second vector of the output of the gate is the OR of all tensor product element where the truth table has a 1. Using the fact that the output feature is composed of a vector and its complement one can spare some operations.

On an architecture with words of m bits, the evaluation of a k-gate when the size of the data set is n (a multiple of m) is (2k + (2(k - 1) + 1))n  /  m elementary gates.

On one core, using no parallelism (other then the fact that 32-bit words are used), using C# we can evaluate 27 million 4-gates over 32 bits. This means that a 5000 gate circuit with 5000 inputs can be evaluated in a second. Of course parallelism can be used both at the vector level and the circuit level, for significant speedups.

Greedy algorithm

The best classifier would be the simplest circuit capable of calssifying the dataset. This optimization is obviously intractable. We simplify this optimization problem several times, obtaining a greedy algorithm that produces a good and extremely efficient classifier. First, we set the arity of all gates to be equal to k (first hyperparameter of our algorithm). Second, we set the topology of our circuit to be a full tree of depth d (the second hyperparameter of our algorithm). Third, we let the leaves' inputs each be a random coordinate of the input space. Finaly, we use greedy local optimization instead of global optimization.

The greedy algorithm is quite simple to understand. Every leaf takes as input a random coordinate (a bit) of the binary input vector. To specify the circuit we then have to specify the truth table of each of its gates.

We chose these truth tables in a greedy way starting with the gates connected to the leaf (data bits) and climbing up the tree until the root gate, which outputs the classification decision. So how do we chose the truth tables for the non-root gates? In fact, every gate simply behaves as if its output were output of the entire circuit, i.e., the classification decision. Every individual gate will be chosen to be the best gate to accomplish this task, i.e. to minimize the classification error of its outputs. The reader might recall that the number of different gates of arity k is double exponential in k and might worry that this optimization is intractable.

That optimization can be simplfied, as follows: In the case of a k-gate, we have 2k possible inputs to worry about and we have to specify the answer of the gate on each of those, nothing less, but also nothing more.

We can optimize a gate independently for each possible input vector, e.g. the best answer for a 4-gate on input (0,0,0,0) can be computed independently to the best outcome on input (0,0,0,1) and so on.

This means for a k-gate we only need to compute 2k values, not 22k. This is reasonable to do when k is small (we mostly use gates of size 2 to 8 in this work).

We can compute the best output for a given input simply by counting how many examples that produce this input for this gate belong to each category. If there are more such examples belonging to category 0, we chose that element of the truth table to be 0, otherwise, we set it to 1.

We start this process of specifying the gates one by one with the gates at the bottom of the tree, which take dimensions of training data as input. Once these gates' truth tables are known, we also know their output on each example, which we use to compute the second row's gates' truth tables, and so on, moving up the tree until we have learned all the gates.

Maximizing information gain versus Maximizing probability

Early on in our investigation, we decided that maximizing the success probability is only a good criterion for the top gate. For lower gates, one should maximize the information gain (Kullback–Leibler divergence).

Information gain: [formula]

This can also be done efficiently. For any given gate, we can calculate the input to this gate on any data example. Now, for each possible input, v, to the gate, Fi, we compute the proportion of examples producing v as input to Fi also are ultimately classified as category 0. We can then sort the 2k possible inputs to Fi based on this proportion, creating a list l. Then we find the two set partition respecting that order which maximizes the information gain (i.e., we choose an index, j, of l and set the output of Fi to be 0 for all previous indices, and 1 for j and all subsequent indices). This leads to the optimal gate.

Experimental results

We perform experiments with a variety of data, ranging from black and white images, and RGB images of common objects, to numeric data. In every experiment, the data is encoded as binary vectors, with the order of dimensions playing no role (note that this makes the algorithm permutation-invariant).

The two hyperparameters of the algorithm are the arity of gates (k) and the depth of the circuit (d). The running time scales exponentially with both hyperparameters, but in practice very good result can be obtain with small values of both k and d. Arity of 4 and depth of 8 appears to be a good default hyperparameter setting that gave good results in all our experiments. With this configuration, the classifier is a tree with 21845 internal nodes and 65536 leaves. For those hyperparameter the C# training time (32 bits) is roughly 10.6s when the number of training example is 50,000 (Using 6 cores and 12 treads the time is reduced to 2.5s). Note that the time required to evaluate the classifier is not much smaller; more than a second is needed to performs 50000 classifications, with such a circuit. With default hyperparameters our algorithm compares favorably with neural nets and with the right choice of hyperparameters it is possible to obtain even better results.

Main algorithm

We have observed that the previous greedy algorithm result is highly dependent on choice of leaves' inputs. Repeating independently at random with different configurations of inputs is not very efficient. In this section we propose to use simple hill climbing to optimize the choices of input dimension for all leaves. This technique is quite powerful and if not used carefully, can result in severe over-fitting.

Again, the idea of this technique is quite simple. Chose one leaf uniformly at random and change it to take a different input dimension, also chosen uniformly at random. If the new classifier is better keep it like that and if not, go back the how it was before. Of course, this process must be repeated an appropriate number of times.

This is efficient, because only the gates along the path from that leaf to the root need to be re-evaluated. For a k array tree this value is the base-k logarithm of the number of leaves and even for very large trees this value is quite small. For example, with the default hyperparameters, only 7 nodes need to be recomputed. (See figure [\ref=hill_climbing])

Experimental results

This algorithm allows us to obtain classifiers that are significantly smaller then the greedy algorithm produces, resulting in very significant improvement for a given tree size. For example, we are able to classify the data using only a few gates. On at least one data set, we obtain results that are significantly better than the 2007 state of the art as presented in [\cite=Larochelle:2007]

Conclusion and future work

In this report we have presented a new paradigm for machine learning. Our preliminary results that strongly indicate that the paradigm is worth studying. To do so we have presented a simple but dramatically new machine learning algorithm that is very efficient and learns good binary classifiers. Experimental results seems to indicate that the technique performs significantly better then feed-forward neural networks with a single hidden layer and that it can outperform deep neural nets in some contexts, as well.

Here is a partial list of things to investigate for this method in the context of supervised classification. Although the preliminary results we have obtained are impressive, we believe further investigation is needed, and that the technique can be improved significantly.

Our experiments were performed on 6 CPU corse, but using GPUs should enable even faster implementation.

FPGAs should also make computation faster. Indeed, they appear taylor-made for this algorithm, with an ultra-fast physical implementation of circuits composed of 6-gates. We are investigating their use on classification problems, and our result will be presented in a coming report.

Taking into consideration the structure of the data for the initialization of the leaves in the circuit tree could lead to significant improvement, especially when n = 0.

Preprocessing of the data will certainly yield improvement. This can be done in several ways with or without exploiting the structure of the input. Dimensions with very low entropy could be eliminated and dimensions that are very similar replace by a single dimenstion that is their average.

Adding noise in part of the learning process could reduce over-fitting.

We can perform hill climbing on the nodes themselves once a good tree is obtained. This looks very promising.

We can compute more features than needed and select a subset with low mutual information.

Explore with more example the advantage/disadvantages of using binary representations for the data.

In every algorithm, the top of the tree tends to be composed of gates that simply output to mode of their inputs. We might be able to improve on this by using something else for the top levels.

Can we extend this framework to perform efficient, effective multiclass classification?

We believe that deep learning of representations using autoencoders can be accomplish in this framework. That being said, the techniques will certainly share some properties with those based on neural nets (hopefully the impressive results), where we already know that there is a significant difference between discrete and continuous cases. For example, using binary outputs, there is no gradient and things like hamming distance are a poor substitute. In some future work we will investigate an autoencoder and we are very optimistic this will leads to interesting results.

Acknowledgment

Thanks to David Krueger for useful comments. A special thanks to François Leclerc who significantly contributed to this work by its expertise in programing and with helpful comments. I would also like to take this opportunity to thanks Yoshua Bengio and his group for accepting me as an intern form my 6 month sabbatical. Most of this work was completed prior to the sabbatical. Finally, I would also like to thanks my wife Sandra for her unconditional support.

Appendix: Detailed experimental results

The algorithm we present in this note is a general purpose supervised learning algorithm for binary classification. As stated, the data to be classified are binary vectors (i.e. strings of bits) and we have avoided preprocessing or using domain-knowledge in order to investigate the intrinsic power of the technique as a black-box, permutation-invariant algorithm. Although we experiment with images, our method completely ignores the spatial structure.

Here is a list of the variables (with typical values) used in the following experimental tests:

Training = 12k, 12,000 examples for training

Test = 50k, 50,000 examples for testing

a = 4, arity of the gates, 4-gates

d  =  8, dept of the tree

t is the dept up to which update are propagated in the hill climbing

n = 0, number of trials for hill climbing

δ  =  0.1, noise level (only for the CUBE dataset)

Bits = 2, number of bits of precision per pixel; means 2 bit by color channel for color pictures and 2 bit in total for black and white pictures

In our experiments, we noticed that the greedy algorithm with arity 4 and depth 8 always gave relatively good performance. We refer to these as the default hyperparameters, or defaults. The running time of the algorithm using the defaults does not depend on the data type but only on the number of training examples. For 10k examples the algorithm completes its training in less then a second. If n = 0 we recover the greedy algorithm, otherwise this describes the hill climbing algorithm.

It seems one of the main advantage of the classification algorithm we have presented here is it's efficiency. All the experiment we done on a 6 core Intel Core i7 CPU with a sufficient (64GB) amount of memory. The algorithm is trivially parallelized, and we ran 12 threads in parallel for most experiments. The presented timing results are with a C# version of the algorithm; Python code will be made available. The fact that both python and C# enable binary vector operation very efficiently makes the algorithm run extremely fast.

We have asked a student to performs some tests using FPGA. The structure of the FPQA uses 6-gates with a fully programmable truth table. The FPGA will not be used for training but it is perfectly suited for classification. Detailed experimental results will be presented in another report. Our preliminary results indicate that 500k classifications per second are possible even with a large classifier (several tens of thousands of leaves). No experiments have been performed with GPU accelerated computing, but we are optimistic that this would yield the expected speedup.

CUBES

The first dataset we use is artificially constructed, so a practically infinite number of examples can be constructed. The CUBE data set (figure [\ref=figure_cube]) is composed of images of size 32 by 32 of which the pixel are black or white (1024 bits string). The first class contain a black cube of 15 by 15 at a random location and the second class contains two cubes, one 12 by 12 and one 9 by 9. When those two cubes do not overlap they have in both case a surface of 225 bits as a single 15 by 15 cube. When the cubes overlap we chose the overlap to be white. In this and all cases, the permutation-invariant nature of the algorithm means it does not have acces to information regarding the relative locations of pixels. This data set have a single parameter which is the level of added noise (between 0 and 1). For a noise δ every bit is independently flipped with probability δ.

When the noise is 20% (δ = 0.2) the default hyperparameter algorithm gives errors of 24.6 for training and 27.4 on the test set.

In term of running time, the C# version on the algorithm with default hyperparameters trains in less then a second (a  =  4, d = 8, t = 4, n = 0, Training = 12k). The running time of the algorithm with defaults depends only on the number of examples, it does not even depends on size of each example. Its running time on datasets of a million example is roughly 30 seconds. The longest training example of this section took less then 6 minutes (a  =  6, d = 6, t = 3, n = 2m, Training = 12k). The python version is slower by a factor 3, approximately.

GAUSS: Numbers with a normal distribution

The second dataset is also computer generated. That being said it is very different from the previous one. In this dataset the examples are lists of 32 integers (16 bits/integer) generated from one of two normal distributions. The task is to classify example lists according to which distribution their integers are drawn from. Since the algorithm does not have access to the structure of the input, it receives no information about which bits are part of which integer. We performed experiments in which the two distributions differ in mean (top two plots) and variance (bottom two plots).

We also performed experiments to see if the scale has an impact on the algorithm; the results we obtained show that apart from rounding errors and significant overflows, rescaling all data by a constant factor does not significantly affect the performance of the classifiers. Figure [\ref=GAUSSdata] shows a graphical representation of the different datasets we used. For visualization, we have interpreted the data as 16 pairs of number which we plot in table [\ref=GAUSS_result1] and [\ref=GAUSS_result2].

MNIST: digits 3 versus 5

Using the famous MNIST dataset we perform binary classification on the set of 3s and 5s. After several experiments, we found these classes the hardest to distinguish. For example, distinguishing 0 and 1 with very high probability only require five 4-gates and driving the test error to zero is very straightforward. For this dataset the only hyperparameter is the number of bits for the pixel representation. Each pixel is an 8 bit integer ranging form 0 to 255. With k bits of resolution we chose the first k most significant bits. We have obtained very good results with this dataset. The fact that the algorithm gives good result on 8 bit resolution does not imply that it behaves well on binarized MNIST (1-bit resolution), but rather that the algorithm do not loose its power in presence of a large number of non significant bits. With default hyperparameters, the greedy algorithm achieved a test error of 5.6%, and using hill climbing is it possible to drive down the error even more, to 3.57%. The results are presented in table [\ref=MNIST_result1],[\ref=MNIST_result2] and [\ref=MNIST_result3].

MNIST 8 bits per pixel

CONVEX

This dataset was created by the LISA group in Montreal and it is a hard classification problem for deep feedforward nets. The data consists of binary images, whose 0-valued pixels form either a convex or non-convex set, as shown in figure [\ref=convex_images]. The classification problem is to determine if the set is convex or not. On this dataset, we obtained significantly better results than the 2007 state of the art, as presented in [\cite=Larochelle:2007]. The size of the training dataset used by [\cite=Larochelle:2007] was 8k and the test dataset has 50k elements. We used the same number of examples for our experiments.

The algorithms compared on this dataset are: Support vector machine with RBF kernel (SVM RBF), support vector machine with polynomial kernel (SVM Poly), feed-forward neural network (NNET) with a single hidden layer, deep believe network with 3 hidden layers (DBN-3), stacked autoassociator with 3 hidden layers (SAA-3). We have included in the table the performance of our algorithm with 3 settings of the hyperparameters. Tapp A uses the default hyperparameters, Tapp B sets a = 8, d = 7, and n = 0 (hill climbing is not used), and finally the best performing algorithm Tapp C, had a  =  6 d = 7, t  =  3 and n  =  20m. Training error of 4.94% was achieved, but with significant over-fitting, as the test error was 15.9. We did not perform a thorough hyperparameter search, and we expect, e.g., an increase in running time to allow further improvement. Tapp C took much longer to train than any other result we present in this article (2 hours, compared to Tapp A running is less then a second).

CONVEX First line is convex and second line is non convex

CIFAR 10

To show the performance of our algorithm on RGB natural images we chose two categories of the CIFAR 10 image dataset: cars and birds.

CIFAR 10, cars versus birds

The original images have 8 bit per color channel with a total of 24 bits per pixel but using more then 4 bit per channel does not provide much visual improvement. All experiments used 10k training and 2k testing images. With default hyperparameters, the algorithm had a test error of 19.2. With hill climbing, the test error can easily be reduces to less then 15%.