=0pt

Thesis Definition Lemma Proposition Convention Example Remark Fact Exercise

Introduction to cirquent calculus and abstract resource semantics

Department of Computing Sciences, Villanova University, 800 Lancaster Avenue, Villanova, PA 19085, USA Email: giorgi.japaridze@villanova.edu URL: http://www.csc.villanova.edu/~japaridz/

MSC: primary: 03B47; secondary: 03B70; 68Q10; 68T27; 68T15.

Keywords: Cirquent calculus; Resource semantics; Computability logic; Proof theory; Sequent calculus; Linear logic; Affine logic; Substructural logics.

Introduction

This paper introduces a refinement of the sequent calculus approach called cirquent calculus. Roughly speaking, the difference between the two is that, while in Gentzen-style proof trees sibling (or cousin, etc.) sequents are disjoint and independent sequences of formulas, in cirquent calculus they are permitted to share elements. Explicitly allowing or disallowing shared resources and thus taking to a more subtle level the resource-awareness intuitions underlying substructural logics, cirquent calculus offers much greater flexibility and power than sequent calculus does.

A need for substantially new deductive tools came with the recent (2003) birth of computability logic (CL), characterized in [\cite=CL1] as "a formal theory of computability in the same sense as classical logic is a formal theory of truth". Indeed, formulas in CL are seen as computational problems rather than propositions or predicates, and their "truth" seen as algorithmic solvability. In turn, computational problems, understood in their most general -- interactive -- sense, are defined as games played by an interactive Turing machine against its environment, with "algorithmic solvability" meaning existence of a machine that wins the game against any possible (behavior of the) environment. A core collection of the most basic and natural operations on computational problems forms the logical vocabulary of the theory, with some of those operations, as logical operators, resembling those of linear logic. With this semantics, CL provides a systematic answer to the fundamental question " what can be computed?", just as classical logic is a systematic tool for telling what is true. Furthermore, as it turns out, in positive cases " what can be computed" always allows itself to be replaced by " how can be computed", which makes CL of interest in not only theoretical computer science, but some more applied areas as well, including interactive knowledge base systems and resource oriented systems for planning and action. On the logical side, CL can serve as a basis for constructive applied theories. This is a very brief summary. See [\cite=Jap03], [\cite=Japic] or [\cite=Japfin] for elaborated expositions of the philosophy, motivations and techniques of computability logic.

The above-mentioned fact of resemblance between computability-logic and linear-logic operators is no accident. Both logics claim to be "logics of resources", with their philosophies and ambitions thus having a significant overlap. The ways this common philosophy is materialized, however, are rather different. Computability logic directly captures resource intuitions through its semantics. Resources, understood in the specific sense of computational resources, are dual/symmetric to computational problems: what is a problem for the machine, is a resource for the environment (=user), and vice versa. So, as a logic of computational problems, CL also automatically is a logic of computational resources. The scheme that CL follows can be characterized as " from semantics to syntax": it starts with a clear concept of resources (=computational problems) and resource-semantical validity (=universal algorithmic solvability), and only after that, as a natural second step, asks what the corresponding syntax is, i.e. how the set of valid formulas can be axiomatized. On the other hand, it would be accurate to say that linear logic, as a logic of resources (rather than that of phases or coherence spaces), has started directly from the second step, essentially by taking classical sequent calculus and deleting the structural rules unsound from a naive, purely intuitive resource point of view. For simplicity, in this discussion we narrow linear logic down to its multiplicative fragment; furthermore, taking some terminological liberty, by "linear logic" we mean the version of it more commonly known as affine logic, which is classical sequent calculus without the contraction rule (Girard's [\cite=Gir87] canonical system for linear logic further deletes the rule of weakening as well). Even the most naive and vague resource intuitions are sufficient to see that the deleted rule of contraction, responsible for the principle [formula], was indeed wrong: having $1 does not imply having $1 and $1, i.e. $2. Such intuitions can also be safely relied upon in deeming all the other rules of classical sequent calculus "right". To summarize, linear logic is undoubtedly sound as a logic of resources. But even more so is ... the empty logic. Completeness is thus a crucial issue. This is where the need for a mathematically strict and intuitively convincing resource semantics becomes critical, without which a question on completeness cannot even be meaningfully asked. Despite intensive efforts, however, such a semantics has never really been found for linear logic. And apparently the reason for this failure is as straightforward as it could possibly be: linear logic, as a resource logic, is simply incomplete. At least, this is what CL believes, for it has been shown ([\cite=Japfin]) that the semantics of the latter, with its well-justified claims to be a semantics of resources, validates a strictly bigger class of formulas than linear (=affine) logic does.

Taking pride in the meaningfulness of its semantics, computability logic, at the same time, has been suffering from one apparent disadvantage: the absence of a good syntax, i.e. proof-theoretically "reasonable" and nice deductive systems, as opposed to the beauty and harmony of the Gentzen-style axiomatizations for linear logic and its variations, let alone proof nets. True, certain sound and complete systems, named CL1, CL2, CL3 and CL4, have been constructed for incrementally expressive (and rather expressive) fragments of CL in [\cite=CL1] [\cite=CL2] [\cite=CL3] [\cite=CL4], and probably more results in the same style are still to come. Yet, hardly many would perceive those systems as "logical calculi", and perhaps not everyone would even call them "deductive systems". Rather, those somewhat bizarre constructions -- one of which (CL2) will be reproduced later in Section [\ref=slast] -- might be seen as just ad hoc syntactic characterizations, offering sound and complete decision or enumeration procedures for the corresponding sets of valid formulas of CL, but otherwise providing no real proof-theoretic insights into this new logic. Repeated attempts to find Gentzen- or Hilbert-style equivalents of those systems have hopelessly failed even at the most basic, [formula] ("multiplicative") level. And probably this failure, just like the failure to find a good resource semantics for linear logic, is no accident. The traditional deductive methods have been originally developed with traditional logics in mind. There are no reasons to expect for those methods to be general and flexible enough to just as successfully accommodate the needs of finer-level semantic approaches, such as the computational semantics of CL, or resource semantics in general. Switching to a novel vision in semantics may require doing the same in syntax.

This is where cirquent calculus as a nontraditional syntax comes in, breaking the stubborn resistance of CL to axiomatization attempts. While the full collection of its rules just offers an alternative axiomatization for the kind old classical logic, removing (the cirquent-calculus version of) contraction from that collection -- we call the resulting system CL5 -- yields a sound and complete system for the [formula]-fragment of CL, the very core of the logic previously appearing to be "most unaxiomatizable". Being complete, CL5 is thus strictly stronger than the incomplete affine logic. The latter, by merely deleting the offending rule of contraction without otherwise trying to first appropriately re(de)fine ordinary sequent calculus, has thrown out the baby with the bath water. Among the innocent victims expelled together with contraction is Blass's [\cite=Bla92]

[formula]

provable in CL5 but not in affine logic, which, in fact, even fails to prove the less general formula

[formula]

To strengthen the implied claim of computability logic that it is CL5 rather than affine logic that adequately materializes the resource philosophy traditionally associated with the latter, the present paper further introduces an abstract resource semantics and shows that CL5 is sound and complete with respect to that semantics as well. Unlike the semantics of computability logic, which understands resources in the special -- computational -- sense, abstract resource semantics can be seen as a direct formalization of the more general intuitions in the style "having $1 does not imply having $1 and $1" or "one cannot get both a candy and an apple for a dollar even if one dollar can buy either". As noted earlier, the inherent incompleteness of linear logic, resulting from the fundamental limitations of the underlying sequent-calculus approach, is the reason why such intuitions and examples, while so heavily relied on in the popular linear-logic literature, have never really found a good explication in the form of a mathematically well-defined semantics.

The set of theorems of CL5 admits an alternative, simple yet non-deductive characterization, according to which this is the set of all binary tautologies and their substitutional instances. Here binary tautologies mean tautologies of classical propositional logic in which no propositional letter occurs more than twice. The class of such formulas has naturally emerged in the past in several unrelated contexts. The earliest relevant piece of literature of which the author is aware is [\cite=Jas63], dating back to 1963, where Jakowski studied binary tautologies as the solution to the problem of characterizing the provable formulas of a certain deductive system. Andreas Blass came across the same class of formulas twice. In [\cite=Bla92] he introduced a game semantics for linear-logic connectives and found that the multiplicative fragment of the corresponding logic was exactly the class of the substitutional instances of binary tautologies. In the same paper he argued that this class was inherently unaxiomatizable -- using his words, "entirely foreign to proof theory". Such an assessment was both right and wrong, depending on whether proof theory is understood in the strictly traditional (sequent calculus) or a more generous (cirquent calculus) sense. 11 years later, in [\cite=Bla03], using Herbrand's Theorem, Blass introduced the concept of universal simple Herbrand validity, a natural sort of resource consciousness that makes sense in classical logic. Blass found in [\cite=Bla03] that this (non-game) semantics validates exactly the same class of propositional formulas as his unrelated game semantics for the multiplicative fragment of the language of linear logic does. While independently experimenting with various semantical approaches prior to the invention of computability logic, the author of the present paper, too, had found game-semantical soundness and completeness of the class of binary tautologies and their substitutional instances. Once this happened in [\cite=Jap97] and then, again, in [\cite=Jap00] [\cite=Jap02]. The underlying semantics in those two cases were rather different from each other, as well as different from that of CL or Blass's game semantics. The fact that the set of the theorems of CL5 arises in different approaches by different authors with various motivations and traditions, serves as additional empirical evidence for the naturalness of CL5. This is somewhat in the same sense as the existence of various models of computation that eventually yield the same class of computable functions speaks in favor of the Church-Turing Thesis.

The version of cirquent calculus presented in this paper captures the most basic yet only a modest fraction of the otherwise very expressive language of computability logic. For instance, the formalism of the earlier-mentioned system CL4, in addition to [formula] called parallel connectives, has the connectives [formula] ( choice connectives, resembling the additives of linear logic), and the two groups , ( choice) and , ( blind) of quantifiers. Among the other operators officially introduced within the framework of CL so far are the parallel ("multiplicative") quantifiers ,, and the two groups , ( branching) and , ( parallel) of recurrence ("exponential") operators. Extending the cirquent-calculus approach so as to accommodate incrementally expressive fragments of CL is a task for the future. The results of the present paper could be seen just as first steps on that long road. What is important is that the syntactic ice cover of computability logic, previously having seemed to be unbreakable, is now cracked.

It should be noted that, even though computability logic has been at the center of discussion almost throughout this introductory section, essentially its relevance to the present paper is limited to being the primary source of motivation and inspiration. Cirquent calculus (the very idea of it), abstract resource semantics and all related technical results presented in this paper are new and, as the author wishes to hope, valuable in their own rights. There is no overlap with any prior work on CL, and familiarity with the latter, while desirable, is not at all necessary for understanding the present material.

Cirquents

Throughout the rest of this paper, unless otherwise specified, by a formula we mean one of the language of classical propositional logic. We consider the version of this language that has infinitely many non-logical atoms (also called propositional letters), for which we use the metavariables P,Q,R,S, and no logical atoms such as [formula] or [formula]. The propositional connectives are limited to the unary [formula] and the binary [formula]. If we write F  →  G, it is to be understood as an abbreviation of [formula]. Furthermore, we officially allow [formula] to be applied only to atoms. [formula] is to be understood as F, [formula] as [formula], and [formula] as [formula].

Where k is a natural number, by a k-ary pool we mean a sequence [formula] of formulas. Such a sequence may have repetitions, and we refer to a particular occurrence of a formula in a pool as an oformula, with the prefix "o" derived from "occurrence". This prefix will as well be used with a similar meaning in other words and contexts where same objects -- such as, say, atoms or subformulas -- may have several occurrences. Thus, the pool 〈F,G,F〉 has two formulas but three oformulas; and the formula [formula] has one atom but three oatoms. For readability, we usually refer to oformulas (or oatoms, etc.) by the name of the corresponding formula (atom, etc.), as in the phrase "the oformula F", assuming that it is clear from the context which of the possibly many occurrences of F we have in mind.

A k-ary cirquentstructure, or simply structure, is a finite sequence [formula] [formula] (m  ≥  0), where each Γi, called a group of [formula], is a subset of [formula]. As in pools, here we may have Γi  =  Γj for some [formula]. Again, to differentiate between a particular occurrence of a group in the structure from the group as such, we use the term ogroup. The structure [formula] thus has three groups but four ogroups. Yet, as in the case of oformulas or oatoms, we may just say "the ogroup {1,2}" if it is clear which of the two occurrences of the group {1,2} is meant.

A k-ary (k  ≥  0) cirquent is a pair C = (C,C), where C, called the structure of C, is a k-ary cirquentstructure, and C, called the pool of C, is a k-ary pool.

An (o)group of such a C will mean an (o)group of C, and an (o)formula of C mean an (o)formula of C. Also, we often prefer to think of the groups of C as sets of its oformulas rather than sets of the corresponding ordinal numbers. For example, if C  =  〈F,G,H〉 and Γ  =  {1,3}, we can understand the same Γ as the set {F,H} of oformulas. In this case we say that Γ contains F and H. When Γ is seen as an ogroup rather than a group, we may also refer to such a set {F,H} as the content of Γ.

An 1-ary cirquent whose only ogroup is {1} is said to be a singleton.

We represent cirquents using diagrams, such as the one shown below:

This diagram represents the cirquent whose pool is 〈F,G,H,F〉 and whose structure is 〈{1},{2,3},{3,4}〉. We typically do not terminologically distinguish between cirquents and diagrams: for us, a diagram is (rather than represents) a cirquent, and a cirquent is a diagram. The top level of a diagram thus lists the oformulas of the cirquent, and the bottom level lists its ogroups, with each ogroup represented by (and identified with) a [formula], where the arcs (lines connecting the [formula] with oformulas) are pointing to the oformulas that a given ogroup contains. The horizontal line at the top of the diagram is just to indicate that this is one cirquent rather than, say, two cirquents (one 1-ary and one 3-ary) put together. Our convention is that such a line should be present even if there is no potential ambiguity. It is required to be long enough -- and OK if longer than necessary -- to cover all of the oformulas and ogroups of the cirquent.

The term "cirquent" is a hybrid of "circuit" and "sequent". So is, in a sense, its meaning. Cirquents can be seen to generalize sequents by imposing circuit-style structures on their oformulas. In a preliminary attempt to see some familiar meaning in cirquents, it might be helpful to think of them as Boolean circuits of depth 2, with oformulas serving as inputs, all first-level gates -- representing ogroups -- being [formula]-gates, and the only second-level gate, connected to each first-level gate, being an [formula]-gate. This is illustrated in Figure 1:

In traditional logic, circuits are interesting only in the context of representational complexity, and otherwise they do not offer any additional expressive power, for duplicating or merging identical nodes creates no difference when Boolean functions are all one sees in circuits. So, from the classical perspective, the circuit of Figure 1 is equivalent to either circuit of Figure 2, with the tree-like circuit on the right being a direct reading of the formula [formula] expressing the Boolean function of the circuit of Figure 1, and the circuit on the left being a most economical representation of the same Boolean function:

Linear logic, understanding the nodes of the circuit as representing resources rather than just Boolean values, would not agree with such an equivalence though: the first and the fourth upper-level nodes of the circuit of Figure 1, even though having the same type, would be seen as two different individual resources. What linear logic generally fails to account for, however, is the possibility of resource sharing. H is a resource shared by two different compound resources -- the resources represented by #2 and #3 [formula]-gates of Figure 1. Allowing shared resources in cirquent calculus refines the otherwise crude approach of linear logic. And by no means does it mean departing from the idea that resources should be accurately book-kept. Indeed, a shared resource does not mean a duplicated resource. Imagine Victor has $10,000 on his bank account. One day he decides to give his wife access to the account. From now on the $10,000 is shared. Two persons can use it, either at once, or portion by portion. Yet, this does not turn the $10,000 into $20,000, as the aggregate possible usage remains limited to $10,000.

Core cirquent calculus rules

Different cirquent calculus systems will differ in what logical operators and atoms their underlying formal languages include, and what rules of inference they allow. The underlying language is fixed in this paper (it will only be slightly extended in the last paragraph of Section [\ref=slast]). And all of the rules will come from the ones introduced in the present section. We explain those rules in a relaxed fashion, in terms of inserting arcs, swapping oformulas, etc. Such explanations are rather clear, and translating them into rigorous formulations in the style and terms of Definition [\ref=first], while possible, is hardly necessary.

We need to agree on some additional terminology first. Adjacent oformulas of a given cirquent are two oformulas F and G with G appearing next to (to the right of) F in the pool of the cirquent. We say that F immediately precedes G, and that G immediately follows F. Similarly for adjacent ogroups.

By merging two adjacent ogroups Γ and Δ in a given cirquent C we mean replacing in C the two ogroups Γ and Δ by the one ogroup [formula], leaving the rest of the cirquent unchanged. The resulting cirquent will thus only differ from C in that it will have one [formula] where C had the two adjacent [formula]s, with the arcs of this new [formula] pointing exactly to the oformulas to which the arcs of one or both of the old [formula]s were pointing. For example, the right cirquent of the following figure is the result of merging ogroups #2 and #3 in the left cirquent:

Merging two adjacent oformulas F and G into H means replacing those two oformulas by the one oformula H, and redirecting to it all arcs that were pointing to F or G. For example, the right cirquent of the following figure is the result of merging, in the left cirquent, (the first) F and G into H:

Now we are ready to look at the rules.

Axioms (A)

Axioms are "rules" with no premises. There are two axioms, called the empty cirquent axiom and the identity axiom. The first one introduces the empty cirquent (〈〉,〈〉) (both the pool and the structure are empty); the second one which -- just like the rest of the rules -- is, in fact, a scheme of rules because F can be an arbitrary formula, introduces the cirquent [formula].

The letter "A" next to the horizontal line stands for the name of the rule by which the conclusion is obtained. We will follow the same notational practice for the other rules.

Mix (M)

This rule takes two premises. The conclusion is obtained by simply putting one premise next to the other, thus creating one cirquent out of the two, as illustrated below:

Exchange (E)

This and all of the remaining rules take a single premise. The exchange rule comes in two flavors: oformula exchange and ogroup exchange. The conclusion of oformula (resp. ogroup) exchange is the result of swapping in the premise two adjacent oformulas (resp. ogroups) and correspondingly redirecting all arcs. The following oformula exchange example swaps F with G; and the ogroup exchange example swaps ogroup #2 with ogroup #3:

The presence of oformula exchange essentially allows us to treat the pool of a cirquent as a multiset rather than a sequence of formulas. Similarly, the presence of ogroup exchange makes it possible to see the structure of a cirquent as a multiset rather than a sequence of groups.

Weakening (W)

This rule, too, comes in two flavors: ogroup weakening and pool weakening. In the first case the conclusion is the result of inserting a new arc between an existing ogroup and an existing oformula of the premise. In the second case, the conclusion is the result of inserting a new oformula anywhere in the pool of the premise.

Duplication (D)

This rule comes in two versions as well: downward duplication and upward duplication. The conclusion (resp. premise) of downward (resp. upward) duplication is the result of replacing in the premise (resp. conclusion) some ogroup Γ by two adjacent ogroups that, as groups, are identical with Γ.

Note that the presence of duplication together with ogroup exchange further allows us to think of the structure of a cirquent as a set rather than a sequence or multiset of groups.

Contraction (C)

The premise of this rule is a cirquent with two adjacent oformulas F,F that are identical as formulas. The conclusion is obtained from the premise by merging those two oformulas into F. The following two examples illustrate applications of contraction.

[formula]-introduction ( [formula])

The conclusion of this rule is obtained by merging in the premise some two adjacent oformulas F and G into [formula]. We say that this application of the rule introduces [formula]. Below are three illustrations:

In what we call conservative [formula]-introduction (the rightmost example), which is a special case of [formula]-introduction, the situation is that whenever an ogroup of the conclusion contains the introduced [formula], the corresponding ogroup of the premise contains both F and G. In a general case (the first two examples), this is not necessary. What is always necessary, however, is that if an ogroup of the conclusion contains the introduced [formula], then the corresponding ogroup of the premise should contain at least one of the oformulas F,G.

We have just used and will continue to use the jargon "the corresponding ogroup", whose meaning should be clear: the present rule does not change the number or order of ogroups, and it only modifies the contents of some of those ogroups. So, to ogroup #i of the conclusion corresponds ogroup #i of the premise, and vice versa. The same applies to the rules of oformula exchange, weakening and contraction. In an application of ogroup exchange that swaps ogroups #i and #i + 1, to ogroup #i of the premise corresponds ogroup #i + 1 of the conclusion, and vice versa; to ogroup #i + 1 of the premise corresponds ogroup #i of the conclusion, and vice versa; and to any other ogroup #j of the premise corresponds ogroup #j of the conclusion and vice versa. Finally, in an application of mix, to ogroup #i of the first premise corresponds ogroup #i of the conclusion, and vice versa; and, where n is the number of the ogroups of the first premise, to ogroup #i of the second premise corresponds ogroup #n + i of the conclusion, and vice versa.

[formula]-introduction ([formula])

The premise of this rule is a cirquent with adjacent oformulas F and G, such that the following two conditions are satisfied:

No ogroup contains both F and G.

Every ogroup containing F is immediately followed by an ogroup containing G, and every ogroup containing G is immediately preceeded by an ogroup containing F.

The conclusion is obtained from the premise by merging each ogroup containing F with the immediately following ogroup (containing G) and then, in the resulting cirquent, merging F and G into [formula]. In this case we say that the the rule introduces [formula].

Below are three examples for the simple case when there is only one ogroup in the conclusion that contains the introduced [formula]:

Perhaps this rule is easier to comprehend in the bottom-up (from conclusion to premise) view. To obtain a premise from the conclusion (where [formula] is the introduced conjunction), we "split" every ogroup Γ containing [formula] into two adjacent ogroups ΓF and ΓG, where ΓF contains F (but not G), and ΓG contains G (but not F); all other ([formula]) oformulas of Γ -- and only such oformulas -- should be included in either ΓF, or ΓG, or both. In what we call conservative [formula]-introduction, all of the non-[formula] oformulas of Γ should be included in both ΓF and ΓG.

The following is an example of an application of the [formula]-introduction rule in a little bit more complex case where the conclusion has two ogroups containing the introduced conjunction. It is not a conservative one. To make this application conservative, we should add two more arcs to the premise: one connecting ogroup #3 with J, and one connecting ogroup #4 with E.

Cirquent calculus systems

By a cirquent calculus system in the present context we mean any subset of the set of the eight rules of the previous section. The one that has the full collection of all eight rules we denote by CCC ("Classical Cirquent Calculus"), and the one that has all rules but contraction we denote by CL5. Any other system we denote by placing the abbreviated names of the corresponding rules between parentheses. For instance, (AME) stands for the system that has the axioms, mix and exchange.

Let S be a cirquent calculus system, and [formula] (possibly n = 0) any cirquents. A derivation of C from [formula] in S is a tree of cirquents with C at its root, where each node is a cirquent that either follows from its children by one of the rules of S, or is among [formula] (and has no children). A derivation of C in S from the empty set of cirquents is said to be a proof of C in S. Of course, if S does not contain axioms, then there will be no proofs in it.

Throughout this paper we identify each formula F with the singleton cirquent (〈{1}〉,〈F〉), i.e. the cirquent

Correspondingly, a proof or derivation of a given formula F in a given system S is a proof or derivation of (〈{1}〉,〈F〉). The following is an example of a proof of [formula] in (AMEC[formula]):

It is our convention that if a proof is a proof of a formula F, then the last cirquent we simply represent as "F" rather than through a diagram. Just to save space. In a similar space-saving spirit, we will often combine several obvious steps together, labeling the combined application of a "rule" by the name of the system which contains all of the rules that have been combined. For instance, the above derivation of [formula] we might want to rewrite in a more compact yet clear way as follows:

Below is an (AME[formula])-proof of Blass's principle mentioned in Section [\ref=intr]:

Classical and affine logics

In sequent calculus (where a sequent means a nonempty sequence of formulas), classical logic can be axiomatized by the following six rules, where F,G stand for any formulas and Γ,Δ stand for any -- possibly empty -- sequences of formulas:

Affine logic is obtained from classical logic by deleting contraction. As noted earlier, the term "affine logic" in this paper refers to what is called the multiplicative fragment of this otherwise more expressive logic. A sequent calculus system, in general, is any subset of the above six rules. The definition of provability of a sequent Γ in a sequent calculus system S is standard: this means existence of a tree of sequents -- called a proof tree for Γ -- with Γ at its root, in which every node of the tree follows from its children (where the set of children may be empty in the case of axiom) by one of the rules of S. A formula F is considered provable in a sequent calculus system iff F, viewed as a one-element sequent, is provable.

At the end of Section [\ref=sccs] we saw that cirquent calculus needs neither weakening nor contraction (nor duplication) to prove Blass's principle. Replacing all atoms by P in our proof tree for Blass's principle also yields an (AME[formula])-proof of

[formula]

The following Fact [\ref=f1] establishes that, in contrast, sequent calculus needs both weakening and contraction to prove ([\ref=bp]), let alone the more general Blass's principle.

Any proof of ([\ref=bp]) in sequent calculus would have to use both weakening and contraction.

First, let us attempt to construct, in a bottom-up fashion, a proof of ([\ref=bp]) in affine logic to see that such a proof does not exist. The only rule that can yield ([\ref=bp]) is [formula]-introduction, so the premise should be the sequent

[formula]

Weakening is not applicable to the above sequent, for both of its formulas are non-valid in the classical sense and hence, in view of the known fact that all of the sequent calculus rules preserve classical validity, those formulas, in isolation, are not provable. [formula]-introduction is not applicable, either, for there is no disjunction on the surface of the sequent. And exchange, of course, would not take us closer to our goal of finding a proof. This leaves us with [formula]-introduction. The sequent is symmetric, so we may assume that the introduced conjunction is, say, the first one. The non-active formula [formula] of the conclusion can then only be inherited by one of the premises, meaning that the other premise will be just [formula]. Now we are stuck with that premise, as it is a non-tautological formula which cannot be proven.

Next, for a contradiction, assume that there is a weakening-free (but not necessarily contraction-free) sequent calculus proof of ([\ref=bp]). Consider any branch [formula] of the proof tree, where Γ1 should be [formula] for some formula F, and Γn be the sequent consisting just of ([\ref=bp]). Notice that once a given sequent Γi of the above sequence contains a formula G, G will be inherited by each of the subsequent sequents [formula] -- either as a formula of the sequent, or as a subformula of such. So, both F and [formula] should be subformulas of ([\ref=bp]). This leaves us only with the possibility [formula], because ([\ref=bp]) does not contain any other subformula F together with [formula]. Let i be the greatest number among  [formula]  such that Γi + 1 is neither [formula] nor [formula]. Γi + 1 cannot be derived from Γi by exchange because then Γi + 1 would again be [formula] or [formula]. Nor can it be derived by contraction which is simply not applicable to Γi. Nor can Γi + 1 be derived by [formula]-introduction, because then Γi + 1 would be [formula] or [formula], which is not a subformula of ([\ref=bp]). Finally, Γi + 1 cannot be derived from Γi (and an arbitrary other premise) by [formula]-introduction either. This is so because an application of this rule would introduce a conjunction where [formula] or P is a conjunct; but, again, ([\ref=bp]) does not have such a subformula.

As we just saw, cirquent calculus indeed offers a substantially more flexible machinery for constructing (substructural) deductive systems than sequent calculus does. Sequent calculus can be seen as a simple special case of cirquent calculus that we call "primitive". Specifically, we say that a cirquent is primitive iff all of its ogroups are (pairwise) disjoint. The groups of such a cirquent can be thought of as -- and identified with -- sequents: in this section we will not terminologically distinguish between a group Γ of a primitive cirquent and the sequent Γ consisting exactly of the oformulas that Γ contains, arranged in the same order as they appear in the pool of the cirquent.

For any given cirquent calculus system S, we let S* denote the version of S where the definition of a proof or a derivation has the additional condition that every cirquent in the proof or derivation should be primitive. So, S* can be called the "primitive version" of S. Of course, S proves or derives everything that S* does.

Strictly speaking, a sequent or cirquent calculus system is the particular collection of its rules, so that even if two systems prove exactly the same formulas or sequents or cirquents, they should count as different systems. Yet, often we identify a sequent or cirquent calculus system with the set of formulas (or sequents, or cirquents) provable in it, as done in the following Theorem [\ref=ll]. The equalities in the left column of that theorem, as can be seen from our subsequent proof of it, extend to all other natural pairs of systems obtained by allowing/disallowing various rules, such as affine logic without weakening (i.e. linear logic in the proper sense) vs. the primitive version of CL5 without weakening, or classical logic without weakening vs. the primitive version of CCC without weakening. It is such equalities that allow us to say that sequent calculus is nothing but the primitive version of cirquent calculus. That primitiveness makes cirquent calculus degenerate to sequent calculus is no surprise. The former owes its special power to the ability to express resource sharing, and it is exactly resource sharing that primitive cirquents forbid.

With the following sequent calculus and cirquent calculus systems identified with the sets of formulas that they prove, we have:

[formula]

As noted earlier, the inclusions of the type S*  ⊆  S are trivial. The inequality CL5 [formula] Affine logic  immediately follow from Fact [\ref=f1] together with the earlier-established provability of ([\ref=bp]) in (AME[formula]). The equality CCC =   Classical logic follows from Theorem [\ref=clascomp], which will be proven in the next section. The latter implies that a formula is provable in CCC iff it is a tautology in the classical sense, and it just remains to remember that the same is known to be true for Classical logic.

Our task now is to verify the equalities   Affine logic = CL5*  and   Classical logic = CCC*.

The inclusions Affine logic ⊆   CL5*   and   Classical logic ⊆   CCC* can be proven by showing that whenever either sequent calculus system proves a sequent Γ, the corresponding primitive cirquent calculus system proves the cirquent whose only group -- as well as pool -- is Γ. This can be easily done by induction on the heights of proof trees. The steps of such induction are rather straightforward, for every application of a sequent calculus rule -- except weakening and [formula]-introduction -- directly translates into an application of the same-name rule of cirquent calculus as shown below:

As for weakening and [formula]-introduction, their sequent-calculus to cirquent-calculus translations take two steps:

The inclusions CL5* ⊆   Affine logic and CCC* ⊆   Classical logic can be verified in a rather similar way. Specifically, this can be done by showing that, whenever the primitive version of either cirquent calculus system proves a given cirquent C, the corresponding sequent calculus system proves each of the groups of C understood as sequents. Induction on the heights of proof trees is again the way to proceed. The basis of induction is straightforward, taking into account that the translation shown earlier for identity axiom works in either direction, and that the case of the empty cirquent axiom is vacuous as there are no groups in its "conclusion". Duplication does not need to be considered, for either the premise or the conclusion of it has to be non-primitive, which automatically bans this rule in primitive cirquent calculus systems. The inductive steps dealing with mix or pool weakening are trivial, because these rules do not create new groups or affect the contents of the existing groups. The same is true for ogroup exchange, as well as oformula exchange if it is external, i.e. swaps oformulas that are in different groups, as opposed to internal exchange that swaps oformulas that are in the same group. What internal oformula exchange, ogroup weakening, contraction, [formula]-introduction and [formula]-introduction do in primitive cirquents is that they modify one or two of the groups of the premise without affecting any other groups (if there are such). This local behavior allows us to pretend for our present purposes that simply there are no other groups in the cirquent under question. So, in inductive steps dealing with internal oformula exchange, contraction and [formula]-introduction, we can rely on the fact that the above-illustrated translations between the sequent- and cirquent-calculus versions of these rules work in either direction. As for ogroup weakening and [formula]-introduction, their cirquent-calculus to sequent-calculus translations work as follows:

Tautologies

By a classical model, or simply model, we mean a function M that assigns a truth value -- true (1) or false (0) -- to each atom, and extends to compound formulas in the standard classical way. The traditional concepts of truth and tautologicity naturally extend from formulas to groups and cirquents. Let M be a model, and C a cirquent. We say that a group Γ of C is true in M iff at least one of its oformulas is so. And C is true in M if every group of C is so. "False", as always, means "not true". Finally, C or a group Γ of it is a tautology iff it is true in every model. Identifying each formula F with the singleton cirquent (〈{1}〉,〈F〉), our concepts of truth and tautologicity of cirquents preserve the standard meaning of these concepts for formulas. Let us mark the evident fact that a cirquent is tautological if and only if all of its groups are so. Note also that a cirquent containing the empty group is always false, while a cirquent with no groups, such as the empty cirquent (〈〉,〈〉), is always true.

All of the rules of Section [\ref=srules] preserve truth in the top-down direction -- that is, whenever the premise(s) of an application of any given rule is (are) true in a given model, so is the conclusion. Taking no premises, (the conclusions of) axioms are thus tautologies.

A routine examination of those rules and our definition of truth for cirquents.

The rules of mix, exchange, duplication, contraction, conservative [formula]-introduction and conservative [formula]-introduction preserve truth in the bottom-up direction as well -- that is, whenever the conclusion of an application of such a rule is true in a given model, so is (are) the premise(s).

The above statement for mix, exchange, duplication and contraction is rather obvious. Let us only examine it for the conservative versions of [formula]- and [formula]-introduction.

Conservative [formula]-introduction: Assume the disjunction that the rule introduced is [formula]. Notice that the only difference between the conclusion and the premise is that wherever the conclusion has an ogroup Γ containing the oformula [formula], the premise has the ogroup [formula] instead. Since truth-semantically a group is nothing but the disjunction of its oformulas, the truth values of Γ and Γ' (in whatever model M) are the same. Hence so are those of the conclusion and the premise.

Conservative [formula]-introduction: Assume the conjunction that the rule introduced is [formula]. The only difference between the conclusion and the premise is that wherever the conclusion has an ogroup Γ containing [formula], the premise has the two ogroups [formula] and [formula] instead. Obviously this implies that if Γ is true in a given model, then so are both ΓF and ΓG. The above, in turn, implies that if the conclusion is true and hence all of its groups are true, then so are all of the groups of the premise, and hence the premise itself.

We say that an oformula F of (the pool of) a cirquent C is homeless iff no group of C contains F.

A literal means P (positive literal of type P) or [formula] (negative literal of type P) for some atom P. The term oliteral has the expected meaning: this is a particular occurrence of a literal in a formula or in (the pool or an oformula of) a cirquent. A literal cirquent is a cirquent whose pool contains only literals. An essentially literal cirquent is one every oformula of whose pool either is an oliteral or is homeless.

A cirquent is provable in CCC iff it is a tautology.

The soundness part of this theorem is an immediate corollary of Lemma [\ref=tau]. For the completeness part, consider any tautological cirquent A. In the bottom-up sense, keep applying to it conservative [formula]-introduction and conservative [formula]-introduction -- in whatever order you like -- until you hit an essentially literal cirquent B, such as the one shown in the following example:

The above procedure will indeed always hit an essentially literal cirquent because conservative [formula]-introduction is obviously always applicable when a given cirquent (conclusion) has a non-homeless oformula [formula], and so is conservative [formula]-introduction whenever such a cirquent has a non-homeless oformula [formula]. A thus follows from B in ([formula]). In view of Lemma [\ref=tau2], B is a tautology, and since all of its non-homeless oformulas are literals, the tautologicity of B obviously means that every group of it contains at least one pair of [formula] of same-type positive and negative oliterals. Fix one such pair for each group, and then apply (in the bottom-up sense) to B a series of weakenings to first delete, in each group, all arcs but the two arcs pointing to the two chosen oliterals, and next delete all homeless oformulas if any such oformulas are present. This is illustrated below:

Every group of the resulting cirquent C will thus have exactly two oformulas: some atom and its negation. B follows from C in (W), so that A follows from C in (W[formula]). Now apply (again in the bottom-up fashion) a series of contractions to C to separate all shared oliterals, as illustrated in the example below, with the resulting cirquent called D:

So, our original cirquent A is derivable from D in (WC[formula]). Every ogroup of D is disjoint from every other ogroup and, as in C, each such ogroup contains exactly two oformulas: P and [formula] for some atom P. Therefore D is provable in (AME) as illustrated below:

(In the pathological case of D having no groups at all, it is simply the empty cirquent and hence an axiom.)

We conclude that A is provable in (AMEWC[formula]) and hence in CCC.

Note that our completeness proof of Theorem [\ref=clascomp] does not appeal to duplication, which means that CCC=(AMEWC[formula]). Duplication is thus syntactic sugar for CCC. Furthermore, from the completeness proof given in the next section it can be seen that downward (though not upward) duplication does not really add anything to the deductive power of CL5, either. How sweet is the sugar of duplication? It can certainly improve proof sizes, but the possible magnitude of that improvement is unknown at this point. One claim that we are making without a proof, however, is that CL5 minus duplication has polynomial-size proofs while still remaining strictly stronger than affine logic (remember that Blass's principle is provable in such a system but not in affine logic).

Binary tautologies and their instances

Let C be a cirquent. An oatom P of C, i.e. an occurrence of an atom P in C, is an occurrence of P in an oformula of (the diagram of) C. Such an oatom is negative if it comes with a [formula]; otherwise it is positive. When C is a cirquent or formula, by an "atom of C" we mean an atom that has at least one occurrence in C.

A substitution is a function σ that sends every atom P to some formula σ(P); if such a σ(P) always (for every P) is an atom, then σ is said to be an atomic-level substitution. Function σ extends from atoms to all formulas in the expected way: [formula]; [formula]; [formula]. σ also extends to cirquents C by stipulating that σ(C) is the result of replacing in C every oformula F by σ(F).

Let A and B be cirquents. We say that B is a (substitutional) instance of A iff B = σ(A) for some substitution σ; and B is an atomic-level instance of A iff B = σ(A) for some atomic-level substitution σ. Example: the second cirquent of Figure 3 is an instance -- though not an atomic-level one -- of the first cirquent; the (relevant part of the) substitution σ used here is defined by [formula], σ(Q) = Q and σ(R) = P.

If a given cirquent calculus system proves a cirquent C, then it also proves every instance of C.

Consider a proof tree T of an arbitrary cirquent C, and an arbitrary instance C' of C. Let σ be a substitution with σ(C) = C'. Replace every oformula F of every cirquent of T by σ(F). It is not hard to see that the resulting tree T', which uses exactly the same rules as T does, is a proof of C'.

A cirquent is said to be binary iff no atom has more than two occurrences in it. A binary cirquent is said to be normal iff, whenever it has two occurrences of an atom, one occurrence is negative and the other is positive. A binary tautology (resp. normal binary tautology) is a binary (resp. normal binary) cirquent that is a tautology in the sense of the previous section. This terminology also extends to formulas understood as cirquents. The left cirquent of Figure 3 is an example of a normal binary tautology.

A cirquent is an instance of some binary tautology iff it is an atomic-level instance of some normal binary tautology.

The "if" part is trivial. For the "only if" part, assume A is an instance of a binary tautology B. Let [formula] be all of the atoms of B that have two positive or two negative occurrences in B. Let [formula] be any pairwise distinct atoms not occurring in B. Let C be the result of replacing in B one of the two occurrences of Pi by Qi, for each [formula]. Then obviously C is a normal binary cirquent, and B an instance of it. By transitivity, A (as an instance of B) is also an instance of C.

We want to see that C is a tautology. Deny this. Then there is a classical model M in which C is false. Let M' be the model such that:

M' agrees with M on all atoms that are not among [formula];

for each [formula], [formula]

By induction on complexity, it can be easily seen that, for every subformula F of a formula of C, whenever F is false in M, so is it in M'. This extends from (sub)formulas to groups of C and hence C itself. Thus C is false in M' because it is false in M. But M' does not distinguish between Pi and Qi (any 1  ≤  i  ≤  n). This clearly implies that C and B have the same truth value in M'. That is, B is false in M', which is however impossible because B is a tautology. From this contradiction we conclude that C is a (normal binary) tautology.

Let σ be a substitution such that A = σ(C). Let σ' be a substitution such that, for each atom P of C, σ'(P) is the result of replacing in σ(P) each occurrence of each atom by a new atom in such a way that: (1) no atom occurs more than once in σ'(P), and (2) whenever [formula], no atom occurs in both σ'(P) and σ'(Q). As an instance of the tautological C, σ'(C) remains a tautology (this follows from Lemma [\ref=l1] and Theorem [\ref=clascomp]). σ'(C) can also be easily seen to be a normal binary cirquent, because C is so. Finally, with a little thought, A can be seen to be an atomic-level instance of σ'(C).

The rules of mix, exchange, duplication, [formula]-introduction and [formula]-introduction preserve binarity and normal binarity in both top-down and bottom-up directions.

This is so because the above five rules in no way affect what atoms occur in a cirquent and how many times they occur.

Weakening preserves binarity and normal binarity in the bottom-up direction.

This is so because, in the bottom-up view, weakening can (delete but) never create any new occurrences of atoms.

A cirquent is provable in CL5 iff it is an instance of a binary tautology.

([formula]:) Consider an arbitrary cirquent A provable in CL5. By induction on the height of its proof tree, we want to show that A is an instance of a binary tautology.

The above is obvious when A is an axiom.

Suppose now A is derived by exchange from B. Let us just consider oformula exchange, with ogroup exchange being similar. By the induction hypothesis, B is an instance of a binary tautology B'. Let A' be the result of applying exchange to B' "at the same place" as it was applied to B when deriving A from it, as illustrated in the following example:

Obviously A will be an instance of A'. It remains to note that, by Lemmas [\ref=tau] and [\ref=mar13], A' is a binary tautology.

The rules of duplication, [formula]-introduction and [formula]-introduction can be handled in a similar way.

Next, suppose A is derived from B and C by mix. By the induction hypothesis, B and C are instances of some binary tautologies B' and C', respectively. We may assume that no atom P occurs in both B' and C', for otherwise, in one of the cirquents, rename P into something different from everything else. Let A' be the result of applying mix to B' and C'. By Lemmas [\ref=tau] and [\ref=mar13], A' is a binary tautology. And, as in the cases of the other rules, it is evident that A is an instance of A'.

Finally, suppose A is derived from B by weakening. If this is ogroup weakening, the conclusion is an instance of a binary tautology for the same reasons as in the case of exchange, duplication, [formula]-introduction or [formula]-introduction. Assume now we are dealing with pool weakening, so that A is the result of inserting a new oformula F into B. By the induction hypothesis, B is an instance of a binary tautology B'. Let P be an atom not occurring in B'. And let A' be the result of applying weakening to B' that inserts P in the same place into B' as the above application of weakening inserted F into B when deriving A. Obviously A' inherits binarity from B'; by Lemma [\ref=tau], it inherits from B' tautologicity as well. And, for the same reasons as in all previous cases, A is an instance of A'.

([formula]:) Consider an arbitrary cirquent A that is an instance of a binary tautology A'. In view of Lemma [\ref=l1], it would suffice to show that CL5 proves A'. We construct a proof of A', in the bottom-up fashion, as follows. Starting from A', we keep applying conservative [formula]-introduction and conservative [formula]-introduction until we hit an essentially literal cirquent B. As in the proof of Theorem [\ref=clascomp], such a cirquent B is guaranteed to be a tautology, and A' follows from it in ([formula]). Furthermore, in view of Lemma [\ref=mar13], B is in fact a binary tautology. Continuing as in the proof of Theorem [\ref=clascomp], we apply to B a series of weakenings and hit a tautological cirquent C with no homeless oformulas, where every group only has two oformulas: P and [formula] for some atom P. By Lemma [\ref=mar13a], C remains binary. Our target cirquent A' is thus derivable from C in (W[formula]). In the proof of Theorem [\ref=clascomp] we next applied a series of contractions to separate shared oformulas. In the present case it suffices to use downward duplication (preceeded with ogroup exchange if necessary) instead of contraction: as it is easy to see, the binarity of C implies that there are no shared oformulas in it except the cases when oformulas are shared by identical-content ogroups. Applying to C a series of ogroup exchanges and downward duplications, as illustrated below, yields a cirquent D that no longer has identical-content ogroups and hence no longer has any shared oformulas.

A' is thus derivable from D in (EWD[formula]). In turn, as in the proof of Theorem [\ref=clascomp], D is provable in (AME). So, CL5 proves A'.

Abstract resource semantics

Elaborating the abstract resource intuitions

Among the basic notions used in our presentation of abstract resource semantics is that of atomic resource. This is an undefined concept, and we can only point at some examples of what might be intuitively considered atomic resources. These can be a specified amount of money; electric power of a specified voltage and amperage; a specified task performed by a computer, such as providing Internet browsing capabilities; a specified number of bits of memory; the standard collection of tasks/duties of an employee in a given enterprise; the choice between a candy and an apple that a vending machine offers to whoever inserts a $1 bill into it; etc.

From atomic resources we will be building compound resources. Of course, whether a resource is considered atomic or thought of as a combination of some more basic resources depends on the degree of abstraction or encapsulation we choose in a given treatment. For instance, $2 can be treated as an atomic resource, but it can as well be understood as a combination of $1 and $1 -- specifically, the combination [formula], with [formula] generally being the resource having which intuitively means having both α and β. Similarly, a multiple-piece software package can be encapsulated and treated as an atomic resource, but in more subtle considerations it can be seen as a combination of the programs, data, etc. of which the package consists. And, had we extended our present approach to choice ("additive") connectives, the earlier listed atomic resource providing a choice between a candy and an apple could be deatomized and understood as the choice conjunction [formula] of Candy and Apple.

When talking about resources, we always have two parties in mind: the resource provider and the resource user. Correspondingly, every entity that we call a resource comes in two flavors, depending on who is "responsible" for providing the resource. Suppose Victor received a salary of $3,000 in the morning, and paid a $3,000 mortgage bill in the afternoon. We are talking about the same resource of $3,000, but in one case it came to Victor as an income ( input), while in the other case it was an expense ( output). In the morning Victor was the user (and his employer the provider), while in the afternoon he was the provider (and the mortgage company the user) of the resource $3,000.

Or, imagine a car dealer selling a Toyota to his customer for $20,000. Two atomic resources can be seen involved in this transaction: the Toyota and the $20,000. The $20,000 is an income/input from the dealer's perspective while an expense/output from the customer's perspective; on the other hand, the Toyota is an expense/output for the dealer while an income/input for the customer.

Or, compare the two devices: a mini power generator that produces 100 watts of electric power, and a lamp with a 100-watt light bulb. Power is an output for the generator while an input for the lamp. In turn, the generator does not produce power for free: it takes/consumes certain input such as fuel in a specified quantity. Similarly, the lamp outputs light in exchange for power input.

The power generator and the lamp are also resources, in our treatment being compound ones unlike the atomic Power, Fuel or Light. Analyzing our intuitive concept of resources, one can notice that we are willing to call a resource anything that can be used -- perhaps in combination with some other resources -- to achieve certain goals. And "achieving a goal", in turn, can be understood as nothing but obtaining/generating certain resources. $20,000 is a resource because it can be used -- in combination with the resource Car dealer -- to obtain the resource Toyota. Similarly, a generator and a lamp can help us -- in combination with the resource Fuel -- obtain Light. The component atomic resources of Generator are Fuel and Power, the former being an input as already noted, and the latter being an output. We will be using the term port as a common name for inputs and outputs. To indicate that a given port is an input, the name of the corresponding atomic resource will be prefixed with a "-  "; the absence of such a prefix will mean that the port is an output. It should be noted that "-  " is merely an indication of the input/output status of a port, and nothing more; it should not be mistaken for an operation on resources as, say, the later-defined operation [formula] is.

The sequence of all ports of a given compound resource we call its interface. Thus, the interface of the resource Generator is 〈〉, and the interface of Lamp is 〈〉. Generally, a compound resource may take any number of inputs and outputs. For example, Victor possessing both a generator and a lamp can be seen as possessing just one compound resource Generator[formula]. The interface of this compound resource is then the concatenation of the interfaces of its two components, i.e. 〈 -  Fuel, Power, -  Power, Light〉. The first and the third ports of this interface stand for the resources that are expected to be provided by the user Victor, so they are inputs and hence come with a "-  "; the second and the fourth ports, on the other hand, stand for the resources that Victor expects to receive, so they are outputs and hence come without a "-  ". As for Victor (as opposed to the provider of his resource Generator[formula]), he sees the same ports, but in negative colors: for him, the first and the third ports are outputs while the second and the fourth ports are inputs. To visualize Generator[formula] as a one resource, it may be helpful for us to imagine a generator and a lamp mounted together on one common board, with the -  Fuel port in the form of a pipe, the Power port in the form of a socket, the -   Power port in the form of a plug, and the Light port in the form of a light bulb. Multiple inputs and/or outputs are very common. A TV set takes two inputs: power and cable. And a look at the back panel of a personal computer will show a whole array of what the engineers indeed call "ports". This explains the choice of some of our terminology.

The list of all inputs and outputs is only a half of a full description of a compound resource. The other half is what we call the resource's truth function. Formally, the latter is a function that returns a truth value -- 0 or 1 -- for each assignment of truth values to the ports of the compound resource. Intuitively, the value 1 for a given resource -- whether it be atomic or compound -- means that the resource is "functioning", or "doing its job", or "keeping its promise". In such cases we will simply say that the resource is true. And the value 0, as expected, means false, i.e. not true. For instance, the value 1 for the resource Power means that power is indeed generated/supplied, and the value 0 means that there is no power supply. If Victor plugs the plug of his lamp into a (functioning, i.e. true) outlet, then the input port -  Power of the resource Lamp becomes true; otherwise the port will probably remain false. We call assignments of truth values to the ports of a given compound resource situations. In these terms, the truth function F of the compound resource tells us in which situations [formula] the resource is considered true ([formula]) and in which situations [formula] it is false ([formula]). Intuitively, such an F can be seen as a description of the job that the resource is "supposed" (or "promises") to perform. Specifically, the job/promise of the resource is to be true, i.e. ensure that no situations [formula] with [formula] will arise. Jobs are not always done and promises not always kept however. So a resource, whether elementary or compound, may or may not be true.

Going back to the resource Generator, its job is to ensure that whenever there is fuel input, there is also power output. That is, whenever the (input) -  Fuel port is true, so is the (output) Power port. In more intuitive but less precise terms, this job can be characterized as "turning fuel into power". The following two tables contain full descriptions of the two resources Generator and Lamp, each table showing both the interface and the truth function (the rightmost column) of the corresponding compound resource:

As we see from the above figure, the only situation in which Generator is false, i.e. considered to have failed to do its job, is 10 -- the situation in which fuel was supplied to the generator but the latter did not produce power. While the situation 01 is unlikely to occur with a real generator, Generator is considered true in it. For this is a situation in which the generator not only did not break its promise, but in fact did even more than promised. A customer who ended up receiving a $20,000-priced Toyota for something less than $20,000 (or for free) would hardly be upset and call the generous dealer a deal-breaker. The philosophy "it never hurts to do more than necessary" is inherent to our present approach, which is formalized in the requirement that the truth function of a resource should always be monotone, in the sense that changing 0 to 1 in an output or 1 to 0 in an input can never turn a true resource into a false one. Since Generator is true in situation 00 (no input, no output), so should it be in 01, for the generator "produced even more than expected"; an equally good reason why Generator is true in situation 01 is that it is true in 11, so that, in 01, the generator "consumed even less than expected".

We remember that the interface of the combination [formula] of resources is the concatenation of those of α and β. As for the truth function of [formula], it should account for the intuition that [formula] is considered to be doing its job iff both α and β are doing their jobs. This can be seen from the following table for the resource Generator[formula]:

The resource Generator[formula] is false in situations 1000, 1001 and 1011 because its Generator component failed to do its job: there was fuel input but no power output. The reason why Generator[formula] is false in situations 0010, 0110 and 1110 is that Lamp malfunctioned: there was power input for it but no light output. And in situation 1010 Generator[formula] is false because neither Generator nor Lamp kept the promise: there were both fuel input (for the generator) and power input (for the lamp), yet neither power output nor light output was generated.

The value of Generator[formula] in a situation xyzt only depends on the value u of Generator in situation xy and the value v of Lamp in situation zt. So, such a xyzt can be simply seen as uv, and the 〈{ -  Fuel, Power〉 and 〈{ -  Power, Light〉 parts of the interface seen as simply Generator and Lamp, respectively. That is, the two compound conjuncts of Generator[formula] can be encapsulated and treated as atomic resources, which yields the following, simpler table:

Ignoring the minor -- at least seemingly so -- technical detail that columns are required to contain an additional bit of information indicating input/output status, our tables in the above style bear resemblance with those used in classical logic. Yet there is one crucial difference, which does not show itself in Figure 6 but catches the eye in Figure 5. In our tables, the same atom -- such as Power in Figure 5 -- may occur more than once, and the rows that assign different truth values to different occurrences of the same atom are as meaningful as any other rows. This is so because the expressions " Power", " Fuel", etc., as such, stand just for resource types, while particular occurrences of such expressions in a table (or a formula, cirquent etc.) stand for individual resources of those types. That is, we (again) deal with the necessity to differentiate between ports and oports, inputs and oinputs, etc. It is possible that the generator is producing power but the lamp is not receiving any: maybe Victor was not smart enough to insert the lamp's input plug into the generator's output socket, or it was a hot and sunny noontime, and he decided to use those 100 watts to feed his fan instead of the lamp. In the particular case of Figure 5, the two Power-labeled columns happen to be of different genders: one an output and the other an input. This, however, would not always be the case, and generally a table can contain any number of columns with identical labels of either gender. For example, the non-simplified table for Generator[formula] would have two (input) columns labeled -  Fuel, and two (output) columns labeled Power. Such a 16-row table would not be at all the same as the 4-row one for the resource Generator seen in Figure 4. On the other hand, in classical logic, the truth table for any formula F would be no different from that for [formula], because for classical logic, which sees formulas as propositions or Boolean functions, F and [formula] are indistinguishable. Generator and Generator[formula], on the other hand, are certainly not the same as resources. Provided that Victor has enough fuel to feed two generators, with Generator[formula] he can produce 200 watts of electricity while with just Generator only 100 watts. It may, however, happen that Victor decides to provide input for the first generator but not for the second one, so that rows with a 1 in the first -  Fuel column and a 0 in the second -  Fuel column cannot be dismissed as meaningless or impossible. And even the fully classical-looking table of Figure 6 would no longer look classical with Generator[formula] instead of Generator[formula]. Such a table would still have 4 rows, while the classical table for [formula] (atomic P) would only have 2 rows.

The meaning of the disjunction [formula] of resources must be easy to guess. The interface of [formula] is the same as that of [formula]: just the interfaces of α and β put together. As for the truth function, it corresponds to the intuition that the resource [formula] is considered to have failed its job if and only if so did both of its components α and β. Hence, say, the table for Generator[formula] would differ from the one of Figure 5 in that the last column would have a 0 only in one -- the 1010 -- row. The job of Generator[formula] is thus to generate either power output or light output (or both) whenever both fuel and power inputs are received.

The implicative combination α  →  β of resources, in rough intuitive terms, can be characterized as the resource that "consumes α and produces β". To see this, it would suffice to point out that our old friends Generator and Lamp (Figure 4) are nothing but Fuel→   and Power→  , respectively. Another intuitive characterization of →   is to say that this is a resource reduction operation. For example, the resource Lamp = Power→   Light reduces (the task of generating) Light to (the task of generating) Power. Generally, the interface of α  →  β is the concatenation of those of α and β, only, in the α part, the input/output status of each port is reversed. That is, in the antecedent the roles of the provider and the user are interchanged: the resource provider of α  →  β acts as a provider in the β part but as a user in the α part. Indeed, Generator provides Power, but uses Fuel. This is why Fuel -- the atomic resource which, in isolation, is its own "output" -- is an input rather than an output of Generator. The promise that the resource α  →  β carries is to make β true as long as α is true. In other words, to guarantee that either β true, or α is false (or both). Imagine a car dealer who promised to his customer to sell to him a Toyota for a "to be negotiated" price. One way to keep this promise is, of course, to actually sell a Toyota. But what if the dealer has run out of cars by the time the customer arrives? A way out for the dealer is to request an unreasonable price that he believes the customer would never be able or willing to pay.

The above discussion makes it clear that α  →  β is, in fact, a disjunction. Specifically, it is [formula], where [formula], intuitively, is "the opposite of α": the interface of [formula] is that of α with all inputs turned into outputs and all outputs turned into inputs; and [formula] is true in exactly the situations in which α is false. Alternatively and equivalently, we can define [formula] as [formula]; here [formula] is the empty-interface resource that is just ("always") false, intuitively meaning a resource that no one can ever provide.

We close this subsection with a look at an intuitive example where →   takes a compound antecedent. Let us imagine that Victor has Fuel and Lamp. Could he generate light if these two resources are all of his possessions? Not really. What he needs is a generator. That is, Victor cannot (successfully) provide the resource Light, but with his Fuel, Lamp and some thought, he can provide the weaker resource Generator→   Light, i.e. ( Fuel→   Power) →   Light. Or can he? "Some thought" was not originally listed among the resources of Victor, and he might have a hard time exercising it should the example be more complex than it is. This is where CL5 can come to help. As it turns out, CL5 is exactly the logic that provides a systematic, sound and complete answer to the question on what and how Victor can generally do. Back to our present example, with perfect knowledge of CL5, Victor has a guarantee of success because CL5 proves

[formula]

Resources and resource operations defined formally

Before we move any further, let us summarize, as formal definitions, the explanations given in the previous subsection. First of all, we agree that what we have been calling "atomic resources" are nothing but propositional letters, i.e. atoms of the language underlying cirquent calculus. This, of course, is some abuse of concepts because, strictly speaking, the atoms of the language are variables ranging over atomic resources rather than atomic resources as such. Similar terminological liberty extends to the concepts formally defined below as "ports", (compound) "resources", etc.

A port is P or - P, where P is an atom called the type of the port. A port which is just an atom is said to be an output, and a port which is a "-  "-prefixed atom is said to be an input. The input/output status of a port is said to be the gender of that port. The two genders input, output are said to be opposite.

An interface is a finite sequence of ports. A particular occurrence of a port (input, output) in an interface will be referred to as an oport (oinput, ooutput). As we did with oformulas in the context of cirquents, we usually refer to an oport by the name of the corresponding port (as in the phrase "the oport P"), even though different oports may be identical as ports.

Let [formula] be an interface. A situation for I is a function [formula] of the type [formula]. We identify such a function [formula] with the bit string [formula], where [formula]; we can also write [formula] instead of [formula], thinking of [formula] as a function assigning truth values to oports. When [formula], we say that Xi is true in [formula], and when [formula], we say that Xi is false in [formula]. We define the relation ≤  I on situations for I by stipulating that [formula] iff, for each [formula], we have:

if Xi is an output, then [formula];

if Xi is an input, then [formula].

The relations ≥  I,  <  I and >  I have the expected meanings: [formula] iff [formula]; [formula] iff [formula] and [formula]; and [formula] iff [formula].

An abstract resource -- henceforth simply "resource" -- is a pair [formula], where:

[formula], called the interface of α, is an interface.

α, called the truth function of α, is a function that sends every situation [formula] for [formula] to 0 or 1, such that the following monotonicity condition is satisfied:

Whenever [formula], we have [formula].

When [formula] (resp. = 0), we say that α is true (resp. false) in situation [formula]. "Output of α", "oport of α", "situation for α", etc. mean "output of [formula]", "oport of [formula]", "situation for [formula]", etc.

We need to agree on some notation used in the following definition of the basic resource operations. Let I,I1,I2 be interfaces. We write - I to mean the interface that is the same as I only with the genders of all oports reversed; that is, - I is obtained from I by deleting the prefix "-  " wherever it was present and, simultaneously, adding such a prefix wherever it was absent. Next, I1I2 will stand for the concatenation of I1 and I2, i.e. the result of appending the oports of I2 to those of I1. Note that every situation (understood as a bit string) for I1I2 will have the form [formula] (the concatenation of strings [formula] and [formula]), where [formula] is a situation for I1 and [formula] is a situation for I2. The empty interface will be denoted by 〈〉. There is only one possible situation for it, and we denote that situation by ε. With situations understood as bit strings, [formula] is thus the empty bit string.

Let α, α1, α2 be resources. The operations [formula], [formula], [formula], →  , [formula], [formula] are defined as follows:

1. Negation [formula]:

[formula];

For any situation [formula] for [formula], [formula] iff [formula].

2. Conjunction [formula]:

[formula];

For any situation [formula] for [formula], where [formula] is a situation for α1 and [formula] is a situation for α2, we have [formula] iff [formula] and [formula].

3. Disjunction [formula]:

[formula];

For any situation [formula] for [formula], where [formula] is a situation for α1 and [formula] is a situation for α2, we have [formula] iff [formula] or [formula].

4. Implication α1  →  α2:

[formula];

For any situation [formula] for α1  →  α2, where [formula] is a situation for α1 and [formula] is a situation for α2, we have [formula] iff [formula] or [formula].

5. Empty-interface (constant) resources [formula] and [formula]:

[formula];

[formula];  [formula].

For safety, we need to verify that the above operations (with [formula] and [formula] seen as 0-ary operations) are indeed operations on resources -- that is, that they do not violate the monotonicity condition of Definition [\ref=res]. The truth function of [formula] (and similarly for [formula]) is trivially monotone, because there is only one situation for the empty interface. Of the other operations, it would be sufficient to only consider →   for, in view of Theorem [\ref=interdef], just as this is the case in classical logic, [formula], [formula] and [formula] are definable in terms of →   and [formula].

Consider any two situations [formula] for α1  →  α2 such that [formula]. Our goal is to show that if α1  →  α2 is false in [formula], then so is it in [formula]. Let [formula] be the situations for α1, and [formula] the situations for α2, such that [formula] and [formula]. Then the condition [formula] implies that   [formula] and [formula]. Assume α1  →  α2 is false in [formula]. This means that [formula] and [formula]. From [formula] and [formula] the monotonicity of α1 implies [formula]. Similarly, from [formula] and [formula] the monotonicity of α2 implies [formula]. This means that α1  →  α2 is false in [formula]. Done.

The following theorem can be verified by a routine examination of the relevant definitions, left as an exercise for the reader:

For any resources α,α1,α2, the following equalities hold:

[formula]

Formulas as resources

By a situation for a formula F we mean an assignment [formula] of truth values (0 or 1) to its oatoms. Such an [formula] will as well be understood as a situation for any osubformula G of F by mechanically restricting its domain to the oatoms of G. Note the difference between a situation and a classical model. The latter is an assignment of truth values to atoms rather than oatoms. So, say, (the relevant part of) a classical model for [formula] would only have to assign a value to P, while a situation for this formula would have to list three -- not necessarily identical -- values for the three oatoms of the formula. Classical models can be viewed as special cases of situations that assign identical truth values to oatoms that are identical as atoms. Disregarding this difference, the truth status of a formula F in a situation [formula] for F is determined in the "standard" way by recursion on (the occurrences of) its subformulas. That is:

[formula] is true in [formula] iff P is false in [formula]; here and later "false", as always, means "not true".

[formula] is true in [formula] iff so are both G and H;

[formula] is true in [formula] iff so is G or H (or both).

While the above definition looks like exactly the classical definition of truth, once again we emphasize the implicit and important difference: in the present definition, [formula], [formula], [formula] and their subformulas are particular occurrences of (sub)formulas rather than formulas as such. This makes it possible for, say, [formula] to be true, which will be the case when the first oatom P is true and the second oatom P is false.

Notice that, graphically, literals and ports are almost the same, with the difference that ports take the prefix "-  " where literals take the prefix "[formula]". Since we often convert between literals and ports, here we introduce two functions [formula] and [formula], with [formula] for literal-to-port conversion and [formula] for port-to-literal conversion. Specifically, for any atom P, we have (P) = (P) = P, [formula] and [formula].

As in the previous subsection, a situation [formula] for a formula F can and will be understood as a bit string -- specifically, a bit string of length n, where n is the number of oatoms of F. Then the same [formula] can also be considered a situation for any resource whose interface has n ports. The second clause of the following definition implicitly relies on this seeing no difference between situations for formulas and situations for resources.

With each formula F we associate the resource [formula], called the resource represented by F, defined as follows:

[formula], where [formula] is the sequence of the oliterals of F listed in the order of their appearance in F.

For every situation [formula] for [formula], [formula] iff F is true in [formula].

According to the following theorem, [formula] respects the meanings of [formula] (and, as we may guess, also of →   if the latter was officially allowed in formulas) as operations on resources. Hence, with propositional letters understood as representing atomic resources, [formula] is indeed "the resource represented by F". The theorem can be verified by a straightforward analysis of the relevant definitions, so we state it without a proof:

For any formulas F,G, we have [formula], [formula] and [formula].

While every formula corresponds to a resource, vice versa does not hold. For example, it is obvious that no formula in our present sense does represent the resource [formula] or [formula], for there are no atomless formulas. This is not a serious issue of course, for we could painlessly add [formula] and [formula] (perhaps using the symbols [formula] and [formula] instead) to our formal language, laziness being the only reason for not having done so.

The resource whose interface is 〈P,Q,R〉 and which is true when so is Q and at least one of P,R cannot be expressed by a formula, either. For example, [formula] would not fit the bill because of the wrong order of its atoms. Again, this is not a "serious" problem, for we may be willing to not distinguish between permutationally equivalent resources -- resources that, informally speaking, only differ in the order in which their interfaces list the ports.

There are, however, really serious reasons that make it impossible to capture all resources with formulas, reasons that essentially call for switching to non-traditional means of expression such as cirquents. The closure of atomic resources under [formula], [formula], [formula], →   and any other operations in a similar style does not yield the class of all resources, and this is so because, vaguely speaking, such operations do not allow us to account for the possibility of resource sharing. An analysis of the following example can make this point clear.

Let β be the resource defined by:

[formula];

[formula] iff at least two of the three bits of [formula] are 1s.

The "two out of three" Boolean function in classical logic would be expressed by the formula [formula]. [formula], however, is not β, for the former has six oports rather than three. We need yet do not have means to indicate that, say, the two occurrences of P in F stand for the same individual resource rather than two different resources of the same type. In other words, we need yet do not have means to indicate that P is shared between the two subresources [formula] and [formula]. It should not be hard for the reader to convince himself or herself that generally for no [formula]-combination F of P,Q,R do we have [formula].

Thus, while the collection [formula] enjoys what is called functional completeness in classical logic, in no reasonable sense is the expressive power of this collection complete when it comes to resource semantics. Nor is there any easy remedy such as adding some extra connectives to the language. What we need is to go substantially beyond the traditional formalisms of logic. As we are going to see in the next subsection (Theorem [\ref=may26]), the formalism of cirquent calculus turns out to be sufficient.

Cirquents as resources

Let C be a cirquent. By a situation for C we mean an assignment [formula] of truth values (0 or 1) to the oatoms of C. Understood as a bit string, such an [formula] is the concatenation of situations for the oformulas of C. Then an oformula of the cirquent is considered true or false in [formula] if it is so in the corresponding substring of [formula]. For instance, if the pool of C is 〈G,H〉 where G has 3 oatoms and H has 2 oatoms, then G is true in situation 10111 iff it is true (in the sense of the previous subsection) in 101, and H is true in 10111 iff it is true in 11. Next, we consider a group Γ of C true in a given situation [formula] for C iff at least one of the oformulas of Γ is true. Notice that, unlike oformulas, the truth values of two different ogroups that are identical as groups would always be the same. So, truth can be considered a property of groups rather than ogroups. Finally, C is true in [formula] iff all of its groups are so.

With each cirquent C we associate the resource [formula], called the resource represented by C, defined as follows:

[formula], where [formula] is the sequence of the oliterals of C listed in the order of their appearance in C.

For every situation [formula] for [formula],  [formula] iff C is true in [formula].

For every resource α there is a cirquent C -- in fact a literal one -- which represents α, i.e. such that [formula].

Consider an arbitrary resource α with [formula]. We construct a corresponding cirquent C as follows. The pool of C is [formula] [formula]. In view of condition 1 of Definition [\ref=june1a], it is already clear that [formula]. We now need to define the structure of C and show that we also have [formula].

Let us call a situation [formula] for α  critical  iff α is false in [formula] and, for every situation [formula] for α with  [formula], α is true in [formula]. Let [formula] be a list of all critical situations for α. Seeing them as bit strings, these situations, of course, are also situations for C (no matter what the structure of C is). For each [formula], we define the group Γi by

[formula]

Now, we define the structure of C to be [formula]. To see that [formula], consider any situation [formula] for C (and hence for [formula] and α).

Suppose [formula], by condition 2 of Definition [\ref=june1a] meaning that C is false in [formula]. Then there is a group Γi (1  ≤  i  ≤  k) which is false in [formula], and this, in turn, means that every Lj which is false in [formula] (i.e. every oformula of Γi) is false in [formula]. In other words, [formula]. But α is false in [formula] because [formula] is critical. Hence, by the monotonicity of α, we have [formula].

Now suppose [formula]. We may assume that [formula] is critical, for otherwise replace it with a critical situation [formula] such that [formula] (by monotonicity, such an [formula] is guaranteed to exist). Since [formula] is critical, [formula] for some 1  ≤  i  ≤  k. Remembering now how the group Γi was chosen, it is clear that Γi is false in [formula], whence C is false in [formula], i.e. [formula].

Applying the construction from our proof of Theorem [\ref=may26] to the resource β of Example [\ref=may25], β is represented by the following cirquent:

Resource-semantical validity

Every logical semantics has a concept of validity, and so does our abstract resource semantics. In classical semantics valid formulas are called tautologies, and in abstract resource semantics they will be called trivialities. Trivialities and tautologies are similar in many respects. Asserting a tautology means "asserting nothing". Likewise, possessing (or providing) a triviality means "possessing (or providing) nothing". Of course, the word "nothing" has a negative flavor. But there is a positive side as well. If possessing α amounts to possessing nothing, this means that, in fact, everyone possesses α. Tautologicity is a guarantee of truth, and can be eventually used in finding true (and non-tautological) statements. Similarly, triviality is a guarantee of success in providing resources, and can be eventually used in finding what (nontrivial) resources can be generated. The formula given at the end of Subsection [\ref=s8.1] is a triviality. And it is exactly this fact that allowed us to be confident that Victor, who possesses the nontrivial resources represented by the antecedent of the formula, can successfully generate the nontrivial resource represented by the consequent.

The simplest examples of trivial resources are those of the form α  →  α. What makes such a resource trivial is that it merely returns back what it takes. Even the poorest person in the world would be able to provide the resource $3,000[formula]$3,000, i.e. pay $3,000 if he or she receives $3,000. And it would not take a power plant to support the resource Power→   Power: assuming here that the input port comes to the resource provider in the form of a socket and the output port in the form of a plug, enough to just insert the plug into the socket. A similar trick works with Power[formula] Power→   Power, providing which not only does not require any spending, but in fact can be even done with a benefit. While [formula] is a triviality, [formula] is not. Only someone having $3,000 of his or her own would be able to pay two $3,000 bills while only receiving an income of $3,000. And a duplex power adapter that seemingly turns Power into Power[formula] Power, does so only seemingly: while the voltage being accurately reproduced, the amperage in the two output (o)ports of the adapter would be inevitably lower than in its input port, as 100w cannot be converted into 200w "for free".

What makes P  →  P, i.e. [formula] valid in classical logic is that the truth table for this formula has a 1 in both of its two rows. The resource-semantical table for [formula], however, has a 0 in one -- 10 -- of its four rows. Generally, no formula in our present sense would have only 1s in its resource-semantical table. Yet Victor, acting as a provider of [formula], has a way to make sure that the falsifying situation 10 never occurs. This way is to allocate the input oport/resource - P to the output oport/resource P. If here P is Power with oport - P given in the form of a socket and oport P in the form of a plug, the physical meaning of allocation, as noted above, could be inserting the plug into the socket, which guarantees that whenever the socket has power supply, so does the plug. If P is computer memory, then allocation may literally mean allocation. If P is $3,000, then allocation probably means redirection or mutual cancellation. If P is Light, allocating probably means just letting the user utilize the light generated by himself or herself. For yet more diversity, assume P is the resource Chess whose promise is to play the game of chess white and win. Then providing the resource [formula] means to play chess on two boards and win on at least one of them; specifically, to play white on the right ("output") board, and play black on the left board, which is considered an "input" and hence the roles -- colors -- of the two players are interchanged. In this case, a way to "allocate" -   and [formula] to each other would be to mimic on one board the moves made by the adversary on the other board, and vice versa. Obviously this strategy, amounting to having the user/adversary play against himself, guarantees that whenever the game is won by white (i.e. the promise of [formula] kept) on the left board, so is it on the right board.

The concept of allocation thus allows various, rather different particular interpretations. Attempting to formalize those meanings (if so, which one?) is beyond the scope and dignity of our resource semantics which is meant to be an abstract, general-purpose formal framework. Essentially we treat allocation as a basic, undefined concept, just as we treat the concepts of atomic resources, inputs, outputs, ports, or truth (for atomic resources). Our semantics only focuses on the conditions that all intended interpretations of its basic concepts would satisfy. There are three such conditions pertaining to allocation:

Notice the egalitarian view of the genders implied by our phrases such as "allocating to each other": if oinput X is allocated to ooutput Y, we also say that ooutput Y is allocated to oinput X. This is in concordance with the fact that the intuitive distinction between input and output is often blurred and, when modeling real-life situations, initial decisions regarding whether a certain port should be listed as an input or an output can be arbitrary. For instance, when representing a computer as a compound resource, the (resource provided by the) monitor would most likely become an output and the keyboard an input; the fates of the modem or the floppy disk drive, however, are not just as clear. And, in our earlier example with [formula], there were hardly any reasons in favor of treating the left rather than the right board as an "input". In each case, however, we still deal with two opposite -- provider's and user's -- perspectives of the same resource, clearly dictating whether any given pair of same-type oports should have the same or opposite genders, even if there is flexibility in choosing what particular genders they have. So, under any choice, the resource modeling what was originally modeled as [formula] would have two same-type and opposite-gender oports. Note, however, that if genders are reversed, so should be the meanings of the truth values and all aspects of the provider/user perspectives of the corresponding atomic resources. For example, in the case of Chess, such a reversal would mean considering Chess (or whatever new name we use for it) true when black rather than white wins the game, with the role of the provider of this resource now being that of the black rather than the white player. This interchangeability and symmetry between input and output explains why many-inputs-to-one-output allocations would generally be just as inadmissible or impossible as many-outputs-to-one-input allocations. The fact that to-be-allocated resources more often than not would involve elements of both "income" and "expense" (encapsulated Generator being a simplest example), with some thought, can also be seen to speak against the admissibility of any dual standards for inputs and outputs when it comes to allocations.

Back to the topic of validity, triviality of a resource is understood as a possibility to establish allocations that rule out all situations in which the resource is false. Assuming that making allocations only requires intellect and no other, "external" resources, and that Victor does possess intellect, the triviality of a resource indeed means a guarantee that Victor can always successfully provide the resource. The following formal definition summarizes these intuitions:

Let α be a resource.

1. An allocation for α is a pair (X,Y), where X is an oinput of α, and Y is an ooutput of α of the same type as X. We say that the allocation (X,Y) utilizes X and Y.

2. An arrangement for α is a set of allocations for α.

3. An arrangement A for α is said to be monogamous iff no oport of α is utilized by more than one allocation of A.

4. Let [formula] be a situation for α, and A an arrangement for α. We say that [formula] is consistent with A iff, whenever (X,Y)∈A, [formula].

5. We say that an arrangement A for α is trivializing (for α) iff α is true in every situation for α consistent with A.

6. We say that resource α is trivial, or is a triviality, iff there is a monogamous trivializing arrangement for it.

7. We say that a cirquent (or formula) C is trivial, or is a triviality, iff the resource represented by such a cirquent (formula) is trivial. That is, C is trivial iff there is a monogamous trivializing arrangement for [formula].

Show that dropping the monogamicity requirement in the above definition of triviality yields the ordinary concept of tautologicity for cirquents and formulas. That is, a cirquent or formula C is a tautology in the sense of Section [\ref=stau] iff there is a (not necessarily monogamous) trivializing arrangement for [formula].

Hint: Let us say that an arrangement A for a given resource is greedy iff A contains every possible allocation for that resource. Exploit the fact that, in a sense, classical models for C are nothing but situations consistent with the greedy arrangement for [formula].

A cirquent (or formula) is trivial iff it is an instance of a binary tautology.

Formulas are special cases of cirquents, so let us limit our attention to cirquents in general. Consider an arbitrary cirquent C. For readability, here we will be identifying the literals of C with the corresponding ports of [formula], so that any arrangement for [formula] can be seen as a set of pairs [formula] of oliterals of C.

([formula]): Assume C is trivial. Let A be a monogamous trivializing arrangement for [formula]. Whenever two oatoms of C are in literals utilized by the same allocation of A, we call such oatoms coupled. We replace oatoms of C by new atoms in such a way that coupled oatoms are replaced by the same atom, and any pair of non-coupled atoms end up being replaced by different atoms. Call the resulting cirquent D. Of course, D is a normal binary cirquent and C is an (atomic-level) instance of it. What remains to show is that D is a tautology. Suppose it is not. Then there must be a classical model M in which D is false. Let [formula] be the situation for C that sends every oatom P of C to the same truth value as M sends the atom that replaced P when obtaining D from C. Clearly [formula] is consistent with A. It is also obvious that every osubformula of every oformula of C has the same truth value in [formula] as the corresponding osubformula of D in M. We conclude that C -- and hence [formula] -- is false in [formula]. This contradicts our assumption that A is trivializing for [formula].

([formula]): Assume C is an instance of a binary tautology D. In view of Lemma [\ref=may4], we may assume that D is normal and C is an atomic-level instance of it. Let A be the arrangement for [formula] that contains an allocation [formula] if and only if the oatoms of the corresponding two oliterals of D are identical as atoms ("corresponding oliterals of D" means the ones that were replaced by [formula] and P when obtaining C from D). Clearly A is monogamous. We want to verify that A is trivializing for [formula]. Suppose it is not. Then there is a situation [formula] for [formula] consistent with A such that [formula] is false in [formula]. In view of the monotonicity of [formula], we may assume that whenever two oatoms of C are coupled ("coupled" in the same sense as in the previous paragraph), [formula] assigns identical truth values to them. Let then M be a classical model such that, for any atom P of D, the truth value of P in M is the same as the truth value of the corresponding oatom(s) of C in [formula] (again, "corresponding oatom(s)" mean(s) the one(s) that replaced P when obtaining C from D). It is not hard to see that then D has the same truth value -- particularly, the value false -- in M as C has in [formula]. So, D is not a tautology, which is a contradiction.

The following theorem, establishing the soundness and completeness of CL5 with respect to our abstract resource semantics, is an immediate corollary of Theorem [\ref=th4] and Lemma [\ref=may26a]:

A cirquent (or formula) is provable in CL5 iff it is trivial.

At the end of Subsection [\ref=s8.1] we promised that CL5 would provide an ultimate answer to the question what and how Victor can achieve purely by means of smart resource management. Theorem [\ref=bbb] directly pertains only to the what part of this question: Victor can successfully provide the resource represented by a formula or cirquent C (i.e. C is trivial) iff CL5[formula]. Specifically, he can achieve his success by just setting up a monogamous trivializing arrangement for [formula] (making allocations is exactly what "resource management" means). So, the how part of the above question reduces to finding such an arrangement. From our proof of the [formula]) part of Lemma [\ref=may26a] one can see that finding a monogamous trivializing arrangement for [formula], in turn, essentially means nothing but finding a normal binary cirquent D such that C is an atomic-level instance of D. Our proof of the soundness part of Theorem [\ref=th4] implicitly provides an easy way to turn a CL5-proof of C into a CL5-proof of a binary (and, in fact, normal) tautological cirquent C' such that C is an instance of C'. C is not necessarily an atomic-level instance of such a C' though. No problem: our constructive proof of Lemma [\ref=may4] shows how to turn C' into a(nother) normal binary tautology D such that C is an atomic-level instance of D. Putting the above steps and observations together yields a polynomial-time algorithm that turns a CL5-proof of an arbitrary cirquent C into a monogamous trivializing arrangement for [formula].

Cirquent calculus and computability logic

The claim that the semantics of computability logic is a semantics of resources has been explicitly or implicitly present in every work on CL. The abstract resource semantics introduced in this paper makes the same claim. While the two semantics are far from being the same, there is no contradiction or competition here. This is so not only due to the forthcoming Theorem [\ref=june11] which, in conjunction with Theorem [\ref=bbb], implies that the two semantics validate the same principles. Abstract resource semantics, as noted, is a general-purpose framework, with its basic notions such as (atomic) resources, their truth values, or allocations being open to various specific interpretations. Computability logic offers one of such interpretations, and its semantics can be seen as a materialization of abstract resource semantics. A "resource" in CL has a very specific meaning as briefly explained in Section [\ref=intr]. It is a derived concept defined in terms of some other, more basic and subtler-level entities (specifically, games). The same can be said about the other basic semantical concepts: in CL, to what we call "successfully providing the resource" (truth value 1) corresponds winning the game; to our "allocations" correspond copy-cat subroutines in game-playing strategies; etc. While being more special, however, the semantics of computability logic still turns out to be general enough to invalidate anything that abstract resource semantics does.

The earlier-promised soundness and completeness of CL5 with respect to the semantics of computability logic can be proven purely syntactically, based on the fact of the soundness and completeness of system CL2 known from [\cite=CL2]. The propositional language of the latter is considerably more expressive than the one in which the formulas of CL5 are written. One difference is that the language of CL2 includes the choice operators [formula] and [formula]. The syntactic behavior of these operators, as noted in Section [\ref=intr], is somewhat reminiscent of that of the additive operators of linear logic, just as [formula], called parallel operators in CL, are relatives of the multiplicative operators of linear logic. Another significant difference is that the language of CL2 has two sorts of atoms: general and elementary. General atoms are the same as in the formulas of CL5, and we continue using the uppercase P,Q,R,S as metavariables for them. As for elementary atoms, they are foreign to CL5. Elementary atoms are divided into logical and non-logical. There are two logical elementary atoms [formula] and [formula], and infinitely many non-logical elementary atoms, for which we will be using the lowercase p,q,r,s as metavariables. There is also a minor difference: in the official version of CL2 given in [\cite=CL2], formulas are allowed to contain →  , and also the scope of [formula] is not limited to atomic formulas. We may safely pretend that this difference does not exist: whether it be classical, linear or computability logic, F  →  G is virtually the same as [formula] and hence can be understood just as an abbreviation. For similar reasons, it is irrelevant whether [formula] is allowed to be applied only to atoms or compound formulas as well. Another insignificant difference is that the language of CL2 officially treats [formula] and [formula] (as well as [formula] and [formula]) as variable-arity operators, as opposed to the strictly binary treatment chosen in the present paper. In view of the associativity of these operators in classical, linear and computability logics, this difference, too, can be safely ignored. So, in this presentation we assume that the official language of CL2 does not include →  , that [formula] is only allowed to be applied to atoms, and that [formula] are strictly binary.

What we have been referring to as "formulas" in the previous sections we will now call CL5-formulas, and formulas of the language of CL2 we will call CL2-formulas. CL5-formulas are thus nothing but CL2-formulas that do not contain [formula] and elementary atoms. A CL2-formula is said to be elementary iff it contains neither general atoms nor [formula],[formula]. Ignoring any differences (in their status) between the general and elementary sorts of atoms, in this section [formula]-free CL2-formulas -- including elementary formulas -- will be seen as formulas of classical propositional logic, with [formula] and [formula] having their standard meanings ("truth" and "falsity", respectively). The terms "positive occurrence" and "negative occurrence" will also be used with their standard meanings as we did before. A surface occurrence of a subformula of a CL2-formula is an occurrence which is not in the scope of [formula]. The elementarization of a CL2-formula F is the result of replacing in F every positive surface occurrence of each general atom by [formula], every negative surface occurrence of each general atom by [formula], every surface occurrence of each [formula]-subformula by [formula], and every surface occurrence of each [formula]-subformula by [formula]. A CL2-formula is said to be stable iff its elementarization is a tautology of classical logic; otherwise the formula is said to be instable. In these terms, and with P  ↦  C meaning "from premise(s) P conclude C", system CL2 is given in [\cite=CL2] by the following three rules of inference:

Axioms are not explicitly stated, but notice that the set of the premises of Rule (a) can be empty, in which case the conclusion acts as an axiom. Let us look at a couple of examples before moving any further. CL2 proves [formula], i.e. [formula]. This formula follows from [formula] by Rule (c). In turn, the stable formula [formula] is derivable from the empty set of premises by Rule (a). On the other hand, CL2 does not prove [formula], i.e. [formula]. Indeed, this formula is instable and does not contain choice operators, so the only rule by which it could be derived is (c). The premise should be [formula] or [formula] for some nonlogical elementary atom p. In either case we deal with an instable formula without choice operators and with only one occurrence of a general atom. Hence it cannot be the conclusion of any of the three rules of CL2.

A CL5-formula is provable in CL2 iff it is an instance of a binary tautology.

In this proof, as agreed a while ago, we treat both general and elementary atoms as atoms of classical propositional logic. With this minor and irrelevant difference, the terms "instance", "binary tautology" etc. have the same meanings as before.

([formula]:) Consider an arbitrary CL5-formula F provable in CL2. Fix a CL2-proof of F in the form of a sequence (rather than tree) [formula] of formulas, with F1 = F. We may assume that this sequence has no repetitions or other redundancies. We claim that, for each i with 1  ≤  i  ≤  n, the following conditions are satisfied:

Condition 4 is obvious, because it is only Rule (a) that may take no premises. That Conditions 1-3 are also satisfied can be verified by induction on i. For the basis case of i = 1, Conditions 1 and 2 are immediate because F (= F1) is its own atomic-level instance and, as a CL5-formula, it contains neither [formula] nor elementary atoms. F1 cannot be derived by Rule (b) because, by Condition 1, F1 does not contain any [formula]. Nor can it be derived by Rule (a) unless n = 1, for otherwise either F1 would have to contain a [formula] (which is not the case according to Condition 1), or the proof of F would have redundancies as F1 would not really need any premises. Thus, if 1 < n, the only possibility for F1 is to be derived from F2 by Rule (c). For the induction step, assume i < n and the above conditions are satisfied for Fi. According to Condition 3, Fi is derived by Rule (c) from Fi + 1. This obviously implies that Fi + 1 inherits Conditions 1 and 2 from Fi. And that Condition 3 also holds for Fi + 1 can be shown in the same way as we did for F1.

Condition 1 implies that F is an instance of Fn. Therefore, in order to complete our proof of the [formula] part of the lemma, it would now suffice to show that Fn is an instance of a binary tautology. As the conclusion of Rule (a) (Condition 4), Fn is stable. Let G be the elementarization of Fn. The stability of Fn means that G is a tautology. Let H be the result of replacing in G every occurrence of [formula] and [formula] by an elementary nonlogical atom not occurring in G, in such a way that different occurrences of [formula] are replaced by different atoms. In view of Condition 2 (applied to Fn), it is obvious that H is binary. By the same condition, Fn did not contain [formula]. This means that every occurrence of [formula] in G comes from replacing a negative occurrence of a general atom in Fn, and every occurrence of [formula] in G comes from replacing a positive occurrence of a general atom in Fn. It is not hard to see that, for this reason, Fn is an instance of H. What remains to show is that H is a tautology. But this is indeed so because H results from the tautological G by replacing positive occurrences of [formula] and negative occurrences of [formula]. It is known from classical logic that such replacements do not destroy truth and hence tautologicity of formulas.

([formula]:) Assume F is a CL5-formula which is an instance of a binary tautology T. In view of Lemma [\ref=may4], we may assume that T is normal and F is an atomic-level instance of it. For simplicity, we may also assume that all atoms of T are elementary (elementary and non-logical, that is). Let us call the atoms that only have one occurrence in T single, and the atoms that have two occurrences married. Let σ be the substitution with σ(T) = F. Let G be the formula resulting from T by substituting each single atom q by σ(q). It is clear that then F can be derived from G by a series of applications of Rule (c), with each such application replacing two -- a positive and a negative -- occurrences of some married atom p by σ(p). So, in order to show that CL2 proves F, it would suffice to verify that G is stable and hence it can be derived from the empty set of premises by Rule (a). But G is indeed stable. To see this, consider the elementarization G' of G. It results from T by replacing its single atoms by [formula] (if negative) or [formula] (if positive). It is known from classical logic that replacing a single atom by whatever formula does not destroy tautologicity of formulas. Hence, as T is a tautology, so is G', meaning that G is stable.

A formula is provable in CL5 iff it is valid in computability logic.

This theorem is an immediate corollary of Lemma [\ref=june9], Theorem [\ref=th4] and the known fact (proven in [\cite=CL2]) that CL2 is sound and complete with respect to the semantics of computability logic.

Theorems [\ref=bbb] and [\ref=june11] are similar in that both establish a soundness and completeness of CL5. A difference that may catch the eye is that Theorem [\ref=bbb] talks about all cirquents while the statement of Theorem [\ref=june11] is restricted only to formulas. This is so because cirquents first emerged in the present paper, and hence the semantics of CL elaborated earlier did not extend to them. Here we briefly outline how to fill this gap. This explanation is very informal, and is only meant for readers already familiar with the semantics of CL. Every n-ary cirquentstructure (see Section [\ref=mul]) can be seen as an n-ary operation on games, and every cirquent C with that structure then seen as the result of applying that operation to the games [formula] represented by the oformulas of the pool of the cirquent. Specifically, C is a game playing which means playing the n games in parallel, i.e. it is a game on n boards, where A1 is played on board #1, A2 is played on board #2, etc. The machine (player [formula]) is considered the winner iff, for each group Γ of the cirquent, it wins at least one of the games (represented by the oformulas) of the group. This is the whole story. As we see, cirquents can be understood as parallel combinations of games in the same style as [formula]-combinations. Not every combination represented by cirquents can be expressed using the ordinary (such as [formula]) operators of CL. Among such combinations is the one expressed by the cirquent of Example [\ref=23]. We claim without a proof that, with the just-outlined extended semantics of CL, Theorem [\ref=june11] generalizes to all cirquents.

We further claim that Theorem [\ref=june11] can be strengthened by replacing CL5 with the more expressive cirquent calculus system CL6. What makes the language of CL6 stronger than that of CL5 is that, along with general atoms, CL6-formulas may also contain elementary atoms including the logical atoms [formula] and [formula], with [formula] now always written as [formula] and [formula] as [formula]. In accordance with the earlier-established meaning of the term "elementary", we call a CL6-formula elementary iff it does not contain general atoms. With "formulas" now meaning any CL6-formulas, the set of the rules of CL6 is obtained from that of CL5 by adding to it [formula] (understood as a singleton cirquent) as an additional axiom, plus the rule of contraction limited only to elementary formulas (that is, the contracted formula F is required to be elementary). One could show that Theorem [\ref=june11] remains true with CL6 instead of CL5. So does it with "formula" further replaced by "cirquent", where computability-logic validity of cirquents is understood in the sense of the previous paragraph.

What is next?

The results of the previous section can be seen as first steps within the program of developing cirquent-calculus deductive systems for ever more expressive fragments of computability logic. Probably the same applies to our present version of abstract resource semantics. Linear-logic literature abounds with examples illustrating the intended resource intuitions for additive and exponential operators. Yet, just as in the case of multiplicatives, such intuitions have never found a good formal explication, the reason for which, again, being the inherent incompleteness of linear logic. If and when abstract resource semantics is successfully and naturally extended to additive- and exponential-style operators, one should probably expect it to validate the same class of formulas as computability logic does, thus yielding a logic properly stronger than linear (affine) logic in its full language.

It would also be interesting to see if abstract resource semantics can be modified so as to make a meaningful semantics for relevance logic, specifically, for the obviously relevance-logic-style system which results from CCC by deleting weakening (but not contraction) and perhaps duplication as well.

Back to proof theory, besides adopting more expressive underlying languages for formulas, a promising direction for cirquent calculus to grow might be relaxing its concept of a cirquentstructure. As illustrated in Section [\ref=mul], cirquentstructures in the sense of the present paper are special sorts of circuits -- ones of depth 2, with all level-1 gates being [formula]-gates and the single level-2 gate being an [formula]-gate. Allowing circuits of arbitrary depths and forms (including circuits with non-traditional types of gates) as underlying cirquentstructures would yield more general concepts of cirquents. It is appropriate to still use the same term "cirquent" in these cases. After all, the gist of the cirquent calculus approach is its ability to syntactically capture resource-sharing, and resource-sharing is exactly what circuits are all about.

As long as obtaining soundness and completeness is the only goal, the semantics of computability logic -- of its [formula]-fragment for sure -- does not call for generalizations in the above style, just as classical logic needs nothing beyond ordinary sequent calculus. But even if, in some good sense, the present form of cirquent calculus is natural and sufficiently powerful as a "universal syntax" (not that the author really wants to make such a claim), studying generalizations of it could be still worthwhile. Switching to the new syntactic vision known as the calculus of structures ([\cite=Gug01]) introduced by Alessio Guglielmi has proved very beneficial, among the benefits being exponential speedups of proofs, and the possibility of richer combinatorial analysis of proofs for diverse logical systems, including the old and well-axiomatized classical, linear or modal logics. Achieving or enhancing similar effects could be some of the possible motivations for tackling general forms of cirquent calculus. A central idea in the calculus of structures is what is called deep inference. It means deducing inside a formula at any depth, as opposed to the shallow inference of sequent calculus where rules only see the roots of formula trees. Notice that all three rules of CL2 modify subformulas at any ([formula])-depths, thus essentially being deep inference rules. Some time ago this observation gave rise to the hope that the calculus of structures could be a well-suited deductive framework for CL. However, efforts to axiomatize even the simplest fragments of CL in it have not been successful so far. While CL obviously does need deep inference, what is making the calculus of structures apparently insufficient is the absence of resource-sharing capabilities. Just like the rules of CL2, our cirquent calculus rules from Section [\ref=srules] can be seen as limited sorts of deep inference, specifically, inferences that always take place at depth 2 (when they modify oformulas) or 1 (when they modify ogroups). With arbitrary-depth underlying cirquentstructures, generalized cirquent calculus would naturally invite inferences at any structural levels, thus enjoying the full generality, flexibility and power offered by both deep inference and resource-sharing.

Last but maybe not least, it would be interesting to understand the impact of sharing on cut elimination, the idol worshiped by all proof-theoreticians. Of course, before attempting to even ask this question, one needs to figure out what a cut rule should exactly mean in the context of cirquent calculus.