Cryptanalysis of Key Issuing Protocols in ID-based Cryptosystems

Review of Lee et al.'s Protocol [\cite=lb]

It includes five stages namely, System Setup, System Public Key Setup, Key Issuing, Key Securing and Key Retrieving.

System Setup

The KGC specifies two cyclic groups G1,G2 of prime order q where G1 is additive and G2 is multiplicative groups. It also defines a bilinear mapping as e:G1  ×  G1  →  G2 between G1,G2 and hash functions H:{0,1}*  →  G1, h:G2  →  Z*q. Let P∈G1 be an arbitrary generator of G1. The KGC selects a master key s0∈Z*q at random and computes its pubic key P0 = s0P.

System Public Key Setup

The n KPAs establish their key pairs. KPAi chooses his master key si and computes his public key Pi = siP,[formula]. Then all KPAs cooperate sequentially and computes [formula]=siYi - 1 where [formula].

Finally, [formula] is published as system public key. This sequential process can be verified by [formula].

Key Issuing

A user with ID chooses a random secret x, computes a blinding factor X = xP and requests the KGC to issue a partial private key by sending X, ID. Then the KGC issues a blinded partial private key as follows.

Checks the identification and computes the public key of the user as QID = H(ID,KGC,KPA1,...,KPAn).

Computes a blinded partial private key as [formula].

Computes KGC's signature on [formula] as [formula].

Sends [formula] and [formula] to the user.

The user can unblind [formula] using his knowledge of x, since h(e(s0X,P0))=h(e(s0xP,P0)) = h(e(P0,P0)x).

Key Securing

The user requests KPAi(i = 1,...,n) sequentially to provide key privacy service by sending ID, X, [formula] and [formula]. Then KPAi performs following steps

Checks [formula].

Computes [formula] and [formula].

Sends [formula] and [formula] to the user.

This process is carried out up to KPAn. Finally user receives [formula].

Key Retrieving

The user retrieves his private key SID by unblinding [formula] as follows.

[formula]

The user can verify the correctness of his private key by e(SID,P) = e(QID,Y).

Cryptanalysis of Lee et al.'s Protocol

Impersonation Attack

In Key Issuing phase, user sends X = xP and ID to the KGC. Any active adversary can modify the X as X* = x*P and still it cannot be detected by KGC. Because there is no binding between the ID and X. Then KGC computes partial private key Q*0 = h(e(s0X*,P0))s0QID, and sends to the user through public channel. Adversary can eavesdrop Q*0 and request the KPAs for key privacy service. At the end Adversary can extract the private key by unblinding Q*n.

Insider Attack

In Key Securing phase, user requests KPAi to provide key privacy service by sending ID, X, [formula], [formula], where fourth parameter is a signature of KPAi - 1 on third parameter.

If KPAi - 1 wants a signature of KPAi on m, he sends ID*, X* = x*P, Q*i - 1 = rH(m) and Sigi - 1(Q*i - 1) = rsi - 1H(m) to KPAi where r∈RZ*q. Then KPAi performs the following steps

Checks e(Sigi - 1(Q*i - 1),P)  =  e(Q*i - 1,Pi - 1).

Computes Q*i = h(e(siX*,Pi))siQ*i - 1 and Sigi(Q*i) = siQ*i.

Sends Q*i and Sigi(Q*i) to the user(i.e. KPAi - 1).

Now, KPAi - 1 has Q*i = h(e(siX*,Pi))sirH(m) and he can extract the signature of KPAi on m as h(e(Pi,Pi)x*)- 1r- 1Q*i = siH(m). At the same time KPAi cannot get signature of the KPAi - 1 (i.e. si - 1H(m)), because KPAi - 1 sends his signature in blinded manner. Thus, KPAi - 1 can obtain KPAi's signature on any message of his choice.

Incompetency of KPAs

In Key Securing Phase, the user requests KPAi(i = 1,2,...,n) sequentially to provide key privacy service by sending ID, X, [formula], and [formula]. Then KPAi validates the received parameters by checking the equality [formula]=[formula].

Any active adversary can alter [formula], [formula] and replaces with the following [formula], [formula]. Then KPAi performs

Checks e(Sigi - 1(Q*i - 1),P) = e(Q*i - 1,Pi - 1)

Computes [formula] and Sigi(Q*i)  =  siQ*i

Sends Q*i, and Sigi(Q*i) to the user.

It may be noted that the user is not checking the correctness of the received parameters in intermediate stages. Therefore any modification by an Adversary during the communication between user and KPAi will be undetected till the end of Key Securing Phase. This requires the user to execute this phase again from the beginning. Further, as the KGC and KPAs are not capable of checking the validity of the received parameters, they are signing them blindly.

The attack given in Section 2.1 can also be applied to [\cite=rcms].

Review of Sui et al. [\cite=sch]

A one time password pwd can be established between the Local Registration Authority(LRA) and the user after the off-line authentication. Setup(run by KGC): It takes the security parameter k and returns params (System Parameters) and the master-key. Let G be a GDH group of prime order p. Public information is ISAKI = (G,p,H,PPKG). P is a generator of G and H:0,1*  →  G is a oneway hash function and QA = H(idA). PPKG = sP is the system public key. Key Generation: It takes inputs as params, master-key, and an arbitrary ID∈{0,1}*; and returns a private key SID. The password pwd is user's chosen password during off-line authentication and the tuple (ID,pwd) is stored in KGC's database of "pending private key".

A:selects a random number r, A  →  KGC:Q = rH(ID),T = r- 1H(pwd).

KGC: checks the validity of the request by checking whether e(Q,T) = e(H(ID),H(pwd)) holds for a certain tuple in KGC's database.

KGC: computes sQ, KGC  →  A:S = sQ

A: verifies the blinded private key by checking e(S,P) = e(Q,PPKG). If it holds, A unblinds the encrypted private key and obtains sH(ID).

The user can delete pwd after obtaining the private key. The KGC can also remove the tuple (ID,pwd) from the database after the protocol.

Cryptanalysis of Sui et al. Protocol

Stolen Verifier Attack

In Sui et al. protocol, (ID, password) is stored in KGC's database. If an Adversary steals the database he can have genuine users' secrets on requesting the KGC on behalf of any registered user available in database. Though the KGC stores (ID, password) for a short-time till the corresponding secret key is issued, it affects the protocol entirely.

Insider Attack

In practice, it is likely that a user uses same password to access several systems and other purposes for his convenience. In the registration phase, the user gives his password pwd to LRA and the LRA stores the ID and corresponding password in the database. In the extended scheme given to remove the key escrow by single KGC, the database is accessible by multiple KGC's and LRA. Any one of the insider of the system could impersonate user's login on stealing password and can get access of the other systems.

Incompetency of KGCs

A user requests for private key as follows:

Selects a random number r, and computes Q = rH(ID),T = r- 1H(password) and sends to the KGC.

KGC checks the validity of the request by checking the equality e(Q,T) = e(H(ID),H(password)).

Computes blinded private key S = sQ and sends to the user where s is the KGC's private key.

Then user verifies S by checking the equality e(S,P) = e(Q,Ppub) where Ppub = sP is KGC's public key.

Any Adversary can alter the parameters Q, T and replace with Q* = r*Q, T* = r*  - 1T and KGC verifies the equality e(Q*,T*) = e(H(ID),H(password)). Then the KGC computes S* = sQ* and sends to the user. In this protocol the KGC cannot check the validity of the parameters received and thus blindly signs on it.

Conclusion

In this work we have cryptanalyzed two ID based key issuing protocols of [\cite=lb] [\cite=sch]. We showed that the Lee et al. [\cite=lb] protocol suffers from impersonation, insider attacks and incompetency of the key privacy authorities. We also showed that the Sui et al.'s[\cite=sch] separable and anonymous key issuing protocol suffers from stolen verifier, insider attacks and incompetency of key generation centers.