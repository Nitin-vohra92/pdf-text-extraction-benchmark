=1

Local algorithms in (weakly) coloured graphs

Introduction

A 2-colouring of a graph is an assignment of the black or white colour to the nodes so that each black node is adjacent only to white nodes, and vice versa. A weak 2-colouring assigns the colours so that each non-isolated black node is adjacent to at least one white node, and vice versa.

A graph can be 2-coloured if and only if it is bipartite; a weak 2-colouring always exists. Given a global view of the graph, it is easy to find a 2-colouring of a bipartite graph and a weak 2-colouring of any graph.

In a distributed setting, it is not possible to 2-colour a bipartite graph without essentially global information of the whole graph. However, Naor and Stockmeyer [\cite=naor95what] showed in 1995 that one can find a weak 2-colouring with a constant-time synchronous distributed algorithm, assuming that the degree of each node is odd and bounded by a constant.

Constant-time distributed algorithms are known as local algorithms [\cite=naor95what] [\cite=suomela09survey] - in a local algorithm, the output of each node depends only on its local neighbourhood, and the radius of the neighbourhood does not depend on the number of nodes in the network.

Contributions

We present local approximation algorithms for both 2-coloured and weakly 2-coloured graphs. We assume that a colouring is given in the input, i.e., that every node knows its colour. We study exactly how much this additional information helps from the perspective of local approximation algorithms.

We focus on two classical problems - minimum dominating set and maximum matching. We consider bounded-degree graphs; we assume that there is a known constant Δ such that the degree of any node is at most Δ. The results are summarised in Table [\ref=tab:results]. All results are tight: there are matching upper and lower bounds.

In particular, we show that a weak 2-colouring is as good as a 2-colouring from the perspective of the local approximability of the dominating set problem. Furthermore, a weak 2-colouring provides enough symmetry-breaking information so that an approximation of a maximum matching can be found locally. Finally, with a 2-colouring, the maximum matching can be approximated to within an arbitrary constant.

We also look at a third problem, maximum independent set. There is a trivial local Δ-approximation algorithm for independent set in 2-coloured graphs: take all white nodes and all isolated black nodes. However, we show that in weakly 2-coloured graphs, the problem does not admit any local constant-factor approximation algorithm (Theorem [\ref=thm:neg-is-weak]).

Model of distributed computing

Let G  =  (V,E) be a graph identified with a distributed system. Each node v∈V is a device; there is an edge {u,v}∈E if u and v can communicate with each other. To avoid trivialities, we assume that there are no isolated nodes in G.

Each node runs the same deterministic algorithm A. Communication is synchronous: on every time step, all nodes first receive messages from their neighbours, then all nodes perform local computation, and finally all nodes send messages to their neighbours. The algorithm running in the node v∈V knows the degree of v. Furthermore, if the node v has a label (such as a colour or a unique identifier), then A has access to the label. If the edges are oriented, then A knows which edges are outgoing and which edges are incoming. Finally, every node knows the maximum node degree Δ.

The distributed algorithm A is a local algorithm if there is a constant T such that the algorithm completes in T synchronous communication rounds, regardless of the input graph G. The algorithm A and the constant T may depend on the degree bound Δ; however, the time T cannot depend on the number of nodes in G.

The results that we present are essentially oblivious to any other details of the model of distributed computing. All lower bounds (impossibility results) hold even if we use Linial's [\cite=linial92locality] model. We can assume that each node knows the total number of nodes [formula], each node is assigned a unique identifier from the set [formula], local computation is free, and the size of a message is unbounded.

Our upper bounds (algorithms) do not need to exploit any of these assumptions. The nodes do not need to know [formula]. Local computations are simple and messages are small; in particular, the size of a message does not depend on [formula]. Furthermore, the algorithms do not require unique identifiers. With the exception of Theorem [\ref=thm:pos-ds-odd], the algorithms only assume that there is a port numbering [\cite=angluin80local]: each node imposes an ordering on incident edges.

Prior work

Randomised local algorithms exist for dominating set [\cite=kuhn05constant-time] [\cite=kuhn05price] [\cite=kuhn06price], matching [\cite=wattenhofer04distributed] [\cite=hoepman06efficient] [\cite=nguyen08constant-time], and independent set [\cite=czygrinow08fast]. However, deterministic local approximation algorithms are scarce. The set of all nodes is a trivial (Δ  +  1)-approximation of a minimum dominating set, and there are local constant-factor approximation algorithms for dominating set in planar graphs [\cite=czygrinow08fast] [\cite=lenzen08what]. Some positive results are known for matchings in bounded-degree 2-coloured graphs: local algorithms exist for finding a maximal matching [\cite=hanckowiak98distributed] and a constant-factor approximation of a maximum-weight matching [\cite=floreen09almost-stable].

To present the earlier negative results on which we build our lower bounds, we need the following definition: a numbered directed n-cycle C is a directed n-cycle where each node is assigned a unique identifier from the set [formula]. Each node has one incoming and one outgoing edge.

Linial's [\cite=linial92locality] seminal work shows that there is no local algorithm for finding a maximal independent set in C. Recently, Czygrinow et al. [\cite=czygrinow08fast] and Lenzen and Wattenhofer [\cite=lenzen08leveraging] have extended this result to the approximability of the maximum independent set problem. We include here a proof of an adaptation of the inapproximability result, since the proofs of our lower bounds build directly upon it. We follow Czygrinow et al.'s [\cite=czygrinow08fast] techniques. In the proof, a k-set is a set with k elements.

For any α  ≥  1 and any local algorithm A, there exists an integer n0 such that for every n  ≥  n0 there is a numbered directed n-cycle C where A does not produce an α-approximation for maximum independent set.

Denote by T the number of synchronous communication rounds that A takes. Let m = ⌈16Tα⌉. By Ramsey's theorem [\cite=ramsey30problem], there is a finite N with the following property: Let S be a set with at least N elements, and assign an arbitrary label f(X)∈{0,1} to each (2T  +  1)-set X  ⊂  S. Then there is an m-set A  ⊂  S and a label [formula] such that [formula] for every (2T  +  1)-set X  ⊂  A. We say that A is an [formula]-coloured m-subset of S.

Let n0  =  ⌈8Nα⌉, let n  ≥  n0 and [formula]. We first assign a label f(X)∈{0,1} to each (2T  +  1)-set X  ⊂  S. Let [formula] with [formula]. Consider a fragment of a numbered directed n-cycle with the unique identifiers [formula], in this order; let f(X)∈{0,1} be the output of A for the node xT + 1, with 1 denoting that the node joins the independent set. Observe that the output only depends on the set X.

Let us next construct a numbered directed n-cycle C as follows. By the choice of n0, we can find an [formula]-coloured m-subset A1 of S for an [formula]. As [formula], we can then find an [formula]-coloured m-subset A2 of [formula] for an [formula], etc. Overall we find p = ⌈(n  -  N) / m⌉ disjoint sets [formula] such that Ai is an [formula]-coloured m-subset of S. Let [formula] with [formula] for each i. Let [formula]. Assign the unique identifiers in C in the order

[formula]

An optimal independent set of C contains at least n / 3 nodes; to prove the theorem, it suffices to show that the algorithm A outputs 1 for at most n / (4α) nodes. To see this, observe that for each i the output of the nodes [formula] is [formula]. Since they cannot all be in the independent set, we have [formula]. Hence there are at most 2Tp  +  k nodes that output 1. By construction, 2Tp  ≤  2Tn / m  ≤  n / (8α) and k  =  n  -  mp  ≤  N  ≤  n / (8α).

This immediately gives a negative result for the approximability of a maximum matching as well: given a matching M in a numbered directed n-cycle, we can construct an independent set I  =  {u:(u,v)∈M} with [formula].

There is no local constant-factor approximation algorithm for the maximum matching problem.

Lower bounds and local reductions

In this section, we present local reductions that establish lower bounds for local approximation algorithms. All reductions are from the maximum independent set problem in numbered directed cycles (Theorem [\ref=thm:neg-is-cycle]). The reductions yield the strongest possible negative results, as there is a matching positive result for each of them. As an introduction to the local reductions, we begin with a known result for general graphs; Theorem [\ref=thm:neg-ds-general] is a restatement of the negative results for planar graphs [\cite=czygrinow08fast] and unit-disk graphs [\cite=lenzen08leveraging].

For any even Δ  ≥  2 and ε  >  0, there is no local algorithm with approximation factor (Δ  +  1  -  ε) for the minimum dominating set problem.

Suppose that such an algorithm A exists for some Δ = 2k. Let α  =  Δ(Δ + 1) / ε. We will use A to find an independent set with at least n / α nodes in numbered directed n-cycles for any n divisible by Δ + 1. This is a contradiction with Theorem [\ref=thm:neg-is-cycle].

Given an n-cycle C (Figure [\ref=fig:reductions]a), we construct the 2k-regular graph G  =  Ck (Figure [\ref=fig:reductions]b illustrates the case k = 2); the node identifiers are inherited from the cycle C. We simulate the algorithm A in the graph G. There is a dominating set of G with n / (Δ + 1) nodes; hence A must output a dominating set D with at most

[formula]

nodes. Thus [formula]. The subgraph of C induced by [formula] consists of paths with at most Δ nodes each; hence there are at least

[formula]

such paths. Construct an independent set I with [formula] by taking the first node of each such path.

For any Δ  ≥  2 and ε  >  0, there is no local algorithm with approximation factor (Δ  +  1)  /  2  -  ε for dominating sets in 2-coloured graphs.

Suppose that such an algorithm A exists. Let α  =  (Δ2 - 1) / (2ε). We will use A to find an independent set with at least n / α nodes in numbered directed n-cycles for any n divisible by Δ + 1. This is a contradiction with Theorem [\ref=thm:neg-is-cycle].

Given an n-cycle C (Figure [\ref=fig:reductions]a), we construct a Δ-regular 2-coloured graph G as follows (Figure [\ref=fig:reductions]c shows the case Δ = 3). For each node v in C, there is a white node v1 and a black node v2 in G. If the directed path from u to v in C has at most Δ - 1 edges, then there is an edge {u1,v2} in G. The node identifiers are inherited from the cycle C: for example, let v1  =  2v - 1 and v2  =  2v.

We simulate the algorithm A in the graph G. There is a dominating set of G with 2n / (Δ + 1) nodes; hence A must output a dominating set D with at most

[formula]

nodes. Let B  =  {v∈V:v1∉Dv2∉D}; we have

[formula]

The subgraph of C induced by B consists of paths with at most Δ - 1 nodes each; hence there are at least

[formula]

such paths. Construct an independent set I with [formula] by taking the first node of each such path.

For any Δ  ≥  3 and ε  >  0, there is no local algorithm with approximation factor (Δ  +  1)  /  2  -  ε for maximum matching in weakly 2-coloured graphs.

Assume that such an algorithm A exists. Let

[formula]

We will use A to find an independent set with at least n / α nodes in numbered directed n-cycles for any even n. This is a contradiction with Theorem [\ref=thm:neg-is-cycle].

Given an n-cycle C  =  (VC,EC), we construct a weakly 2-coloured graph G as follows (Figure [\ref=fig:reductions]d shows the case Δ = 3). For each node v in C, there are Δ + 1 nodes in G: white nodes [formula] and a black node v0. Each black node v0 has degree Δ: it is adjacent to all white nodes [formula]. Each white node has degree 3: for each edge (u,v) in C, there are edges [formula] in G.

There is a matching with (Δ + 1)n / 2 edges in G. To see this, let X be a perfect matching in C, with [formula]. Construct a perfect matching in G as follows: for each edge (u,v) in X, choose the edges {v0,vΔ}, {u0,uΔ}, and {ui,vi} for each [formula].

We simulate the algorithm A in the graph G. The algorithm must output a matching M with at least (1  +  ε')n edges. Since there are n black nodes in G, there are at least ε'n edges in M that connect a pair of white nodes. For each [formula], let

[formula]

Now each Ii is an independent set in C and [formula].

We will now use the sets Ii to construct an independent set I in C with [formula]. At least one of the sets Ii satisfies this condition, but a local algorithm cannot find the right index i; hence we proceed as follows. We begin with [formula]. At each iteration [formula], for each node v∈Ii in parallel, we (i) add v to I, and (ii) remove the copy of v and its neighbours from [formula].

In the end, I is an independent set and each Ii is empty. Furthermore, for each node added to I there are at most 2Δ - 1 nodes that we removed from [formula]; the worst case is that I1 contains a node v and each of [formula] contains the two neighbours of v. Hence [formula].

There is no local constant-factor approximation algorithm for independent set in weakly 2-coloured graphs.

The reduction is from an n-cycle C to the 3-regular weakly 2-coloured graph G illustrated in Figure [\ref=fig:reductions]e. If we can find an independent set with at least k nodes in G, then techniques similar to those in the proof of Theorem [\ref=thm:neg-m-weak] can be used to construct an independent set with at least k / 3 nodes in C. By Theorem [\ref=thm:neg-is-cycle], we must have k  =  o(n).

Algorithms for weakly coloured graphs

In this section we give a local algorithm to find a spanning forest of stars in a weakly 2-coloured graph. Once the stars are formed, it is simple to find a dominating set (roots of the stars) and a matching (one edge for each star).

To find a small dominating set, we would prefer large (high-degree) stars, and to find a large matching, we would prefer small (low-degree) stars. Nevertheless, the same approach - find any set of stars - yields the same approximation factor (Δ  +  1) / 2 for both problems. Moreover, this is the best possible (Theorems [\ref=thm:neg-ds-strong] and [\ref=thm:neg-m-weak]).

To build the stars, we can use an algorithm that is similar to the Balanced_DOM subroutine in Kutten and Peleg [\cite=kutten98fast]. We first construct a forest F of rooted trees (Figure [\ref=fig:weak-algo]); the directed edges in F point towards the trees' roots. The construction is simple:

Each black node b chooses a white neighbour w; add the edge (b,w) to F (Figure [\ref=fig:weak-algo]b).

Each white node w which does not have any children in F chooses a black neighbour b; add the edge (w,b) to F (Figure [\ref=fig:weak-algo]c).

At this point, every node belongs to a tree; the depth of each tree is 1 or 2. Next we make local modifications within each tree, depending on its structure. Let r be the root of the tree.

If all leaves are at depth 1, do nothing.

If there are leaf nodes both at depth 1 and at depth 2, remove all edges (c,r) where c is a non-leaf child.

Otherwise, choose arbitrarily a child x of the root. Remove all edges (c,r) where c is a child of the root, and c  ≠  x. Reverse the edge (x,r).

Now F consists of stars, i.e., rooted trees of depth 1 (Figure [\ref=fig:weak-algo]d). Each node is either a root node with at least one child, or a leaf node. The algorithm can be implemented by using only a port numbering; unique node identifiers are not needed. The port numbers are used both for representing the forest F (e.g., a child does not know the identity of the parent node, but it knows the port number of the edge that leads to the parent node) and for breaking ties (e.g., when a black node has to choose one of its white neighbours).

Next we present the applications of the stars.

For any Δ  ≥  1, there is a local algorithm with approximation factor (Δ  +  1)  /  2 for dominating set in weakly 2-coloured graphs.

Let D be the set of the roots of the stars. The set D is a dominating set with at most [formula] nodes. Let D* be a minimum dominating set. Since a node cannot dominate more than Δ neighbours, [formula]. Therefore D is a (Δ  +  1)  /  2-approximation of a minimum dominating set.

For any Δ  ≥  1, there is a local algorithm with approximation factor (Δ  +  1)  /  2 for maximum matching in weakly 2-coloured graphs.

Let M be the set of edges with one edge chosen arbitrarily from each star. The set M is a matching. Each star contains at most Δ + 1 nodes; hence [formula]. For an optimal matching M*, we have [formula]. Hence M is a (Δ  +  1)  /  2-approximation of a maximum matching.

Approximating dominating set if is odd

Now we are ready to present an application of the Naor-Stockmeyer algorithm for weak 2-colouring [\cite=naor95what] and the techniques that we developed in Section [\ref=sec:weak-algo]. In this section we assume that the graph is not only port-numbered, but there is also an orientation: for each edge {u,v}∈E, exactly one direction (u,v) or (v,u) has been chosen.

The orientation can be used to break the symmetry in some cases. Specifically, if each node of G has an odd degree, then we can use Naor and Stockmeyer's algorithm to find a weak 2-colouring; the algorithm does not require unique identifiers [\cite=mayer95local]. Theorem [\ref=thm:pos-ds-weak] then provides a factor (Δ  +  1)  /  2 approximation for dominating set.

However, in this section we study the case where the degree bound Δ is odd, but nothing else is known about the degrees of the graph; that is, the case for which we have the lower bound Δ  -  ε from Theorem [\ref=thm:neg-ds-general]. A combination of weak colouring and Theorem [\ref=thm:pos-ds-weak] provides a matching upper bound.

For any odd Δ  ≥  1, there is a local algorithm with approximation factor Δ for dominating set in graphs with maximum degree Δ, assuming that there is a port numbering and an orientation.

Partition V into [formula] such that A consists of the odd-degree nodes, B consists of the even-degree nodes adjacent to at least one node in A, and C is the rest; in particular, the degree of each node in B or C is at most Δ - 1.

Consider the subgraph H induced by [formula]. In the subgraph H, the degree of each node in A is odd, but some of the nodes in B may have an even degree. Construct a new graph H2 by adding a new dummy node of degree 1 as a neighbour of each even-degree node in the subgraph H. Now every node in H2 has an odd degree, and we can use the Naor-Stockmeyer algorithm [\cite=mayer95local] to weakly 2-colour it.

At this point, each node in A is adjacent to a node of the opposite colour, but this does not necessarily hold for the nodes in B. However, we can easily find valid colours for each node in B in parallel: if b∈B and each a∈A adjacent to b has the same colour as b, then we reverse the colour of b. Now each node in B has a neighbour with the opposite colour in A; furthermore, no node in A lost a neighbour of the opposite colour.

Thus H is weakly 2-coloured, and we can apply the algorithm of Theorem [\ref=thm:pos-ds-weak] to find a dominating set [formula] with [formula] in the subgraph H. The set [formula] is now a dominating set of the original graph G.

Let D* be a minimum dominating set of V. Let [formula] and [formula]. Since a node with a degree d can dominate at most d + 1 nodes, and the nodes in D*1 are not adjacent to the nodes in C, the set D* must satisfy

[formula]

Since [formula], we have [formula].

It is necessary to assume that the graph is oriented in Theorem [\ref=thm:pos-ds-odd]. If the nodes are anonymous and there is a port numbering but no orientation, a deterministic distributed algorithm cannot have a better approximation factor than Δ + 1. To see this, consider the complete graph KΔ + 1 on Δ + 1 nodes. Find an edge colouring of KΔ + 1 with Δ colours - this is possible, since we assumed that Δ is odd. Use the edge colouring to assign the port numbers: an edge with colour k has the port number k in both ends. Now from the perspective of distributed algorithms, the nodes are indistinguishable. Any deterministic algorithm has to produce the same output for each node; in particular, it has to output a dominating set with Δ + 1 nodes, while 1 node would suffice.

Matching in two-coloured graphs

In Sections [\ref=sec:lower] and [\ref=sec:weak-algo] we proved that in weakly 2-coloured graphs the maximum matching problem can be approximated to within a factor of (Δ  +  1)  /  2, but not better. In this section we show that in 2-coloured graphs the problem has a local approximation scheme.

Given a matching M, an augmenting path (w.r.t. M) is a path that starts and ends at an unmatched node and whose every other edge belongs to M. An augmenting tree is a tree whose every root-leaf path is an augmenting path. In Figures [\ref=fig:mm-scheme]a-c, a matching, two augmenting trees (rooted at black nodes), and two augmenting paths are shown.

The symmetric difference of M and an augmenting path is a new matching whose size is larger than the size of M by 1. If every augmenting path is longer than 2k  -  1, then the size of M is at least k / (k  +  1) times the size of the maximum matching (folklore). Hence we have the following (1  +  1 / k)-approximation algorithm for maximum matching: Starting from an empty matching, for each [formula], find repeatedly augmenting paths of length 2i  -  1 and augment along the paths, until no such path exists. The iteration i = 1 is equal to finding a maximal matching, which could be done locally by Hakowiak et al.'s [\cite=hanckowiak98distributed] algorithm. Below we give a local algorithm that implements the iteration i for a general i  ≥  1. The algorithm uses techniques presented by Balas et al. [\cite=balas91parallel] in the context of parallel algorithms.

Our algorithm repeatedly invokes a subroutine that removes some augmenting paths of length h = 2i  -  1, assuming that there is no shorter augmenting path. The subroutine consists of three phases (refer to Figure [\ref=fig:mm-scheme]).

In the flooding phase, we construct a forest F of disjoint augmenting trees, rooted at black nodes (Figure [\ref=fig:mm-scheme]b). Each root-leaf path has length h. Furthermore, if there is a length-h augmenting path in the original graph between a black node b and a white node w, then w is a leaf node in a tree of F. (However, b may or may not be a root node in a tree of F.)

In the proposal phase, we choose one augmenting path in each tree (Figure [\ref=fig:mm-scheme]c).

Finally, in the augmenting phase, we augment along the paths in parallel to find a new matching (Figure [\ref=fig:mm-scheme]d).

To implement the flooding phase, each unmatched black node considers itself as a potential root of an augmenting tree. Every root node sends a message to each of its neighbours. When a white node receives messages, it chooses one of the senders as its parent, and forwards the message to its neighbour along an edge in the matching. When a black node receives a message, it chooses the sender as its parent, and forwards the message to its neighbours along each edge that is not in the matching. Messages are propagated for h hops; messages that reach a matched white node or a dead end are simply discarded.

Since there is no augmenting path shorter than h, every unmatched white node that receives a message is an endpoint of a length-h augmenting path. Conversely, all white endpoints of length-h augmenting paths are reached by the messages. These unmatched white nodes become the leaves of the forest F. The edges of F are defined by the links that point towards the parent nodes.

We now show that the trees of the forest F are disjoint. To reach a contradiction, assume that T1 and T2 are two trees in F and they share a node v. Let bj be the root node of the tree Tj; by assumption, b1  ≠  b2. Let Pj be an augmenting path in Tj that begins from bj, passes through v, and ends at a leaf node; let [formula] be the distance between bj and v along Pj. If we had [formula], the message initiated by the root b1 would have reached the node v on the same time step as the message initiated by the root b2, and in our algorithm v (or one of its ancestors) would have discarded one of the messages and joined only one of the trees. Hence we must have [formula]; but then it is possible to find an augmenting path (in the union of P1 and P2) that is strictly shorter than h, which contradicts our assumption.

Hence a local algorithm can find the forest F with the above-mentioned properties. The other steps of the algorithm are straightforward. In the proposal phase, messages are initiated by the leaf nodes and propagated towards the root nodes; whenever several messages meet, all but one of them are discarded. Eventually, we have chosen exactly one augmenting path in each tree. Finally, in the augmenting phase, we augment along each of these paths in parallel.

To analyse how many invocations of the subroutine are needed, note that a white node can be an endpoint of at most ti  =  Δ(Δ - 1)i - 1 length-h augmenting paths. Every invocation matches the other endpoint of at least one such path. Furthermore, it can be shown that no new augmenting paths with at most h edges are created. Therefore, after ti invocations, there is no augmenting path with h edges or fewer.

For any Δ  ≥  1 and ε  >  0, there is a local algorithm with approximation factor 1  +  ε for maximum matching in 2-coloured graphs.

Acknowledgements

This work was supported in part by the Academy of Finland, Grants 116547, 118653 (ALGODAN), and 132380, by Helsinki Graduate School in Computer Science and Engineering (Hecse), and by the Foundation of Nokia Corporation.