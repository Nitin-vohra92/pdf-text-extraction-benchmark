Proof:

Solving Shift Problems and the Hidden Coset Problem Using the Fourier Transform

Introduction

The Fourier transform lies at the heart of the solution of all problems that are known to admit a large quantum speedup over classical algorithms. This is due to two factors, the quantum Fourier transform can be performed exponentially faster than its classical counterpart, and the Fourier transform is particularly suited to extracting information about periodicities.

Taking a periodic superposition, performing a Fourier transform and measuring gives us the period. More generally, the Fourier transform of a superposition over coset states of a subgroup yields a superposition over the dual or "perp" of the subgroup. This is the basis of the hidden subgroup problem. The most well known example of a problem and algorithm fitting this framework is Shor's solution to the factoring problem [\cite=Shor].

However, information about periodicities is not the only feature that Fourier transforms can identify. The Fourier transform can also identify shifts or translations. This suggests that we look for ways in which the Fourier transform can be used to identify unknown shifts.

The shift problem may be formulated as follows.

Let g be a complex valued function defined on the group G. Let f be a shifted version of g where f(x) = g(x + s) for some s in G. Find s.

We give an efficient quantum algorithm for solving the shift problem provided G is abelian and g satisfies certain conditions. The conditions are satisfied if G is the additive group of a finite field and g is a multiplicative character. So our algorithm solves the shifted multiplicative character problem on a finite field.

If the shift is not uniquely determined, it can be shown that the set of possible shifts is a coset of a subgroup of the group G. We then have the hidden coset problem.

Let g be a complex valued function defined on the group G. Let f be a shifted version of g where f(x) = g(x + s) for some s in G. Find all s' satisfying f(x) = g(x + s') for all x.

The hidden coset problem combines the features of the hidden subgroup problem and the shift problem. Our algorithm treats this problem by first solving a hidden subgroup problem to find H and then solving a shift problem on the quotient group G / H. The shifted multiplicative character problem over fits this framework. The multiplicative characters of are periodic with respect to the additive group and so the shift is not uniquely determined.

Our algorithm solves the shifted Legendre symbol problem and the shifted quadratic character problem considered by van Dam and Hallgren [\cite=vanDamHallgren]. The quadratic character is an example of a multiplicative character and the Legendre symbol is the quadratic character for . van Dam and Hallgren also give an algorithm for the shifted Jacobi symbol problem for where n is square free. The Jacobi symbol is also an example of a multiplicative character. Our treatment solves the problem for all multiplicative characters of for all odd n.

The Shift Problem

In this section we state the shift problem, and show how it can be formulated in terms of matrix multiplication. By factoring the relevant matrix we obtain an algorithm for solving the shift problem and also sufficient conditions for the algorithm to be implemented efficiently on a quantum computer. The analysis involves Fourier transforms over finite abelian groups. For a review of characters and Fourier transforms over finite abelian groups see Appendix [\ref=sect:background].

The shift problem is the following. Let g be a complex valued function defined on the group G. Let f be a shifted version of g where f(x) = g(x + s) for some s in G. Find s.

We begin by reformulating the shift problem in the following way. Let s be the unknown shift and X be the matrix with columns and rows indexed by the elements of G and the matrix element in row x and column y given by g(x + y). The precise ordering of the elements of G is irrelevant as long as we are consistent. That is

[formula]

We then compute

[formula]

Solving the shift problem then reduces to inverting X.

We show below that the structure of X allows us to factor X into X = (FT)- 1DF- 1, where F is the Fourier transform matrix and D is a diagonal matrix. The diagonal entries of D (up to a scale factor) turn out to be the Fourier transform of g evaluated at the characters of G. Provided g satisfies certain conditions, we can efficiently compute X- 1 by inverting FT, D and F in turn to obtain X- 1 = FD- 1FT.

Matrix Factorization

We now show that X is "diagonalized" by the Fourier transform matrix. Let F be the Fourier transform matrix defined by

[formula]

where x and y index the rows and columns respectively and ψy is a character of G indexed by y. Thus each column of F contains a character of G evaluated at all elements of G.

Computing FTXF we find that

[formula]

which is a diagonal matrix. Let D denote this diagonal matrix and we have FTXF  =  D.

Matrix Inversion

The algorithm then consists of computing X- 1  =  FD- 1FT. If X is not full rank, then D contains some zeros along the diagonal. We then calculate the pseudoinverse of X (sometimes called the Moore-Penrose generalized inverse). The pseudoinverse of X, X* satisfies

XX*X  =  X,

X*XX*  =  X,

XX* and X*X are Hermitian.

The pseudoinverse of a matrix always exists and is unique [\cite=HornJohnson]. The pseudoinverse of a diagonal matrix is given by inverting the nonzero elements of the diagonal. We then have X* = FD*FT.

The fraction of zeros along the diagonal of D gives the probability of error, the probability that the algorithm fails to output s.

Sufficient Conditions

To implement the algorithm efficiently we need some conditions on g.

The magnitude of g(x) is constant for all x such that g(x) is nonzero.

The Fourier transform of g, ĝ(ψy), has constant magnitude for all y for which ĝ(ψy) is nonzero.

ĝ can be computed efficiently up to a multiplicative constant (on a classical computer).

The above conditions are sufficient for efficient implementation of the algorithm. The following two parameters determine the probability of the algorithm outputting the correct answer.

α, the fraction of x in G for which g(x) is nonzero

β, the fraction of y in G for which the Fourier transform of g, ĝ(ψy), is nonzero.

The probability of our algorithm succeeding is αβ.

Condition [\ref=condition:magnitude] is needed to be able to create the superposition with having amplitude g(x) up to a global constant,

[formula]

This can be done efficiently with probability α.

Conditions [\ref=condition:magnitudeFT] and [\ref=condition:efficient] are needed because we will need to compute [formula] to invert D.

The parameter β is describes the rank of D and thus of X. When we apply X followed by its pseudoinverse, we get a vector close enough to so that when we measure we obtain s with probability β.

Thus the overall probability of success of the algorithm is αβ.

Implementation of the Algorithm

We now show how to implement the algorithm efficiently on a quantum computer.

Setup a superposition of the all the values of f with the amplitude of equal to f(x) to obtain

[formula]

Compute the Fourier transform to obtain

[formula]

Now compute [formula] into the phase to obtain

[formula]

Computing the inverse Fourier transform and measuring gives - s.

In step [\ref=alg:superposition] we setup a superposition over the elements of G,

[formula]

compute f(x) and measure to see whether f(x) is zero. If so, then the algorithm fails. If not, we are left with a superposition over all x such that f(x)  ≠  0. The algorithm succeeds here with probability α. We next compute f(x) into the amplitude of (up to a constant factor) . Condition [\ref=condition:magnitude] ensures that we can do this by computing the phase of f(x) into the phase of . We can always approximate this arbitrarily closely by approximating the phase of f(x) to the nearest 2nth root of unity for some sufficiently large n.

Step [\ref=alg:1stFT] follows from observing that

[formula]

where C' is a constant.

Step [\ref=alg:invertD] can be performed because of Conditions [\ref=condition:magnitudeFT] and [\ref=condition:efficient].

In Step [\ref=alg:2ndFT] we measure and obtain - s with probability of β. The reason we get - s instead of s is that computing the inverse Fourier transform corresponds to multiplying by F† instead of FT.

Thus the algorithm succeeds in identifying s with probability αβ and only requires one query of f and one query of ĝ .

The Hidden Coset Problem

If g has a "subgroup" structure then the shift may not be unique. We can make this precise in the following way by formulating a hidden coset problem that combines the features of the shift problem with that of the hidden subgroup problem. The hidden coset problem is a shift problem where the shift may not be uniquely defined.

The hidden coset problem is the following. Let g be a complex valued function defined on the group G. Let f be a shifted version of g where f(x) = g(x + s) for some s in G. Find all s' satisfying f(x) = g(x + s') for all x.

Let H be the largest subgroup of G such that g is constant on cosets of H. Because of the structure of g, s is determined only "modulo" H. Thus to solve the hidden coset problem, we need to first identify the hidden subgroup H and then the shift s modulo H.

Assuming that we have already found H, to find s modulo H, define g' and f' as complex valued functions on the quotient group G / H in the natural way so that g'(x + H)  =  g(x) and f'(x + H) = f(x) for all x in G. Then if g' satisfies the conditions in Section [\ref=sect:suffcond] when considered over the group G / H we can apply the algorithm for the shift problem to find s modulo H.

We now show how to find H. The standard formulation of the hidden subgroup problem assumes that g is constant on cosets of H and that g takes on distinct values on distinct cosets. This can be solved using the "standard" algorithm

Prepare a superposition over all of G.

Computing g into a register.

Fourier sampling to obtain a random element of [formula].

The condition that g takes on distinct values on distinct cosets of H means that we sample uniformly over the elements of [formula]. This condition can be relaxed slightly so that the standard algorithm still works. Boneh and Lipton [\cite=BonehLipton] and Mosca and Ekert [\cite=MoscaEkert] give the condition that g' is at most m to 1 and m is less than the smallest prime factor of |H|, the cardinality of H. Hales and Hallgren [\cite=HalesHallgren] give the condition that at least a polylogarithmic number of values of g need to be changed to reduce the period of g.

However, as we already have restrictions on g' and ĝ' (so that we can solve the shift problem) we can give another condition for the hidden subgroup problem to be solved efficiently. If β, the fraction of values of ĝ' that is nonzero satisfies [formula], where p is the smallest prime factor of |H|, then the following algorithm will find H.

Prepare a superposition over all of G.

Computing g into the phase.

Fourier sampling to obtain a random element of [formula].

The difference from the standard algorithm for solving the hidden subgroup problem is that we compute g into the phase.

Shifted Character Problem (Finite Field)

The shifted character problem for the finite field  is as follows.

Given a finite field  (where q = pm for some prime p), a multiplicative character χ of  and a shifted version of χ, f(x) = χ(x + s). Find s.

For a review of additive and multiplicative characters in finite fields see Appendix [\ref=sect:background]. Appendix [\ref=sect:FTofcharacters] contains a discussion of Fourier transforms over the additive group of multiplicative characters.

The shifted multiplicative character problem over a finite field fits into our general framework. The group G is the additive group of the finite field. g = χ is a (non-trivial) multiplicative character of . We show that χ satisfies the sufficient conditions of Section [\ref=sect:suffcond].

For all nonzero x, χ(x) has unit magnitude.

(ψ0) = 0 and as shown in Appendix [\ref=sect:FTofcharacters], [formula] and so has magnitude |(ψg0)| which is constant.

χ and thus [formula] can be computed efficiently. So [formula] can be computed efficiently (up to a constant phase).

We next calculate the probability of our algorithm succeeding.

χ(x) is zero only if x = 0 so α  =  1 - 1 / q.

(ψy) is zero if for y = 0 so β = 1 - 1 / q.

So our algorithm succeeds with probability αβ  =  (1 - 1 / q)2.

Shifted Character Problem for

The shifted character problem for is as follows.

Given a ring with n odd, a multiplicative character χ of and a shifted version of χ, f(x) = χ(x + s). Find s.

The shifted character problem over has the interesting feature that the solution to the shift is not unique. This is because multiplicative characters in have periodicities with respect to the additive group. See Appendix [\ref=sect:background] for a discussion of periodicities of multiplicative characters. Appendix [\ref=sect:FTofcharacters] contains a discussion of Fourier transforms of multiplicative characters.

The shifted character problem over fits into the hidden coset problem framework described in Section [\ref=sect:HiddenCoset] so we can apply our algorithm. If [formula] we have [formula] and so our algorithm will succeed with probability [formula] (after solving the associated hidden subgroup problem).

Interpretation as Deconvolution

Our algorithm for solving the shift problem can be thought of solving a deconvolution problem. To see this, let δy(x) = δ(x - y) be the delta function centered at y. Then f is the convolution of δ- s and g, that is

[formula]

So to recover s or equivalently δ- s, we need to solve a deconvolution problem.

Taking Fourier transforms and observing that in the Fourier domain convolution becomes pointwise multiplication we see that

[formula]

where [formula], ĝ, - s are the Fourier transforms of f, g and δ- s respectively. We then have

[formula]

where the division is pointwise.

For the division to be performed on efficiently on a quantum computer would require that the magnitude of ĝ be constant and non-zero. However even if a fraction of the values of ĝ are zero we can still approximate division of ĝ by only dividing when ĝ is non-zero and doing nothing otherwise.

Deconvolution is a well studied classical problem and perhaps this interpretation will enable us to leverage existing deconvolution techniques to broaden the class of problems amenable to our approach.

Conclusion

We have presented a general framework for a class of shift problems and a set of sufficient conditions for the problems to be efficiently solved on a quantum computer. However, the sufficient conditions are fairly restrictive although they include the shifted multiplicative character problem over finite fields and rings .

It would be of interest to investigate what other shift problems satisfy the sufficient conditions and whether a less restrictive set of sufficient conditions exists.

Acknowledgements

I would like to thank Umesh Vazirani for much appreciated advice and encouragement and Sean Hallgren and Wim van Dam for useful discussions.

Bibliography

Mathematical Background

We start with some definitions and background. For more details see the book by Lidl and Niederreiter [\cite=LidlNiederreiter], and the book by Tolimieri et al. [\cite=TolimieriAnLu].

Characters of a Group

A character χ of a finite abelian group G is a homomorphism from a group G to [formula], the group of complex numbers with multiplication. That is

[formula]

for all g1,g2∈G. If G is cyclic with generator g, the characters are

[formula]

for [formula].

The characters of G form a group Ĝ, known as the dual group, with multiplication defined as

[formula]

for all χ1,χ2∈Ĝ, g∈G. Ĝ is isomorphic to G. In particular, |Ĝ| = |G|, that is the number of characters of G is the same as the cardinality of G.

Fourier Transform over a Group

Given a complex valued function f over G, the Fourier transform of f over the group G is given by

[formula]

for all χ∈Ĝ.

Characters of a Field

In a field  (where q = pm for some prime p) we have two operations, multiplication and addition, with corresponding groups. Thus we can define two different groups of characters.

Characters of the multiplicative group [formula] of  are called multiplicative characters of . Since [formula] is cyclic with order q - 1, its characters [formula] can be explicitly represented as

[formula]

for all [formula], where g is a generator of [formula]. It is often convenient to extend the definition of χk to include 0 by defining χk(0) = 0. The quadratic character referred to in van Dam and Hallgren [\cite=vanDamHallgren] is [formula].

Characters of the additive group of  are called additive characters of . The additive characters ψa (for all [formula]) have the form

[formula]

for all [formula], where

[formula]

is the trace function from  to  and  is identified with for the purposes of evaluating the exponential. ψ1 is the canonical additive character of . We have that ψa(c)  =  ψ1(ac).

Characters of

Similarly we can define additive and multiplicative characters in where p is an odd prime. with addition is a cyclic group so we can define additive characters [formula]

[formula]

for all [formula].

[formula] is a cyclic group, so we can define multiplicative characters [formula], where

[formula]

for all [formula] and g is a generator of [formula]. We can extend the definition of χk to include all of by defining χk(x) = 0 if x is a multiple of p.

with addition is a cyclic group so we can define additive characters [formula]

[formula]

for all [formula].

If n is odd, we can define multiplicative characters over by observing that if [formula] then

[formula]

Let φ be an isomorphism from to [formula] with [formula] given by φj(x) = x mod pmjj. Define the multiplicative characters as the product of the multiplicative characters in the corresponding . That is

[formula]

where χ(r)lr is a multiplicative character of . Noting that all the [formula] are distinct for appropriate ranges of [formula] and that there are exactly the right number of them we see that we have all the multiplicative characters.

Periodicities of Multiplicative Characters of

The multiplicative characters of have a particular additive periodic structure. Every multiplicative character has a period that is a power of p. That is, for every k, there is a j such that

[formula]

for all [formula].

In fact we have the following theorem [\cite=TolimieriAnLu] that explicitly gives the period.

Let g be a generator of the group of units [formula] and let χk be a multiplicative character of defined

[formula]

Let j be such that gcd (pm,k) = pm - j. Then pj is the additive period of χk, the smallest T such that χk(x + T) = χk(x) for all [formula].

Suppose gcd (pm,k) = pm - j and that the period of χk is T. We first show that T|pj and then that T = pj.

If p|x then p|(x + pj) and so χk(x + pj) = 0 = χk(x). If x = gl then because pm - j|k, the value of χk(gl) is determined by the value of l mod (p - 1)pj - 1, which is in turn determined by the value of gl mod pj. But [formula] and so χk(x + pj) = χk(x). This shows that T|pj.

Since T|pj, if T  ≠  pj, we must have T = pj' for some j' < j. Then χk(1) = χk(1 + rpj') for all [formula]. Now

[formula]

since all the g(p - 1)pj' - 1l' are distinct and [formula]. But χk(g(p - 1)pj' - 1l') = 1 for all l' only if k(p - 1)pj' - 1 is a multiple of (p - 1)pm - 1 which implies that pm - j'|k. This is a contradiction since pm - j was the largest power of p dividing k. Thus T = pj.

Periodicities of Multiplicative Characters of

As we saw in Appendix [\ref=CharactersZn], a multiplicative character [formula] of can be decomposed into a product of multiplicative characters [formula] of [formula]. The period of [formula] is then the product of the periods of [formula].

Fourier Transforms of Multiplicative Characters

Finite Field Case

Consider the natural representation of [formula], the multiplicative group. It is well known that this is cyclic. If g is a generator then the elements can be represented as [formula]. The multiplicative characters are then exponentials in k

[formula]

The non-trivial additive characters can be written

[formula]

Note that these are all translates of the canonical additive character

[formula]

When we take the Fourier transform of a multiplicative character over the additive group we are expressing an exponential in terms of a basis where the basis functions are translates of the canonical additive character. To compute the change of basis we compute the inner product of the exponential with all the translates of the canonical additive character. This is the same as the inner product of the canonical additive characters with the exponential translated in the opposite direction. But a translated exponential is just the original exponential with a phase shift that is given by the exponential of the size of the translation. Thus

[formula]

Case

If a multiplicative character χl of has no periodicity, then [formula]. An extension of the argument used for the finite field case shows that

[formula]

See Tolimieri et al. for details [\cite=TolimieriAnLu]. If gcd (pm,l) = pm - j, χl has period pl and the previous argument does not work because pm, the size of the additive group, and l are not relatively prime. However, by projecting onto by sending x to x mod pj we transform χl to a multiplicative character of with no periodicity. Thus the Fourier transform of χl over must be

[formula]

for some constant K.

Case

Given a multiplicative character of , [formula] the vector with component x equal to [formula] is equal to the tensor product of the corresponding vectors of the [formula].

The Fourier transform of [formula] will then be the tensor product of the Fourier transforms of the [formula]. So if the period of [formula] is T, the Fourier transform of [formula] is

[formula]

for some constant K.