Proposition Example Algorithm Fact Conjecture Postulate Axiom Remark

Distributed implementation of standard oracle operators

The rapidly developing field of quantum information science has yielded many new concepts in communications and computation, which have led to major applications such as quantum cryptography and fast quantum algorithms [\cite=NC]. In quantum, as in classical information processing, situations involving spatially separated parties are of particular interest. It is therefore necessary to develop the theory of distributed quantum information processing [\cite=GC] [\cite=CGB] [\cite=EJPP] [\cite=CLP] [\cite=KC] [\cite=BHLS] [\cite=LHL] [\cite=VNM]. Here, we consider quantum systems whose component subsystems are possessed by a number of spatially-separated parties. These subsystems cannot interact directly, so the effect of an interaction must be brought about using only local quantum operations and non-local resources. The non-local resources needed to implement an arbitrary quantum operation in this manner are classical communication channels and shared entangled states.

One particularly important quantum operation within the context of quantum information processing is the standard oracle operator. This operator is a key building block for quantum algorithms. Generally speaking, an oracle operator is a unitary operator that computes a function. The key difference between oracle operators and classical methods of computation is that the former, being linear quantum mechanical operators, maintain superpositions. A superposition of different values of the independent variable, which we denote by x, will then evolve into a superposition of the corresponding values of f(x), giving rise to the well-known and important phenomenon of quantum parallelism. The standard oracle operator is a convenient oracle operator which can be used to compute an arbitrary function [\cite=KKVB] [\cite=CKTST]. However, it has different registers for x and f(x) and in a distributed setting it is natural to consider these to be spatially separated.

In this Letter, we investigate numerous aspects of the distributed implementation of standard oracle operators. We consider both the minimum entanglement and classical communication resources, in both directions, required for this implementation and also the corresponding capacities, which relate to the fact that it is possible to use such an operator to send classical information and create entangled states. It is important to determine the values of these quantities for the following reasons. Regarding the minimal resources necessary for the distributed implementation of the standard oracle operator, it is highly desirable to use classical communication and, even more so, shared entanglement, as efficiently as possible when implementing distributed quantum operations. Concerning the capacities, it is important to have knowledge of these quantities in circumstances where we are able to perform this operation and wish to use it to create entangled states or transmit classical information.

The main result of this Letter is that for an arbitrary function f, all six minimum implementation resources and capacities are equal to log 2(nf) bits/ebits, where nf is the number of different values this function can take. In the course of this investigation, we provide optimal protocols for entanglement creation and classical communication using an arbitrary standard oracle operator, indeed also for bidirectional classical communication when the function f is a permutation. We also give an optimal protocol for the distributed implementation of an arbitrary standard oracle operator.

Let us set the scene by reviewing the main properties of standard oracle operators. Let M,N be arbitrary finite integers ≥  1. Consider FMN, the set of functions from [formula]. Let A and B be quantum systems with M- and N-dimensional Hilbert spaces HM and HN. These systems are taken to be spatially separated and in the possession of corresponding parties Alice and Bob. To each f∈FMN there corresponds a unitary standard oracle operator on [formula]:

[formula]

A and B may be referred to as the control and target systems respectively. In Eq. [\eqref=oracleaction], [formula] denotes addition modulo N. Also, [formula] and {|x〉} is an orthonormal basis set for HM, likewise with {|y〉} and HN. These are the computational basis sets for both systems. There are NM functions in FMN, so there are NM associated standard oracle operators Uf.

To proceed, let us partition [formula] into subsets corresponding to different values of f(x). Let nf be the number of different values that f(x) can take. Clearly, nf  ≤  M,N. Let fj, where [formula], be the possible values of f(x). We also define [formula] to be the set of values of x for which f(x) = fj and denote by [formula] the projector onto the subspace spanned by the states |x〉 for x∈Sj. Finally, let Kj be the cardinality of Sj. Clearly, Kj is the rank of Pj. It is a simple matter to prove that Uf can be written in the form [\cite=CKTST]

[formula]

where we use the N-dimensional Pegg-Barnett phase operator

[formula]

whose eigenstates are the N-dimensional Pegg-Barnett phase states [formula] [\cite=PB]. These states form an orthonormal basis for HN which is conjugate to the computational basis {|y〉}. One can readily verify that

[formula]

We note that Eq. [\eqref=USchmidt] gives an operator Schmidt decomposition of Uf, where the related Schmidt operator sets are [formula] and [formula]. These are orthonormal sets with respect to the Hilbert-Schmidt inner product [formula]. The Schmidt coefficients are [formula] and the Schmidt rank of Uf, denoted by [formula], is equal to nf.

In a distributed setting, any type of non-local resource that can be created by a quantum operation must also be consumed in order to perform the operation. For a bipartite quantum operation, there are three such resources: shared entanglement E and classical communication in the Alice→  Bob and Bob→  Alice directions, which we shall denote by C→ and C← respectively. We shall use the subscripts R and C to denote, respectively, the minimum of the corresponding resource required to perform a quantum operation and the capacity of the operation corresponding to this resource. The entangling capacity is the maximum amount of entanglement that the operation can create. The classical capacity, in a given direction, is the maximum amount of classical information that the operation can be used to send in that direction.

A fundamental result in quantum information theory is that, for any bipartite unitary operator U, each capacity cannot exceed the amount of the corresponding resource that must be consumed [\cite=EJPP]. We therefore have the following inequalities:

[formula]

There is a further capacity to consider, the bidirectional classical capacity CC  ↔(U). This is the maximum total amount of classical information that Alice and Bob can send to each other with one use of the quantum operation. Since the unidirectional classical capacities are optimised for transmission in their associated directions, we have

[formula]

We shall now obtain, for an arbitrary standard oracle operator Uf, lower bounds on the entangling and unidirectional classical capacities EC(Uf), CC  →(Uf) and CC←(Uf). We begin by examining entanglement creation. Consider some arbitrary but fixed xj∈Sj, for each [formula]. Suppose that A and B are initially prepared in the product state

[formula]

where |0〉 is the zeroth computational basis state in HN. Acting upon this state with Uf gives

[formula]

This is a maximally entangled state with Schmidt rank nf, having log 2(nf) ebits of entanglement. We conclude that

[formula]

Let us now show that Alice and Bob can send each other log 2(nf) classical bits using Uf. That Alice can send Bob log 2(nf) bits is almost trivially demonstrated. Let [formula] be the classical message she wishes to send to Bob. She prepares A in the state |xr〉. Meanwhile, Bob prepares B in the state |0〉. The oracle operator Uf then acts on these systems, giving rise to the state [formula]. Bob can subsequently perform a computational basis measurement to reveal fr and hence r, Alice's log 2(nf) bit message.

For Bob to send the same amount of classical information to Alice, the two parties can use the following entangled state:

[formula]

where [formula] denotes subtraction modulo N. Bob wishes to send the value of [formula] to Alice. To encode his chosen value of s in the above state, he makes use of a unitary phase shift operator G acting on HN which is defined through

[formula]

His encoding of s is performed through the transformation [formula], giving

[formula]

The oracle operator Uf is then applied, resulting in the state

[formula]

The states inside the parentheses, indexed by s, are orthonormal and can be perfectly discriminated by Alice. Doing so enables her to read Bob's log 2(nf) bit message s. The existence of these classical communication protocols implies that

[formula]

Let us now consider simultaneous, bidirectional classical communication. Here we will see that, when f is permutation from [formula], the above protocol can be modified to enable Alice and Bob to send to each other log 2(nf) =  log 2(M) classical bits simultaneously. Let [formula] be a permutation of degree M. We begin with the state

[formula]

which resembles the state |ψ〉 in Eq. [\eqref=psi]. Here, [formula] denotes addition/subtraction modulo M. Alice encodes her message [formula] with the unitary transformation [formula] on A. Again, Bob encodes his message s with a unitary phase shift on B, here [formula] where [formula]. The total state transformation is |Ψ〉  ↦  |Ψrs〉, where

[formula]

The corresponding standard oracle operator Uf is then applied, which results in the transformation

[formula]

Alice and Bob are now able to read each other's messages. For the sake of clarity, let Alice now invert her earlier unitary transformation on A and Bob perform the unitary transformation [formula] on B. This results in the state

[formula]

The states of A are the orthonormal eigenstates of ΦM indexed by s. These states are perfectly distinguishable by Alice, as are the states |r〉 by Bob. Discrimination among these states enables Alice and Bob to read each other's log 2(M) bit messages. We therefore conclude, for a standard oracle operator corresponding to a permutation of degree M, that the bidirectional classical capacity satisfies

[formula]

Having obtained lower bounds on the entangling and classical capacities for a standard oracle operator, we now obtain upper bounds on the corresponding minimum resources for its distributed implementation. We will now show that

[formula]

by describing an explicit protocol that uses log 2(nf) ebits of entanglement and the same number of classical bits in each direction to perform the distributed implementation of a standard oracle operator. We begin with an arbitrary initial state of systems A and B, which may be written in the form

[formula]

In addition to A and B, Alice and Bob have respective ancillas a and b. Their Hilbert spaces can be described in the following way. Let us define Hf as the nf-dimensional subspace of HM spanned by the states |xj〉 for [formula]. Then the Hilbert spaces of a and b are copies of Hf. The two ancillas are initially prepared in the maximally entangled state [formula], which has log 2(nf) ebits of entanglement. The total initial state is therefore

[formula]

Our protocol can be described in the following way:

Step 1: Alice applies the following unitary operator to Aa:

[formula]

Here, Vk is a unitary operator on Hf which acts as Vk|xj〉 = |xjk〉, where throughout,   /   denotes addition/subtraction modulo nf. The state transformation effected by this operator is |Φ0〉  ↦  |Φ1〉, where

[formula]

Step 2: Alice performs a computational basis measurement on a, getting result xr for some [formula]. This results in the state transformation |Φ1〉  ↦  |Φ2r〉 where

[formula]

Step 3: Alice communicates the value of r to Bob, thus sending him log 2(nf) classical bits. With his knowledge of r, Bob performs the unitary transformation |xrk〉  ↦  |xk〉 on b, resulting in the total state transformation |Φ2r〉  ↦  |Φ3r〉 where

[formula]

Step 4: Bob now performs the unitary transformation

[formula]

where [formula] denotes addition modulo N. This transformation is effectively the oracle operator Uf, with b and B being the control and target systems respectively and the state of the control system is restricted to the subspace Hf of HM. The gives |Φ3r〉  ↦  |Φ4r〉 where

[formula]

Step 5: Bob performs a discrete Fourier transform on the b system whose effect is [formula], resulting in the total state transformation |Φ4r〉  ↦  |Φ5r〉, where

[formula]

Step 6: Bob now performs a computational basis measurement on b. On obtaining the result xs, where [formula], the total state is transformed as

[formula]

and he communicates the value of s to Alice. This requires him to send her log 2(nf) bits of classical information.

Step 7: Alice now uses the degenerate but unitary phase shift operator [formula]. Knowing s, she applies the operator Ts to A. This results in the transformation |Φ6rs〉  ↦  |Φ7rs〉, where

[formula]

which is the desired transformation of the state of AB. The existence of this protocol for the distributed implementation of the standard oracle operator Uf, with the specified resources together with the lower capacity bounds in [\eqref=ebound], [\eqref=ccbound] and inequalities [\eqref=in1], [\eqref=in2] and [\eqref=in3], establishes that all six quantities in these latter inequalities are equal to log 2(nf) [\cite=footnote]. We also see from [\eqref=bcc] that when f is a permutation of degree M, the bidirectional classical capacity CC  ↔(Uf) is equal to 2 log 2(nf) bits and that the bidirectional classical communication protocol we described is optimal.

There are several points to be made about this distributed protocol. Firstly, it generalises earlier work on the distributed implementation of the CNOT gate [\cite=GC] [\cite=EJPP] [\cite=CLP]. In fact, this unitary gate is the standard oracle operator corresponding to the one-bit identity function. Our protocol has interesting security properties. The actual classical data that Alice and Bob send to each other consists of random measurement results. It follows that if they wish to use Uf to send classical information to each other, this will be concealed from an eavesdropper listening to their classical transmissions. Also, we see that in step 4, Bob effectively implements the oracle locally. Only this step makes reference to the details of the function f, which even Alice doesn't have to know for the successful implementation of Uf. The details of f will also be concealed from a potential eavesdropper on the classical transmissions.

We also point out that this protocol simplifies when f is a permutation on [formula]. When this is so, M = N = nf and all four quantum systems have identical Hilbert spaces. The projectors Pk have rank-one and project onto all of the computational basis states in HM. One further curious property of permutations is the ease with which their standard oracle operators can be seen to be locally equivalent. Kashefi et al. [\cite=KKVB] noted that for any permutation f on [formula], one can define the unitary minimal oracle operator [formula], which is related to Uf through [formula]. Here, UID is the standard oracle operator corresponding to the [formula] identity function. All standard oracle operators for permutations of degree M are therefore interconvertible with local unitary operations. It follows that the minimum non-local resources to implement these operators and their corresponding capacities are equal.

To conclude, we have studied numerous aspects of the distributed implementation of standard oracle operators. These arise frequently in the context of quantum algorithms and the results presented here will be useful in relation to distributed quantum computation. It is also to be expected that the methods used to establish the minimum non-local implementation resources and capacities of standard oracle operators will be useful in a more general context. In particular, the optimal distributed protocol for standard oracle operators has the potential to be modified for more general unitary operators.

Acknowledgements: I would like to thank Timothy Spiller and Bill Munro for helpful discussions and comments on this manuscript and also Martin Plenio for many enjoyable conversations about this topic. Part of this work was carried out at NICT, Tokyo and I would like to thank Masahide Sasaki and his group for their hospitality. This work was supported by the EU project QAP.