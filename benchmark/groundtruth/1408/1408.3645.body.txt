Lemma Definition Proposition Remark Claim Conjecture Question Note

The "Game about Squares" is NP-hard

Keywords: Game about Squares, NP-hardness, computational complexity

Introduction

The "Game about Squares" [\cite=gas] is an addictive game where unit squares have to be moved on an integer lattice onto dots of the same color. It has been released by Andrey Shevchuk in July 2014. In the meantime several clones of the game are available for different platforms.

The basic rules of the game are the following:

Let D  =  {( - 1,0),(1,0),(0, - 1),(0,1)} (left, right, down and up, respectively) be a set of directions. The game is played on an infinite integer lattice [formula]. An instance (S,p(S),f(S),d(S),A,p(A),d(A)) of the game consists of

A finite set of squares S with different initial positions [formula] on the lattice. In the game the squares are represented by unit squares of different colors.

A final position [formula] for every square, marked by a dot of the color of the corresponding square. No two squares have the same final position.

An initial direction d:S  →  D for every square.

A finite set of arrows A with distinct positions [formula] and directions d:A  →  D.

The game is played in rounds. In every round the player chooses a square s∈S that is pushed. Let d be the direction d(s) of the square. The square moves one position into direction d, that is, its new position is [formula]. If there is already another square s2 at the new position, s2 also moves into direction d, independent of its own direction. If s2 lands on the position of a third square s3, s3 also moves into direction d and so on. If a square s lands on a position with an arrow (that is, there exists an a∈A with [formula]), the square adopts the direction of the arrow, that is, [formula].

The player wins the game if after a finite number of moves each square s∈S is on its final position f(s). A winning sequence is a sequence [formula], si∈S, such that if in each round [formula] the player pushes the square si, the game is won in round k.

The original game [\cite=gas] consists of 35 levels with increasing difficulty. Between Level 22 and Level 23 the author of the game, Andrey Shevchuk, asks "Do you think this game is hard?". We interpret this question in a mathematical way (even if this has not been the intention of Shevchuk). We prove by a reduction from Satisfiability, that the game is NP-hard. Nevertheless, it remains an open question, if this game is in NP or if it is even PSPACE-hard.

Reduction from SATISFIABILITY

We prove that the game is NP-hard by a reduction from SATISFIABILITY, which has been proven to be NP-hard by Cook [\cite=Cook]. More precisely we prove, that it is NP-hard to decide if a given instance of the "Game about Squares" (in short GaS) can be won, that is, there is a finite number of moves such that all squares reach their final position.

Let (X,C) be a Satisfiability instance where [formula] is a set of variables and [formula] is a set of clauses over X. We construct an instance for the GaS that can be won if and only if there is a truth assignment [formula] satisfying all clauses.

In our GaS instance squares can only be moved to the left and down. To this end, the initial direction of each square and the direction of each arrow is either left or down. With this restriction we observe, that a square can never be above or left of its initial position. If a square if below or right of its final position, the game cannot be won. For a given square s we call a position infeasible, if it it left or below of the final position of s or if it is above or right of the initial position of s. Otherwise, we call the position feasible for s.

Moreover, we use in our instance so called blockers, that are squares that are initially at their final position. Moving them from that position, they can never be moved back to their final position. Thus in order to win the game, blockers are not allowed to be moved.

For every variable we insert a variable gadget as shown in Figure [\ref=fig:variable]. It consists of a variable square (labeled x), a decision square (labeled p), a blocker and two columns. The decision square can push the variable square from the right to the left column, where the blocker ensures that these are the only two columns that can be used. Depending on which column the variable square moves to its final position, the variable is set to [formula] or to [formula]. Accordingly we associate the literal xi with the left and [formula] with right column.

For every clause Cj we insert a clause gadget as shown in Figure [\ref=fig:clause]. It consists of two rows, a clause square Cj and a square Dj indicating if the clause is satisfied or not. Only if the clause square moves on the lower row the indication square Dj can reach its final position.

We build a lattice containing these gadgets such that each pair of variable columns intersects with each pair of clause rows: For [formula] we place the variable gadget for xi in such a way that the variable square is at (4(i + 1),4(m + 1)) and its final position is at (4(i + 1) - 2,1). For [formula] we place the clause gadget for Cj such that the clause square is at (4(n + 1),4(m - j) + 6) and its final position is at (1,4(m - j) + 4). See Figure [\ref=fig:all] for an example. All gadgets are placed into a lattice of size 4(n + 1)  ×  4(m + 1). Note that each lattice point is feasible for one variable and one clause square. It remains to specify the crossings of clause rows and variable columns.

Figure [\ref=crossing] shows a crossing between the columns of a variable xi and a clause Cj that neither contains xi nor [formula]. Note that if a variable square pushed a clause tile ore vice versa, the pushed square changes its orientation and cannot reach its final position.

Finally, Figure [\ref=fig:cross2] shows the crossing of a variable xi and a clause Cj that contains xi (on the left) and clause Cj that contains [formula] (on the right), respectively. Note that in these cases, the clause square can be pushed to the lower row by the variable square without changing its direction if and only if the corresponding literal is satisfied, that is, the variable square uses the column of the corresponding literal. Once again, the blockers ensure that the clause squares can leave the crossing only on one of the two clause rows.

We can assume w.l.o.g. that no clause contains both xi and [formula] as such clauses are always satisfied.

GaS is NP-hard.

For a given SATISFIABILITY instance S with n variables and m clauses we construct a GaS instance as shown above. Obviously, this is a polynomial transformation: the GaS instance is placed on a grid of total size O(nm) and contains O(n + m) squares and O(nm) arrows.

We have seen that each variable square has to use either its left or right column in order to win the game. Once such a square has left the uppermost row it cannot be moved to the left until it has reached the lowermost row. Otherwise, the square would change its direction and cannot reach its final position.

Assume that there exists a truth assignment π satisfying S. Using the decision squares we push each variable square x to the columns corresponding to π(x). As the truth assignment is satisfied, for each clause C there exists a literal l∈C that is set to [formula] by π. Now we push the clause square C to the left until we reach the column assigned to l. Moving the variable squares down they can be used to push the clause square into their lower rows. Now they can be used to push the squares D by one position to the left so that they can reach their final destination. Finally, all remaining squares can reach their final position without problems and the game is won.

Now assume, that we have an instance of the game that can be won. We define a truth assignment π by setting [formula] if the variable square xi uses its left column when moving down and [formula] otherwise. Now consider the sequence Q of pushes that is used to win the game. As for all [formula] the square Di reaches its final position, it must be pushed by the square Ci by one to the left in one of the rounds. But then Ci has been pushed to its lower row, which can only be done by a variable square xi such that the corresponding literal xi or [formula] is in Ci and is satisfied by π. Thus each clause is satisfied by π.

First note that each instance of the game can be restricted to a grid of size O(|S|(|S| + |A|)  ×  O(|S|(|S| + |A|). If there are more than |S| succeeding rows or columns that neither contain squares, final positions nor arrows, we can delete all but |S| of them. Thus the size of the grid is polynomially bounded in the size of the input. For the problem to be in NP, we have to show that for every instance that can be won there exists a certificate verifiable in polynomial time. Such a certificate could be a winning sequence. Unfortunately, it is not known if there always exists a winning sequence of polynominal size.

Nevertheless, the restricted version of the "Game about Squares" with instances, where only one horizontal and one vertical direction are allowed, is in NP: Every square can be pushed at most O(|S|(|S| + |A|)) times and thus the game ends after a polynomial number of rounds. By the proof of Lemma [\ref=lemma1], this restricted version is NP-hard.

Acknowledgment

The author likes to thank Andrey Shevchuk for this addictive game and Jan Schneider for valuable discussions.