Complexity analysis of quantum walk based search algorithms

Introduction

Search algorithms employing quantum walks have been the focus of several recent studies (see, for example, [\cite=Childs2003] [\cite=Shenvi2003] [\cite=Childs2004a] [\cite=Childs2004b] [\cite=Magniez2007] [\cite=Santha2008] [\cite=Reitzner2009]). Along certain types of graphs, quantum search algorithms have been shown to yield a quadratic speedup over their classical equivalents, relative to a fixed oracle [\cite=Moore2002] [\cite=Ambainis2005] [\cite=Potocek2009]. These types of graphs include sparse graphs with efficiently computable neighbours [\cite=Aharonov2003], and highly symmetric graphs such as complete graphs, hypercycles and hypercubes [\cite=Reitzner2009] [\cite=Douglas2009].

Previous studies of quantum walk based search algorithms have focussed on a computational complexity comparison between the quantum search and the best possible classical search. These search algorithms are usually formulated relative to an oracle, a black box that accepts some input, and returns some corresponding output. A comparison is made as to the relative number of queries to the fixed oracle needed to complete the search. As such, there has been no need to consider the resource requirements of the oracle itself.

However, an efficient practical implementation of such a search algorithm would require an efficiently implementable oracle. Specifically, it requires the ability to efficiently perform steps of the quantum walk along the graph. So far efficient implementation of quantum walks has been shown to be possible only along some graphs from a certain type, whose global structure is completely characterised by a small number of parameters. Several graphs belonging to this category were considered in [\cite=Douglas2009] [\cite=Loke2011], and shown to be amenable to exact, efficient quantum circuits implementing quantum walks along them.

Note that there are two differing notions of efficiency considered here. We consider an efficient quantum search algorithm to be one which exhibits at least a quadratic speedup over the best possible classical search, in some oracular setting. In the case of implementing a quantum walk along a graph on n vertices, we use the term efficient to mean that a step of the walk can be implemented using O(log(n)) elementary 2-qubit gates. Which of these two situations we are referring to when we mention efficiency should be clear from the context.

In this paper we present examples of families of graphs for which both notions of efficiency hold, that is they yield both efficient quantum walk implementations and efficient quantum walk based search algorithms, without reference to an oracle. For these graphs, we construct quantum circuits that implement a step of the quantum walk (corresponding to an efficient search algorithm) using O(log(n)) 2-qubit gates, for graphs on n nodes. By specifying explicitly the method by which the walk is implemented, without reference to an oracle, we ensure there are no hidden resource requirements, and as such provide a practically implementable method to experimentally test these search algorithms.

Quantum Walk Based Search

Quantum walks can be thought of as the quantum analogues of classical random walks. They are a unitary process, and can be naturally implemented by quantum systems (see, for example, references in [\cite=Kia2008] [\cite=Kia2009]. Both discrete time [\cite=Tregenna2003] [\cite=Aharonov2001] and continuous time [\cite=Farhi1998] [\cite=Gerhardt2003] quantum walks can be considered, both of which have yielded several quantum algorithms [\cite=Kempe2003] [\cite=Childs2003] [\cite=Shenvi2003] [\cite=Childs2004a] [\cite=Childs2004b] [\cite=Ambainis2004] [\cite=Douglas2008] [\cite=Berry2010] [\cite=Berry2011]. Here we consider only discrete time quantum walks. This walk consists of a unitary operator U  =  SC, acting on the state space, where S and C are termed the shifting and coin operators respectively.

Consider a discrete-time quantum walk along a general undirected graph G(V,E), with vertex set [formula], and edge set [formula], being unordered pairs connecting the vertices. The quantum walk acts on an extended position space, in which each node vi, having di edges, is split into di states, alternatively termed sub-nodes or coin positions. This space then consists of states |vi,ai〉, where 1  ≤  ai  ≤  di. The shifting operator acts on this extended position space, with its action defined by:

[formula]

for some vj∈V with valency dj, such that (vi,vj)∈E, and 1  ≤  aj  ≤  dj. The coin operator comprises a group of unitary operators, or a set of coins, which independently mix the probability amplitudes associated with the group of sub-nodes of a given node. For example, given a vertex vi with valency di, the coin can be represented by a unitary (di  ×  di) matrix. In the cases we consider here, the coin matrix is always constrained to be symmetric. Berry et al. [\cite=Berry2011a] has recently developed a software package qwViz, which provides an interactive visualisation of the time-evolution of quantum walks on arbitrarily complex graphs.

One particular algorithmic application of quantum walks is that of searching for a marked node in a graph, and has been the focus of several recent studies (see, for example, [\cite=Childs2003] [\cite=Shenvi2003] [\cite=Childs2004a] [\cite=Childs2004b] [\cite=Magniez2007] [\cite=Santha2008] [\cite=Reitzner2009]). These search algorithms generally involve starting in an equal superposition of all possible states, and marking one or more nodes of the graph. The aim is to evolve the state by successive steps of a quantum walk, until the probability to measure the walk at a marked node is sufficiently high, at which point the state of the walk is measured.

In the following section, we present quantum circuits that implement the full quantum walk based search algorithm. In this situation the efficiency is not just measured relative to the best possible classical search in an oracular setting. Instead, since in previous quantum search studies [\cite=Childs2003] [\cite=Shenvi2003] [\cite=Childs2004a] [\cite=Childs2004b] [\cite=Magniez2007] [\cite=Santha2008] [\cite=Reitzner2009] the oracle is queried once per step of the walk, generally taking the place of the coin or shifting operators of the walk, we will analyse the complexity of these examples based on the number of steps of the quantum walk required, together with the total number of elementary 2-qubit quantum gates required to implement the walk. Explicit circuits implementing the quantum walk based search will be provided for each family of graphs.

Examples

Hypercube

Firstly we consider the n-dimensional hypercube, with N = 2n nodes, each of degree n. The graph for n = 5 is shown in Fig. [\ref=hypercube]. Shenvi et al. [\cite=Shenvi2003] demonstrated an efficient quantum walk based search algorithm for finding marked nodes on the hypercube. Their algorithm operates quadratically faster than classical methods, requiring O([formula]) calls to an oracle that effectively acts as a coin operator which is biased only relative to the marked node during each step of the quantum walk.

Here we show that this quantum walk oracle can be implemented efficiently, due to the symmetric nature of the graph, requiring O(log(N)) elementary 2-qubit gates per call. The coin operator C is defined as [formula], where C' is the perturbed coin acting on the marked node x (for the examples presented here, [formula]). G is the Grover operator, defined on d dimensions by [formula]. The shifting operator has its standard definition, provided above, such that for vi,vj∈V, S|vi,ai〉  =  |vj,aj〉, where [formula] and 1  ≤  ai,aj  ≤  n.

An example quantum circuit implementing a step (U  =  SC) of the walk along the n-dimensional hypercube and biased towards the marked node is shown in Fig. [\ref=circuit_hypercube]. Here the G operator represents the Grover operator defined above, and the π operator (also known as the negative identity operator) represents a π phase change applied to each qubit it acts upon. This circuit requires n 'node' qubits, with each bit string representing a node of the hypercube, with the natural ordering on the hypercube, such that two nodes are connected if and only if their bit strings have a Hamming distance of 1. Log(n) 'subnode' qubits are required (rounded up to the nearest integer), with the first n bit strings representing the n edges of each node.

This circuit provides an efficient implementation, in that O(log(N)) elementary 2-qubit gates are required per step. The Grover operator G acting on the log(n) subnode qubits requires O(log(n)) 2-qubit gates [\cite=Diao2002]. The generalized conditional NOT operations are described in [\cite=Tucci2004], in which it is shown that a generalized CnNOT gate, performing a NOT operation conditionally based on the state of n other nodes, can be implemented using O(n) 2-qubit gates together with O(n) auxilliary qubits. Performing both these and the conditional G and π operations requires O(n) 2-qubit gates and an additional O(n) auxilliary qubits (see, for example, [\cite=Tucci2004] [\cite=Diao2002]).

Hence the circuit of Fig. [\ref=circuit_hypercube], performing a step of the walk implementing a quantum search along the hypercube on n-dimensions (with N = 2n nodes), can be implemented using O(log(N)) qubits and O(log(N)) 2-qubit gates. This circuit is a representation of a single step of the search algorithm of [\cite=Shenvi2003], with the explicit action of the oracle included in the circuit. For the 5-dimensional hypercube, given an initial equal superposition across all states, the resulting probability distribution against number of steps is given in Fig. [\ref=hyp_prob]. Hence as in [\cite=Shenvi2003], after O([formula]) steps of the walk (or equivalently O([formula]) repetitions of the circuit of Fig. [\ref=circuit_hypercube], each requiring O(log(N)) elementary quantum gates), the walk will be found at the marked node with sufficiently high probability.

Complete graph

Similar results pertain to the complete graph on N = 2n nodes. Here we consider each node to possess a self loop, so that each node has degree N. Combining the circuits of [\cite=Douglas2009] for complete graphs with 2n nodes (which efficiently implements a step of the walk along a complete graph) with the search algorithm of [\cite=Reitzner2009] yields a complete implementation of the search for the marked node in such graphs. Fig. [\ref=circuit_complete] presents this implementation, for a single step of the walk. The shifting and coin operations are applied to the topology of the complete graph exactly as with the hypercube. As in the hypercube example above, for a complete graph on N = 2n nodes, O(n) node qubits are required. In this case no particular mapping between the bit strings and the nodes is necessary. Since each node has degree N, O(n) subnode qubits are also required, together with O(n) auxilliary qubits to implement the CnG and Cnπ gates. Hence O(n) = O(log(N)) elementary 2-qubit gates are again sufficient to implement a step of the walk along this family of graphs. The marked node is found with sufficiently high probability after O([formula]) steps (see [\cite=Reitzner2009]), hence in total it requires O([formula] log(N)) 2-qubit quantum gates to locate the marked node.

Twisted toroid

Following on from the discussion of the twisted toroid in [\cite=Douglas2009], we considered the possibility of marked node searching along this family of graphs. Formally, a graph in this family of dimension n  ×  m is constructed by taking an n  ×  m grid, and associating the endpoints with each other as in the construction of a simple toroid, with the modification : {1,j}  ↔  {n,(j + 1)m} and {i,1}  ↔  {(i + 1)n,m}, where '↔  ' denotes an edge. Here {i,j} refers to the corresponding point on the grid, where 1  ≤  i  ≤  n,1  ≤  j  ≤  m. Fig. [\ref=toroid_graph] shows a member of this family of graphs, of dimension 10  ×  10.

This family of graphs is highly symmetric, and can be completely characterized by a small number of parameters (growing logarithmically with the size of the graph). Given this symmetry, it is a good candidate for a graph on which both quantum search and a direct implementation of quantum walks are efficient. We previously showed in [\cite=Douglas2009] that the latter criteria for efficiency holds, in that for a graph of size n a step of an unbiased walk requires O(log(n)) elementary quantum gates. Fig. [\ref=circuit_toroid] extends this result, providing a circuit explicitly performing a step of a search for a marked node, given a twisted toroid of dimension 2n  ×  2m.

For this quantum search, the coin and shifting operator are again defined as in the hypercube example above, with the coin operator applying the Grover coin to every node except the marked node, on which the negative identity operator is applied. Each node has degree 4, and the 'node' states are represented by bit strings comprising the x- and y-coordinates of the grid from which the twisted toroid was constructed, such that the node (i,j) is represented by the bit string (i - 1) concatenated with (j - 1). Hence the shifting operator applied to node (i,j) can be implemented by either incrementing or decrementing the bit string associated with each of i and j (modulo 2n and 2m respectively), depending on the coin state of this node.

Incrementing and decrementing these bit strings is performed by the 'incr' and 'decr' operators in Fig. [\ref=circuit_toroid], each of which can be implemented using O(n2) 2-qubit gates via the circuits of Fig. [\ref=incr_decr]. We are now in a position to calculate an upper bound on the number of 2-qubit gates required to implement Fig. [\ref=circuit_toroid]. For a twisted toroid of dimension 2n  ×  2m, with N = 2n  ×  2m nodes, n 'x-coord' and m 'y-coord' qubits are required, together with 2 'subnode' qubits. The controlled G and π gates are implementable using O(n + m) 2-qubit gates, and since the increment and decrement gates on i qubits require O(i2) 2-qubit gates, the controlled increment and decrement operators are implementable using O(n2m  +  m2n) 2-qubit gates. Note that since the degree of the graph is fixed at 4, only 2 subnode qubits are required regardless of the values of n and m. Hence a step of the quantum walk along a twisted toroid on O(N) nodes can be implemented using O(log(N)) 2-qubit gates.

It remains to show whether or not the circuit of Fig. [\ref=circuit_toroid] can perform an efficient search for the marked node - i.e. whether for a twisted toroid of dimension n  ×  m, the marked node can be found with O([formula]) iterations of this circuit. To examine this, the behaviour of the walk was analyzed for a range of different toroid sizes. Regardless of the size, the search behaviour was in one respect successful, in that the probability to find the walk at the marked node reached a sufficiently high level after a certain number of steps, with fixed periodic behaviour. The approximate number of steps required was found for a range of twisted toroid sizes by calculating the period of the success probability (to find the walk at the marked node) with number of steps. The resulting correlation between toroid size (in number of vertices) and approximate number of steps required to reach maximum success probability is shown in Fig. [\ref=toroid_prob]. These numerical results show that for a twisted toroid with N nodes, O([formula]) steps of the walk are required to find the marked node, matching (up to a constant factor) the theoretical lower bound for unstructured search [\cite=Bennett1997].

Putting these results together, we see that this family of twisted toroids satisfy both criteria for efficient search via quantum walks, yielding for a graph on N nodes both an efficient implementation of the walks themselves (using O(log(N)) 2-qubit gates), and requiring O([formula]) steps of the walk to find a marked node with sufficiently high probability.

Conclusions

The examples given in this paper are intended to provide a 'proof of concept', presenting graphs for which both efficient quantum search and efficient implementation of quantum walks are possible. By explicitly characterising the internal action of the oracle, these circuits provide a practically implementable method to experimentally test these quantum walk based search algorithms. In some previous studies, quantum speedups have been shown relative to oracles that cannot be efficiently implemented. Whilst these studies are very useful from a computational complexity viewpoint, the algorithms involved cannot be practically implemented.