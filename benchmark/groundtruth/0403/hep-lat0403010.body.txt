Systematic errors due to linear congruential random-number generators with the Swendsen-Wang algorithm: A warning

Definition Proposition Proposition Lemma Lemma Conjecture Question Question Problem Problem Theorem Theorem Corollary Corollary Conjecture Conjecture

Introduction

It has been known for about two decades that linear congruential pseudo-random-number generators [\cite=Knuth_81] suffer from strong long-range correlations [\cite=Kalle_84] [\cite=Filk_85] [\cite=Percus_88] [\cite=DeMatteis_88] [\cite=Eichenauer_89]: for instance, generators with modulus m  =  2β have strong correlations at lags that are multiples of 2k whenever the ratio k / β is large enough [\cite=Kalle_84] [\cite=Filk_85] [\cite=Percus_88]. Furthermore, these long-range correlations are known to give rise to systematic errors in Monte Carlo simulations employing local (e.g. Metropolis or heat bath) updates whenever the lattice sites are updated in a fixed order and the number of random numbers used per sweep is a multiple of a large-enough power of 2: this happens because one is using strongly correlated random numbers to update the same lattice sites in successive sweeps (within roughly one autocorrelation time) [\cite=Kalle_84] [\cite=Filk_85] [\cite=Montvay_87] [\cite=Damgaard_88] [\cite=Berg_89] [\cite=Baig_95]. On the other hand, these systematic errors can be eliminated by the simple expedient of throwing away one random number at the end of each lattice sweep [\cite=Kalle_84] [\cite=Filk_85] [\cite=Montvay_87] [\cite=Damgaard_88] [\cite=Berg_89] [\cite=Baig_95].

It has generally been thought that non-local algorithms such as the Swendsen-Wang algorithm [\cite=Swendsen_87] and Wolff's single-cluster variant [\cite=Wolff_89] would be immune to these particular defects of linear congruential generators, inasmuch as they employ random numbers in a highly aperiodic way both in "space" and in "time". We were therefore astonished to find, in our Swendsen-Wang simulation of the three-dimensional Ising model [\cite=Ossola-Sokal], large systematic errors on the 1283 and 2563 lattices that we eventually traced (after much wringing of hands) precisely to long-range correlations in the random-number generator.

Recall that one iteration of the Swendsen-Wang (SW) algorithm consists of two steps: first one updates the bond occupation variables at a fixed configuration of the Ising spin variables; then one computes the connected clusters associated to the bond configuration and updates the Ising spin variables by choosing a new spin value independently for each cluster. The second (spin-update) half of the SW algorithm indeed uses random numbers in a thoroughly aperiodic way, because the cluster sizes and shapes are random. But the first (bond-update) half uses random numbers in a highly structured way: typically one sweeps the bonds of the lattice in some simple fixed order (e.g. lexicographic). Therefore, if the lattice size is very large, the effects of the long-range correlations of the random-number generator can be observed within a single half-sweep: the random numbers used in updating the bonds of one part of the lattice will be strongly correlated with those used elsewhere in the lattice. One may expect this correlation to cause systematic errors particularly if (a) the lattice size is commensurate with the lag giving rise to long-range correlations (e.g. a power of 2), and (b) the system's correlation length is large enough so that the long-range correlations of the random-number generator couple correlated parts of the lattice.

The purpose of this note is, first of all, to provide evidence that such systematic errors can indeed occur and that we have accurately diagnosed their origin; and secondly, to show how the implementation of the Swendsen-Wang algorithm can be modified so as to eliminate (or at least radically reduce) these systematic errors. A more detailed account will be published elsewhere [\cite=systematic_full].

Evidence of systematic errors

We simulated the nearest-neighbor three-dimensional Ising model on an L  ×  L  ×  L simple-cubic lattice with periodic boundary conditions, using the Swendsen-Wang (SW) algorithm [\cite=Swendsen_87]. We studied lattice sizes L = 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256 and performed between 107 and 108 SW iterations for each lattice size. We did all our runs at β  =  0.22165459, which is Blöte et al.'s best estimate of the critical temperature [\cite=Blote_99] and is very near to the estimates by other workers [\cite=Ballesteros_99] [\cite=Hasenbusch_99] (see also the review [\cite=Hasenbusch_01]). We measured a large number of observables, including the susceptibility χ, the second-moment correlation length ξ, the energy E, and the specific heat CH.

In the first version of our program, the random numbers were supplied by a linear congruential generator with modulus m = 248, increment c = 1, and multiplier a = 31167285, 10430376854301, 77596615844045 or 181465474592829. All these multipliers give good results on the spectral test in low dimensions, compared to other multipliers for the same modulus [\cite=Knuth_81] [\cite=Lecuyer_99]. We verified that the runs with the four different multipliers gave results that are consistent within error bars for all the major observables; after making this verification, we averaged all the runs for each L.

The results for the correlation length ξ are reported in the first two columns of Table [\ref=table_3Dising_1]. Finite-size-scaling theory predicts that ξ / L should behave for large L (if indeed we are at the critical temperature) as

[formula]

where [formula] is a universal amplitude ratio characteristic of the given system with periodic boundary conditions, ω is a correction-to-scaling exponent, A is a nonuniversal correction-to-scaling amplitude, and the dots indicate higher-order corrections to scaling. The data in Table [\ref=table_3Dising_1] are qualitatively consistent with ([\ref=def_FSS]), except for the points at L = 128 and L = 256, which show extremely large deviations.

A closer examination of the data in Table [\ref=table_3Dising_1] reveals that the point at L = 192 may also exhibit a small but statistically significant deviation from the fitting curve. To make all these observations more quantitative, let us perform a weighted least-squares fit to ([\ref=def_FSS]) with ω  =  0.82 (the best estimate from [\cite=Blote_99]), using all the data with L min  ≤  L  ≤  96 and varying L min while checking the goodness of fit. A good fit (χ2  =  3.85, 6 DF, confidence level = 70%) can be obtained already with L min  =  8, yielding

[formula]

Not surprisingly, the points L = 4 and L = 6 show significant deviations from the fit curve, due to higher-order corrections to scaling. More surprising are the points L = 128, which lies roughly 3% (≈  79 standard deviations) below the fit curve, and L = 256, which lies a whopping 21% (≈  170 standard deviations) above the fit curve. Obviously something has gone badly wrong! Finally, the point L = 192 lies approximately 0.2% (≈  3 standard deviations) above the fit curve: this may indicate the presence of a small systematic error also for this lattice.

At first we worried whether we had made a programming error that might lead to incorrect results on large lattices (e.g. due to integer overflow). We checked the program carefully and were unable to find any such mistakes. Moreover, the fact that the systematic discrepancy is much smaller (if it exists at all) at L = 192 than at L = 128 suggests that the problem -- whatever its cause -- does not arise solely from the lattice being large.

Intrigued by the fact that these large discrepancies might be arising only at lattice sizes that are large powers of 2 (or perhaps multiples of large powers of 2), we made shorter runs (between 3  ×  104 and 106 SW iterations) at many other lattice sizes -- all multiples of 2 from 4 through 140, and all multiples of 10 through 250 -- in order to check whether any other deviant points could be found. The upshot is that -- to within the statistical error of these shorter runs, which ranges from 0.2% on small lattices to 1% at L  ≈  128 to an admittedly rather crude 2.3% on the largest lattices -- there are no detectable discrepancies except at L = 128 and 256.

At L = 128 and L = 256 we found discrepancies not only for the correlation length but also for the susceptibility, the energy and the specific heat. It is a curious fact, however, that all the Fortuin-Kasteleyn identities [\cite=Salas-Sokal_00] are verified perfectly (to within statistical error). This contrasts with the systematic errors found by Damgaard and Heller [\cite=Damgaard_88] in a Metropolis Monte Carlo simulation of the U(1) Higgs model, where a Ward identity was violated by up to 10 standard deviations, and those found by Ballesteros and Martín-Mayor [\cite=Ballesteros_98] in a Wolff single-cluster simulation of the two- and three-dimensional Ising models, in which Schwinger-Dyson identities were violated by up to 8 standard deviations.

For several weeks we had no idea what might be causing the systematic discrepancies at L = 128 and L = 256. (We felt like a detective with a corpse on his hands but no suspect and no modus operandi.) But then we realized, as explained in the Introduction, that long-range correlations in the random-number generator could cause undesired correlations within a single bond-update sweep.

Variant simulations

In order to test whether our proposed explanation for the systematic errors is the correct one, we ran variant simulations in which two aspects of the simulation were systematically altered: the modulus m = 2β of the random-number generator (β = 16, 20, 24, 28, 32, 40, 48, 60, 63, 64), and the manner in which the random numbers are used within the bond-update subroutine. The latter test is essential if we are to prove not only that the trouble comes from the random-number generator, but more specifically that it comes from the way that the random numbers are used in the bond-update subroutine.

All of the multipliers used here give good results on the spectral test in low dimensions compared to other multipliers for the same modulus. The purpose of trying random-number generators with less than 48 bits was to induce systematic errors on small lattices where they could be studied quantitatively to high precision and compared with those observed with the 48-bit generator on larger lattices. The purpose of trying random-number generators with 60/63/64 bits was, of course, to provide a standard of comparison in which the systematic error is eliminated or at least radically reduced.

We also tried three variants of the bond-update subroutine:

Standard: This is our original program, in which the bonds are updated in lexicographic order, and one random number is used per bond.

Aperiodic: Here the bonds are again updated in lexicographic order, but a random number is used only if the two spins are equal. (If the two spins are unequal, the corresponding bond is automatically left unoccupied, so no random number is needed.) If our explanation of the cause of the systematic errors is correct, this strategem should eliminate the systematic errors on lattices that are multiples of large powers of 2, though it may conceivably shift those systematic errors to other lattice sizes (namely, those for which the lattice size, multiplied by the fraction of nearest-neighbor spins that are equal, yields a suitable "resonance").

Shuffle: The bonds are updated in a random order. If our explanation of the cause of the systematic errors is correct, this strategem should entirely eliminate the systematic errors, even with a relatively poor (e.g. 32-bit) random-number generator.

Our first version of the "shuffle" subroutine permuted the array containing the bond indices. Unfortunately, this program ran very slowly -- about a factor of 2 slower than the "standard" version at L = 16, growing to a factor ≈  8 at L = 256 -- probably because the highly nonlocal access to the bond array caused a large number of cache misses. Our second version permuted instead the array of random numbers; this is statistically equivalent but allows the bond array to be accessed in sequential order. This program ran less slowly: once again about a factor of 2 slower than the "standard" version at L = 16, but growing only to a factor ≈  4 at L = 256.

The results of all these variant simulations, carried out on lattice sizes L = 8,16,32,64,96,128,192,256, will be reported elsewhere [\cite=systematic_full]; here we provide only a brief summary. We find that the 60/63/64-bit generators give consistent results (within statistical error) for all three variants of the bond-update subroutine, confirming our expectation that they exhibit negligible systematic error on lattices L  ≤  256. By contrast, each "standard" algorithm with ≤  48 bits exhibits detectable systematic errors whenever the lattice size L is a multiple of a sufficiently large power of 2; how large depends on the modulus. More precisely, the 16-bit (resp. 20-bit, 24-bit, 28-bit, 32-bit, 40-bit, 48-bit) standard algorithm exhibits detectable systematic errors whenever L is a multiple of 8 (resp. 8, 8, 16, 32, 64, 128). In addition, the 48-bit "standard" algorithm at L = 192 shows a discrepancy of almost 3σ, which may indicate a systematic error. No other statistically significant discrepancies are observed.

We conclude that, if one wants to use a linear congruential generator with the Swendsen-Wang algorithm, the safest approach is to use a generator of 64 bits (or more) together with the "shuffle" bond update. Unfortunately, the shuffle method is somewhat slow. A much faster -- and, as far as we can tell, also safe -- method is to use a 64-bit generator together with the "aperiodic" bond update.

Despite the known problems of linear congruential generators arising from long-range correlations, there are still several advantages in using them. First, they are relatively cheap in terms of CPU time, and are convenient for use in a series of successive runs because the complete state of the generator can be saved in a single computer word. More importantly, they are well understood theoretically, as regards both short-range [\cite=Knuth_81] and long-range [\cite=Kalle_84] [\cite=Filk_85] [\cite=Percus_88] [\cite=DeMatteis_88] [\cite=Eichenauer_89] [\cite=systematic_full] correlations; in particular, excellent equidistribution of t-tuples of successive random numbers for small t can be achieved by careful choice of the multiplier. By contrast, for more exotic random-number generators (e.g. combination generators), the problems may not be absent, but simply hidden.

A more detailed analysis of these simulations will be published elsewhere [\cite=systematic_full], along with a discussion of the advantages and disadvantages of linear congruential versus other types of pseudo-random-number generators (see also [\cite=Ferrenberg_92] [\cite=Vattulainen_94] [\cite=Coddington_94] [\cite=Ballesteros_98]).