=0pt

Thesis Definition Lemma NotationCorollary Proposition Convention Example Remark Fact Exercise Open Problem Conjecture

The countable versus uncountable branching recurrences in computability logic

Supported by NNSF (60974082) of China.

MSC: primary: 03B47; secondary: 03B70; 68Q10; 68T27; 68T15.

Keywords: Computability logic; Cirquent calculus; Interactive computation; Game semantics; Resource semantics.

Introduction

Computability logic (CoL), introduced by G. Japaridze [\cite=Jap03] [\cite=Japfin], is a formal theory of interactive computational problems, understood as games between a machine and its environment (symbolically named as [formula] and [formula], respectively). Formulas in it represent such problems, logical operators stand for operations on them, and "truth" means existence of an algorithmic solution, i.e. [formula]'s effective winning strategy.

Among the most important operators of CoL are recurrence operators, in their overall logical spirit reminiscent of the exponentials of linear logic. Recurrences, in turn, come in several flavors, two most natural and basic sorts of which are countable branching recurrence [formula] and uncountable branching recurrence [formula], together with their duals [formula] defined by [formula] and [formula]. Intuitive discussions and elaborations on the two sorts of recurrences and the relations between them were given in [\cite=Japfour] [\cite=Japsep] [\cite=Mosc]. However, finding syntactic characterizations of the logic induced by recurrences had remained among the greatest challenges in CoL until the recent work [\cite=Japtam] [\cite=Japtam2], where a sound and complete axiomatization, called CL15, for the basic [formula]fragment of computability logic was constructed. At the same time, the logical behavior of countable branching recurrence [formula] still remains largely ununderstood. It is not even known whether the set of principles validated by [formula] is recursively enumerable. The present paper brings some initial light into this otherwise almost completely dark picture. It introduces a new simplified definition of [formula] and proves that the new version of [formula] is logically equivalent to the old one originally introduced in [\cite=Japfour]. Relying on this equivalence, the paper then shows that the set of principles validated by [formula] in combination with the basic operations [formula] is a proper superset of the set of those validated by ,. This is achieved by positively settling Conjecture 6.4 of [\cite=Japtam], according to which CL15 continues to be sound--but not complete-- with [formula] and [formula] instead of [formula] and [formula]. Further, to make our investigation of the relationship between [formula] and [formula] more complete, at the end of this paper we also prove that [formula] is strictly weaker than [formula] in the sense that F logically implies [formula] but not vice versa.

CL15 is a system built in cirquent calculus. The latter is a refinement of sequent calculus. Unlike the more traditional proof theories that manipulate tree-like objects (formulas, sequents, hypersequents, etc.), cirquent calculus deals with graph-style structures called cirquents (the term is a combination of "CIRcuit" and "seQUENT"), with its main characteristic feature being allowing to explicitly account for possible sharing of subcomponents between different subcomponents. The approach was introduced by Japaridze in [\cite=Cirq] as a new deductive tool for CoL and was further developed in [\cite=Cirdeep] [\cite=fromto] [\cite=wenyan1] [\cite=wenyan2] where a number of advantages of this novel sort of proof theory were revealed, such as high expressiveness, flexibility and efficiency.

In order to make this paper reasonably self-contained, in Section 2 we reproduce the basic concepts from [\cite=Japfin] [\cite=Japtam] on which the later parts of the paper will rely, including the old version of [formula] and its dual [formula]. An interested reader may consult [\cite=Japfin] [\cite=Japtam] for detailed explanations, illustrations and examples. In Section 3 we define the earlier-mentioned simplified version of [formula], and prove its equivalence to the old one. In Section 4 we prove that the set of principles validated by the operators [formula] is a proper superset of the set of those validated by [formula]. Finally, in Section 5, we show that [formula] is strictly weaker than [formula].

Preliminaries

The letter [formula] is used as a variable ranging over [formula], with [formula] meaning [formula]'s adversary. A move is a finite string over standard keyboard alphabet. A labmove is a move prefixed ("labeled") with [formula] or [formula]. A run is a finite or infinite sequence of labmoves, and a position is a finite run. Runs are usually delimited by "〈" and "〉", with 〈〉 thus denoting the empty run. For any run Γ, [formula] is the same as Γ, with the only difference that every label [formula] is changed to [formula].

A game is a pair [formula], where: (1) [formula] is a set of runs satisfying the condition that a finite or infinite run Γ is in [formula] iff so are all of Γ's nonempty finite initial segments. If [formula], then Γ is said to be a legal run of A; otherwise Γ is an illegal run of A. A move α is a legal move for a player [formula] in a position Φ of A iff [formula]; otherwise α is an illegal move. When the last move of the shortest illegal initial segment of Γ is [formula]-labeled, Γ is said to be a [formula]-illegal run of A. (2) [formula] is a function that sends every run Γ to one of the players [formula] or [formula], satisfying the condition that if Γ is a [formula]-illegal run of A, then [formula]. When [formula], Γ is said to be a [formula]-won run of A.

The game operations dealt with in the present paper are [formula] (negation), [formula] (parallel disjunction), [formula] (parallel conjunction), [formula] (countable branching recurrence), [formula] (countable branching corecurrence), [formula] (uncountable branching recurrence) and [formula] (uncountable branching corecurrence).

Intuitively, [formula] is a role switch operator: [formula] is the game A with the roles of [formula] and [formula] interchanged ([formula]'s legal moves and wins become those of [formula], and vice versa). Both [formula] and [formula] are games playing which means playing the two components A and B simultaneously (in parallel). In [formula], [formula] is the winner if it wins in both components, while in [formula] winning in just one component is sufficient.

Next, as originally defined in [\cite=Japfour], a play of [formula] (resp. [formula]) starts as an ordinary play of A. At any time, however, the player [formula] (resp. [formula]) may make a "replicative move" to create two copies of the current position Φ of A. This makes the game turn into two parallel games that continue from the same position Φ. The bits 0 and 1 are used to denote those two threads. Generally, at any time, [formula] (resp. [formula]) may (further) split any existing thread w into two threads w0 and w1. Each thread in the eventual run of the game will be thus denoted by a (possibly infinite) bitstring, where a bitstring is a finite or infinite sequence of bits 0,1. A bitstring w is said to be essentially finite if it contains only a finite number of "1"s; otherwise w is said to be essentially infinite. In [formula], [formula] is the winner if it wins A in all infinite but essentially finite threads, while in [formula] winning in just one such thread is sufficient. Since there are only countably many essentially finite bitstrings, only countably many runs of A are relevant when playing [formula] or [formula]. This is the intuitive explanation of what we called "the old version" of [formula] (resp. [formula]) in the introduction.

Finally, the game A (resp. A) is the same as the game [formula] (resp. [formula]), with the only difference that, when determining the winner, all--essentially finite or essentially infinite--threads are relevant. Since there are uncountably many infinite bitstrings, uncountably many parallel runs of A may be generated when playing A or A. We also call this version of [formula] (resp. [formula]) the "old" version found in [\cite=Jap03] [\cite=Japfin]. Because recently a new simplified version of uncountable branching (co)recurrence was introduced in [\cite=Japface]. It is different from yet equivalent to (in all relevant respects) the above old version. Specifically, both (the new versions of) A and A are games playing which means simultaneously playing a continuum of copies (or "threads") of A. Each copy/thread is denoted by an infinite bitstring and vice versa. Making a move w.α, where w is a finite bitstring, means making the move α simultaneously in all threads of the form wy. In A, [formula] is the winner iff it wins in all threads of A, while in A winning in just one thread is sufficient. It should be noted that, when dealing with the uncountable branching (co)recurrence in this paper, we exclusively employ the new version of it.

Let Γ be a run and α be a move. The notation Γα will be used to indicate the result of deleting from Γ all moves (together with their labels) except those that look like αβ for some move β, and then further deleting the prefix "α" from such moves. For instance, [formula].

Let Θ be a run and x be an infinite bitstring. The notation [formula] will be used to indicate the result of deleting from Θ all moves (together with their labels) except those that look like u.β for some move β and some finite initial segment u of x, and then further deleting the prefix "u." from such moves. For instance, [formula].

The earlier-outlined intuitive characterizations of the game operators are captured by the following formal definition. Below, A, A1, A2 are arbitrary games, α ranges over moves, i∈{1,2}, s ranges over finite bitstrings, x ranges over infinite bitstrings, Γ is an arbitrary run, and Ω is any legal run of the game that is being defined. 1. [formula] (negation) is defined by:

(i) [formula] iff [formula].

(ii) [formula] iff [formula]. 2. [formula] (parallel conjunction) is defined by:

(i) [formula] iff every move of Γ is i.α for some i,α and, for both i, [formula].

(ii) [formula] iff, for both i, [formula]. 3. [formula] (parallel disjunction) is defined by:

(i) [formula] iff every move of Γ is i.α for some i,α and, for both i, [formula].

(ii) [formula] iff, for some i, [formula]. 4. A (uncountable branching recurrence) is defined by:

(i) [formula] iff every move of Γ is s.α for some s,α and, for all x, [formula].

(ii) [formula] iff, for all x, [formula]. 5. A (uncountable branching corecurrence) is defined by:

(i) [formula] iff every move of Γ is s.α for some s,α and, for all x, [formula].

(ii) [formula] iff, for some x, [formula]. 6. [formula] (countable branching recurrence) is defined as follows. There are two types of legal moves in legal positions of [formula]: replicative and non-replicative. What is called a node of the underlying BT-structure of [formula], where Φ is a position, is a bitstring w such that w is either empty, or else is u0 or u1 for some bitstring u such that Φ contains the move u:. Such a node is said to be a leaf iff it is not a proper prefix of any other node of the underlying BT-structure of [formula]. There are two sorts of legal moves in every position: replicative and non-replicative. A replicative move can only be made by [formula], and such a move in a given position Φ should be w:, where w is a leaf of the underlying BT-structure of [formula]. As for non-replicative moves, they can be made by either player. Such a move by a player [formula] in a given position Φ should be w.α, where w is a node of the underlying BT-structure of [formula] and α is a move such that, for any infinite extension v of w, α is a legal move by [formula] in the position [formula] of A. A legal run Γ of [formula] is won by [formula] iff, for every infinite but essentially finite bitstring v, [formula] is a [formula]-won run of A. 7. [formula] (countable branching corecurrence) is defined in a symmetric way to [formula], by interchanging [formula] with [formula]. Equivalently, it can be simply defined by [formula].

In what follows, we explain--formally or informally--several additional concepts relevant to our proofs.

(1) Static games: CoL restricts its attention to a special yet very wide subclass of games termed "static". Intuitively, static games are interactive tasks where the relative speeds of the players are irrelevant, as it never hurts a player to postpone making moves. For either player [formula], a run Ω is said to be a [formula]-delay of a run Γ iff for both players [formula], the subsequence of [formula]-labeled moves of Ω is the same as that of Γ, and for any n,k  ≥  1, if the n'th [formula]-labeled move is made later than (is to the right of) the k'th [formula]-labeled move in Γ, then so is it in Ω. For instance, the run [formula] is a [formula]-delay of the run [formula]. A run is said to be [formula]-legal iff it is not [formula]-illegal. Finally, a game A is said to be static iff, whenever a run Ω is a [formula]-delay of a run Γ, we have: if Γ is a [formula]-legal run of A, then so is Ω; if Γ is a [formula]-won run of A, then so is Ω. It is known ([\cite=Jap03] [\cite=Japfin] [\cite=Japface]) that the class of static games is closed under the operations [formula] (as well as any other game operations studied in CoL).

(2) EPM and BMEPM: CoL understands [formula]'s effective strategies as interactive machines. Several sorts of such machines have been proposed and studied in CoL, all of them turning out to be equivalent in computing power once we exclusively consider static games. In this paper we will use two sorts of such machines, called the easy-play machine (EPM) and the block-move EPM (BMEPM). Both of them are sorts of Turing machines with the additional capability of making moves, and have two tapes: the ordinary read/write work tape, and the read-only run tape. The run tape serves as a dynamic input, at any time ("clock cycle") spelling the current position: every time one of the players makes a move, that move--with the corresponding label--is automatically appended to the content of this tape. An EPM is the machine where either player can make at most one move on a given clock cycle, but the environment can move only when the machine explicitly allows it to do so (this sort of an action is called granting permission ); an BMEPM only differs from an EPM in that either player can make any finite number of moves at once.

(3) Strategies: Let M be an EPM or BMEPM. A configuration of M is a full description of the current state of the machine, the contents of its two tapes, and the locations of the corresponding two scanning heads. The initial configuration is the configuration where M is in its start state and both tapes are empty. A configuration C' is said to be an successor of a configuration C if C' can legally follow C in the standard sense, based on the (deterministic) transition function of the machine and accounting for the possibility of nondeterministic updates of the content of the run tape. A computation branch of M is a sequence of configurations of M where the first configuration is the initial configuration, and each other configuration is a successor of the previous one. Each computation branch B of M incrementally spells a run Γ on the run tape, which is called the run spelled by B. Subsequently, any such run Γ will be referred to as a run generated by M. A computation branch B of M is said to be fair iff, in it, permission has been granted infinitely many times. An algorithmic solution ( [formula]'s winning strategy) for a given game A is understood as an EPM or BMEPM M such that, whenever B is a computation branch of M and Γ the run spelled by B, Γ is a [formula]-won run of A, where B should be fair unless Γ is a [formula]-illegal run of A. When the above is the case, we say that M wins A. It is known ([\cite=Japtowards]) that the two sorts of machines win the same static games. And since all games we ever deal with in this paper are static, in the following we may simply say "a machine M" without being specific about whether it is an EPM or BMEPM.

Now about formulas and the underlying semantics. We have some fixed set of syntactic objects, called atoms, for which P, Q, R will be used as metavariables. A formula is built from atoms in the standard way using the connectives [formula],[formula],[formula],[formula],[formula],[formula],[formula], with F  →  G understood as an abbreviation for [formula] and [formula] limited only to atoms, where [formula] is understood as F, [formula] as [formula], [formula] as [formula], [formula] as [formula], [formula] as [formula], [formula] as [formula], and [formula] as [formula]. A [formula]-formula is one not containing [formula],[formula]. Similarly, a [formula]-formula is one not containing [formula],[formula]. An interpretation is a function * that sends every atom P to a static game P*, and extends to all formulas by seeing the logical connectives as the same-name game operations. A formula F is uniformly valid, symbolically F, iff there is a machine M, called a uniform solution of F, such that, for every interpretation *, M wins F*.

As noted in Section 1, CL15 is built in cirquent calculus for the basic [formula]-fragment of CoL, whose formalism goes beyond formulas. In what follows in this paragraph, by a "formula", we mean one of the [formula]-formulas. A cirquent is a triple [formula] where: (1) [formula] is a nonempty finite sequence of formulas, whose elements are said to be the oformulas of C. Here the prefix "o" is used to mean a formula together with a particular occurrence of it in [formula]. For instance, if [formula], then the cirquent has three oformulas while only two formulas. (2) Both [formula] and [formula] are nonempty finite sequences of nonempty sets of oformulas of C. The elements of [formula] are said to be the undergroups of C, and the elements of [formula] are said to be the overgroups of C. Again, two undergroups (resp. overgroups) may be identical as sets (have identical contents), yet they count as different undergroups (resp. overgroups) because they occur at different places in [formula] (resp. [formula]). (3) Additionally, every oformula is required to be in at least one undergroup and at least one overgroup.

Rather than writing cirquents as ordered tuples in the above style, we prefer to represent them through (and identify them with) diagrams. Below is such a representation for the cirquent that has four oformulas H,F,E,F, three undergroups {H,F}, {F,E}, {F} and three overgroups {H,F,E}, {E}, {F}.

Each group in the cirquent/diagram is represented by (and identified with) a [formula], where the arcs (lines connecting the [formula] with oformulas) are pointing to the oformulas that the given group contains.

There are ten inference rules in CL15. Below we reproduce those rules from [\cite=Japtam] with [formula] and [formula] rewritten as [formula] and [formula], respectively. To semantically differentiate the two versions of CL15 (when necessary), we may use the name [formula] for the system that understands (and writes) the recurrence operator as [formula], and use [formula] for the system that understands (and writes) the recurrence operator as [formula]. Correspondingly, throughout the rest of this section, by a "formula", we mean one of the [formula]-formulas.

Axiom (A): Axiom is a "rule" with no premises. It introduces the cirquent

[formula], where n is any positive integer, and [formula] are any formulas. All rules other than Axiom take a single premise.

Exchange (E): This rule comes in three versions: Undergroup Exchange, Oformula Exchange and Overgroup Exchange. The conclusion of Oformula Exchange is obtained by interchanging in the premise two adjacent oformulas E and F, and redirecting to E (resp. F) all arcs that were originally pointing to E (resp. F). Undergroup (resp. Overgroup) Exchange is the same, with the only difference that the objects interchanged are undergroups (resp. overgroups).

Duplication (D): This rule comes in two versions: Undergroup Duplication and Overgroup Duplication. The conclusion of Undergroup Duplication is obtained by replacing in the premise some undergroup U with two adjacent undergroups whose contents are identical to that of U. Similarly for Overgroup Duplication.

Merging (M): The conclusion of this rule can be obtained from the premise by merging any two adjacent overgroups O1 and O2 into one overgroup O, and including in O all oformulas that were originally contained in O1 or O2 or both.

Weakening (W): For the convenience of description, we explain this and the remaining rules in the bottom-up view. The premise of this rule is obtained by deleting in the conclusion an arc between some undergroup U with ≥  2 elements and some oformula F; if U was the only undergroup containing F, then F should also be deleted, together with all arcs between F and overgroups; if such a deletion makes some overgroups empty, then they should also be deleted.

Contraction (C): The premise of this rule is obtained by replacing in the conclusion an oformula [formula] by two adjacent oformulas [formula] and [formula], and including both of them in exactly the same undergroups and overgroups in which the original [formula] was contained.

Disjunction introduction ([formula]): The premise of this rule is obtained by replacing in the conclusion an oformula [formula] by two adjacent oformulas E and F, and including both of them in exactly the same undergroups and overgroups in which the original [formula] was contained.

Conjunction introduction ([formula]): According to this rule, if a cirquent (the conclusion) has an oformula [formula], then the premise can be obtained by splitting the original [formula] into two adjacent oformulas E and F, including both of them in exactly the same overgroups in which the original [formula] was contained, and splitting every undergroup Γ that originally contained [formula] into two adjacent undergroups ΓE and ΓF, where ΓE contains E (but not F), and ΓF contains F (but not E), with all other ([formula]) oformulas of Γ contained by both ΓE and ΓF.

Recurrence introduction ([formula]): The premise of this rule is obtained by replacing in the conclusion an oformula [formula] by F, with all arcs unchanged, and inserting a new overgroup Γ that contains F as its only oformula.

Corecurrence introduction ([formula]): The premise of this rule is obtained by replacing in the conclusion an oformula [formula] by F, with all arcs unchanged, and additionally including F in any (possibly zero) number of the already existing overgroups.

Below we provide illustrations for all rules, in each case an abbreviated name of the rule standing next to the horizontal line separating the premise from the conclusion. Our illustration for the axiom (the "A" labeled rule) is a specific cirquent where n = 2; our illustrations for all other rules are merely examples chosen arbitrarily. Unfortunately, no systematic ways for schematically representing cirquent calculus rules have been elaborated so far. This explains why we appeal to examples instead.

The above are all ten rules of CL15[formula]. A CL15[formula]-proof (or simply a proof) of a cirquent C is a sequence [formula] of cirquents, where n  ≥  1, such that Cn = C, C1 is an axiom, and Ci (1 < i  ≤  n) follows from Ci - 1 by one of the rules of CL15[formula]. For any formula F, the expression [formula] is used to denote the cirquent (〈F〉,〈{F}〉,〈{F}〉). Then a CL15[formula]-proof (or simply a proof) of a formula F is stipulated to be a proof of the cirquent [formula]. A formula or cirquent X is provable, symbolically CL15[formula], iff it has a proof.

As mentioned, CL15() is the same as CL15[formula], only with , instead of [formula].

(Japaridze [\cite=Japtam] [\cite=Japtam2]) A [formula]-formula is uniformly valid iff it is provable in CL15().

A new version of the countable branching recurrence

As we have seen in the preceding section, the existing definition of [formula] is relatively intricate, which considerably impedes the task of understanding this sort of recurrence. So, in this section we introduce a new simplified--yet equivalent to the old--version of the countable branching recurrence. In order to avoid confusion, when necessary, we shall use [formula], [formula] for the new versions of [formula],[formula], and use [formula], [formula] for the old ones. The same notation applies to any formula F, where FT is the result of replacing in F all occurrences of [formula] (resp. [formula]) by [formula] (resp. [formula]), and FL is the result of replacing in F all occurrences of [formula] (resp. [formula]) by [formula] (resp. [formula]). Here, as understood, we extend the earlier-defined concept of a formula so that now a formula may contain either version [formula],[formula] of [formula] and/or either version [formula],[formula] of [formula]. The semantics of formulas and, particularly, the concept of uniform validity extend to this broader class of formulas in a straightforward/expected way.

As mentioned earlier, the old version of [formula] only differs from the old version of [formula] in that, when determining the winner, only essentially finite threads are relevant. On the other hand, the paper [\cite=Japface] has completed the task of replacing the old "canonical" definition of [formula] by a new, simple and compact, definition of [formula] as we have seen in Section 2. For these reasons, the new definition of [formula], that we will introduce in the following, follows the same idea of the new definition of [formula], only with "infinite but essentially finite bitstrings" instead of "infinite bitstrings", when determining the winner.

Below A is an arbitrary game, α ranges over moves, w ranges over finite bitstrings, x ranges over infinite bitstrings, v ranges over infinite but essentially finite bitstrings, Γ is any run, and Ω is any legal run of the game that is being defined.

1. [formula] is defined by:

2. [formula] is defined by:

It is obvious that [formula] is the dual operation of [formula] with [formula]. In what follows, we first prove that [formula] and [formula] preserve the static property of games, and then show that [formula] and [formula] are logically equivalent to [formula] and [formula], respectively.

Assume A is a static game, Ω is a [formula]-delay of Γ, and Ω is a [formula]-illegal run of A. Then Γ is also a [formula]-illegal run of A.

The class of static games is closed under [formula] and [formula].

Since [formula] can be expressed through [formula] and [formula], with [formula] already known ([\cite=Jap03]) to preserve the static property of games, we need only to consider [formula]. In what follows, A is a static game. We want to show that [formula] is also static.

Assume Γ is a [formula]-legal run of [formula], and Ω is a [formula]-delay of Γ. We need to show that Ω is also a [formula]-legal run of [formula]. Since the legal runs of [formula], by Definition [\ref=def], are the same as the legal runs of A, Lemma [\ref=Japlegal] still holds with [formula] instead of A. So, by this lemma with [formula] instead of A, we immediately get that Ω is a [formula]-legal run of [formula].

Assume Γ is a [formula]-won run of [formula], and Ω is a [formula]-delay of Γ. We will show that Ω is also a [formula]-won run of [formula], thus completing our proof of the promise. If Ω is a [formula]-illegal run of [formula], then Ω is won by [formula] as promised. Assume that Ω is not [formula]-illegal, i.e., Ω is [formula]-legal. Then we claim that Γ is also [formula]-legal. First, by Lemma 4.6 of [\cite=Jap03], Ω is a [formula]-delay of Γ implies that Γ is a [formula]-delay of Ω. Next, if Γ is a [formula]-illegal run of [formula], by Lemma [\ref=Japlegal] with [formula] instead of A, Ω is also a [formula]-illegal run of [formula], contrary to our assumption. Hence, Γ is [formula]-legal. On the other hand, since Γ is a [formula]-won run of [formula], it is obvious that Γ is a [formula]-legal run of [formula]. Then, by the previously proven fact, Ω is also a [formula]-legal run of [formula]. Thus, both Γ and Ω are legal runs of [formula]. But Γ being a legal, [formula]-won run of A means that, for every (if [formula]) or some (if [formula]) infinite but essentially finite bitstring v, [formula] is a [formula]-won run of A. Therefore, as A is static and [formula] is obviously a [formula]-delay of [formula], [formula] is also a [formula]-won run of A. Hence Ω is a [formula]-won run of [formula].

For any formula F, the formulas [formula] and [formula] are uniformly valid.

Our proof here almost literally follows the proof of Theorem 4.1 of [\cite=Japface].

Firstly, we prove the uniform validity of [formula], which means that we should construct an EPM M1 such that, for any static game A, M1 wins [formula], i.e. [formula]. Such an EPM (strategy) M1 can be constructed as a machine that repeats the following routine over and over again (possibly infinitely many times). At any step of the strategy, Ψ denotes Φ1., where Φ is the then-current position of the play. That is, Ψ is the then-current position in the [formula] component of the overall game.

ROUTINE: Keep granting permission until the adversary makes a move α satisfying the conditions of one of the following two cases, and then act as prescribed in that case.

Case 1: α is a move w.β in [formula], where w is a finite bitstring. Make the same move w.β in [formula].

Case 2: α is a move w.β in [formula], where w is a finite bitstring. Make a series of replicative moves in [formula] if necessary, so that w becomes a node of the underlying BT-structure of [formula]. Then make the move w.β in [formula].

Let Γ be any run that could be generated by such M1. According to the description of ROUTINE, M1 (in the role of [formula]) does not make any illegal moves unless its adversary does so first. So, if Γ is an illegal run of [formula], then it is [formula]-illegal and hence [formula] is the winner. Suppose now Γ is a legal run of [formula]. Let Σ  =  Γ1. and Π  =  Γ2.. In other words, Σ is the run that took place in the [formula] component, and Π is the run that took place in the [formula] component. If for all infinite but essentially finite bitstrings v, [formula] is a [formula]-won run of A, then [formula] wins the whole game [formula] because it wins the component [formula]. Now assume there exists an infinite but essentially finite bitstring v such that [formula] is a [formula]-won run of A. From the above strategy we can see that the run taking place in thread v of [formula] is the same as the run taking place in thread v of A, with the only difference that [formula] and [formula] are interchanged. That is, [formula]. Therefore, [formula] is a [formula]-won run of [formula], and hence Σ is a [formula]-won run of [formula], and hence Γ a [formula]-won run of the overall game [formula].

Secondly, we show that the formula [formula] is uniformly valid, meaning that there exists an EPM/strategy M2 that wins [formula] for any static game A. Such a strategy M2 repeats the following routine over and over again. At any step of the strategy, Ψ denotes Φ2., where Φ is the then-current position of the play. In other words, Ψ is the then-current position of the component [formula]. Furthermore, a function f from the leaves v of the underlying BT-structure of [formula] to finite bitstrings f(v) is maintained by M2 such that, for any two leaves v1  ≠  v2, f(v1) is not a prefix of f(v2). At the beginning, i.e. when Ψ is empty, of the play, the empty string ε is the only leaf of the underlying BT-structure of [formula], and the value of f(ε) is initialized to ε.

ROUTINE: Keep granting permission until the adversary makes a move α satisfying the conditions of one of the following three cases, and then act as that case prescribes. In what follows, w ranges over finite bitstrings.

Case 1: α is a replicative move w: in [formula]. Let v = f(w). Then update f by setting f(w0) = v0,f(w1) = v1, with the value of f on any other leaves of the underlying BT-structure of [formula] unchanged, and do not make any moves.

Case 2: α is a non-replicative move w.β in [formula]. Let [formula] be all leaves u of the underlying BT-structure of [formula] such that w is a prefix of u, and let [formula]. Then make the series of moves [formula] in [formula], leaving the value of f unchanged.

Case 3: α is a move w.β in [formula]. First assume that there is a unique leaf x in the underlying BT-structure of [formula] such that w is a proper extension of f(x). Let v = f(x), and w = vu for some nonempty finite bitstring u. If there is a "1" in u, then ignore the move α, leaving the value of f unchanged and making no moves. If there is no "1" in u, i.e. there are only "0"s in u, then update f by letting f(x) = w without changing the value of f on any other leaves, and make the move x.β in [formula]. Now assume that there is no leaf x in the underlying BT-structure of [formula] such that w is a proper extension of f(x). Let [formula] (possibly n = 0) be all leaves y of the underlying BT-structure of [formula] such that w is a prefix of f(y). Then make the series of moves [formula] in [formula] and leave the value of f unchanged.

Consider any run Γ that could be generated by the above machine M2. We may, again, assume that Γ is a legal run of [formula], for otherwise it is [formula]-illegal and hence [formula]-won. Let Σ  =  Γ1. and Π  =  Γ2.. In other words, Σ is the run that took place in [formula], and Π is the run that took place in [formula]. For a number i such that ROUTINE is iterated at least i times, we use fi to denote the value of f at the beginning of the i'th iteration, and use Ψi to denote the position reached by that time in the [formula] component.

Let v be any infinite but essentially finite bitstring. Suppose that [formula] is a [formula]-won run of A (if there is no such v, then [formula] wins the overall game [formula], as desired). Let z be an infinite bitstring satisfying the following condition: for any i such that ROUTINE is iterated at least i times, we have that fi(vi) is a prefix of z, where vi is the unique prefix of v such that vi is a leaf of the underlying BT-structure of [formula]. From the description of ROUTINE, we see that the following property of f is maintained: for any two finite bitstrings x1 and x2, if [formula], then [formula]. For any given v and any i in the previous sense, we have [formula], and hence [formula]. Therefore, a z satisfying the above condition indeed exists.

From the description of ROUTINE we can see that what happened in thread z of [formula] is the same as what happened in thread v of A with [formula] interchanged with [formula]. Namely, [formula]. Therefore, [formula] is a [formula]-won run of [formula]. All that is left to show is that z is essentially finite. According to the description of ROUTINE, the steps making z different from v could occur in Case 3. But Case 3 could only make z different from v in that z can be obtained by inserting in v some "0"s between some two "1"s. Namely, the number of "1"s in z is the same as that of "1"s in v. So, due to the essential finiteness of v, z is also essentially finite. Hence Σ is a [formula]-won run of [formula], and hence Γ a [formula]-won run of [formula], which ends our proof.

Any formula of the form [formula] is uniformly valid.

To prove the uniform validity of [formula], we should construct an EPM M such that, for any static game A, M wins [formula], i.e. [formula]. The work of such an EPM (strategy) M is very simple. It keeps granting permission, and whenever the adversary makes a move 1.w.α for some finite bitstring w and some move α, it makes the move 2.w.α, and vice versa: whenever the adversary makes a move 2.w.α, it makes the move 1.w.α.

Consider any run Γ generated by M. It is obvious that M never makes illegal moves unless its adversary does so first. Hence we may safely assume that Γ is a legal run of [formula]. Let Σ  =  Γ1. and Π  =  Γ2.. In other words, Σ is the run that took place in the [formula] component, and Π is the run that took place in the [formula] component. If for all infinite but essentially finite bitstrings v, [formula] is a [formula]-won run of A, then [formula] wins the whole game [formula] because it wins the [formula] component. Now assume there exists an infinite but essentially finite bitstring v such that [formula] is a [formula]-won run of A. From the above strategy we can see that the run took place in thread v of [formula] is the same as the run that took place in thread v of A, with the only difference that [formula] and [formula] are interchanged. Namely, [formula]. Therefore, [formula] is a [formula]-won run of [formula], and hence Σ is a [formula]-won run of [formula], and hence Γ a [formula]-won run of the overall game [formula].

Any formula of the form [formula] is uniformly valid.

To prove the uniform validity of [formula], we should construct an EPM M such that, for any static games A and B, M wins [formula], i.e. [formula]. Such an EPM M works as follows. It keeps granting permission. Whenever the adversary makes a move 1.w.1.α, where w is some finite bitstring and α is some move, it makes a move 2.1.w.α; whenever the adversary makes a move 1.w.2.α, it makes a move 2.2.w.α. And vice versa: whenever the adversary makes a move 2.1.w.α for some finite bitstring w and some move α, it makes a move 1.w.1.α; whenever the adversary makes a move 2.2.w.α, it makes a move 1.w.2.α.

Consider any run generated by M when playing the overall game [formula]. We may assume that Γ is a legal run of the overall game because M never makes illegal moves unless its adversary does so first. Let Σ  =  Γ1. and Π  =  Γ2.. Namely, Σ is the run that took place in the [formula] component, and Π is the run that took place in the [formula] component. If there exists an infinite but essentially finite bitstring v such that [formula] is a [formula]-won run of [formula], then [formula] is the winner in the [formula] component, and hence [formula] wins the overall game. If for every infinite but essentially finite bitstring v, [formula] is a [formula]-won run of [formula], then [formula] wins at least A or [formula] in thread v. But the run that took place in A (resp. [formula]) in the thread v of [formula] is the same as the run that took place in the thread v of [formula] (resp. B) in the [formula] (resp. [formula]) component, only with [formula] interchanged with [formula]. Hence we have that for every infinite but essentially finite bitstring v, at least [formula] is a [formula]-won run of [formula], or [formula] is a [formula]-won run of B. This means that [formula] is the winner in the [formula] component, and hence the winner in the overall game.

For any formula F, the formulas FT  →  FL and FL  →  FT are uniformly valid.

We prove this theorem by induction on the complexity of F.

(i) The basis of induction is trivial: when F is an atom P, we have FT = FL = P. It is known ([\cite=Japfin]) that affine logic is sound with respect to uniform validity, and that the formula P  →  P is provable in affine logic. So, we have P  →  P.

(ii) In this and the remaining clauses of this proof, when affine logic proves a formula A, we may simply say that A for the reason explained in the preceding clause. Assume that [formula] for some formula E. Now we should show that [formula] and [formula]. By the induction hypothesis, we have ET  →  EL (1) and EL  →  ET (2). So, by (1) (resp. (2)), [formula] and modus ponens, which was proved in [\cite=Japfin] to hold with respect to uniform validity, we have [formula] (resp. [formula]).

(iii) Assume that [formula] for some formulas E and G. Our goal is to show that [formula] and [formula]. By the induction hypothesis, we have ET  →  EL (1),   GT  →  GL (2),   EL  →  ET (3),   GL  →  GT (4). By (1), [formula] and modus ponens, we have [formula]. Again, by (2),(5), and modus ponens, we have [formula]. Similarly, [formula].

(iv) Assume that [formula] for some formulas E and G. This case can be proven in a similar way to the preceding clause, with the only difference that in this case we depend on "[formula]" instead of "[formula]".

(v) Assume that [formula] for some formula E. Below we should show that [formula] and [formula]. By the induction hypothesis, we have ET  →  EL (1),  EL  →  ET (2). By the known fact that if A, then A (proven in [\cite=Jap03]), (1) implies that (ET  →  EL) (3). On the other hand, by Lemma [\ref=lemma1], we have [formula]. So, by (3),(4), and modus ponens, we have [formula]. Next, by (5), Lemma [\ref=lemma2] and modus ponens, we obtain [formula]. In addition, by Theorem [\ref=atom], [formula]. Finally, by (6),(7), (A  →  B)  →  ((B  →  C)  →  (A  →  C)) and modus ponens, we get [formula] as one of our desired results. In a similar way, we can show that [formula].

(vi) Assume that [formula] for some formula E. By the induction hypothesis, ET  →  EL (1). By (1) and [formula], we have [formula]. Then, from (2), as in the preceding clause, we get [formula], i.e. [formula]. Again, by (4) and [formula], we get one of the desired results: [formula]. Similarly, we have [formula].

(vii) Assume that F = E for some formula E. By the induction hypothesis, we have ET  →  EL (1), EL  →  ET (2). Then, by (1) and the known fact ([\cite=Jap03]) that A implies A, we get (ET  →  EL) (3). But it is known ([\cite=Japfin]) that, for any formulas A and B in affine logic, (A  →  B)  →  (A  →  B) (4). So, by (3),(4), and modus ponens, we have ET  →  EL. Similarly, we have EL  →  ET.

(viii) Assume that F = E for some formula E. By the induction hypothesis and clause (ii), we have [formula]. Then, from (1), as in the preceding clause, we get [formula], i.e. [formula]. Finally, by (2), [formula] and modus ponens, we get [formula], i.e. ET  →  EL. In a similar way, we get that EL  →  ET.

For any formula F, FT is uniformly valid iff so is FL.

Immediately form Theorem [\ref=formula] and the fact ([\cite=Japfin]) that uniform validity is closed under modus ponens.

In view of Corollary [\ref=equivalent], from now on, when studying the fragments of CoL involving [formula] and [formula], we can safely exclusively focus on the new version of [formula] and [formula]. So, let us agree that, for the rest of the paper, [formula] and [formula] always mean [formula] and [formula], respectively.

The soundness of CL15 with countable branching recurrence

To prove the soundness of CL15[formula], we first need to extend the earlier-described semantics from formulas to cirquents. In this section, unless otherwise specified, by a "formula" we mean a [formula]-formula.

Let Γ be a run, a be a positive integer, and [formula] be a nonempty sequence of n infinite bitstrings. The notation

[formula]

will be used to indicate the result of deleting from Γ all moves (together with their labels) except those that look like [formula] for some move β and some finite initial segments [formula] of [formula], respectively, and then further deleting the prefix "[formula]" from such moves. For instance, [formula].

Let * be an interpretation, and [formula] be a cirquent. Then C* is the game defined as follows, where Γ is an arbitrary run and Ω is any legal run of C*. (i) [formula] iff the following two conditions are satisfied:

Every move of Γ looks like [formula], where α is some move, [formula], and [formula] is a sequence of n finite bitstrings such that, whenever an overgroup Oj (1  ≤  j  ≤  n) does not contain the oformula Fa, uj  =  ε.

For every [formula] and every sequence [formula] of n infinite bitstrings, [formula].

(ii) [formula] iff, for every [formula] and every sequence [formula] of n infinite but essentially finite bitstrings, there is an [formula] such that the undergroup Ui contains the oformula Fa and [formula].

Intuitively, any legal run Ω of C* consists of parallel plays of countably infinite copies/threads of each of the games F*a (1  ≤  a  ≤  k). To every sequence [formula] of n infinite but essentially finite bitstrings corresponds a thread of F*a, and [formula] is the run played in that thread. We shall simply say the thread [formula] of F*a to mean the copy of F*a which corresponds to the sequence [formula]. Now, consider a given undergroup Ui. [formula] is the winner in Ui iff, for every sequence [formula] of n infinite but essentially finite bitstrings, there is an oformula Fa in Ui such that [formula] is won by [formula]. Finally, [formula] wins the overall game C* iff it wins in all undergroups of C. In fact, overgroups can be seen as generalized [formula]s, with the only main difference that the former can be shared by several oformulas; undergroups can be seen as generalized disjunctions, with the only main difference that the former may have shared arguments with other undergroups.

We say that a cirquent C is uniformly valid iff there is a machine M, called a uniform solution of C, such that, for every interpretation *, M wins C*.

The formula [formula] is uniformly valid.

This is one exception where we prefer to deal with the old version [formula] of [formula]. Our goal is to show that there exists an EPM M such that, for any static game A, M wins [formula], i.e. [formula]. Such an EPM M works as follows. It never makes any replicative moves in the left component. Whenever the environment makes a move 1.ε.α for some move α, it makes the move 2.α; and whenever the environment makes a move 2.β for some move β, it makes the move 1.ε.β.

Consider any run Γ generated by M. As earlier, we assume that Γ is a legal run of the overall game. Let Σ  =  Γ1. and Π  =  Γ2.. That is, Σ is the run that took place in the [formula] component, and Π is the run that took place in the A component. If there is an infinite but essentially finite bitstring v such that [formula] is a [formula]-won run of [formula], then M wins the [formula] component, and hence wins the overall game. Now assume that, for every infinite but essentially finite bitstring v, [formula] is a [formula]-won run of [formula]. But from the description of the work of M, one can easily see that [formula] for every such v. Therefore, Π is a [formula]-won run of A, and hence Γ is won by M.

It should be acknowledged that the following proofs in the present section very closely follow the proofs of [\cite=Japtam].

There is an effective function f from machines to machines such that, for every machine M, formula F and interpretation *, if M wins [formula], then f(M) wins F*.

Lemma [\ref=lemma3] almost immediately implies that there is a machine N0 such that N0 wins [formula] for any formula F and interpretation *. Furthermore, by Proposition 21.3 of [\cite=Jap03], there is an effective procedure that, for any pair (N,M) of machines, returns a machine h(N,M) such that, for any static games A and B, if N wins A  →  B and M wins A, then h(N,M) wins B. So, let f(M) be the function satisfying f(M) = h(N0,M). Then f(M) wins F*.

There is an effective function g from machines to machines such that, for every machine M, formula F and interpretation *, if M wins [formula], then g(M) wins F*.

Every legal move of [formula] looks like 1;w.α for some finite bitstring w and move α, while the corresponding legal move of [formula] simply looks like w.α, and vice versa. Consider an arbitrary EPM M and an arbitrary interpretation *. Below we show the existence of an effective function f such that, if M wins [formula], then (the strategy) f(M) wins [formula].

We construct an EPM f(M) that plays [formula] by simulating and mimicking a play of [formula] (called the imaginary play) by M as follows. Throughout simulation, f(M) grants permission whenever the simulated M does so, and feeds its environment's response--in a slightly modified form described below--back to the simulated M as the response of M's imaginary adversary (this detail of simulation will no longer be explicitly mentioned later in similar situations). Whenever the environment makes a move w.α for some finite bitstring w and move α, f(M) translates it as the move 1;w.α made by the imaginary adversary of M, and "vice versa": whenever the simulated M makes a move 1;w.α for some finite bitstring w and move α in the imaginary play of [formula], f(M) translates it as its own move w.α in the real play of [formula]. The effect achieved by f(M)'s strategy can be summarized by saying that it synchronizes every thread x of F* in the real play of [formula] with the "same thread" x of F* in the imaginary play of [formula].

Let Γ be an arbitrary run generated by f(M), and Ω be the corresponding run in the imaginary play of [formula] by M. From our description of f(M) it is clear that the latter never makes illegal moves unless its environment or the simulated M does so first. Hence we may safely assume that Γ is a legal run of [formula] and Ω is a legal run of [formula], for otherwise either Γ is a [formula]-illegal run of [formula] and thus f(M) is an automatic winner in [formula], or Ω is a [formula]-illegal run of [formula] and thus M does not win [formula]. Now, it is not hard to see that, for any infinite but essentially finite bitstring x, we have [formula]. Therefore, f(M) wins [formula] as long as M wins [formula].

Finally, in view of Lemma [\ref=apr14a], the existence of function g satisfying the promise of the present lemma is obviously guaranteed.

A rule of CL15[formula] (other than Axiom) is said to be uniform-constructively sound iff there is an effective procedure that takes any instance (A,B) (i.e. a particular premise-conclusion pair) of the rule, any machine MA and returns a machine MB such that, for any interpretation *, whenever MA wins A*, MB wins B*. Axiom is uniform-constructively sound iff there is an effective procedure that takes any instance B of (the "conclusion" of) Axiom and returns a uniform solution MB of B.

All rules of CL15[formula] are uniform-constructively sound.

In what follows, A is the premise of an arbitrary instance of a given rule of CL15[formula], and B is the corresponding conclusion, except the case of Axiom where we only have B. We will prove that each rule of CL15[formula] is uniform-constructively sound by showing that an EPM MB can be constructed effectively from an arbitrary EPM (or BMEPM in some cases) MA such that, for whatever interpretation *, whenever MA wins [formula], MB wins [formula]. Since an interpretation [formula] is never relevant in such proofs, we may safely omit it, writing simply A instead of [formula] to represent a game. Next, in all cases the assumption that MA wins A will be implicitly made, even though it should be pointed out that the construction of MB never depends on this assumption. Correspondingly, it will be assumed that MA never makes illegal moves. Further, as in the proof of Lemma [\ref=apr14b], we shall always implicitly assume that MB's adversary never makes illegal moves either. To summarize, when analyzing MB, MA and the games they play, we safely pretend that illegal runs never occur.

(1) Assume that B is an axiom with 2n oformulas. An EPM MB that wins B can be constructed as follows. It keeps granting permission. Whenever the environment makes a move [formula], where 1  ≤  a  ≤  2n and [formula] is a sequence of n finite bitstrings, MB makes the move [formula], where b = a + 1 if a is odd, and b = a - 1 if a is even. Then, for any run Γ of B generated by MB and any sequence [formula] of n infinite but essentially finite bitstrings, we have [formula]. It is obvious that Γ is a [formula]-won run of B, so that MB wins B.

(2) Assume that B follows from A by Overgroup Exchange, where the i'th (i  ≥  1) and the (i + 1)'th overgroups of A have been swapped when obtaining B from A. The EPM MB works by simulating and mimicking MA as follows. Let n be the number of overgroups of either cirquent, and a be a positive integer not exceeding the number of oformulas of either cirquent. For any move (by either player) [formula] in the real play of B, where [formula] and [formula] are any sequences of i - 1 and n - i - 1 finite bitstrings, respectively, and u1,u2 are two finite bitstrings, MB translates it as the move [formula] (by the same player) in the imaginary play of A, and vice versa, with all other moves not reinterpreted.

Let Γ be any run of B generated by MB, and Ω be the corresponding run generated by MA in the imaginary play of A. It is obvious that, for any sequence [formula] of n infinite but essentially finite bitstrings, [formula], where [formula] is the result of swapping in [formula] the i'th and (i + 1)'th bitstrings. Hence MB wins B because MA wins A.

In the case of Oformula Exchange, a similar method can be used to construct MB, with the only difference that the reinterpreted objects are the occurrences of two adjacent oformulas rather than the occurrences of two adjacent overgroups.

As for Undergroup Exchange, its conclusion, as a game, is the same as its premise. So, the machine MB  =  MA does the job.

In the subsequent clauses, as in the present one, without any further indication, Γ will stand for an arbitrary run of B generated by MB, and Ω will stand for the run of A generated by the simulated machine MA in the corresponding scenario.

(3) Assume B is obtained from A by Weakening. If no oformula of B was deleted when moving from B to A, then MB works exactly as MA does and succeeds, because every [formula]-won run of A is also a [formula]-won run of B (but not necessarily vice versa). If, when moving from B to A, an oformula Fa of B was deleted, then MB can be constructed as a machine that works by simulating and mimicking MA. What MB needs to do during its work is to ignore the moves within Fa, and play exactly as MA does in all other oformulas. Again, it is obvious that every [formula]-won run of A is also a [formula]-won run of B, which means that MB wins B as long as MA wins A.

(4) Since Exchange has already been proven to be uniform-constructively sound, in this and the remaining clauses of the present proof, we may safely assume that the oformulas and overgroups affected by a rule are at the end of the corresponding lists of objects of the corresponding cirquents.

Assume B follows from A by Contraction, and the contracted oformula [formula] is at the end of the list of oformulas of B. Let a be the number of oformulas of B, and let b = a + 1. Thus, the a'th oformula of B is [formula], and the a'th and b'th oformulas of A are [formula] and [formula]. Let n be the number of overgroups in either cirquent. In this case, we assume that MA is a BMEPM rather than an EPM. As always, we let MB be an EPM that works by simulating and mimicking MA. Namely, let [formula] be any sequence of n finite bitstrings. If the moves take place within the oformulas other than [formula], then nothing should be reinterpreted. If the moves take place in [formula], then we have:

For any move [formula] made by the environment in the real play of B, MB translates it as the move [formula] by the imaginary adversary of MA in the play of A; whenever the simulated MA makes a move [formula] in the imaginary play of A, MB makes the move [formula] in the real play of B.

For any move [formula] made by the environment in the real play of B, MB translates it as the move [formula] by the imaginary adversary of MA in the play of A; whenever the simulated MA makes a move [formula] in the imaginary play of A, MB makes the move [formula] in the real play of B.

If the environment makes a move [formula] in the real play of B, MB translates it as a block of the two moves [formula] and [formula] by the imaginary adversary of MA in the play of A, and vice versa.

Note that if MA makes a block of several moves at once (because it is a BMEPM), MB still works as described above, with the only difference that it will correspondingly make several consecutive moves in the real play, rather than only one move. In the remaining clauses of the present proof, whenever MA is assumed to be a BMEPM, for simplicity we may assume that it never makes more than one move at once. For, otherwise, a block of several moves made by MA at once will be translated through several consecutive moves by MB as noted above.

Below we show that MB wins B, i.e., MB is the winner in every undergroup of B. Let UBi be any i'th undergroup of B and UAi be the corresponding i'th undergroup of A, and let [formula] be any sequence of n infinite but essentially finite bitstrings. Since MA wins A, UAi is won by MA. So, for the sequence [formula], there is an oformula Fj (1  ≤  j  ≤  b) in UAi such that [formula] is a [formula]-won run of Fj. Next, if such Fj is not one of the two contracted oformulas [formula] and [formula], then, for [formula], the corresponding oformula Fj of B is won by MB, i.e. [formula] is a [formula]-won run of Fj, because MB plays in the thread [formula] of Fj exactly as MA does. This means that UBi is won by MB. If Fj is one of the two contracted oformulas [formula] and [formula], below let us assume that Fj is the right [formula], with the case of the left [formula] being similar. Then there is an infinite but essentially finite bitstring w such that the thread w of F within the thread [formula] of the right [formula] is won by MA, i.e. [formula] is a [formula]-won run of F. But, according to the above description, MB plays in the thread 1w of F within the thread [formula] of [formula] in B exactly as MA plays in the thread w of F within the thread [formula] of the right [formula] in A, i.e. [formula]. Therefore, [formula] is a [formula]-won run of F, which means that [formula] is a [formula]-won run of [formula] in B, and hence the [formula]-containing undergroup UBi is won by MB.

Remark:  In the remaining clauses, just as in the preceding one, when talking about playing, winning, etc. in A (resp. B) or any of its components, it is to be understood in the context of Ω (resp. Γ). Furthermore, if A and B have the same number n of overgroups, then the context will additionally include some arbitrary but fixed sequence [formula] of n infinite but essentially finite bitstrings.

(5) Undergroup Duplication does not modify the game associated with the cirquent, so we only need to consider Overgroup Duplication.

Assume B is obtained from A by Overgroup Duplication. We assume that the duplicated overgroup is at the end of the list of overgroups of A. Let n + 1 be the number of overgroups of A. Thus, every legal move of A (resp. B) looks like [formula] (resp. [formula]), where a is a positive integer not exceeding the number of oformulas of A, [formula] is a sequence of n finite bitstrings, and u,u1,u2 are finite bitstrings.

Let x and y be any two--finite or infinite--bitstrings, a bitstring z is a fusion of x and y iff z is a shortest bitstring satisfying that, for any natural numbers i,j such that x has at least i bits and y has at least j bits, we have: (1) the (2i - 1)'th bit of z exists and it is the i'th bit of x; (2) the (2j)'th bit of z exists and it is the j'th bit of y. Here and later the count of bits starts from 1, and goes from left to right. For instance, if x = 001 and y = 110, then they have only one fusion z = 010110; if x = 01 and y = 110, then they have two fusions z1 = 011100, z2 = 011110. Note that when both x and y are infinite, they have only one fusion. The defusion of a bitstring z is the pair (x,y) where x (resp. y) is the result of deleting from z all bits except those that are found in odd (resp. even) positions. For instance, the defusion of 100110101 is (10111,0100). It is obvious that if x and y are infinite but essentially finite bitstrings, then their unique fusion z is also essentially finite, and vice versa.

In the present case, we assume that MA is a BMEPM. As before, MB works by simulating MA. Whenever MA makes a move [formula] in A, MB makes the move [formula] in the real play of B, where (u1,u2) is the defusion of u. And whenever the environment makes a move [formula] in the real play of B, MB translates it as a block of MA's imaginary adversary's moves [formula] in B, where [formula] are all the fusions of u1 and u2.

For every oformula Fa of either cirquent, every sequence [formula] of n infinite but essentially finite bitstrings and any infinite but essentially finite bitstrings x1 and x2, we have [formula], where x is the fusion of x1 and x2. So it is obvious that MB wins B as long as MA wins A.

(6) Assume B follows from A by Merging. Let us assume that A has n + 2 overgroups, and B is the result of merging in A the two adjacent overgroups On + 1 and On + 2. Then every legal move of A (resp. B) looks like [formula] (resp. [formula]), where a is a positive integer not exceeding the number of oformulas in either cirquent, [formula] is a sequence of n finite bitstrings, and u,u1,u2 are finite bitstrings. We still assume that MA is a BMEPM. The EPM MB works as follows.

If the a'th oformula of A is neither in On + 1 nor in On + 2, then MB interprets every move [formula] made by MA in the imaginary play of A as the move [formula] in the real play of B, and vice versa.

If the a'th oformula of A is in On + 1 but not in On + 2, MB interprets every move [formula] made by MA in the imaginary play of A as the move [formula] in the real play of B, and vice versa. Namely, MB interprets every move [formula] by its environment in the real play of B as the move [formula] by the imaginary adversary of MA in the play of A.

The case of the a'th oformula of A being in On + 2 but not in On + 1 is similar.

Finally, suppose that the a'th oformula of A is in both On + 1 and On + 2. Whenever the environment makes a move [formula] in the real play of B, MB translates it as the move [formula] by the imaginary adversary of MA in the play of A, where (u1,u2) is the defusion of u. Next, whenever MA makes a move [formula] in the imaginary play of A, MB translates it as a series of moves [formula] in the real play of B, where [formula] are all the fusions of u1 and u2.

For every oformula Fa of either cirquent, every sequence [formula] of n infinite but essentially finite bitstrings and any infinite but essentially finite bitstring x, we have [formula], where x1,x2 are infinite but essentially finite bitstrings satisfying that x1 = x (when Fa is contained in On + 1 but not On + 2), or x2 = x (when Fa is contained in On + 2 but not On + 1), or (x1,x2) is the defusion of x (when Fa is contained in both On + 1 and On + 2, or is contained in neither of them). So it is obvious that MB wins B as long as MA wins A.

(7) In this and the remaining clauses of the present proof, we will limit our descriptions to what moves MB needs to properly reinterpreted and how, with any unmentioned sorts of moves implicitly assumed to remain unchanged.

Assume B is obtained from A by Disjunction Introduction. Let us assume that the last (a'th) oformula of B is [formula], and the last two (a'th and b'th, where b = a + 1) oformulas of A are E and F. As always, MB reinterprets every move [formula] (resp. [formula]) by either player in the imaginary play of A as the move [formula] (resp. [formula]) by the same player in the real play of B, and vice versa.

Consider any undergroup UBi of B, and let UAi be the corresponding undergroup of A. As before, MA's winning A means that UAi is won by MA, which, in turn, means that there is an oformula G in UAi that is won by MA. If G is neither E nor F, then the oformula G of B is also won by MB, because MB plays in G exactly as MA does. Hence UBi is won by MB. If G is E, then its being [formula]-won means that MB wins the E component of [formula], because MB plays in the E component of [formula] exactly as MA plays in E. Therefore, [formula] is won by MB, and hence so is the [formula]-containing undergroup UBi. The case of G being F is similar.

(8) Assume B follows from A by Conjunction Introduction. We also assume that the last (a'th) oformula of B is [formula], and the last two (a'th and b'th, where b = a + 1) oformulas of A are E and F. As the case of Disjunction Introduction, MB reinterprets every move [formula] (resp. [formula]) by either player in the imaginary play of A as the move [formula] (resp. [formula]) by the same player in the real play of B, and vice versa.

Let Ui be any undergroup of B. If Ui does not contain [formula], then the corresponding undergroup Vi of A contains neither E nor F. In this case, Ui is won by MB for the same reason as in the preceding clause. If Ui contains [formula], then there are two undergroups VEi, VFi of A corresponding to Ui, where VEi contains E (but not F), and VFi contains F (but not E), with all other ([formula]) oformulas of Ui contained by both VEi and VFi. Of course, both VEi and VFi are won by MA because MA wins the overall game A. This means that there is an oformula G1 (resp. G2) in VEi (resp. VFi) such that MA wins it. If at least one oformua G∈{G1,G2} is neither E nor F, then the corresponding oformula G of B is won by MB, because MB plays in G exactly as MA does. Hence the G-containing undergroup Ui of B is won by MB. If G1 is E and G2 is F, then MA winning them means that MB wins both the E and the F components of [formula], because MB plays in the E (resp. F) component of [formula] exactly as MA does in E (resp. F). Hence [formula] is won by MB, and hence so is the [formula]-containing undergroup Ui.

(9) Assume B is obtained from A by Recurrence Introduction. That is, the last (a'th) oformula of B is [formula], and the last (a'th) oformula of A is F. We further assume that the number of overgroups of B is n, and thus the number of overgroups of A is n + 1. In what follows, [formula] is any sequence of n finite bitstrings, and b is a positive integer not exceeding the number of oformulas of either cirquent. If b  ≠  a, then MB simply reinterprets every move [formula] by either player in the imaginary play of A as the move [formula] by the same player in the real play of B, and vice versa. If b = a, then MB reinterprets, for any finite bitstring u, every move [formula] by either player in the imaginary play of A as the move [formula] by the same player in the real play of B, and vice versa.

Consider any undergroup UBi of B. Let [formula] be any sequence of n infinite but essentially finite bitstrings. MA's winning A means that Ω is a [formula]-won run of A and that the corresponding undergroup UAi of A is won by MA. Then, for any sequence [formula], where x is any infinite but essentially finite bitstring, there is an oformula Fb in UAi such that [formula] is a [formula]-won run of Fb. If such Fb is not the a'th oformula F, then, in the context of [formula], the oformula Fb of B is also won by MB, i.e. [formula] is a [formula]-won run of Fb, because MB plays in the thread [formula] of Fb in B exactly as MA does in the thread [formula] of Fb in A. Hence UBi is won by MB. If Fb is the a'th oformula F, then, in the context of [formula], the corresponding oformula [formula] of B is won by MB as well, i.e. [formula] is a [formula]-won run of [formula]. This is so because MB plays in the thread x of F within the thread [formula] of [formula] exactly as MA does in the thread [formula] of F in A. Namely, [formula]. Since [formula] is a [formula]-won run of F, so is [formula]. Further, due to the arbitrariness of x, [formula] is a [formula]-won run of [formula]. Therefore, the [formula]-containing undergroup UBi is won by [formula].

(10) Finally, assume that B is obtained from A by Corecurrence Introduction. Let us assume that the last (a'th) oformula of B is [formula], and the last (a'th) oformula of A is F. And assume that n (n  ≥  0) is the number of the new overgroups Uj in which the a'th oformula F was included when moving from B to A. Let us further assume that all of such n overgroups are at the end of the list of overgroups of either cirquent. In what follows, let [formula] be any sequence of m finite bitstrings, where m is the total number of overgroups of either cirquent minus n. We construct the EPM MB as follows.

If, when moving from B to A, no new overgroups emerged to include the a'th oformula (i.e. n = 0), then MB's work is simple. What it should do is to "synchronize" one single (fixed) thread of F within each thread [formula] of [formula] with the same thread [formula] of F in A. Specifically, let z be the infinite bitstring [formula] (note that it is essentially finite). MB translates every move [formula] made by MA in the imaginary play of A as its own move [formula] in the real play of B, where u is a finite initial segment of z such that u is not a proper prefix of any other finite bitstring v already used in the real play within some move [formula]. And whenever the environment makes a move [formula] in the real play of B, if v is a prefix of z, MB translates it as the move [formula] by the imaginary adversary of MA in the play of A, otherwise (i.e. v is not a prefix of z), MB simply ignores it.

If, when moving from B to A, the a'th oformula was included by some overgroups of A (i.e. n  ≥  1), then as always MB works by simulating MA. To describe its work, we need to generalize the concepts of fusion and defusion from the case of n = 2 to the case of n  ≥  1.

Let [formula] be any n--finite or infinite--bitstrings. A bitstring z is a fusion of [formula] iff z is a shortest bitstring such that, for any [formula] and any positive integer j not exceeding the length of xi, the following condition is satisfied: the (jn - n + i)'th bit of z exists and it is the j'th bit of xi. For instance, if x1 = 000, x2 = 11, and x3 = 001, then the fusions of x1,x2,x3 are 010010001 and 010010011. Note that when all n bitstrings are infinite, they have a unique fusion, as before. The n-defusion of a bitstring z is the n-tuple [formula], where each xi is the result of deleting from z all bits except those that were found in positions j such that j modulo n equals i. For instance, the 4-defusion of 00110101101001111 is (00101,0101,1011,1101). It is obvious that the generalized concepts of fusion and defusion also preserve the essentially finiteness.

Now about the work of MB. Whenever the environment makes a move [formula] (n occurrences of ε after [formula]) in the real play of B, MB translates it as the move [formula] made by the imaginary adversary of MA in the play of A, where [formula] is the n-defusion of u. Next, whenever MA makes a move [formula] in the imaginary play of A, MB translates it as a series of its own moves [formula] in the real play of B, where [formula] are all the fusions of [formula].

As usual, consider any undergroup UBi of B, and let [formula] be any sequence of (m + n) infinite but essentially finite bitstrings, where [formula] is any sequence of m infinite but essentially finite bitstrings. Then the corresponding undergroup UAi of A is won by MA, which, in turn, means that there is an oformula Fb (1  ≤  b  ≤  a) in UAi such that MA wins it. If such Fb is not the a'th oformula F, then the corresponding oformula Fb of B is also won by MB, because MB plays in Fb of B exactly as MA does in Fb of A. Therefore, the Fb-containing undergroup UBi is won by MB. If Fb is the a'th oformula F, then the corresponding oformula [formula] of B is won by MB as well. This is so because MB plays in at least one thread of F within [formula] of B exactly as MA does in F of A. Precisely, we have [formula], where x is the fusion of [formula]. Thus the [formula]-containing undergroup UBi is won by MB.

Every cirquent provable in CL15[formula] is uniformly valid.

Furthermore, there is an effective procedure that takes an arbitrary CL15[formula]-proof of an arbitrary cirquent C and constructs a uniform solution of C.

Immediately from Theorem [\ref=mainth1] by induction on the lengths of CL15[formula]-proofs.

For any formula F, if CL15[formula], then F is uniformly valid.

Furthermore, there is an effective procedure which takes any CL15[formula]-proof of any formula F and constructs a uniform solution of F.

Immediately from Theorem [\ref=mainth2] and Lemma [\ref=apr14b].

Below, a uniformly valid [formula]-principle means the result of replacing every occurrence of the operator [formula] (resp. [formula]) by the symbol ! (resp. ?) in some uniformly valid [formula]-formula. Similarly, a uniformly valid [formula]-principle means the result of replacing every occurrence of the operator [formula] (resp. [formula]) by the symbol ! (resp. ?) in some uniformly valid [formula]-formula. The reason for introducing these technical concepts is merely to make it possible to directly compare the otherwise syntactically nonidentical [formula]-formulas with [formula]-formulas.

The set of uniformly valid [formula]-principles is a proper superset of the set of uniformly valid [formula]-principles.

The fact that the set of uniformly valid [formula]-principles is a superset of the set of uniformly valid [formula]-principles is immediate from Theorems [\ref=niu] and [\ref=mainth3]. Furthermore, the former set is in fact a proper superset of the latter set because, as proven in [\cite=Japsep], the formula [formula] is uniformly valid while its counterpart [formula] is not.

A further result

To make our investigation of the relationship between [formula] and [formula] more comprehensive, in this section we show that [formula] is strictly weaker than [formula] (and thus [formula] is strictly stronger than [formula]) in the sense that the formula [formula] is uniformly valid while its converse [formula] is not. The first part of this statement is immediate from Lemma [\ref=lemma1] of Section 3. So, we only need to prove the second part.

The formula [formula] is not uniformly valid.

Let M be an arbitrary EPM, i.e. strategy of the machine [formula]. Below we construct a counterstrategy C such that, when the environment [formula] follows it, M loses [formula] with P interpreted as a certain enumeration game. Here, an enumeration game ([\cite=Japsep]) is a game where any natural number, identified with its decimal representation, is a legal move by either player at any time (and there are no other legal moves). It should be noted that, as shown in [\cite=Japtam2], every enumeration game is static, and hence is a legitimate value of an interpretation * on any atom. Hence, due to the arbitrariness of M, [formula] (i.e. [formula]) is not uniformly valid.

Since P is going to be interpreted as an enumeration game and its legal moves are known even before we actually define that interpretation, in certain contexts we may identify formulas with games without creating any confusion. The work of C consists in repeating the following interactive routine over and over again (infinitely many times), where i is the number of the iteration. In our description below, a fresh number means a natural number that has not yet been chosen in the play by either player as a move in any thread/copy of P.

LOOP(i): Whenever permission is granted by the machine M, make the move 2.w.u, where u is a fresh number and w is the ith finite bitstring of the lexicographic list of all finite bitstrings.

Consider the run Δ generated by M in the scenario when its adversary follows the above counterstrategy. Let Ω  =  Δ1. and Γ  =  Δ2.. That is, Ω is the (sub)run that took place in the [formula] component, and Γ is the (sub)run that took place in the P component. From some analysis of the work of LOOP, details of which are left to the reader, one can see that [formula] for any two different infinite bitstrings x1 and x2. Hence, as there are uncountably many infinite bitstrings while only countably many infinite but essentially finite bitstrings, there is an infinite bitstring y such that, for every infinite but essentially finite bitstring v, [formula]. Fix this y.

Now we select an interpretation * that interprets P as the enumeration game such that, for any legal run Θ of the game P, [formula] iff [formula]. We claim that M loses the overall game under this interpretation. First, it is obvious that M loses the game P in the thread y, which means that it loses the P component. Next, M also loses the [formula] component because it loses in every essentially finite thread of [formula] within [formula]. This is so because the run that took place in any essentially finite thread of [formula] within [formula] is won by [formula] iff it is [formula], which, however, is impossible (due to the above analysis).

An alternative albeit non-constructive and less direct proof of Theorem [\ref=notuni] would rely on Theorem [\ref=superset]. Namely, one could show that, if [formula] was uniformly valid and hence (in view of the already proven fact of the uniform validity of the converse of this formula) P and [formula] were "logically equivalent", then they would induce identical logics, in the precise sense that the set of uniformly valid [formula]-principles would coincide with the set of uniformly valid [formula]-principles, contrary to what Theorem [\ref=superset] asserts.