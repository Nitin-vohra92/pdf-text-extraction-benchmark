Optimal leader election in multi-hop radio networks

Research partially supported by the Centre for Discrete Mathematics and its Applications (DIMAP).

Contact information: {A.Czumaj, P.W.Davies} Phone: +44 24 7657 3796.

= by 60= by 60= by - = by -1900

Proof of :

Corollary Lemma Proposition Definition Remark Claim Invariant Observation

Introduction

Leader election is the problem of ensuring that all nodes agree on a single node to be designated leader. Specifically, at the conclusion of a leader election algorithm, all nodes should output the same ID, and precisely one node should identify this ID as its own. Leader election is a fundamental primitive in distributed computations and, as the most fundamental means of breaking symmetry within radio networks, it is used as a preliminary step in many more complex communication tasks. For example, many fast multi-message communication protocols require construction of a breadth-first search tree (or some similar variant), which in turn requires a single node to act as source (for more examples, cf. [\cite=-CKP12] [\cite=-FSW14] [\cite=-GH13], and the references therein).

In this paper we present a simple framework combining the simulation approach of Bar-Yehuda et al. [\cite=-BGI91] with basic communication primitives that enables us to obtain new, optimal or almost optimal leader election algorithms.

We begin with noting that, under certain assumptions, the simulation approach of Bar-Yehuda et al. [\cite=-BGI91] can be used to obtain an optimal algorithm for the task of randomized leader election in multi-hop radio networks without collision detection (Theorem [\ref=thm:expected-leader-election]). The algorithm runs in [formula] time, where n is the number of the nodes and D is the eccentricity or the diameter of the network; the complexity of this algorithm is asymptotically equal to the amount of time required to broadcast a single message. This improves by a O( log  log n) factor over the expected running time claimed by Bar-Yehuda et al. [\cite=-BGI91], and, in the case of undirected networks, by a similar O( log  log n) factor over the high probability bound of Ghaffari and Haeupler [\cite=-GH13]. While our algorithm could be seen as a variation of the approach by Bar-Yehuda et al. [\cite=-BGI91], the obtained result has not previously been noted despite substantial research into the model.

We then present another algorithm which follows a similar outline but exploits the properties of the collision detection mechanism (Theorem [\ref=thm:LECD]). The algorithm operates on undirected multi-hop radio networks with collision detection (as well as the strictly weaker beep model) and has O(D  +   log n) expected running time, which matches the amount of time required to broadcast a single Θ( log n) bit message to the network. It is the first known optimal leader election algorithm in this model.

For situations when a high-probability bound is required, we present an algorithm for directed networks without collision detection which takes a fixed [formula] time and succeeds with high probability (Theorem [\ref=thm:whp-leader-election]). This algorithm is non-optimal, and for undirected networks slower than the algorithm of [\cite=-GH13], but is the fastest known algorithm for high probability leader election in directed networks.

Multi-hop radio networks.

We consider the classical model of directed radio networks with unknown structure. A radio network is modeled by a network (directed or undirected graph) N  =  (V,E), where the set of nodes corresponds to the set of transmitter-receiver stations. The nodes of the network are assigned different identifiers, IDs. A directed edge (v,u)∈E means that the node v can send a message to the node u, whereas an undirected edge {v,u}∈E means that the nodes v and u can exchange messages in both directions. To make the leader election problem feasible, we assume that every pair of nodes in N is strongly connected or connected, depending on whether we consider directed or undirected networks.

In accordance with the standard model of unknown radio networks, we assume that a node does not have any prior knowledge about the topology of the network, its in-degree and out-degree, or the set of its neighbors. We assume that the only knowledge of each node is the size of the network n, and the eccentricity of the network D, which is the maximum distance between any pair of nodes in N. The assumption of knowledge of n and D is integral to the result, and is common in the study of multi-hop radio networks.

We assume that all nodes have access to a global clock and work synchronously in discrete time steps. When we refer to the 'running time' of an algorithm, we mean the number of time steps which elapse before completion (i.e. we are not concerned with the number of calculations nodes perform within time steps). In each time step a node can either transmit an O( log n)-bit message to all of its out-neighbors at once or can remain silent and listen to the messages from its in-neighbors. The distinguishing feature of radio networks is the interfering behavior of transmissions. In the most standard radio networks model, the model without collision detection, if a node v listens in a given round and precisely one of its in-neighbors transmits, then v receives the message. In all other cases v receives nothing; in particular, the lack of collision detection means that v is unable to distinguish between zero of its in-neighbors transmitting and more than one. The model without collision detection describes the most restrictive interfering behavior of transmissions; we also consider a less restrictive variant, the model with collision detection. In this model, if a node v listens in a given round then it can distinguish between zero of its in-neighbors transmitting and more than one.

Rather than directly studying the multi-hop radio network model with collision detection added, in this paper we will instead work in the strictly weaker beep model, introduced recently by Cornejo and Kuhn [\cite=-CK10] as an alternative way of modeling the classical radio network model. In this model, in synchronous time steps, each node can either beep or not beep. If a node beeps, then it does not receive any information in this time step. If a node does not beep, then it can tell whether zero neighbors beeped, or whether at least one did. Any algorithm designed for the beep model can be directly used for the standard multi-hop radio network model with collision detection.

We will consider randomized algorithms for leader election and we say that a leader election algorithm runs in expected time T, if it finishes in expected time T, and that with high probability (w.h.p.) all nodes in the network hold the same ID that identifies a single node in the network. We will say that a leader election algorithm runs in time T with high probability (w.h.p.) if with high probability it finishes in time T and all nodes in the network hold the same ID that identifies a single node in the network.

Previous work.

The study of leader election in radio networks started in the 1970s with the single-hop network model, in which all nodes are directly reachable by all others (in a single hop). In this setting, in the model with collision detection, leader election can be performed deterministically in O( log n) time, which was proven to be optimal by Greenberg and Winograd [\cite=-GW85]. While randomization provides no benefit if a high probability bound is required, as a Ω( log n) lower bound also exists [\cite=-GLS11] [\cite=-NO02], Willard [\cite=-W86] gave an algorithm with the expected running time of O( log  log n) and showed that this bound is also asymptotically optimal. (We note, however, that this result assume that nodes do not know the value of n, nor a linear upper bound.) For the single-hop network model without collision detection, deterministic leader election has complexity Θ(n log n) [\cite=-CMS03] [\cite=-KP13], and randomized leader election has expected time complexity O( log n) [\cite=-KM98] and high probability time complexity O( log 2n) [\cite=-JS05].

While the complexity of leader election in single-hop networks is well understood, the complexity of the problem in the more general model of multi-hop networks has been less developed. In the seminal work initiating the study of the complexity of communication protocols in multi-hop radio networks, Bar-Yehuda et al. [\cite=-BGI91] developed a general randomized framework of simulating single-hop networks with collision detection by multi-hop networks without collision detection. The framework yields leader election algorithms for multi-hop networks (in directed and undirected networks) running in O(TBC  ·   log  log n) expected time and O(TBC  ·   log n) time with high probability, where TBC is the time required to broadcast a message from a single source to the entire network. The same authors also gave a randomized broadcasting algorithm running in O(D log n +  log 2n) time with high probability, thereby yielding a leader election algorithm taking O((D log n  +   log 2n) log  log n) expected time and O(D log 2n  +   log 3n) time with high probability.

The next improvement came with faster algorithms for broadcast due to Czumaj and Rytter [\cite=-CR06], and independently Kowalski and Pelc [\cite=-KP03b], which require only [formula] time w.h.p. Combining these algorithms with the simulation framework of Bar-Yehuda et al., one obtains leader election algorithms (even in the model without collision detection, and in both directed and undirected graphs) running in [formula] expected time and [formula] time with high probability.

Very recently, Ghaffari and Haeupler [\cite=-GH13] took a new approach, which yielded faster high-probability leader election algorithms in undirected networks. The main idea of Ghaffari and Haeupler is to randomly select a small (logarithmic) number of candidates for the leader and then repeatedly run "debates" to reduce the number of candidates to one. Standard random sampling technique allows one to choose in constant time a random set of Θ( log n) candidates, with high probability. Then, by running a constant number of broadcasting computations and neighborhood exploration algorithms (this phase is called a "debate" in [\cite=-GH13] and it relies heavily on the assumption that the network is undirected), one can reduce the number of candidates by a constant factor. Using this approach, Ghaffari and Haeupler [\cite=-GH13] gave a leader election algorithm (in undirected networks) that in [formula] rounds elects a single leader with high probability. In the model with collision detection (in fact, the beep model also employed in this paper), Ghaffari and Haeupler [\cite=-GH13] used the approach above to elect a leader in [formula] rounds with high probability. These algorithms are nearly optimal, and are the fastest currently known for undirected networks and for high-probability running time.

A different approach has been developed by Chlebus et al. [\cite=-CKP12], who presented a randomized leader election algorithm in undirected networks without collision detection running in the expected number of O(n) rounds, or in O(n log n) rounds with high probability. This first bound is optimal in terms only of n, but does not seem tractable to parameterizations by D.

There have been also some deterministic algorithms for leader election in multi-hop radio networks. Kowalski and Pelc [\cite=-KP13] presented a deterministic leader election algorithm in undirected networks with collision detection running in the optimal O(n) time. For the model without collision detection, it is known that any deterministic leader election requires Ω(n log n) time [\cite=-CMS03], and Chlebus et al. [\cite=-CKP12] gave a deterministic leader election algorithm in undirected networks running in [formula] time. We note also that Förster et al. [\cite=-FSW14] presented a deterministic algorithm in the beep model running in O(D log n) time.

Let us finally emphasize that leader election takes at least as long as broadcasting an Ω( log n) bit message (cf. [\cite=-GH13]), and, as such, is subject to the lower bounds [formula] for broadcasting without collision detection (cf. [\cite=-ABLP91] [\cite=-KM98]), and Ω(D  +   log n) for broadcasting with collision detection or in the beep model [\cite=-GLS11] [\cite=-NO02].

Relation of our approach to earlier works.

While our main approach for randomized leader election in multi-hop radio networks without collision detection (Theorem [\ref=thm:expected-leader-election]) essentially follows the approach of Bar-Yehuda et al. [\cite=-BGI91], and while the result in Theorem [\ref=thm:expected-leader-election] could be deducted from [\cite=-BGI91], to the best of our knowledge such implication has not been published before (and in fact this has been indirectly mentioned recently as an open problem in [\cite=-GH13]). The main contribution of our paper is the observation that this approach can be applied in several different scenarios, yielding not only optimal expected-time leader election in the model without collision detection (Theorem [\ref=thm:expected-leader-election]), but also to optimal or almost optimal leader election algorithms for multi-hop radio networks with collision detection (Theorem [\ref=thm:LECD]) and for directed networks with high probability bound (Theorem [\ref=thm:whp-leader-election]).

Basic primitives

Our algorithms rely on several basic primitives, all being rather standard in the area of distributed computing in radio networks. When called, these subroutines will be implicitly passed an input set S of "sources". While this set is not common knowledge, and so cannot be an explicit parameter, we will ensure that each node knows whether it is itself a member of S, and so can behave accordingly. We also remark on the synchronization of the algorithm: all calls to these subroutines take some fixed predetermined number of time steps which (assuming knowledge of n and D, or at least common linear upper bounds) is known to all nodes. Therefore, nodes can perform these tasks in a synchronized fashion.

Model without collision detection

We begin by introducing the primitives we will use in the radio network model without collision detection.

Decay

The Decay protocol, first introduced by Bar-Yehuda et al. [\cite=-BGI92], is a fundamental primitive employed by many randomized radio network communication algorithms. Its aim is to ensure that, if a node has on or more in-neighbors which wish to transmit a message, it will hear at least one of them.

The following lemma (cf. [\cite=-BGI92]) describes a basic property of Decay, as used in our analysis.

After four rounds of Decay(S), a node v with at least one in-neighbor in S receives a node ID with probability greater than [formula].

While Decay has a very localized effect, to achieve global tasks we will need more complex primitives.

Partial multi-broadcast

We consider a scenario when one wants to broadcast information to the entire network from multiple-sources. We will require a (S,f,l) algorithm with the following properties:

S  ⊆  V is a (possibly empty) set of source nodes;

f:S  →  {0,1}l, where l  =  O( log n), is a function giving each source a bit-string to broadcast. In our applications, this will either be a node ID, or a single bit "1";

Each node v interprets some bit-string m(v) upon completion;

If [formula], then m(v)  =  ε (the empty string) for all v;

If [formula], then [formula] [formula] with m(v)  =  f(s), i.e., each node interprets some source's bit-string.

The broadcasting algorithm of Czumaj and Rytter [\cite=-CR06], performed with every node in S operating as a single source and with nodes interpreting the first transmission they receive to be their m(v), yields:

There is a Partial Multi-Broadcast algorithm running in [formula] time, which succeeds with high probability.

Selection

We now consider another basic primitive, Selection, that relies on a combination of Decay and Partial Multi-Broadcast. The purpose of Selection, when run with a set of source nodes (also called candidates) as implicit input, is to determine which of the following three cases hold: if there are 0, 1, or multiple source nodes. In the latter case, it also gives information allowing the removal of the minimum candidate (by ID).

Formally, we require (S) with the following properties:

S  ⊆  V is a (possibly empty) set of source nodes;

Each node outputs a string m(v) and a bit b:

If [formula], then m(v)  =  ε (the empty string) for all v, and b = 0;

If |S|  =  1, then m(v) is equal to the ID of the sole node in S for all v, and b = 1;

If |S|  >  1, then b = 0 and m(v) is the ID of some node in [formula], where s is the node in S with lowest ID. (Here, we allow that m(v)  ≠  m(u) for distinct v,u.)

The output bit b is to indicate whether exactly one candidate remains, in which case we would have completed leader election and can terminate. This final condition is to allow the source node with the minimum ID to be removed: if any candidate who receives back a higher ID than his own drops out, then the condition ensures that at least one (min-ID) must drop out, and at least one (max-ID) remains.

We achieve the properties by Algorithm [\ref=alg:Debate]. Intuitively, in Selection(S), candidates broadcast out their IDs, ensuring that every node hears an ID. The executions of Decay then ensure that, with high probability, if a node has any in-neighbors who received a different ID, it will hear at least one of these IDs from them. Nodes who did detect such a conflict, called witnesses, then broadcast this information, along with the highest ID they heard, back throughout the network. Since any node ID which is broadcast back in this way must have been higher than a competing ID, the lowest cannot be among them.

We first prove a claim needed to detect multiple candidates and then show the correctness of Algorithm [\ref=alg:Debate].

If Algorithm [\ref=alg:Debate] is run with |S|  >  1, then the set W of witnesses is non-empty with high probability.

For any distinct u,v∈S let pu,v be the probability that there are fewer than log n bits i such that m(u)i  =  1 and m(v)i  =  0 or vice versa. Since, on each bit, this occurs independently with probability [formula], by a Chernoff bound [formula]. By the union bound, the probability that any pair has the property is at most [formula]. So, with high probability, for every u,v∈C there are at least log n bits i where m(u)i and m(v)i differ.

Assuming that [formula] is successful (which happens w.h.p.), there will be at least one node in the graph v which has at least one in-neighbor u such that m(v)  ≠  m(u). Then, w.h.p. there are at least log n bits i with m(u)i  =  1 and m(v)i  =  0. If Decay(Si) succeeds on any of these i then v becomes a witness. This happens with probability greater than [formula].

Algorithm [\ref=alg:Debate] satisfies the conditions for Selection with high probability, and terminates within [formula] time-steps.

If [formula] then clearly m(v) = ε and b = 1 for all v. If |S|  =  1 then w.h.p. all nodes will receive the ID of the sole source, and so none will become witnesses and all will output b = 1 as required. If |S|  >  1 the by the previous claim there will be at least one witness. Witnesses receive at least two IDs (one in the initial Partial Multi-Broadcast and one from the decay phase), and send out the highest of these in the second Partial Multi-Broadcast. Assuming these broadcasts are successful, all nodes will then output some non-minimum ID and b = 0.

Running time is dominated by that of two rounds of Partial Multi-Broadcast, taking [formula] time, and 64 log n rounds of Decay, taking O( log 2n) time.

Search

During the course of our high-probability algorithm we will wish to identify an ID or range of IDs which we know to be held by at least one candidate. We can do this by performing a binary search over the range of ID, using Partial Multi-Broadcast at every step to allow all nodes to agree on each bit of the ID. If IDs are unique and we identify one particular one, then we have performed leader election. However, doing so using this binary search technique would be too slow (log n times broadcasting time). What we will do, without incurring excessive time-cost, is partially complete the process, and have all nodes agree on the first [formula] bits of an ID, for some parameter [formula]. Since the remaining bits are undecided, this leaves a range of possible IDs.

Accordingly, we define a procedure [formula] with the following properties:

S  ⊆  V is a nonempty set of source nodes;

Each source node has an ID;

Each node receives as output the first [formula] bits of the highest ID in use.

These requirements are achieved by Algorithm [\ref=alg:Search].

Algorithm [\ref=alg:Search] performs Search in [formula] time, succeeding with high probability.

We prove by induction that, after iteration i of the For loop, all nodes know the first i bits of the largest ID in use. For the base case i = 1, all nodes with a first bit of 1 will participate in the Partial Multi-Broadcast. If there are any such nodes, the whole network will receive a transmission, and know that the first bit is 1; otherwise, all nodes will interpret ε and know that it is 0.

The same argument holds for the inductive steps: if the claim is true up to round j, then in round j + 1 all nodes whose IDs are in agreement with the highest for the first j bits, and who have a 1 as the j + 1th, participate in the Partial Multi-Broadcast. If there are any such nodes, all nodes are aware of this and set the j + 1th bit to 1, otherwise they set it to 0. Thereby all nodes now agree on the first j = 1 bits of the highest ID.

The procedure fails only if one of the O( log n) calls to Partial Multi-Broadcast fails, and so there is high probability of success.

Running time is [formula] times that of Partial Multi-Broadcast, i.e. [formula].

Beep Model

The beep model requires slightly different methods, since messages larger than one bit cannot be transmitted within a single time-step as in radio networks.

Beep Waves

We will need to have an analogue of [formula] for the beep model. For this purpose we will make use of a standard technique known as beep-waves, first mentioned in [\cite=-GH13]. Specifically, we require procedure [formula] which satisfies the following:

S  ⊆  V is a (possibly empty) set of source nodes;

[formula], where [formula], is a function giving each source a bit-string to broadcast.

Each node interprets a string m(v);

If [formula], then m(v)  =  ε (the empty string) for all v;

If S  =  {s}, for some s∈V, then [formula], m(v) = f(s);

If |S| > 1, then for all v, m(v)  ≠  ε. Furthermore, there exists w∈V and two distinct u,v∈S (we allow w∈{u,v}) such that [formula], for some bit-string m.

The last condition may seem convoluted; the reason for it is that, while we cannot guarantee messages are correctly received as in the single source case, we will at least need some means of telling that there were indeed multiple sources. This will be detailed later, but for now we require that, as well as all nodes receiving some non-empty message, at least one receives the logical OR of two source messages, possibly with some extra 1s. This node will act in a similar way to the witnesses in the Selection algorithm.

We achieve these conditions with Algorithm [\ref=alg:BW]. The intuition behind the algorithm is that a source uses beeps and silence to transmit the 1s and 0s of its message respectively (prefixed by a 1 so that it is obvious when transmission starts), and other nodes forward this pattern, one adjacency layer per time-step, by simply relaying a beep when they hear one. This process takes [formula] time, where [formula], as introduced above, is the maximum length, in bits, of message that is to be broadcast. Since we are here making the restriction [formula], our running time is O(D  +   log n).

We prove that the algorithm has the desired behavior:

If Beep-Wave[formula] is run with S = {s}, then [formula], m(v) = f(s)

Partition all nodes into layers depending on their distance from the source s, i.e. layer Li  =  {v∈V:dist(v,s)  =  i}. We first note that a node in layer i beeps for the first time in time-step i, since this first beep will propagate through the network one layer per time-step. The algorithm then ensures that such a node will beep only in time-steps equivalent to i mod 3, and only if a beep was heard in the previous step. Since all neighbors of the node must be in layers i - 1,i, and i + 1, only messages from neighbors in layer i - 1 can be relayed (as these are the only neighbors whose beeps are in time-steps equivalent to i  -  1 mod 3). It is then easy to see that layers act in unison, and beep if and only if the previous layer beeped in the previous time-step.

If Beep-Wave[formula] is run with |S| > 1 then there exists w∈V and two distinct u,v∈S (we allow w∈{u,v}) such that [formula], for some bit-string m.

Let u,v be the closest pair of sources in the graph. Let w be the midpoint on the shortest u  →  v path (if the path is of odd length, pick either midpoint arbitrarily).

If w is a source, then we can assume, without loss of generality, that w  =  u and v is an adjacent source. Then if f(w)i  =  1 or f(v)i  =  1, w receives or transmits a beep in time-step 3i and sets m(w)i  =  1, so we are done.

Otherwise, assume without loss of generality that dist(w,u)  ≤  dist(w,v)  ≤  dist(w,u) + 1, and denote j: = dist(w,u) - 1. w receives its first beep in time-step j. Then, since u is the closest source to every node along the shortest u  →  w path and v is the closest source to every node along the shortest v  →  w path, beeps from u and v will always be relayed along these paths. So, if f(u)i  =  1, w receives a beep in time-step j + 3i, and if f(v)i  =  1, w receives a beep in time-step dist(v,w)  -  1 + 3i  =  j + 3i or j + 3i + 1 (unless w beeps itself in time-step j + 3i + 1, i.e. it received a beep in time-step j + 3i). In either case, m(w)i is set to 1.

Algorithm correctly achieves the Beep-Wave conditions in [formula] time-steps.

Correctness for the cases |S|  =  1 and |S| > 1 follow from Lemmas [\ref=lem:BW1]-[\ref=lem:BW2], and the case [formula] follows since no node ever beeps. To analyze the running time: clearly all sources will have ceased transmission after [formula] time, and since beeps are propagated through the network one layer per time-step, it may be a further D time-steps before a source's last beep is heard by the whole network, yielding [formula] time.

Leader election algorithms

Having defined all of the primitives needed, we can now present our leader election algorithms.

Optimal expected-time leader election in radio networks

The approach in our optimal expected-time leader election, Algorithm [\ref=alg:LE], follows the ideas developed by Bar-Yehuda et al. [\cite=-BGI91], which in our framework can be described as follows: We repeatedly attempt to randomly select a single candidate, and then run a process to check whether we have indeed done so. If we have, we terminate the algorithm, and if not, we continue. Since we can achieve a constant probability of selecting one candidate, the expected number of iterations required to do so is also constant.

Algorithm [\ref=alg:LE] terminates in expected [formula] time and correctly performs leader election with high probability.

We first prove the correctness of Algorithm [\ref=alg:LE] and then analyze its running time.

Correctness:  If, in any iteration, |C|  =  1, then w.h.p., (C) will be successful (i.e. every node will receive the ID of the one candidate and b = 1), and the algorithm will terminate.

If |C|  =  0 or |C|  >  1, then w.h.p. (C) will correctly cause every node to set b = 0 and therefore again the iteration will end and the algorithm will continue.

Running time:   In any particular iteration, the probability that |C|  =  1 is [formula]. Therefore the expected number of iterations required until |C| = 1 is fewer than 3.

The running time of each iteration is dominated by that of [formula], which takes [formula] time. Hence, since an expected constant number of iterations is required, the expected asymptotic running time of the whole algorithm is [formula].

Observation on simulation of single-hop networks

We note that our approach in Algorithm [\ref=alg:LE] is similar to that used by Bar-Yehuda et al. [\cite=-BGI91] to simulate a single time-step of a single-hop network with collision detection using O(TBC) time-steps in a multi-hop network without collision detection (where TBC is the number of time-steps required to broadcast a single message throughout the latter network). They cite the leader election algorithm of Willard [\cite=-W86], for single-hop networks, as a prime application of their simulation method. This algorithm takes O( log  log n) time-steps and is optimal under its assumptions about the model. However, the standard model of multi-hop networks assumes that nodes have knowledge of n, or at least a common linear upper bound; this assumption is made, for example, in the work of Ghaffari and Haeupler [\cite=-GH13], who present leader election algorithms with the fastest-known high-probability running times. If this knowledge is available, a simpler algorithm in single-hop networks is possible (Algorithm [\ref=alg:LESH]), which achieves successful transmission, and hence election of a leader, in expected constant time.

From the perspective of this work, Algorithm [\ref=alg:LE] can be understood as being equivalent to the simulation of Algorithm [\ref=alg:LESH], using the optimal broadcasting algorithm of Czumaj and Rytter [\cite=-CR06].

While this approach yields an optimal expected-time algorithm, if we wished to achieve high probability the Ω( log n) lower bound for single-hop networks would seem to limit the effectiveness a similar approach. However, due to the fact that Selection can not only inform the network that there are multiple candidates but also provide enough information for the lowest to drop out, we can employ our techniques in a way that is not equivalent to simulating single-hop networks. As a result, we can get a high-probability leader election algorithm which beats the [formula] simulation lower bound.

Radio networks, high-probability running time

We present our second leader election algorithm for radio networks, which terminates in [formula] time and succeeds with high probability (Algorithm [\ref=alg:LE2]). This is the fastest algorithm for high probability of success on directed networks, though for undirected networks, it is slower than that of [\cite=-GH13].

The idea is to trade-off between the two methods of cutting down the field of candidates: we first perform a partial binary search to find a range of IDs in which we know that, with high probability, there are between 1 and [formula] candidates. We then remove candidates one at a time using our Selection procedure.

Algorithm [\ref=alg:LE2] completes leader election in time [formula] with high probability.

By Chernoff bound log n  ≤  |C|  ≤  16 log n w.h.p. Conditioning on this, we prove that with high probability no [formula] candidates from C share the same first [formula] bits of their ID. Let E be the event that this does not occur, i.e., that there are [formula] candidate such candidates. Then, by a union bound,

[formula]

Therefore, after execution of Search, with high probability no more than [formula] (and no fewer than 1) candidates remain. While there are still multiple candidates, each iteration of Selection removes at least one (the one with lowest ID), and so after [formula] iterations, only one remains. Since for any constant c we can bound the probability of failure of Selection above by n- c at only a constant factor slowdown, we can easily ensure that all [formula] succeed w.h.p.

The running time of the algorithm is dominated by the [formula] time of Search, and the [formula] total time of [formula] iterations of Selection. This gives a total running time of [formula].

Beep Model

Communication in the beep model relies on some different techniques from those used in radio networks, since messages cannot be transmitted in a single time-step and must instead be carried by procedures such as Beep-Wave. Nonetheless, our algorithm for leader election in the beep model (Algorithm [\ref=alg:LECD]) bears some similarities to Algorithm [\ref=alg:LE]. Again, we repeatedly attempt to randomly select a single candidate, and then run a procedure to check whether we have successfully done so. This is complicated by the fact that our method of broadcast experiences interference when attempted from multiple sources.

In any iteration of the loop of Algorithm [\ref=alg:LECD], w.h.p., every candidate chooses a different ID.

First, we note that |C|  ≤   log n w.h.p. Next, conditioned on |C|  ≤   log n, by the union bound, the probability that any pair of candidates a,b chooses the same ID is at most [formula]. This implies that every candidate chooses a different ID w.h.p.

Algorithm [\ref=alg:LECD] terminates in expected O(D  +   log n) time and correctly performs leader election with high probability.

We first prove the correctness of Algorithm [\ref=alg:LECD] and then analyze its running time.

Correctness:   In each iteration of the loop within Algorithm [\ref=alg:LECD], we consider three possible cases for the size of the set of candidates C:

If |C| = 1, then [formula] will ensure that every node receives the ID of the single candidate. Since this will have exactly log n [formula]s, The set W of witnesses will be empty, so the algorithm will successfully terminate.

If |C|  =  0, then all nodes will receive the empty string ε during [formula], and therefore the iteration will end and the algorithm will continue.

If |C|  >  1, then by Lemma [\ref=lem:BW3] there exists w∈V and distinct u,v∈S such that [formula], for some bit-string m. Since w.h.p. f(u)  ≠  f(v), and both contain log n [formula]s, m(w) contains strictly more than log n [formula]s, and so w becomes a witness. Then each node receives a transmission during Beep-Wave(W,1,1), so again the iteration will end and the algorithm will continue.

Running time:   In any particular iteration, the probability that |C|  =  1 is [formula]. Therefore the expected number of iterations required until |C| = 1 is fewer than 3.

The running time of each iteration is dominated by that of [formula] taking O(D  +   log n) time. Hence, the expected asymptotic running time of the whole algorithm is O(D  +   log n).

Conclusion

In this paper we present the first asymptotically optimal expected time leader election algorithms: one for the setting without collision detection, and another for undirected graphs with collision detection. Our leader election algorithm in networks without collision detection follows the simulation approach of Bar-Yehuda et al. [\cite=-BGI91] and achieves an optimal [formula] expected running time for directed (and also undirected) networks, when the size of the network, or a common upper bound, is known. We then extend the ideas behind this algorithm to take advantage of the presence of collision detection (even in the simplest beep model), and present an algorithm for the corresponding model which terminates in optimal O(D +  log n) expected time, this time though only for undirected networks. We also give an algorithm which for radio networks which terminates in [formula] time and succeeds with high probability.

There are several important open question in this area. Firstly, can anything be done in the case of directed graphs with collision detection? Here, the method of beep-waves used as the backbone of Algorithm [\ref=alg:LECD] does not provide the same guarantees, as a wave can revisit nodes it already passed through and be interpreted as a new transmission. The best known leader election algorithm in this setting is Algorithm [\ref=alg:LE] with an expected running time of [formula], but the only known lower bound is the same as that of undirected graphs, Ω(D +  log n), and we would wish to close this gap.

Secondly, what is the complexity of the leader election problem if we require high probability bounds for the running time? The best results in this direction, for undirected graphs, are the algorithms of Ghaffari and Haeupler [\cite=-GH13], with running times of [formula] without collision detection, and [formula] with collision detection, but these running times are off from the respective lower bounds by both an additive term and multiplicative factor. For the directed case our [formula]-time algorithm is the best known, but is again slower than the [formula] lower bound by a multiplicative factor.