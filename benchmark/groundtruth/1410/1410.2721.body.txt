A note on a sports league scheduling problem

Introduction

The sports league scheduling problem studied in this note, called "prob026" in CSPLib [\cite=CSPLib] and also known as the "balanced tournament design" problem in combinatorial design theory [\cite=Colbourn&Dinitz1996], is a NP-hard problem [\cite=Briskorn&al2010] that seems to be first introduced in [\cite=Gelling&Odeh1974]:

There are T = 2n teams (i.e., T even). The season lasts W = T - 1 weeks. Weeks are partitioned into P = T / 2 slots called "periods" or "stadiums". Each week, one match is scheduled in every period;

cH constraint: All teams play each other exactly once (Half competition);

cP constraint: No team plays more than twice in a Period. This constraint may be motivated by the equal distribution of stadiums to teams;

cW constraint: Every team plays exactly one game in every Week of the season, i.e., all teams are different in a week.

The problem then is to schedule a tournament with respect to these definitions and constraints. A solution to prob026 is a complete assignment of D  =  {(t,t'),1  ≤  t  <  t'  ≤  T} items (couples of teams) to variables of X = {x = 〈p,w〉,1  ≤  p  ≤  P,1  ≤  w  ≤  W} (couples of periods and weeks) verifying the constraint set C = {cH,cP,cW}, 〈p,w〉  =  (t,t') meaning that team t meets team t' in period p and week w. Thus, a solution can be conveniently represented by a P  ×  W sized table, whose items are integer couples (t,t'), see Table [\ref=Example_valid_schedule] for an example of a valid schedule for T  =  8. For T  =  70 teams, this represents a problem with 2 415 variables and 2 415 values per variable. There are T(T  -  1) / 2 matches to be scheduled. A valid schedule can be thought of as a particular permutation of these matches. So, for T teams, the search space size is !.

Direct construction methods exist when (T - 1) mod 3  ≠  0 [\cite=Hamiez&Hao2004a] [\cite=Haselgrove&Leech1977] or T / 2 is odd [\cite=Lamken&Vanstone1985] [\cite=Schellenberg&al1977]. However, finding a solution (schedule) in the general case for any arbitrary T remains a highly challenging task. Indeed, to our knowledge, the best performing search algorithm [\cite=Hamiez&Hao2008] can solve all the instances for T up to 50, but only some cases when 50  <  T  ≤  70. Other representative solution approaches include integer programming [\cite=McAloon&al1997] (limited to T  ≤  12), transformation into the SAT problem [\cite=Bejar&Manya2000] (T  ≤  20), distributed approach (T  ≤  28 according to [\cite=Gomes&al1998a]), constraint programming [\cite=vanHentenryck&al1999] and tabu search [\cite=Hamiez&Hao2001] (T  ≤  40).

In this paper, we present two improvements to the Enumerative Algorithm (EnASS) proposed in [\cite=Hamiez&Hao2008]. With the proposed enhancements, all the instances for 12  ≤  T  ≤  70 can now be solved.

We provide in the next section a brief recall of the original EnASS method. We show then in the following sections a new EnASS variant that solves all instances up to T  =  60 (including the problematic T mod 4  =  0 cases) and another new variant that solves all the 12  ≤  T  ≤  70 instances.

A brief recall of the EnASS algorithm

EnASS starts with a complete [formula] conflicting assignment. [formula] is built, in linear-time complexity, to satisfy the cW and cH constraints (thanks to patterned one-factorization [\cite=Colbourn&Dinitz1996]). At this stage, the remaining cP constraint is not verified in [formula], see Table [\ref=Initial_schedule_8] where team 8 appears more than twice in the 4th period.

Roughly speaking, EnASS uses [formula] to search for a valid tournament by filling a P  ×  W table (initially empty) row by row, see Algorithm [\ref=AlgoEnASS] where wf and wl are the first and last weeks EnASS considers when filling any period p (1  ≤  wf  <  wl  ≤  W), [formula] is the match in [formula] scheduled in period [formula] and week w, and R is a set of properties (or "Requirements") that (partial or full) solutions must verify. EnASS admits three integer parameters: p and w specify which 〈p,w〉 variable is currently considered, [formula] specifies the value assignment tried (see step [\ref=Assign]). The function returns TRUE if a solution has been found or FALSE otherwise. Backtracks are sometimes performed in the latter case. EnASS is called first, after the [formula] initialization, with p  =  1,w  =  wf and [formula] meaning that it tries to fill the slot in the first period of week wf with the [formula] match.

The basic EnASS skeleton presented in Algorithm [\ref=AlgoEnASS] solves prob026 only up to T  =  12 when the R set is restricted to [formula] while considering the first week as invariant with respect to [formula] (i.e., [formula]) with wf  =  2 (since the first week is invariant) and wl  =  W. Note that making the first week invariant helps to avoid some evident symmetries mentioned in [\cite=Hamiez&Hao2008].

To tackle larger-size problems, several EnASS variants were considered in [\cite=Hamiez&Hao2008]. EnASS0 solved prob026 up to T  =  32, except the T  =  24 case, including in R an implicit property (called "cD" in [\cite=Hamiez&Hao2008]) of all prob026 solutions: [formula]. The cD property was not originally mentioned in the seminal definition of the problem [\cite=Gelling&Odeh1974] and seems to be first introduced in [\cite=Schellenberg&al1977]. EnASS1, derived from EnASS0 by further including an "implied" requirement (r⇒), solved all instances up to T  =  50: [formula]. Finally, EnASS2 solved some cases (when T mod 4  ≠  0) for T up to 70 with two additional invariants (rI and rV): [formula].

Solving all instances of prob026 up to T  =  60

The rule r'⇒ used to solve all prob026 instances up to T  =  60 resembles the original r⇒ requirement introduced in [\cite=Hamiez&Hao2008]. Like r⇒, r'⇒ fixes more than one variable (two exactly, to be more precise) when exploring a new branch in the search tree. The difference between r⇒ and the new r'⇒ rule is the weeks that are concerned: While r⇒ connects any week wf  ≤  w  ≤  P to week T - w + 1, the r'⇒ constraint links any week 1  ≤  w  ≤  P  -  1 together with week W - w + 1. More formally, [formula].

This leads to EnASS3 which comes from the EnASS1 algorithm from [\cite=Hamiez&Hao2008] by replacing in R1 the r⇒ requirement with the new r'⇒ rule: R3  =  {cP,cD,r'⇒}. Like for EnASS1, step [\ref=Assign] in the basic EnASS description (see Algorithm [\ref=AlgoEnASS]) may be adapted since one additional variable has now to be instantiated and wl has to be set to P - 1 before running EnASS3. Steps [\ref=BeginPeriodFilled]-[\ref=EndPeriodFilled] have also to be modified since, when w  =  wl  +  1, the P week is not yet filled (so, the p period is not entirely filled either). Table [\ref=Example_valid_schedule] in Sect. [\ref=SectIntroduction] shows an example of a solution found by EnASS3 for T = 8: For instance, scheduling the (3,4) match from week 3 in period 2 forces the (5,6) match from week 5 (5 = 7 - 3 + 1) to be also in period 2.

In Table [\ref=CTS3vsCTS1], we show for 6  ≤  T  ≤  50 comparisons of our new EnASS3 variant (as well as another new EnASS4 variant discussed in the next section), against the EnASS1 algorithm which solves all the instances for T  ≤  50 within 3 hours per T value. The reported statistics include execution times (in seconds in all tables) and number of backtracks (columns labeled "|BT|") needed to find a first solution.

In Table [\ref=CTS3vsCTS2], we show for 52  ≤  T  ≤  70 comparisons between the new variant EnASS3 (and EnASS4) and the EnASS2 algorithm from [\cite=Hamiez&Hao2008] which solves some instances with T  ≤  70 where T mod 4  ≠  0. "-" marks in the "Time" (respectively "|BT|") columns indicate that the method found no solution within 3 hours (resp. that |BT| exceeds the maximal integer value authorized by the compiler/system, i.e., 4 294 967 295). All EnASS variants were coded in C and all computational results were obtained on an Intel PIV processor (2 Ghz) Linux station with 2 Gb RAM.

From Table [\ref=CTS3vsCTS1]-[\ref=CTS3vsCTS2], one observes that EnASS3 solves more prob026 instances than EnASS1 within 3 hours. Indeed, while EnASS1 is limited to T  ≤  50, EnASS3 finds solutions for T up to 56 in at most 67 minutes (see the T  =  50 case in Table [\ref=CTS3vsCTS1]). Moreover, except two cases ([formula]), the number of backtracks required to find a solution is much smaller for EnASS3 than for EnASS1.

Table [\ref=CTS3vsCTS2] shows that the comparison between EnASS3 and EnASS2 is somewhat mitigated. Indeed, EnASS3 is able to find solutions for all T up to 56 within 3 hours while EnASS2 solves the instances up to T = 70, but only when T mod 4  ≠  0. For the cases that are solved by both EnASS3 and EnASS2, EnASS2 finds a solution much faster. On the other hand, EnASS3 finds solutions for [formula] for which EnASS2 fails. Finally, one notices that EnASS3 requires much more time to solve the [formula] instances (about 55 hours for T  =  60).

Solving all prob026 instances when 50  <  T  ≤  70

The rule r'I used to solve all prob026 instances for 50  <  T  ≤  70 is similar to the original rI requirement introduced in [\cite=Hamiez&Hao2008]. Indeed, like rI, r'I inverses two weeks and keeps them invariant during the search. The only difference between rI and the new r'I rule is the weeks that are concerned: While rI considers weeks 2 and W, the r'I constraint inverses weeks 2 and W - 1. More formally, [formula].

This leads to EnASS4 which comes from EnASS3 by adding in R3 the new r'I rule: R4  =  {cP,cD,r'⇒,r'I}. Since the first two weeks are now invariant (and the last two due to r'⇒), wf has to be set to 3 before running EnASS4. Table [\ref=Example_valid_schedule] in Sect. [\ref=SectIntroduction] shows an example of a solution found by EnASS4 (and EnASS3) for T = 8: For instance, the first match in week 2 is [formula], i.e., 〈1,2〉  =  (6,8).

The computational performance of the EnASS4 variant is provided in Table [\ref=CTS3vsCTS1] for 6  ≤  T  ≤  50 and in Table [\ref=CTS3vsCTS2] for 50  <  T  ≤  70. One notices that EnASS4 is faster than EnASS3 and EnASS1 (see the "|BT|" columns in Table [\ref=CTS3vsCTS1]) to solve instances when T  ≥  12 (and for T = 8), except for the T∈{12,14,16,22,28,30} cases. Furthermore, within 3 hours per T value, EnASS4 is capable of solving larger instances (up to T = 62, see Table [\ref=CTS3vsCTS2]) than EnASS1 (T  ≤  50) and EnASS3 (T  ≤  56). While EnASS2 solves only some instances for 50  <  T  ≤  70 (those verifying T mod 4  ≠  0, see Table [\ref=CTS3vsCTS2]), EnASS4 finds solutions for all these cases. This is achieved within 3 hours for T up to 62, but larger instances can require more execution time (about 18 days for T = 70). Finally, note that adding the new r'I rule excludes solutions for T∈{6,10}.

Conclusion

We provided in this short note two enhancements to an Enumerative Algorithm for Sports Scheduling (EnASS) previously proposed in [\cite=Hamiez&Hao2008]. These enhancements are based on additional properties (identified in some solutions) as new constraints to reduce the search tree constructed by the algorithm. With these enhancements, all prob026 instances with T  ≤  70 can be solved for the first time. Since the main idea behind the enhancements is to add refined requirement rules in the EnASS method, we expect that the method can be further improved to solve prob026 instances for T  >  70.

Acknowledgments

This work was partially supported by the "Pays de la Loire" Region (France) within the LigeRO (2010 - 2013) and RaDaPop (2009 - 2013) projects.