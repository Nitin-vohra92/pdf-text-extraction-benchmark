Experimental Realization of Quantum Artificial Intelligence

As an approach to artificial intelligence (AI), machine learning is computer software that have the ability to learn from data for specific tasks when no direct solutions are available [\cite=intro_ml]. Machine learning is widely used in the fields such as data mining, where the amount of data grows rapidly and so does the required computational resources. There are two major types of machine learning which are supervised and unsupervised learning, differing from whether the training data are labeled in advance. Among the supervised machines, support vector machine (SVM) is a popular learning machine which learns from training data and classifies vectors in a feature space into one of two subgroups [\cite=csvm]. The machine first converts the training data to feature space and find the optimal hyperplane to divide the two subgroups. Then the machine could use the hyperplane to classify a new unknown instance which subgroup it belongs. The computational complexity of SVM in time is proportional to O(poly(NM)), where N is the number of dimensions of the feature space and M is the number of the training samples. It is well-known that quantum algorithms presented in many fields provide impressive speedup over their classical counterparts [\cite=Shor_algorithm] [\cite=Grover_search] [\cite=qcqi] [\cite=rv_qc]. In the area of AI, Rebentrost et. al. recently reported a quantum algorithm for SVM (QSVM)[\cite=qsvm] based on recently developed techniques[\cite=qpca] [\cite=qml] [\cite=qlinear], which can achieve O(log(NM)) of performance in both training and classifying process. The exponential speedup is achieved by utilizing a quantum circuit to calculate the inner products of the vectors in parallel[\cite=qml] and convert the SVM training to an approximate least-square problem which is subsequently solved it by the quantum matrix inversion algorithm[\cite=qlinear] [\cite=qfit].

Here we report an experimental implementation of the QSVM algorithm. To be more comprehensive, we apply the algorithm in a popular problem, i.e., a Optical Character Recognition (OCR) problem [\cite=ocr], to classify handwritten characters in a candidate set. In the state-of-art quantum computing technologies, only a limited number of qubits can be well controlled and managed. While on the other side, a realistic OCR problem in the QSVM may need tens of qubits, which can not be satisfied today. Thus here we restrict the problem to the minimal case where only two characters ( '6' and '9') are in the candidate set and only two features (horizontal and vertical ratios, which are defined in the following) are considered in the problem. This allows us to demonstrate this quantum artificial intelligence algorithm on a 4-qubit nuclear spin quantum processor at room-temperature.

A usual OCR process often contains four stages [\cite=ocr]: (i) preprocessing the image, (ii) dividing the sentence image into character images, (iii) extracting features from the image, and (iv) classifying the character image. Here the machine is only designed to recognize a single character image, thus the second stage for segmentation is not necessary. The quantum SVM here works as follows: first train the machine by the two printed image with standard font of the characters as in Fig. [\ref=fig:OCR_problem]a, and then the handwritten images of character '6' or '9' (as in Fig. [\ref=fig:OCR_problem]b) are provided and the machine recognize (classify) each to determine which character group it belongs. The vertical (horizontal) ratio is calculated from the pixels in the left (upper) half over the right (lower) half (as in Fig. [\ref=fig:OCR_problem]a). It is worth noting that, the machine actually works with a vector formed by the features of each image, and before feeding to the machine every image should be preprocessed, such as resizing the pixels. Furthermore we applied a linear conversion on the feature vectors to match our machine. After these preprocessing, the two printed image with standard font can be represented by [formula] for character "6" and [formula] for character "9". Before diving into the experimental details, we give a brief introduction to the SVM algorithm. The task for a SVM algorithm on classical computers is to classify a vector [formula] into one of two classes which is denoted by a variable [formula] for each class. In the training process where M training samples in the form [formula] are provided, the machine finds a maximum-margin hyperplane with normal vector [formula] which separates the samples by their classes. The margin in the vector space is bounded by two parallel hyperplanes with maximal possible distance [formula] and no points inside. Mathematically, we construct the hyperplane with [formula] so that [formula] for [formula] in the + 1 class and [formula] for [formula] in the - 1 class where [formula] is the offset of the hyperplane. Thus in this formation, to find the optimal hyperplane is to minimize [formula] subject to the constraints [formula] for all i. This dual formulation is to maximize the function [formula] over the Karush-Kuhn-Tucker multipliers [formula] subject to the constraints [formula] and [formula] [\cite=dual].

The hyperplane parameters [formula] and b could be recovered from the least-squares approximation of SVM [\cite=LS_SVM]:

[formula]

where K is the kernel matrix with [formula], [formula], [formula] and [formula] is the M  ×  M identity matrix. Here γ determines the relative weight of the training error and the SVM objective. Solving this linear equation leads to the value of offset b and the normal vector [formula]. Then the classification process for the handwritten character represented by [formula] is [formula], which also have a matrix form:

[formula]

In the OCR problem, we will define the character "6" as "positive class" , i.e. [formula], and the character "9" as "negative class", i.e. [formula].

The process of Least-squares SVM could be summarized as follows: (i) calculate the kernel matrix K, (ii) solving the LS-equation to obtain the hyperplane parameters, and (iii) the classification result will be produced from Eq. ([\ref=eq_classification]), which is the inner product of a query-vector and a training-data vector.

Stepping into the quantum SVM, we need to assume that we have the training-data oracles that could prepare the state [formula], which is the quantum counterpart of the training data [formula]. Starting from the initial state [formula], the training-data oracles are used to prepare the state [formula], with [formula]. After discarding the training set register, the quantum density matrix will reduce to the kernel matrix up to a constant factor, i.e., [formula] .

In the second step, the quantum algorithm for solving linear equation have been proposed [\cite=qlinear] and experimentally realized [\cite=LEexp_optics] [\cite=LEexp_NMR], with an exponentially speedup. Using the same method, the hyperplane parameters are determined by [formula], where the vectors here represent quantum states.

The classification results in Eq. ([\ref=eq_classification]) could be reproduced by the overlap of two quantum states : [formula], with the training-data state [formula] and the query-state [formula]. Here the training-data state |ũ〉 could be easily obtained by calling the training-data oracle on [formula]. By applying a inverse operation [formula], the expansion coefficients [formula] will produce the classification result [formula] [\cite=note1]. A schematic diagram of this part is shown in Fig. [\ref=Fig:Classification]. Note that the unitary operations are conditional operations here, controlled by an ancillary qubit. Hence the final state will be [formula], where [formula] and the subscript "A" indicates the state of ancillary qubit. By measuring the expectation value of coherent term [formula], the classification result will be revealed by:

[formula]

If the expectation value is greater than 0, the classification result will be positive ([formula]), otherwise it will be negative ([formula]).

Now we will turn to the experimental implementation of the quantum algorithm for OCR. We employ the widely-utilized nuclear magnetic resonance (NMR) technique [\cite=nmr1] [\cite=nmr2] [\cite=molsim] [\cite=cdsim] [\cite=compress] to realize the 4-qubit quantum processor. The experiments are carried out on a Bruker AV-400 spectrometer at 306 K. The sample used is the 13C-iodotrifluroethylene([formula]) dissolved in d-chloroform, which consists of a 13C nuclear spin and three 19F nuclear spins. The natural Hamiltonian of this weakly-coupled spin system in the rotating frame is

[formula]

with the parameters shown in Fig. [\ref=Fig:circuits]a. The deviation density matrix of thermal equilibrium state is [formula], where γi represents the gyromagnetic ratio of each nuclear spin.

The experimental procedure consists of three parts: (i) pseudopure state (PPS) preparation [\cite=pps1], (ii) building the kernel matrix K, and (iii) machine learning and classification. Starting from the thermal state [formula], the line-selective method is employed to prepare the PPS [\cite=PPS_preparation]: [formula]. Here [formula] represents the 16  ×  16 identity operator and ε  ≈  10   -   5 is the polarization.

The quantum circuit of the second part is shown in Fig. [\ref=Fig:circuits]. Here the first qubit (13C ) serves as the probe qubit, and the second qubit (training set register) is encoded with information of the two standard sample of the characters "6" and "9". The training-data oracle is realized by using two controlled rotations here. After that, the state of the probe qubit will represent the kernel matrix K, up to a constant factor [formula]. In the experiment, the density matrix [formula] is measured as [formula] by utilizing the quantum state tomography technique [\cite=tomo].

The third part of the experiment is classification. The training set are encoded into the system register (the third qubit). In this implementation, we will make the non-offset reduction, i.e., b = 0. Then the linear equation (Eq. ([\ref=eq:Linear_equation]))will reduce to [formula], which is 2  ×  2 dimensional in this case. The user-specified weight is set as γ = 2. Here by using a rotation along y axis, i.e. R-  π / 4y, the system register are prepared into [formula]. Then the phase estimation algorithm is used to realize the matrix inversion [\cite=qlinear] [\cite=qfit], which generate the state [formula]. In this stage, the weight of support vectors αi have been solved and stored into the system register, when the forth qubit is on state [formula]. By calling the training-data oracle again, the weights are encoded to the coefficient of related support vectors [formula], leading to the preparation of training-data state |ũ〉. Then the inverse operation Ux0, which relates to the query state x0, is applied. Note that these operations after matrix inversion F   -   1 should be conditional rotation, as shown in Fig. [\ref=Fig:Classification]. In experiment, we pack the circuit for matrix inversion into one shaped pulse optimized by the gradient ascent pulse engineering (GRAPE) method [\cite=GRAPE_method], with the length of each pulse being 20 ms and the number of segments being 1000. The rest parts of the circuit is packed into another GRAPE pulse, with the length being 25 ms and 2000 segments. All the pulses have theoretical fidelities over 99% and are designed to be robust against the inhomogeneity of radio-frequency pulses.

Finally, the classification result is read out through the expectation value of the coherent term of the ancillary qubit [formula]. The expression is slightly different from Eq. ([\ref=eq_classification_result]), since the auxiliary registers for matrix inversion are not shown there. In the experiment, the information of the ancillary qubit is transferred to the 13C spin by a gate, and then read through the 13C spectrum [\cite=C2F3I]. If the corresponding peak in 13C spectrum is upward (e.g. Fig. [\ref=Fig:Results]), the classification result will be positive, which means the character recognition results is "6". On the other hand, when the peak is downward, the classification result will be "9". In the experiment, we perform 8 different recognition tasks, corresponding to the 8 hand-written characters in Fig. [\ref=fig:OCR_problem]. The results are shown in Fig. [\ref=Fig:Results]b, which accord with human observation.

To conclude, in this letter we demonstrate the first artificial intelligence algorithm implemented quantum-mechanically on a four-qubit quantum processor, i.e., a quantum learning machine. As an example, we utilized the quantum support vector machine to solve a minimal optical character recognition problem. In the experiment, the quantum machine are trained with standard font of the characters "6" and "9", and then used to classify new-coming hand-written characters. The successful classification shows the ability of our quantum machine to learn and work like an intelligent human. This quantum machine could be extended to large-scale dataset using resources only logarithmic in feature size and the number of training data. This work paves the way to a bright future where the Big Data is processed efficiently in a parallel way provided by quantum mechanics.

This work was supported by the National Key Basic Research Program of China (Grant No. 2013CB921800), the National Natural Science Foundation of China (Grant No. 11227901, No. 91021005 and No. 61376128), the Strategic Priority Research Program (B) of the CAS (Grant No. XDB01030400) and the Fundamental Research Funds for the Central Universities.