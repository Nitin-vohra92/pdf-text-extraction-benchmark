=←

Learning Onto-Relational Rules with Inductive Logic Programming

,

Introduction

Rules are widely used in Knowledge Engineering (KE) and Knowledge Representation (KR) as a powerful way of modeling knowledge. In the broadest sense, a rule could be any statement which says that a certain conclusion must be valid whenever a certain premise is satisfied, i.e. any statement that could be read as a sentence of the form "if .. then ..". Rules have been successfully applied in the fields of Logic Programming (LP) and Deductive Databases [\cite=Ceri90]. Rules play also a role in the Semantic Web architecture. Interest in this area has grown rapidly over recent years as testified by the Rules Interchange Format (RIF) activity at W3C. Rules from the RIF perspective would allow the integration, transformation and derivation of data from numerous sources in a distributed, scalable, and transparent manner. Because of the great variety in rule languages and rule engine technologies, RIF consists of a core language to be used along with a set of standard and non-standard extensions. These extensions need not all be combinable into a single unified language. As for the expressive power, two directions are followed: monotonic extensions towards full First Order Logic (FOL) and non-monotonic (NM) extensions based on the LP tradition. The debate around a RIF has taken a long time also due to the controversial issue of having rules on top or aside ontologies [\cite=HorrocksADKGW03]. There is a consensus now on the fact that rules complement and extend ontologies. Indeed, rules can be used in combination with ontologies, or as a means to specify ontologies. They are also frequently applied over ontologies, to draw inferences, express constraints, specify policies, react to events, discover new knowledge, transform data, etc. In particular, RIF rules can refer to RDF and OWL facts. Since the design of OWL has been based on the [formula] family of very expressive Description Logics (DLs) (see Chapter [\ref=OL-book-chapter-description-logics] for an introduction), the NM dialects of RIF will most likely be inspired by those hybrid KR systems that integrate DLs and LP. Such rule formalisms are of interest to this chapter. We shall refer to them as onto-relational rule languages from now on. Apart from the specific ontology language, the integration of ontologies and rules is already present in existing knowledge bases (KBs). Notably the Cyc KB consists of terms (which constitute the vocabulary, i.e. the ontology) and assertions which relate those terms and include both simple ground assertions and rules [\cite=LenatGPPS90].

The acquisition of rules for very large KBs like Cyc is a very demanding KE activity. Indeed, according to an estimate from the Cyc project, human experts produce rules at the rate of approximately three per hour but can evaluate an average of twenty rules per hour. Also, for untrained knowledge engineers, while rule authoring may be very difficult, rule reviewing is feasible (although still difficult). A partial automation of the rule authoring task, e.g. by applying Machine Learning (ML) algorithms (see Chapter [\ref=OL-book-chapter-machine-learning] for an introduction), can be of help even though the automatically produced rules are not guaranteed to be correct. In fact, of those rules, some will turn out to be correct, and some will be found to need editing to be assertible. Yet, as mentioned above, rule reviewing is less critical than rule authoring. In order to partially automate the authoring of onto-relational rules, the bunch of ML techniques collectively known under the name of Inductive Logic Programming (ILP) [\cite=Nienhuys97] seems particularly promising for the following reasons. ILP was born at the intersection of ML and LP [\cite=Muggleton91a], and is widely recognized as a major approach to Relational Learning [\cite=DeRaedt08]. Apart from the KR framework of LP, the distinguishing feature of ILP, also with respect to other ML forms, is the use of prior domain knowledge in the form of a logical theory during the induction process. In this chapter we take a critical look at ILP proposals for learning relational rules while having an ontology as the background theory. These proposals try to overcome the difficulties of accommodating ontologies in Relational Learning. The work of [\cite=CabralKMWS05] on using semantic meta-knowledge from Cyc as inductive bias in an ILP system is another attempt at solving this problem though more empirically. Conversely, we promote an extension of Relational Learning, called Onto-Relational Learning (ORL), which accounts for ontologies in a clear, elegant and well-founded manner by resorting to onto-relational rule languages. In this chapter, for the sake of illustration, we provide details of a specific ORL solution to the problem of learning rule-based definitions of DL concepts and roles with ILP.

The chapter is organized as follows. Section [\ref=sect:pre] is devoted to preliminaries on LP and its applications to databases and ontologies as well as on ILP. Section [\ref=sect:ilp4sw-today] provides a state-of-the-art survey of ILP proposals for learning onto-relational rules. Section [\ref=sect:learning-fwk] describes in depth the most powerful of these proposals. Section [\ref=sect:concl] concludes the chapter with final remarks and outlines directions of future work.

Preliminaries

Logic Programming and databases

Logic Programming (LP) is rooted into a fragment of Clausal Logics (CLs) known as Horn Clausal Logic (HCL) [\cite=Lloyd87]. The basic element in CLs is the atom of the form [formula] such that each p is a predicate symbol and each tj is a term. A term is either a constant or a variable or a more complex term obtained by applying a functor to simpler term. Constant, variable, functor and predicate symbols belong to mutually disjoint alphabets. A literal is an atom either negated or not. A clause is a universally quantified disjunction of literals. Usually the universal quantifiers are omitted to simplify notation. Alternative notations are a clause as set of literals and a clause as an implication. A program is a set of clauses. HCL admits only so-called definite clauses. A definite clause is an implication of the form

[formula]

where m  ≥  0 and αi are atoms, i.e. a clause with exactly one positive literal. The right-hand side α0 and the left-hand side [formula] of the implication are called head and body of the clause, respectively. Note that the body is intended to be an existentially quantified conjunctive formula [formula]. Furthermore definite clauses with m  >  0 and m  =  0 are called rules and facts respectively. The model-theoretic semantics of HCL is based on the notion of Herbrand interpretation, i.e. an interpretation in which all all constants and function symbols are assigned very simple meanings. This allows the symbols in a set of clauses to be interpreted in a purely syntactic way, separated from any real instantiation. The corresponding proof-theoretic semantics is based on the Closed World Assumption (CWA), i.e. the presumption that what is not currently known to be true, is false. Deductive reasoning with HCL is formalized in its proof theory. In clausal logic resolution comprises a single inference rule which, from any two clauses having an appropriate form, derives a new clause as their consequence. Resolution is sound: every resolvent is implied by its parents. It is also refutation complete: the empty clause is derivable by resolution from any set S of Horn clauses if S is unsatisfiable. Negation As Failure (NAF) is related to the CWA, as it amounts to believing false every predicate that cannot be proved to be true. Clauses with NAF literals in the body are called normal clauses. The concept of a stable model, or answer set, is used to define a declarative semantics for normal logic programs [\cite=GelfondL91]. According to this semantics, a logic program may have several alternative models (but possibly none), each corresponding to a possible view of the reality. Also based on the stable model (answer set) semantics, Answer Set Programming (ASP) is an alternative LP paradigm oriented towards difficult search problems [\cite=MarekT99].

Definite clauses played a prominent role in the rise of deductive databases [\cite=Ceri90]. More precisely, functor-free non-recursive definite clauses are at the basis of the language Datalog for deductive databases [\cite=CeriGT89]. Generally, it is denoted by Datalog[formula] where [formula] is treated as NAF. The restriction of Datalog to only positive rules (i.e., rules without NAF literals) is denoted by Datalog. Based on the distinction between extensional and intensional predicates, a Datalog program Π can be divided into two parts. The extensional part, denoted as EDB(Π), is the set of facts of Π involving the extensional predicates, whereas the intensional part IDB(Π) is the set of all other clauses of Π. The main reasoning task in Datalog is query answering. A query Q to a Datalog program Π is a Datalog clause of the form

[formula]

where m  >  0, and αi is a Datalog atom. An answer to a query Q is a substitution θ for the variables of Q. An answer is correct with respect to the Datalog program Π if [formula]. The answer set to a query Q is the set of answers to Q that are correct w.r.t. Π and such that Qθ is ground. In other words the answer set to a query Q is the set of all ground instances of Q which are logical consequences of Π. Answers are computed by refutation.

Disjunctive Datalog (denoted as Datalog[formula]) is a variant of Datalog where disjunctions may appear in the rule heads [\cite=EiterGM97]. Therefore Datalog[formula] can not be considered as a fragment of HCL. Advanced versions (Datalog[formula]) also allow for negation in the bodies, which can be handled according to a semantics for negation in CLs. Defining the semantics of a Datalog[formula] program is complicated by the presence of disjunction in the rules' heads because it makes the underlying disjunctive logic programming inherently nonmonotonic, i.e. new information can invalidate previous conclusions. Among the many alternatives, one widely accepted semantics for Datalog[formula] is the extension of the stable model semantics to the disjunctive case.

Logic Programming and ontologies

The integration of LP and ontologies follows the tradition of KR research on so-called hybrid systems, i.e. those systems which are constituted by two or more subsystems dealing with distinct portions of a single KB by performing specific reasoning procedures [\cite=FrischC91]. The motivation for investigating and developing such systems is to improve on two basic features of KR formalisms, namely representational adequacy and deductive power, by preserving the other crucial feature, i.e. decidability. Indeed DLs and CLs are FOL fragments incomparable as for the expressiveness [\cite=Borgida96] and the semantics [\cite=Rosati05] but combinable at different degrees of integration: Tight, loose, full.

The semantic integration is tight when a model of the hybrid KB is defined as the union of two models, one for the DL part and one for the CL part, which share the same domain. In particular, combining DLs with CLs in a tight manner can easily lead to undecidability if the interaction scheme between the DL and the CL part of a hybrid KB does not solve the semantic mismatch between DLs and CLs [\cite=Rosati05-ppswr]. This requirement is known as DL-safety [\cite=MotikSS05]. With respect to this property, the hybrid KR system Carin [\cite=LevyR98] is unsafe because the interaction scheme is left unrestricted. Conversely, [formula]-log [\cite=Donini98] guarantees a safe interaction scheme by means of syntactic restrictions. Finally, [formula]+log[formula] [\cite=Rosati06] is weakly DL-safe because it relaxes the condition of DL-safety. The distinguishing features of these three KR frameworks are summarized in Table [\ref=tab:kr-comp] and further discussed in Section [\ref=sect:carin], [\ref=sect:al-log], and [\ref=sect:dl+log] respectively.

The semantic integration is loose when the DL part and the CL part are separate components connected through a minimal interface for exchanging knowledge. An example of one such kind of coupling is the integration scheme for ASP and DLs illustrated in [\cite=EiterILST08]. It derives from the previous work of the same authors on the extension of ASP with higher-order reasoning and external evaluations [\cite=DBLP:conf/ijcai/EiterIST05] which has been implemented into the system DLVHEX.

The semantic integration is full when there is no separation between vocabularies of the two parts of the hybrid KB. One such kind of coupling is achieved by means of the logic of Minimal Knowledge and Negation as Failure in [\cite=DBLP:journals/jacm/MotikR10].

A complete picture of the computational properties of systems combining DL ontologies and Datalog rules can be found in [\cite=Rosati08]. An updated survey of the literature on hybrid DL-CL systems [\cite=DBLP:series/lncs/DrabentEIKLM09] is suggested for further reading.

Carin

A comprehensive study of the effects of combining DLs and CLs (more precisely, Horn rules) can be found in [\cite=LevyR98]. Special attention is devoted to the DL [formula]. The results of the study can be summarized as follows: (i) answering conjunctive queries over [formula] TBoxes is decidable, (ii) query answering in [formula] extended with non-recursive Datalog rules, where both concepts and roles can occur in rule bodies, is also decidable, as it can be reduced to answering a union of conjunctive queries (UCQ), (iii) if rules are recursive, query answering becomes undecidable, (iv) decidability can be regained by disallowing certain combinations of constructors in the logic, and (v) decidability can be regained by requiring rules to be role-safe, where at least one variable from each role literal must occur in some non-DL-atom. The integration framework proposed in [\cite=LevyR98] and known as Carin is therefore DL-unsafe. Reasoning in Carin is based on constrained SLD-resolution, i.e. an extension of SLD-resolution with a tableau calculus for DLs to deal with DL literals in the rules. Constrained SLD-refutation is a complete and sound method for answering ground queries.

[formula]-log

[formula]-log is a hybrid KR system that integrates safely the DL [formula] and Datalog [\cite=Donini98]. In particular, variables occurring in the body of rules may be constrained with [formula] concept assertions to be used as 'typing constraints'. This makes rules applicable only to explicitly named objects. As in Carin, query answering is decided using the constrained SLD-resolution which however in [formula]-log is decidable and runs in single non-deterministic exponential time.

[formula]+log[formula]

The hybrid KR framework of [formula]+log[formula] allows a [formula] KB, i.e. a KB expressed in any DL, to be extended with weakly DL-safe Datalog[formula] rules [\cite=Rosati06]. Weak DL-safeness allows to overcome the main representational limits of the DL-safe approaches, e.g. the possibility of expressing UCQs, by keeping the integration scheme still decidable. For [formula]+log[formula] two semantics have been defined: a FOL semantics and a NM semantics. In particular, the latter extends the stable model semantics of Datalog[formula]. According to it, [formula]-predicates are still interpreted under OWA, while Datalog-predicates are interpreted under CWA. Notice that, under both semantics, entailment can be reduced to satisfiability and, analogously, that CQ answering can be reduced to satisfiability. The problem statement of satisfiability for finite [formula]+log[formula] KBs relies on the problem known as the Boolean CQ/UCQ containment problem in [formula]. It is shown that the decidability of reasoning in [formula]+log[formula], thus of ground query answering, depends on the decidability of the Boolean CQ/UCQ containment problem in [formula]. Currently, [formula] is one of the most expressive DLs for which this problem is decidable [\cite=GlimmHLS08].

Inductive Logic Programming

Inductive Logic Programming (ILP) was born at the intersection between LP and ML [\cite=Muggleton91a]. From LP it has borrowed the KR framework, i.e. HCL. From ML (more precisely, from Concept Learning) it has inherited the inferential mechanisms for induction, the most prominent of which is generalization. However, a distinguishing feature of ILP with respect to other forms of Concept Learning is the use of prior knowledge of the domain of interest, called background knowledge (BK). Therefore, induction with ILP generalizes from individual instances/observations in the presence of BK, finding valid hypotheses. Validity depends on the underlying setting. At present, there exist several formalizations of induction in ILP that can be classified according to the following two orthogonal dimensions: the scope of induction (discrimination vs characterization) and the representation of observations (ground definite clauses vs ground unit clauses). Discriminant induction aims at inducing hypotheses with discriminant power as required in tasks like classification. In classification, observations encompass both positive and negative examples. Characteristic induction is more suitable for finding regularities in a data set. This corresponds to learning from positive examples only. The second dimension affects the notion of coverage, i.e. the condition under which a hypothesis explains an observation. In learning from entailment, hypotheses are clausal theories, observations are ground definite clauses, and a hypothesis covers an observation if the hypothesis logically entails the observation. In learning from interpretations, hypotheses are clausal theories, observations are Herbrand interpretations (ground unit clauses) and a hypothesis covers an observation if the observation is a model for the hypothesis.

In Concept Learning, generalization is traditionally viewed as search through a partially ordered space of inductive hypotheses [\cite=Mitchell82]. According to this vision, an inductive hypothesis in ILP is a clausal theory and the induction of a single clause requires (i) structuring, (ii) searching and (iii) bounding the space of clauses [\cite=Nienhuys97]. First we focus on (i) by clarifying the notion of ordering for clauses. An ordering allows for determining which one, between two clauses, is more general than the other. Since partial orders are considered, uncomparable pairs of clauses are admitted. Given the usefulness of BK, orders have been proposed that reckon with it. Among them, generalized subsumption [\cite=Buntine88] is of major interest to this chapter: Given two definite clauses C and D standardized apart and a definite program K, we say that [formula] iff there exists a ground substitution θ for C such that (i) head(C)θ = head(D)σ and (ii) [formula] where σ is a Skolem substitution for D with respect to [formula]. Generalized subsumption is also called semantic generality in contrast to other orders which are purely syntactic. In the general case, it is undecidable. However, for Datalog it is decidable and admits a least general generalization. Once structured, the space of hypotheses can be searched (ii) by means of refinement operators. A refinement operator is a function which computes a set of specializations or generalizations of a clause according to whether a top-down or a bottom-up search is performed. The two kinds of refinement operator have been therefore called downward and upward, respectively. The definition of refinement operators presupposes the investigation of the properties of the various orderings and is usually coupled with the specification of a declarative bias for bounding the space of clauses (iii). Bias concerns anything which constrains the search for theories, e.g. a language bias specifies syntactic constraints such as linkedness and connectedness on the clauses in the search space. A definite clause C is linked if each literal li∈C is linked. A literal li∈C is linked if at least one of its terms is linked. A term t in some literal li∈C is linked with linking-chain of length 0, if t occurs in head(C), and with linking-chain of length d + 1, if some other term in li is linked with linking-chain of length d. The link-depth of a term t in li is the length of the shortest linking-chain of t. A clause C is connected if each variable occurring in head(C) also occurs in body(C).

ILP for Onto-Relational Rule Learning: State of the Art

Hybrid KR systems combining DLs and CLs with a tight integration scheme have very recently attracted some attention in the ILP community: [\cite=RouveirolV2000] chooses Carin-[formula], [\cite=Lisi08] resorts to [formula]-log, and [\cite=LisiE08-ilp] builds upon [formula]+log. A comparative analysis of the three is reported in Table [\ref=tab:ilp-comp]. They can be considered as attempts at accommodating ontologies in ILP. Indeed, they can deal with [formula], [formula], and [formula] ontologies respectively. We remind the reader that [formula] and [formula] are incomparable DLs whereas DLs in the [formula] family enrich [formula] with further constructors.

Closely related to KR systems integrating DLs and CLs are the hybrid formalims arising from the study of many-sorted logics, where a FOL language is combined with a sort language which can be regarded as an elementary DL [\cite=Frisch91]. In this respect the study of a sorted downward refinement [\cite=Frisch99] can be also considered as a contribution to the problem of interest to this chapter. Finally, some work has been done on discovering frequent association patterns in the form of DL-safe rules [\cite=JozefowskaLL10].

Learning Carin-[formula] rules

The framework proposed in [\cite=RouveirolV2000] focuses on discriminant induction and adopts the ILP setting of learning from interpretations. Hypotheses are represented as Carin-[formula] non-recursive rules with a Horn literal in the head that plays the role of target concept. The coverage relation of hypotheses against examples adapts the usual one in learning from interpretations to the case of hybrid Carin-[formula] BK. The generality relation between two hypotheses is defined as an extension of generalized subsumption. Procedures for testing both the coverage relation and the generality relation are based on the existential entailment algorithm of Carin. Following [\cite=RouveirolV2000], Kietz studies the learnability of Carin-[formula], thus providing a pre-processing method which enables ILP systems to learn Carin-[formula] rules [\cite=Kietz03].

Learning [formula]-log rules

In [\cite=Lisi08], hypotheses are represented as constrained Datalog clauses that are linked, connected (or range-restricted), and compliant with the bias of Object Identity (OI). Unlike [\cite=RouveirolV2000], this framework is general, meaning that it is valid whatever the scope of induction is. The generality relation for one such hypothesis language is an adaptation of generalized subsumption, named B-subsumption, to the [formula]-log KR framework. It gives raise to a quasi-order and can be checked with a decidable procedure based on constrained SLD-resolution [\cite=LisiM03-aiia]. Coverage relations for both ILP settings of learning from interpretations and learning from entailment have been defined on the basis of query answering in [formula]-log [\cite=LisiE04-ilp]. As opposed to [\cite=RouveirolV2000], the framework has been implemented in an ILP system [\cite=LisiM04] [\cite=DBLP:journals/ijswis/Lisi11]. More precisely, an instantiation of it for the case of characteristic induction from interpretations has been considered. Indeed, the system supports a variant of a very popular data mining task - frequent pattern discovery - where rich prior conceptual knowledge is taken into account during the discovery process in order to find patterns at multiple levels of description granularity. The search through the space of patterns represented as unary conjunctive queries in [formula]-log and organized according to B-subsumption is performed by applying an ideal downward refinement operator [\cite=LisiM03-ilp].

Learning [formula]+log rules

The ILP framework presented in [\cite=LisiE08-ilp] represents hypotheses as [formula]+log rules and organizes them according to a generality ordering inspired by generalized subsumption. The resulting hypothesis space can be searched by means of refinement operators either top-down or bottom-up. Analogously to [\cite=Lisi08], this framework encompasses both scopes of induction but, differently from [\cite=Lisi08], it assumes the ILP setting of learning from entailment only. Both the coverage relation and the generality relation boil down to query answering in [formula]+log, thus can be reformulated as satisfiability problems. Compared to [\cite=RouveirolV2000] and [\cite=Lisi08], this framework shows an added value which can be summarized as follows. First, it relies on a more expressive DL, i.e. [formula]. Second, it allows for inducing definitions for new DL concepts, i.e. rules with a [formula] literal in the head. Third, it adopts a more flexible form of integration between the DL and the CL part, i.e. the weakly-safe one.

The work reported in [\cite=LisiE09-ilp] [\cite=DBLP:journals/tplp/Lisi10] generalizes the results of [\cite=LisiE08-ilp] to any decidable instantiation of [formula]+log[formula]. The following section illustrates how learning [formula]+log[formula] rules can support the evolution of ontologies.

Learning Rule-based Definitions of [formula] Concepts and Roles with ILP

In KE, Ontology Evolution is the timely adaptation of an ontology to changed business requirements, to trends in ontology instances and patterns of usage of the ontology-based application, as well as the consistent management/propagation of these changes to dependent elements [\cite=StojanovicMMS02]. As opposed to Ontology Modification, Ontology Evolution must preserve the consistency of the ontology. According to [\cite=NoyK04] one can distinguish between conceptual, specification and representation changes. In this section we consider the conceptual changes of a [formula] ontology due to extensional knowledge (i.e., facts of the instance level of the ontology) previously unknown but classified which may become available. In particular, we consider the task of defining new concepts or roles which provide the intensional counterpart of such extensional knowledge and show how this task can be reformulated as an ORL problem [\cite=LisiE08-swap]. For example, the new facts LONER(Joe), LONER(Mary), and LONER(Paul) concerning known individuals may raise the need for having a definition of the concept LONER in the ontology. One such definition can be learned from these facts together with prior knowledge about Joe, Mary and Paul, i.e. facts concerning them and already available in the ontology. A crucial requirement is that the definition must be expressed as a [formula] formula or similar. In the following we provide the means for learning rule-based definitions of [formula] concepts/roles in the KR framework of [formula]+log[formula].

The learning problem

We assume that a [formula] ontology [formula] is integrated with a Datalog[formula] database Π to form a [formula]+log[formula] KB B. The problem of inducing rule-based definitions of [formula] concepts/roles that do not occur in B can be formalized as follows.

Given:

a [formula]+log[formula] KB B (background theory)

a [formula] predicate name p (target predicate)

a set [formula] of [formula] assertions that are either true or false for p (examples)

a set L of [formula]+log[formula] definitions for p (language of hypotheses)

the problem of building a rule-based definition of p is to induce a set H  ⊂  L (hypothesis) of [formula]+log[formula] rules from E and B such that:

The background theory B in Definition [\ref=def:learning-problem] can be split into an intensional part K (i.e., the TBox T plus IDB(Π)) and an extensional part F (i.e., the ABox A plus EDB(Π)). Also we denote by PC(B), PR(B), and [formula] the sets of concept, role and Datalog predicate names occurring in B, respectively. Note that [formula].

Suppose we have a [formula]+log[formula] KB B (adapted from [\cite=Rosati06]) built upon the alphabets PC(B)  =  {,}, PR(B)  =  {,}, and [formula] and consisting of the following intensional knowledge K: MM MMMMMM MM

[formula]

WANTS-TO-MARRY [formula] LOVES

[formula]

happy(X) ← famous(X), WANTS-TO-MARRY(Y,X) and the following extensional knowledge F: MM MMMMMM MM UNMARRIED(Mary) UNMARRIED(Joe) famous(Mary) famous(Paul) famous(Joe) scientist(Joe) meets(Mary,Paul,Italy) meets(Mary,Joe,Germany) meets(Joe,Mary,Italy) that concerns the individuals Mary, Joe, Paul, Italy, and Germany.

The hypothesis language L in Definition [\ref=def:learning-problem] is given as a set of declarative bias constraints. It allows for the generation of [formula]+log[formula] rules starting from three disjoint alphabets PC(L)  ⊆  PC(B), PR(L)  ⊆  PR(B), and [formula]. Also we distinguish between [formula] and [formula] in order to specify which Datalog predicates can occur in positive and negative literals, respectively. More precisely, we consider [formula]+log[formula] rules of the form

[formula]

where m,k,q  ≥  0, [formula] and each [formula], [formula], [formula] is an atom with [formula], [formula], and [formula]. The admissible rules must be compliant with the following restrictions:

which also guarantee that the conditions of linkedness and connectedness, usually assumed in ILP, are satisfied.

Suppose that the target predicate is the [formula] concept LONER. If [formula] is defined over [formula], then the following [formula]+log[formula] rules MMMMMM MMMMMM MM [formula] LONER(X) ← famous(X) [formula] LONER(X) ← famous(X), UNMARRIED(X) [formula] LONER(X) ← famous(X), [formula]happy(X) belong to [formula] and represent hypotheses of a definition for LONER.

Suppose now that the [formula] role LIKES is the target predicate and the set [formula] provides the building blocks for the language [formula]. The following [formula]+log[formula] rules MMMMMM MMMMMM MM [formula] LIKES(X,Y) ← meets(X,Z,Y) [formula] LIKES(X,Y) ← meets(X,Z,Y), happy(X) [formula] LIKES(X,Y) ← meets(X,Z,Y), RICH(Z) belonging to [formula] can be considered hypotheses of a definition for LIKES.

The set E of examples in Definition [\ref=def:learning-problem] contains assertions of the kind [formula] where p is the target predicate and [formula] is a tuple of individuals occurring in the ABox A. Note that, when p is a role name, the tuple [formula] is a pair < a1i,a2i  >   of individuals. We assume [formula]. However, a possibly incomplete description of each ei∈E is in B.

With reference to Example [\ref=ex:hyp-lang2], suppose that the following concept assertions: MMMMMM MMMMMM MM [formula] LONER(Mary) [formula] LONER(Joe) [formula] LONER(Paul) are examples for the target predicate LONER.

With reference to Example [\ref=ex:hyp-lang3], the following role assertions: MMMMMM MMMMMM MM [formula] LIKES(Mary,Italy) [formula] LIKES(Mary,Germany) [formula] LIKES(Joe,Italy) can be assumed as examples for the target predicate LIKES.

The ingredients for an ILP solution

In order to solve the learning problem in hand with the ILP methodological approach , the language L of hypotheses needs to be equipped with (i) a coverage relation which defines the mappings from L to the set E of examples, and (ii) a generality order [formula] such that [formula] is a search space.

The definition of a coverage relation depends on the representation choice for examples. The normal ILP setting is the most appropriate to the learning problem in hand and can be extended to the [formula]+log[formula] framework depicted in Definition [\ref=def:learning-problem] as follows.

We say that a rule h∈L covers (does not cover, resp.) an example [formula] w.r.t. a background theory B iff [formula] ([formula], resp.).

Note that the coverage test can be reduced to query answering w.r.t. a [formula]+log[formula] KB, which in turn can be reformulated as a satisfiability problem of the KB.

With reference to Example [\ref=ex:hyp-lang2] and [\ref=ex:observations2], the rule [formula] covers the example [formula] because all NM-models for [formula] do satisfy famous(Mary). It covers also [formula] and [formula] for analogous reasons. The rule [formula] covers only [formula] and [formula] whereas [formula] covers [formula] and [formula].

With reference to Example [\ref=ex:hyp-lang3] and [\ref=ex:observations3], the rule [formula] covers the example [formula] because all NM-models for [formula] do satisfy meets(Mary,Z,Italy). It covers also [formula] and [formula] for analogous reasons. The rule [formula] covers only [formula] and [formula] whereas [formula] covers only [formula] and [formula].

The definition of a generality order for hypotheses in L must consider the peculiarities of the chosen L. Generalized subsumption, subsequently extended in [\cite=Sakama01] to deal with NAF literals, is suitable for the problem in hand and can be adapted to the case of [formula]+log[formula] rules. In the following we provide a characterization of the resulting generality order, denoted by [formula], that relies on the reasoning tasks known for [formula]+log[formula] and from which a test procedure can be derived.

Let h1,h2∈L be two [formula]+log[formula] rules standardized apart, K a [formula]+log[formula] KB, and σ a Skolem substitution for h2 with respect to [formula]. We say that h1 is more general than h2 w.r.t. K, denoted by [formula], iff there exists a ground substitution θ for h1 such that (i) head(h1)θ = head(h2)σ and (ii) [formula]. We say that h1 is strictly more general than h2 w.r.t. K, denoted by [formula], iff [formula] and [formula]. We say that h1 is equivalent to h2 w.r.t. K, denoted by [formula], iff [formula] and [formula].

Let us consider the rules reported in Example [\ref=ex:hyp-lang2] up to variable renaming: MMMMMM MMMMMM MM [formula] LONER(A) ← famous(A) [formula] LONER(X) ← famous(X),UNMARRIED(X) In order to check whether [formula] holds, let σ  =  {  /  } a Skolem substitution for [formula] with respect to [formula] and θ  =  {  /  } a ground substitution for [formula]. The condition (i) is immediately verified. The condition

(ii) [formula]

is a ground query answering problem in [formula]+log[formula]. It can be easily proved that all NM-models for [formula] satisfy [formula]. Thus, it is the case that [formula]. The viceversa does not hold. Also, [formula] and [formula] is incomparable with [formula].

With reference to Example [\ref=ex:hyp-lang3], it can be proved that [formula] and [formula]. Conversely, the rules [formula] and [formula] are incomparable. Note that MMMMMM MMMMMM MM [formula] LIKES(X,Y) ← meets(X,Z,Y), LOVES(X,Z) [formula] LIKES(X,Y) ← meets(X,Z,Y), WANTS-TO-MARRY(X,Z) also belong to [formula]. It can be proved that [formula], [formula], and [formula].

Note that the decidability of [formula] follows from the decidability of [formula]+log[formula]. Also it can be proved that [formula] is a quasi-order (i.e., it is a reflexive and transitive relation) for [formula]+log[formula] rules, therefore the space [formula] can be searched by refinement operators like the following one able to traverse the hypothesis space top down.

Let L be a [formula]+log[formula] hypothesis language built out of the three finite and disjoint alphabets PC(L), PR(L), and [formula]. We define a downward refinement operator [formula] for [formula] such that, for each h∈L, the set [formula] contains all [formula] that can be obtained from h by applying one of the following refinement rules:

[formula]

[formula]

[formula]

[formula]

it does not exist any [formula] such that [formula]

[formula]

[formula]

[formula]

[formula]

[formula]

[formula]

All the rules of [formula] are correct, i.e. the [formula]'s obtained by applying any of the rules of [formula] to h∈L are such that [formula]. This can be proved intuitively by observing that they act only on body(h). Thus condition (i) of Definition [\ref=def:K-subsumption-2] is satisfied. Furthermore, it is straightforward to notice that the application of any of the rules of [formula] to h reduces the number of models of h. In particular, as for 〈SpecOntoLit_B〉, this intuition follows from the semantics of DLs. So condition (ii) also is fulfilled.

With reference to Example [\ref=ex:hyp-lang2], applying 〈AddDataLit_B+〉 to MMMMMM MMMMMM MM [formula] LONER(X) ← produces [formula] which can be further specialized by means of 〈AddOntoLit_B〉 and 〈AddDataLit_B-〉. Note that no other refinement rule can be applied to [formula] and that [formula] and [formula] are among the refinements of [formula].

With reference to Example [\ref=ex:hyp-lang3], applying 〈AddDataLit_B+〉 to MMMMMM MMMMMM MM [formula] LIKES(X,Y) ← produces [formula] which can be further specialized into [formula], [formula], [formula] and [formula] by means of 〈AddDataLit_B〉 and 〈AddOntoLit_B〉. Note that no other refinement rule can be applied to [formula] and that [formula] can be also obtained as refinement from [formula] via 〈SpecOntoLit_B〉.

An ILP algorithm

The ingredients identified in the previous section are the starting point for the definition of ILP algorithms. Figure [\ref=fig:foil-like-algo] reports the main procedure of a Foil-like algorithm, named OR-Foil, for learning onto-relational rules. In OR-Foil, analogously to Foil, the outer loop (steps 2-12) corresponds to a variant of the sequential covering algorithm, i.e., it learns new rules one at a time, removing the positive examples covered by the latest rule before attempting to learn the next rule (steps 11-12). The hypothesis space search performed by OR-Foil is best understood by viewing it hierarchically. Each iteration through the outer loop (steps 2-13) adds a new rule to its disjunctive hypothesis H. The effect of each new rule is to generate the current disjunctive hypothesis (i.e., to increase the number of instances it classifies as positive), by adding a new disjunct. Viewed at this level, the search is a bottom-up search through the space of hypotheses, beginning with the most specific empty disjunction (step 1) and terminating when the hypothesis is sufficiently general to cover all positive training examples (step 13). The inner loop (steps 5-9) performs a more fine-grained search to determine the exact definition of each new rule. This loop searches a second hypothesis space, consisting of conjunctions of literals, to find a conjunction that will form the body of the new rule. Within this space, it conducts a top-down, hill-climbing search, beginning with the most general preconditions possible (step 3), then refining the rule (step 6) until it avoids all negative examples. To select the most promising specialization from the candidates generated at each iteration, OR-Foil-ChooseBest (called at step 7) considers the performance of each candidate over E and chooses the one which maximizes the information gain. This measure is computed according to the following formula

[formula]

where p is the number of distinct variable bindings with which positive examples covered by the rule h are still covered by [formula] and cf() is the confidence degree. Thus, the gain is positive iff [formula] is more informative in the sense of Shannon's information theory (i.e. iff the confidence degree increases). If there are some literals to add which increase the confidence degree, the information gain tends to favor the literals that offer the best compromise between the confidence degree and the number of examples covered.

One may think to use the confidence degree defined for [formula]-Foil (see Chapter [\ref=OL-book-chapter-concept-learning] for more details) which takes OWA into account. Indeed, many individuals may be available which can not be classified as instances of the target concept nor of its negation. This requires a different setting able to deal with unlabeled individuals.

With reference to Example [\ref=ex:ref-op-2] and Example [\ref=ex:coverage-test2], we suppose that MM MMMMMM MM [formula] [formula] The outer loop of OR-Foil starts from [formula] which is further refined through the iterations of the inner loop, more precisely it is first specialized into [formula] which in turn, since it covers negative examples, is then specialized into [formula] and [formula] out of which the rule [formula] is added to [formula] the hypothesis because it does not cover negative examples. At this point the algorithm stops because [formula] covers both positive examples.

Following Example [\ref=ex:ref-op-3] and Example [\ref=ex:coverage-test3], we assume that [formula] and [formula]. At the end of the first iteration, [formula] is included into [formula] since it does not cover negative examples but only one positive example.

Final Remarks and Directions of Research

Building rules within ontologies poses several challenges not only to KR researchers investigating suitable hybrid DL-CL formalisms but also to the ML community which has been historically interested in application areas where the knowledge acquisition bottleneck is particularly severe. In particular, ORL may open up new opportunities for KE because it will make systems available to support the knowledge engineer in her most demanding task, i.e. defining rules that extend or complement an ontology. Thus, ORL may produce time and cost savings in KE. In this chapter, we have revised the ML literature addressing the problem of learning onto-relational rules. Very few ILP works have been found that propose a solution to this problem [\cite=RouveirolV2000] [\cite=Lisi08] [\cite=LisiE08-ilp]. They adopt Carin-[formula], [formula]-log and [formula]+log as KR framework, respectively. Note that matching Table [\ref=tab:ilp-comp] against Table [\ref=tab:kr-comp] one may figure out what is the state-of-the-art and what are the directions of research on onto-relational rules from the ML viewpoint. Also he/she can get suggestions on what is the most appropriate among these ILP frameworks to be implemented for a certain intended application. The specific solution illustrated in Section [\ref=sect:learning-fwk] takes advantage from an augmented expressive power thanks to the chosen [formula]+log[formula] instantiation [\cite=DBLP:journals/tplp/Lisi10]. It supports the evolution of ontologies with the creation of a concept/role, change operations which both boil down to the addition of new rules to the input KB.

From the comparative analysis of the ILP frameworks reviewed in Section [\ref=sect:ilp4sw-today], a common feature emerges: All proposals resort to Buntine's generalized subsumption and extend it in a non-trivial way. This choice is due to the fact that, among the semantic generality orders in ILP, generalized subsumption applies only to definite clauses, therefore suits well the hypothesis language in all three frameworks. Following these guidelines, new ILP frameworks can be designed to deal with more or differently expressive hybrid DL-CL languages according to the DL chosen (e.g., learning Carin-[formula] rules), or the clausal language chosen (e.g., learning recursive Carin rules), or the integration scheme (e.g., learning Carin rules with [formula]-literals in the head). An important requirement will be the definition of a semantic generality relation for hypotheses to take into account the background knowledge. Of course, generalized subsumption may turn out to be not suitable for all cases, e.g. for the case of learning [formula]+log[formula] rules [\cite=DBLP:journals/tplp/Lisi10]. Also it would be interesting to investigate how the nature of rules (i.e., the intended context of usage) may impact the learning process as for the scope of induction and other variables in the learning problem statement. For example, the problem of learning [formula]-log rules for classification purposes differ greatly from the apparently similar learning problem faced in [\cite=LisiM04]. Finally, it is worthy to consider hybrid KR formalisms with loose and full integration scheme.

Besides theoretical issues, most future work will have to be devoted to implementation and application. When moving to practice, issues like efficiency and scalability become of paramount importance. These concerns may drive the attention of ILP research towards less expressive hybrid KR frameworks in order to gain in tractability, e.g. instantiations of [formula]+log[formula] with DL-Lite [\cite=CalvaneseLRV04]. Applications can come out of some of the many use cases for Semantic Web rules specified by the RIF W3C Working Group.