Lemma Corollary

A (k  +  3) / 2-approximation algorithm for monotone submodular k-set packing and general k-exchange systems

Introduction

In the general k-set packing problem, we are given a collection G of sets, each with at most k elements, and an objective function [formula] assigning each subset of G a value, and seek a collection of pairwise-disjoint sets S  ⊆  G that maximizes f. In the special case that f(A)  =  |A|, we obtain the unweighted k-set packing problem. Similarly, if f is linear function, so that [formula] for some weight function [formula] we obtain the weighted k-set packing problem. In this paper we consider the case in which f may be any monotone submodular function.

For unweighted k-set packing, Hurkens and Schrijver [\cite=Hurkens-1989] and Halldórsson [\cite=Halldorsson-1995] independently obtained a k / 2  +  ε approximation via a simple local search algorithm. Using similar techniques, Arkin and Hassin [\cite=Arkin-1997] obtained a k  -  1  +  ε approximation for weighted k-set packing, and showed that this result is tight for their simple local search algorithm. Chandra and Halldórsson [\cite=Chandra-1999] showed that a more sophisticated local search algorithm, which starts with a greedy solution and always chooses the best possible local improvement at each stage, attains an approximation ratio of 2(k  +  1) / 3  +  ε. This was improved further by Berman [\cite=Berman-2000], who gave a non-oblivious local search algorithm yielding a (k  +  1) / 2  +  ε approximation for weighted k-set packing. Non-oblivious local search [\cite=Khanna-1994] is a variant of local search in which an auxiliary objective function to evaluate solutions, rather than the problem's given objective. In the case of Berman, the local search procedure repeatedly seeks to improve the sum of square of the weights in the current solution, rather than the sum of the weights.

Many of the above local search algorithms for k-set packing yield the same approximations for the more general problem of finding maximum independent sets in (k  +  1)-claw free graphs. Additionally, local search techniques have proved promising for other generalizations of k-set packing, including variants of the matroid k-parity problem [\cite=Lee-2010] [\cite=Soto-2011a]. Motivated by the similarities between these problems, Feldman et al. [\cite=Feldman-2011] introduced the class of k-exchange systems, which captures problems amenable to approximation by local search algorithms. These systems are formulated in the general language of independence systems, which we now briefly review.

An independence system is specified by a ground set G, and a hereditary (i.e. non-empty and downward-closed) family I of subsets of G. These subsets of G contained in I are called independent sets, and the inclusion-wise maximal sets of I are called bases of the independence system (I,G). Given an independence system (G,I) and a function [formula], we consider the problem of finding an independent set S∈I that maximizes f.

The class of k-exchange systems satisfy the following additional property:

A hereditary system I is a k-exchange system if, for all A and B in I, there exists a multiset [formula], containing a subset Ye of [formula] for each element [formula], that satisfies:

|Ye|  ≤  k for each x∈A.

Every [formula] appears in at most k sets of Y.

For all [formula], [formula].

We call the set Ye in Definition [\ref=def:k-exchange] the neighborhood of e in B. For convenience, we extend the collection Y in Definition [\ref=def:k-exchange] by including the set Yx  =  {x} for each element [formula]. It is easy to verify that the resulting collection still satisfies conditions [\ref=N1]-[\ref=N3].

The 1-exchange systems are precisely the class of strongly base orderable matroids described by Brualdi [\cite=Brualdi-1971]. This class is quite large and includes all gammoids, and hence all transversal and partition matroids. For k  >  1, the class of k-exchange systems may be viewed as a common generalization of the matroid k-parity problem in strongly base orderable matroids and the independent set problem in (k  +  1)-claw free graphs. Feldman et al. showed that k-exchange systems encompass a wide variety of combinatorial optimization problems, including as k-set packing, intersection of k strongly base orderable matroids, hypergraph b-matching (here k  =  2), as well as problems such as asymmetric traveling salesperson (here k  =  3).

Our results hold for any k-exchange system, and so we present them in the general language of Definition [\ref=def:k-exchange]. However, the reader may find it helpful to think in terms of a concrete problem, such as the k-set packing problem. In that case, the ground set G is the given collection of sets, and a sub-collection of sets S  ⊆  G is independent if and only if all of the sets in S are disjoint. Given A and B as in Definition [\ref=def:k-exchange], Ye is the set of all sets in B that contain any element contained by the set e∈A (i.e. the set of all sets in B that are not disjoint from e). Then, property [\ref=N3] is immediate, and [\ref=N1] and [\ref=N2] follow directly from the fact that each set in G contains at most k elements.

Related Work

Recently, the problem of maximizing submodular functions subject to various constraints has attracted much attention. We focus here primarily on results pertaining to matroid constraints and related independence systems.

In the case of an arbitrary single matroid constraint, Calinescu et al. have attained a e / (e  -  1) approximation for monotone submodular maximization, via the continuous greedy algorithm. This result is tight, provided that P  ≠  NP [\cite=Feige-1998]. In the case of k  ≥  2 simultaneous matroid constraints, an early result of Fisher, Nemhauser, and Wolsey [\cite=Fisher-1978] shows that the standard greedy algorithm attains a k  +  1 approximation for monotone submodular maximization. Fischer et al. state further that the result can be generalized to k-systems (a full proof appears in Calinescu et al. [\cite=Calinescu-2007]). More recently, Lee, Sviridenko, and Vondràk [\cite=Lee-2010a] have improved this result to give a k  +  ε approximation for monotone submodular maximization over k  ≥  2 arbitrary matroid constraints, via a simple, oblivious local search algorithm. A similar analysis was used by Feldman et al. [\cite=Feldman-2011] to show that oblivious local search attains a k  +  ε approximation for the class of k-exchange systems (here, again, k  ≥  2). For the more general class of k-systems, Gupta et al. [\cite=Gupta-2010] give a (1  +  β)(k  +  2  +  1 / k) approximation, where β is the best known approximation ratio for unconstrained non-monotone submodular maximization.

In the case of unconstrained non-monotone submodular maximization, Feige, Mirrokni, and Vondrák [\cite=Feige-2007] gave a randomized 2.5 approximation, which was iteratively improved by Gharan and Vondrák [\cite=Gharan-2011] and then Feldman, Naor, and Shwartz [\cite=Feldman-2011a] to ≈  2.38. For non-monotone maximization subject to k matroid constraints, Lee, Sviridenko, and Vondrák [\cite=Lee-2009] gave a k  +  2  +  1 / k  +  ε approximation, and later improved [\cite=Lee-2010a] this to a k  +  1  +  1 / (k  -  1)  +  ε approximation. Again, the latter result is obtained by a standard local search algorithm. Feldman et al. [\cite=Feldman-2011] apply similar techniques to yield a k  +  1  +  1 / (k  -  1)  +  ε approximation for non-monotone submodular maximization the general class of k-exchange systems.

Our Contribution

In the restricted case of a linear objective function, Feldman et al. [\cite=Feldman-2011] gave a non-oblivious local search algorithm inspired by Berman's algorithm [\cite=Berman-2000] for (k  +  1)-claw free graphs. They showed that the resulting algorithm is a (k  +  1) / 2  +  ε approximation for linear maximization in any k-exchange system. Here we consider a question posed in [\cite=Feldman-2011]: namely, whether a similar technique can be applied to the case of monotone submodular maximization in k-exchange systems. In this paper, we give a successful application of the non-oblivious local search techniques to the case of monotone submodular maximization in a k-exchange system. As in [\cite=Feldman-2011], the k-exchange property is used only in the analysis of our algorithm. The resulting non-oblivious local search algorithm attains an approximation factor of [formula]. For k  >  3, this improves upon the k  +  ε approximation obtained by the oblivious local search algorithm presented in [\cite=Feldman-2011]. Additionally, we note that our algorithm runs in time polynomial in ε- 1, while the k  +  ε approximation algorithm of [\cite=Feldman-2011] requires time exponential in ε- 1.

As a consequence of our general result, we obtain an improved approximation guarantee of [formula] for a variety of monotone submodular maximization problems (some of which are generalizations of one another) including: k-set packing, independent sets in (k  +  1)-claw free graphs, k-dimensional matching, intersection of k strongly base orderable matroids, and matroid k-parity in a strongly base orderable matroid. In all cases, the previously best known result was k  +  ε.

A First Attempt at the Submodular Case

Before presenting our algorithm, we describe some of the difficulties that arise when attempting to adapt the non-oblivious local search algorithm of [\cite=Feldman-2011] and [\cite=Berman-2000] to the submodular case. Our hope is that this will provide some intuition for our algorithm, which we present in the next section.

We recall that a function [formula] is submodular if [formula] for all A,B  ⊆  G. Equivalently, f is submodular if for all S  ⊆  T and all [formula], f(S  +  x)  -  f(S)  ≥  f(T  +  x)  -  f(T). In other words, submodular functions are characterized by decreasing marginal gains. We say that a submodular function f is monotone if it additionally satisfies f(S)  ≤  f(T) for all S  ⊆  T.

The non-oblivious algorithm of [\cite=Feldman-2011] for the linear case is shown in Algorithm [\ref=alg:nols]. It proceeds from one solution to another by applying a k-replacement (A,B). Formally, we call the pair of sets (A,B), where [formula] and B  ⊆  S a k-replacement if |A|  ≤  k, |B|  ≤  k2  -  k  +  1 and [formula]. Algorithm [\ref=alg:nols] repeatedly searches for a k-replacement that improves an auxiliary potential function w2. Because f is linear, it can be represented as a sum of weights, one for each element in S. If w(e)  =  f({e}) is the weight assigned to an element e in this representation, then the non-oblivious potential function is given by [formula]. That is, our non oblivious potential function w2(S) is simply the sum of the squared weights of the elements of S.

In the monotone submodular case, we can no longer necessarily represent f as a sum of weights. However, borrowing some intuition from the greedy algorithm, we might decide to replace each weight w(e) in the potential function w with the marginal gain/loss associated with e. That is, at the start of each iteration of the local search algorithm, we assign each element e∈G weight w(e)  =  f(S  +  e)  -  f(S  -  e), where S is the algorithm's current solution, then we proceed as before. Note that w(e) is simply the marginal gain attained by adding e to S, in the case that [formula] or the marginal loss suffered by removing e from S, in the case that e∈S. We define the non-oblivious potential function w2 in terms of the (current) weight function w, as before.

Unfortunately, the resulting algorithm may fail to terminate, as the following small example shows. We consider a simple, unweighted coverage function on the universe U  =  {a,b,c,x,y,z}, defined as follows. Let:

[formula]

We define G  =  {1,2,3,4} and [formula] for all A  ⊆  G. Finally, we consider the 2-exchange system with only 2 bases: P  =  {1,2} and Q  =  {3,4}. For current solution S  =  P we have w(1)  =  w(2)  =  1 and w(3)  =  w(4)  =  2. Since w2({1,2})  =  2  <  8  =  w2({3,4}), the 2-replacement ({3,4},{1,2}) is applied, and the current solution becomes Q. In the next iteration, we have S  =  Q, and w(1)  =  w(2)  =  2 and w(3)  =  w(4)  =  1, so the 2-replacement ({1,2},{3,4}) is applied by the algorithm. This returns us to the solution to P, where the process repeats indefinitely.

The New Algorithm

Intuitively, the problem with this initial approach stems from the fact that the weight function used at each step of the algorithm depends on the current solution S (since all marginals are taken with respect to S). Each time the algorithm makes an improvement, it changes the current solution, thereby changing the weights assigned to all elements in the next iteration. Hence, we are effectively making use of an entire family of non-oblivious potential functions, indexed by the current solution S. It may be the case that a k-replacement (A,B) results in an improvement with respect to the current solution's potential function, but in fact results in a decreased potential value in the next iteration, after the weights have been updated.

Surprisingly, we can solve the problem by introducing even more variation in the potential function. Specifically, we allow the algorithm to use a different weight function not only for each current solution S, but also for each k-replacement (A,B) that is considered. We give the full algorithm at the end of this section and a detailed analysis in the next.

Our general approach is to consider the elements of a set X in some order [formula], and assign to each e∈X in the set the marginal gain in f obtained when it is added to the set containing all the preceding elements of X. By carefully updating [formula] together with the current solution S at each step, we ensure that the algorithm converges to a local optimum. We now give the details for how are weights are calculated, given the current ordering [formula].

At each iteration of the algorithm, before searching an improving k-replacement, we assign weights w to all of the elements of the current solution S. The weights will necessarily depend on S, but remain fixed for all k-replacements considered in the current phase. Let si be the ith element of S in the ordering [formula] and let Si  =  {sj∈S:j  ≤  i} be the set containing the first i elements of S in the ordering [formula]. Then, the weight function [formula] is given by

[formula]

for all si∈S. Note that our weight function satisfies

[formula]

In order to evaluate each k-replacement (A,B), we need to assign weights to the elements in [formula]. We use a different weight function for each k-replacement. Suppose that we are considering the k-replacement (A,B). Let ai be the ith element of A in the ordering [formula] and let Ai  =  {aj∈A:j  ≤  i} be the set containing the first i elements of A in the ordering [formula]. Then, we define the weight function [formula] by

[formula]

for all ai∈A. Note that for every k-replacement (A,B),

[formula]

where the last inequality follows from the decreasing marginals characterization of submodularity. Note that since the function f is monotone submodular, all of the weights w and w(A,B) that we consider will be nonnegative. This fact plays a crucial role in our analysis.

Our final algorithm appears in Algorithm [\ref=alg:1]. We start from an initial solution [formula], consisting of the singleton set of largest value. Note that after applying a k-replacement (A,B), the algorithm updates [formula] to ensure that all of the elements of [formula] precede those of A. As we shall see in the next section, this ensures that the algorithm will converge to a local optimum. As in the linear case, we use the non-oblivious potentials [formula] and [formula]. Again, we note that while all of our weights implicitly depend on the current solution, the weights w(A,B) additionally depend on the k-replacement (A,B) considered.

Additionally, to ensure polynomial-time convergence, we round all of our weights down to the nearest integer multiple of α, depending on the parameter ε. This will ensure that every improvement improves the current solution by an additive factor of at least α2. Because of this rounding factor, we must actually work with the following analogs of ([\ref=eq:15]) and ([\ref=eq:16]):

[formula]

[formula]

Analysis of Algorithm [\ref=alg:1]

We now analyze the approximation and runtime performance of Algorithm [\ref=alg:1]. We now consider the worst-case ratio, or locality gap, f(O) / f(S) where S is any locally optimal solution (with respect to Algorithm [\ref=alg:1]'s potential function) and O is a globally optimal solution. We shall need the following technical lemma, which is a direct consequence of Lemma 1.1 in [\cite=Lee-2010a]. We give a proof here for the sake of completeness.

Let f be a submodular function on G, Let T,S  ⊆  G, and {Ti}ti = 1 be a partition of [formula]. Then,

[formula]

Define A0  =  S and [formula] for all 1  ≤  i  ≤  t. Suppose that Ti  =  {tj}|Ti|j  =  1. Then, note that S  ⊆  Ai  -  1 and [formula]. Submodularity of f implies that:

[formula]

Now, we have

We begin by considering the approximation ratio of Algorithm [\ref=alg:1]. Suppose that S is the locally optimal solution returned by the algorithm on some instance, while O is a global optimum for this instance. Then, for every k-replacement (A,B), we must have w2(A,B)(A)  ≤  w2(B), where w and each w(A,B) are weight functions determined by the solution S. We consider only a particular subset of k-replacements in our analysis.

We have S,O∈I for the k-exchange system I. Thus, there must be a collection Y assigning each e of O a neighborhood Ye  ⊆  S, satisfying the conditions of Definition [\ref=def:k-exchange]. For each x∈S, let Px be the set of all elements in e∈O for which: (1) x∈Ye and (2) for all z∈Ye, w(z)  ≤  w(x). That is, Px is the set of all elements of O in which x is the heaviest element. Note that the construction of Px depends on the fact that the weights w assigned to elements in S are fixed throughout each iteration, and do not depend on the particular improvement under consideration.

We define [formula], and consider (Px,Nx). Property [\ref=N2] of Y ensures that |Px|  ≤  k. Similarly, property [\ref=N1], together with the fact that all elements e∈Px have as a common neighbor x∈Ye, ensures that |Nx|  ≤  1  +  k(k  -  1)  =  k2  -  k  +  1. Finally, property [\ref=N3] ensures that [formula]. Thus, (Px,Nx) is a valid k-replacement for all sets Px  ⊆  O, x∈S. Observe that {Px}x∈S is a partition of O. Furthermore, by the definition of Px, we have w(x)  ≥  w(z) for all z∈Nx. Again, this depends on the fact that the weights of elements in S are the same for all k-replacements considered by the algorithm during a given phase.

The following extension of a theorem from [\cite=Berman-2000] allows us to relate the non-oblivious potentials w2 and w2(Px,Nx) to the weight functions w and w(Px,Nx) for each of our k-replacements (Px,Nx).

For all x∈S, and e∈Px,

[formula]

Let [formula], and b,c be such that w(x)  =  a  +  b and w(Px,Nx)(e)  =  a  +  c (note that b and c are not necessarily positive). Then, since e∈Px, every element z in Ye has weight at most w(x)  =  a  +  b. Furthermore, w(Ye  -  x)  =  w(Ye)  -  w(x)  =  a  -  b. Thus,

[formula]

Using [\eqref=eq:6] and our definition of a, b, and c, we have

[formula]

Using Lemma [\ref=thm:axy-lemma] we can prove the following lemma, which uses the local optimality of S to obtain a lower bound on the weight w(x) of each element x∈S.

For each x∈S, [formula].

Because S is locally optimal with respect to k-replacements, including in particular (Px,Nx), we must have:

[formula]

First, we consider the case w(x)  =  0. Recall that all the weights produced by the algorithm are non-negative. Because w(x) is the largest weight in Nx, we must have w(e)  =  0 for all e∈Nx and so w2(Nx)  =  0. Moreover, ([\ref=eq:7]) implies that w2(Px,Nx)(Px)  =  0 as well, and so, in particular, w(Px,Nx)(e)  =  0. The claim then follows.

Now, suppose that w(x)  ≠  0. From ([\ref=eq:7]), together with the fact that x∈Ye for all e∈Px, and the non-negativity of all the weights w, we have:

[formula]

Rearranging [\eqref=eq:8] using [formula] we obtain:

[formula]

Applying Lemma [\ref=thm:axy-lemma] to each term on the left of [\eqref=eq:9] we have:

[formula]

Dividing by w(x) (recall that w(x)  ≠  0) then yields

We now prove our main result, which gives an upper bound on the locality gap of Algorithm [\ref=alg:1].

[formula]

Lemma [\ref=thm:charge] gives us one inequality for each x∈S. We now add all |S| inequalities to obtain

[formula]

We have [formula] by ([\ref=eq:15r]). Additionally, from ([\ref=eq:16r]), [formula] for every Px. Thus, ([\ref=eq:10]) implies

[formula]

Since {Px}x∈S is a partition of O, ([\ref=eq:11]) is equivalent to

[formula]

We have w(x)  ≥  0 for all x∈S, and there are at most k distinct e for which x∈Ye, by property [\ref=N2] of Y. Thus, we have

[formula]

by ([\ref=eq:15]). Combining this with ([\ref=eq:12]), we obtain

[formula]

Using again the fact that P is a partition of O, we can apply Lemma [\ref=lem:submod] to the remaining sum on the left of [\ref=eq:2], yielding which simplifies to

[formula]

From the definition of α and the optimality of O, we have Finally, since f is monotone, we have [formula]. Thus, ([\ref=eq:17]) implies: which, after expanding the definition of δ and simplifying, is equivalent to [formula].

Next, we consider the runtime of Algorithm [\ref=alg:1]. Each iteration requires time O(n) to compute the weights for S, plus time to evaluate all potential k-replacements. There are O(nk  +  k(k  -  1)  +  1)  =  O(nk2  +  1) such k-replacements (A,B), and each one can be evaluated in time O(k2), including the computation of the weights w(A,B). Thus, the total runtime of Algorithm [\ref=alg:1] is O(Ik2nk2  +  1), where I is the number of improvements it makes. The main difficulty remaining in our analysis is showing that Algorithm [\ref=alg:1] constantly improves some global quantity, and so I is bounded. Here, we show that although the weights w assigned to elements of S change at each iteration, the non-oblivious potential w2(S), is monotonically increasing. While the preceding analysis of the locality gap is valid regardless of the particular ordering [formula] used to generate the weights, our analysis of the convergence of Algorithm [\ref=alg:1] requires that [formula] be updated at each phase to maintain the relative ordering of all elements in the current solution.

Finally, we consider what happens to the total squared weight w2(S) of the current solution after applying an k-replacement (A,B). In order to show that our algorithm terminates, we would like to show that this value is strictly increasing. To show this, it is sufficient to show that each weight w(x) for [formula] is strictly greater after applying the k-replacement than the corresponding weight before. Unfortunately, the weight assigned to an element is highly sensitive to the ordering [formula] in which elements are considered. Let w be the weight function for solution S, and w' be the weight function for solution [formula]. If [formula] for some x∈A, [formula], then in the updated weight function, we could have w'(y)  <  w(y), since w' considers the marginal gain of y with respect to a set containing x, while w does not (since [formula]). We avoid this phenomenon by updating the ordering [formula] each time an improvement is made. In particular, we ensure that all the elements of S and A are considered in the same relative order, but that all of A comes after all of S. As we shall show, this ensures that the weights assigned each individual element in the [formula] and A solution do not decrease after applying the k-replacement (A,B).

Suppose that for some k-replacement (A,B) and α  >  0, we have w2(A,B)(A)  ≥  w2(B)  +  α, and Algorithm [\ref=alg:1] applies the replacement (A,B) to S to obtain solution [formula]. Let wS be the weight function for solution S and wT be the weight function for solution T. Then, w2T(T)  ≥  w2S(S)  +  α.

After applying the k-replacement (A,B) to S, we obtain a new current solution [formula] and a new ordering [formula]. We now show that for any element [formula], we must have w(x)  =  wS(x)  ≤  wT(x) and for any element y∈A, we must have w(A,B)(y)  ≤  wT(y).

In the first case, let Sx be the set of all elements in S that come before x in the ordering [formula], and similarly let Tx be the set of all elements in T that come before x in [formula]. Suppose that for some element z∈T we have [formula]. Then, since [formula], we must have [formula]. Thus, Tx  ⊆  Sx. It follows directly from the submodularity of f that

In the second case, let Ay be the set of all elements of A that come before y in the ordering [formula], and let Ty be the set of all elements of T that come before y in the ordering [formula]. Suppose that for some element z∈T we have [formula]. Then, since y∈A, we must have either [formula] or z∈A and [formula]. Thus, [formula], and so

From the above bounds on w and w(A,B), together with the assumption of the lemma, we now have

[formula]

For any value ε∈(0,1), Algorithm [\ref=alg:1] makes at most O(n3ε- 2) improvements.

Note submodularity implies that for any element e and any set T  ⊆  G, we must have [formula]. In particular, for any solution S  ⊆  G with associated weight function w, we have

[formula]

Consider a given improvement (A,B) applied by the algorithm. Because every weight used in the algorithm is a multiple of α, we have w2(A,B)(A)  >  w2(B) only if w2(A,B)(A)  ≥  w2(B)  +  α2. Let [formula] be the solution resulting from the improvement, and, as in the proof of Lemma [\ref=lem:monotonic], let wS be the weight function associated with S and wT be the weight function associated with T. For any ε  >  0, we have α  >  0, and hence α2  >  0. Thus, from Lemma [\ref=lem:monotonic], after applying the improvement must we must have w2T(T)  ≥  w2S(S)  +  α2.

Thus, the number of improvements we can make is at most

[formula]

For any ε  >  0, Algorithm [\ref=alg:1] is a [formula] approximation algorithm, running in time O(ε- 2k2nk2  +  4).

Open Questions

We do not currently have an example for which the locality gap of Algorithm [\ref=alg:1] can be as bad as stated, even for specific k-exchange systems such as k-set packing. In the particular case of weighted independent set in (k  +  1)-claw free graphs Berman [\cite=Berman-2000] gives a tight example that shows his algorithm can return a set S with [formula]. His example uses only unit weights, and so the non-oblivious potential function is identical to the oblivious one. However, the algorithm of Feldman et al. (given here as Algorithm [\ref=alg:nols]) considers a larger class of improvements than those considered by Berman, and so Berman's tight example no longer applies, even in the linear case. For the unweighted variant, Hurkens and Schrijver give a lower bound of k / 2  +  ε, where ε depends on the size of the improvements considered. Because the non-oblivious local search routine performs the same as oblivious local search on instances with unit weights (since 1  =  12), this lower bound applies to Algorithm [\ref=alg:nols] in the linear case. From a hardness perspective, the best known bound is the Ω(k /  ln k) NP-hardness result of Hazan, Safra, and Schwartz [\cite=Hazan-2006], for the special case of unweighted k-set packing.

In addition to providing a tight example for our analysis, it would be interesting to see if similar techniques could be adapted to apply to more general problems such as matroid k parity in arbitrary matroids (here, even an improvement over k for the general linear case would be interesting) or to non-monotone submodular functions. A major difficulty with the latter generalization is our proof's dependence on the weights' non-negativity, as this assumption no longer holds if our approach is applied directly to non-monotone submodular functions.

The author thanks Allan Borodin for providing comments on a preliminary version of this paper.