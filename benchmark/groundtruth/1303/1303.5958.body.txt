Theorem Corollary Proposition

A Faster Algorithm for Computing Motorcycle Graphs

Lie Yan

Introduction

The straight skeleton of a polygon P is a straight line graph embedded in P, formed by the traces of the vertices of P when it is shrunk, each edge moving at the same speed and remaining parallel to its original position. (See  [\ref=fig:mgdef].) It has been known since at least the 19th century; for instance, figures representing the straight skeleton can be found in the book by von Peschka [\cite=peschka-1877]. Aichholzer et al. [\cite=aichholzer1995novel] gave the first efficient algorithms for computing the straight skeleton, and presented it as an alternative to the medial axis having only straight-line edges. The straight skeleton has found numerous applications in computer science, for instance to city model reconstruction [\cite=ld03], architectural modeling [\cite=Kelly11], polyhedral surface reconstruction [\cite=bgls03] [\cite=Fel98] [\cite=Oli96], biomedical image processing [\cite=Clo00]. It also has a direct application to CAD, as it allows to compute offset polygons [\cite=eppstein1999raising]. The straight skeleton has become a standard tool in geometric computing, and thus fast and robust software has been developed to compute it [\cite=Cacciola] [\cite=HuberH11] [\cite=PalfraderHH12].

The complexity of straight skeleton computation, however, is still very much open. The previously best known algorithms were the O(n17 / 11 + ε)-time algorithm by Eppstein and Erickson [\cite=eppstein1999raising], and the O(n3 / 2 log 2n)-time randomized algorithm by Cheng and Vigneron [\cite=ChengV07]. The only known lower bound is Ω(n log n), by a reduction from sorting [\cite=jeffwebpage]. In this paper, we give new subquadratic algorithms for computing straight skeletons. In particular, if all input coordinates are O( log n)-bit rational numbers, we give an [formula]-time randomized algorithm for computing the straight skeleton of a polygon with h holes. It is the first near-linear time algorithm for computing the straight skeleton of a simple polygon.

Eppstein and Erickson [\cite=eppstein1999raising] introduced motorcycle graphs so as to model the main difficulty of straight skeleton computation. We are given a set of n motorcycles, each motorcycle having a starting point and a velocity. Each motorcycle moves at constant velocity until it reaches the track left by another motorcycle, in which case it crashes. The resulting graph is called a motorcycle graph. (See  [\ref=fig:mgss]a.) The motorcycle graph is a special case of the straight skeleton, where each motorcycle is modeled by a small and thin triangle. Conversely, a polygon induces a motorcycle graph, where each motorcycle starts at a reflex vertex and moves with the same velocity as this vertex moves during the shrinking process. (See  [\ref=fig:mgss]b.) Cheng and Vigneron [\cite=ChengV07] showed that computing the straight skeleton of a non-degenerate polygon reduces to computing this induced motorcycle graph, and a lower envelope computation; Huber and Held extended this proof to degenerate cases [\cite=HuberH11]. The lower envelope computation can be done in [formula] expected time if P has h holes.

Previously, the bottleneck of straight skeleton computation was the induced motorcycle graph computation. This is our main motivation for designing a faster motorcycle graph algorithm. In this paper, we give an algorithm for computing a motorcycle graph that runs in O(n4 / 3 + ε) time, for any ε > 0, improving on all previously known algorithms. Here is a brief description of our algorithm. For each motorcycle, we maintain a tentative track, which may be longer than its actual track in the motorcycle graph. We also maintain a set of target points, which contains the endpoints of the tentative tracks that have been created earlier for this motorcycle, and that it has not reached yet. Initially, the tentative tracks are empty, and then we try to extend them one by one, all the way to the destination point. If two tentative tracks cross, we retract them, by roughly halving the number of possible crossing points on each of them. After performing this halving, the tentative tracks do not intersect, and we can safely move the motorcycle that reaches the end of its tentative track first. Then we try to extend the tentative track of this motorcycle to its next target point, and repeat the process. An example is given in Appendix [\ref=sec:example].

Apart from obtaining better time bounds for straight skeleton computation, there are at least two other reasons for studying motorcycle graphs. First, Huber and Held [\cite=HuberH11] used the idea of computing the straight skeleton from its induced motorcycle graph to design and implement a practical straight skeleton algorithm. So it is important, even in practice, to get a better understanding of motorcycle graph computation. Another motivation for studying motorcycle graphs is a direct application to computer graphics, for quad mesh partitioning [\cite=EppsteinGKT08].

Some of our results make no particular assumptions on the input, but we also present a few results where we assume that the input coordinates are O( log n)-bit rational numbers. We believe that this assumption is sufficient for most applications. For instance, in the applications mentioned above, it is hard to imagine that the input polygons would have features smaller than 1nm, and size larger than 1000km, so 64-bit integers should be more than sufficient.

Summary of our results and comparison with previous work

The main novelty in this paper is our algorithm for computing motorcycle graphs (Section [\ref=sec:algorithm]). This algorithm is essentially different from the two previous algorithms [\cite=ChengV07] [\cite=eppstein1999raising] that both simulate the construction in chronological order. Our algorithm, on the other hand, does not construct the motorcycle tracks in chronological order: It may move some motorcycle to its position at time t, and then later during the execution of the algorithm, move another motorcycle to its position at an earlier time t' < t. (We give one such example in Appendix [\ref=sec:example].) This answers an open question by Eppstein and Erickson [\cite=eppstein1999raising], who asked whether the running time can be improved by relaxing the chronology of the events.

Our algorithm uses two auxiliary data structures, one for ray shooting, and another for halving queries. Given a query segment on the supporting line of a motorcycle, a halving query returns a splitting point on this segment such that there are roughly the same number of intersections with other supporting lines on both sides. (See Section [\ref=sec:notation].) The implementation of these data structures in different settings lead to different time bounds.

For all our results, we use the standard real-RAM model [\cite=PreparataShamos], that allows to perform arithmetic operations exactly on arbitrary real numbers. But for some of our results, we make the assumption that all input coordinates are O( log n)-bit rational numbers. It has two advantages: It yields better time bounds, and allows us to handle the straight skeleton of degenerate polygons. This improvement comes from the fact that, for bounded precision input, two distinct crossing points between the supporting lines of two pairs of motorcycles are at distance 2- O( log n) from each other. It allows us to use a simpler halving scheme: Instead of halving a segment according to the number of intersection points, we use the midpoint according to the Euclidean distance. (See Section [\ref=sec:bpmg] and [\ref=sec:prelss].)

Arbitrary precision input.

For our first set of results, the input coordinates are arbitrary real numbers, on which we can perform exact arithmetic operations. In this case, our new algorithm computes a motorcycle graph in O(n4 / 3 + ε) time (Theorem [\ref=th:general]). This improves on the two subquadratic algorithms that were known before: the O(n17 / 11 + ε)-time algorithm by Eppstein and Erickson [\cite=eppstein1999raising], which was first published in 1998, and the O(n3 / 2 log n)-time algorithm by Cheng and Vigneron [\cite=ChengV07], which first appeared in 2002.

We also give, in Section [\ref=sec:coriented], an O(Cn log 2(n) min (C, log n))-time algorithm for the case of C-oriented motorcycles, where the velocities take only C different directions. This improves on the algorithm by Eppstein and Erickson [\cite=eppstein1999raising], which runs in O(n4 / 3 + ε) time when C = O(1).

Our last result with arbitrary precision input is an [formula] expected time algorithm for computing the straight skeleton of a polygon with n vertices and h holes. (This result does not hold for a degenerate polygon where two reflex vertices may collide during the shrinking process, as in  [\ref=fig:degenerate].) It improves on the algorithm by Cheng and Vigneron [\cite=ChengV07] which runs in [formula] expected time. It also improves on the O(n17 / 11 + ε) time bound of the algorithm by Eppstein and Erickson [\cite=eppstein1999raising], but their algorithm is deterministic and applies to degenerate cases.

Bounded precision input.

The following results hold when all input coordinates are O( log n)-bit rational numbers. There has been recent interest in studying computational geometry problems under a bounded precision model (the word RAM), for instance the computation of Delaunay triangulations, convex hulls, polygon triangulation and line segment intersections [\cite=BuchinM11] [\cite=ChanP09].

We first show in Section [\ref=sec:bpmg] that a motorcycle graph can be computed in O(n log 3n) time if the motorcycles move within a simple polygon, starting from its boundary. The only other non-trivial cases where we know how to compute a motorcycle graph in near-linear time seem to be the case where all velocities have positive x-coordinate, which can be solved in O(n log n) time by plane sweep, the case of a constant number of different velocity vectors [\cite=eppstein1999raising], or a constant number of directions (Section [\ref=sec:coriented]).

Then in Section [\ref=sec:bpss], we show that the straight skeleton of a polygon with n vertices and h holes can be computed in [formula] expected time. This result still holds in degenerate cases. So with bounded-precision input, and if we allow randomization, it improves on the O(n17 / 11 + ε)-time algorithm by Eppstein and Erickson [\cite=eppstein1999raising]. When h = o(n /  log 2n), it also improves on the O(n3 / 2 log 2n)-time algorithm by Cheng and Vigneron [\cite=ChengV07], which cannot handle all degenerate cases.

In particular, our algorithm runs in expected O(n log 3n) time when h = 0, so it is the first near-linear time algorithm for computing the straight skeleton of a simple polygon. The previously best known algorithms run in ω(n3 / 2) time in the worst case [\cite=ChengV07] [\cite=eppstein1999raising].

Notation and preliminaries

For any two points p,q, we denote by [formula] the line segment between p and q. Unless specified otherwise, [formula] is a closed segment. The relative interior of [formula] is the open segment [formula]. We say that two segments cross if their relative interiors intersect.

The motorcycles are numbered from 1 to n. Each motorcycle i has a starting point si, moves with constant velocity [formula], and has a destination point di that lies in the ray [formula]. (See  [\ref=fig:notation]a.) When [formula], we denote by τ(i,p) the time when motorcycle i reaches p, so [formula]. The supporting line [formula] of motorcycle i is the line through si with direction [formula].

Each motorcycle i starts at si at time 0, and moves at velocity [formula] until it meets the track left by another motorcycle and crashes, or it reaches di and stops. So motorcycle i crashes if it reaches a point p such that τ(i,p)  ≥  τ(j,p), for some motorcycle j that has not crashed or stopped earlier than τ(j,p). If motorcycle i crashes, we denote by κi the point where it crashes, called the crashing point. (See  [\ref=fig:notation]b.) Otherwise, i reaches di, and we set κi = di. The trajectory of i is the segment [formula]; in other words it is the track of i in the motorcycle graph.

In the original motorcycle graph problem, the destination point di is at infinity in direction [formula]. We can handle this case by computing a bounding box that includes all the vertices of the arrangement of the supporting lines [formula], [formula], and choosing as destination points the intersections of the rays [formula] with the bounding box. The bounding box can be computed in O(n log n) time as any extreme vertex in the arrangement is the intersection of two lines with consecutive slopes.

Unless specified otherwise, we make the following general position assumptions. No two motorcycles share the same supporting line, or have parallel supporting lines. No three supporting lines are concurrent. No point si,di lies on [formula] if j  ≠  i. No two motorcycles reach the same point at the same time. (We make these assumptions so as to simplify the description of the algorithm and the proofs, but our results still hold in degenerate cases.)

The crossing point χij is the intersection between [formula] and [formula], and thus [formula]. The size |pq| of a segment [formula] is the number of crossing points χij that lie in [formula]. (See  [\ref=fig:size].) We will need a data structure to answer halving queries: Given a query (i,p,q) where p,q are points on the supporting line [formula], find a point [formula] such that |ph|  ≤  ⌈ρ|pq|⌉ and |hq|  ≤  ⌈ρ|pq|⌉, for a constant ρ < 1. In addition, we require that h is not a crossing point, and that both |ph| and |hq| are strictly smaller than |pq| if |pq|  ≥  2.

Algorithm for Computing Motorcycle Graphs

In this section, we present our algorithm for computing motorcycle graphs, as well as its proof of correctness and analysis. An example of the execution of this algorithm on a set of 4 motorcycles is given in Appendix [\ref=sec:example].

Algorithm description

Our algorithm maintains, for each motorcycle i, a confirmed track [formula], and a tentative track [formula], such that [formula] and [formula]. So the tentative track is at least as long as the confirmed track. As we will show in the next section, the confirmed track is a subset of the trajectory, so we have [formula] at any time during the execution of the algorithm. The tentative track, however, may go beyond κi. (See Appendix [\ref=sec:example].)

Our algorithm will ensure that no two tentative tracks cross. We keep all the tentative tracks in a ray shooting data structure, so that we can enforce this invariant by checking for intersection each time we try to extend a tentative track. This data structure returns the first tentative track hit by a query ray [formula], if any. We also build a data structure to answer halving queries, which will be used to shorten tentative tracks and keep them disjoint.

Our algorithm builds the motorcycle graph by extending the confirmed tracks until they form the whole motorcycle graph. We may also update the tentative track of a motorcycle when we extend its confirmed track.

A set of target points is associated with each motorcycle i. In particular, we maintain in a stack Si the set of target points that lie beyond the confirmed track of motorcycle i, thus [formula]. In other words, Si records the target points that motorcycle i has not reached yet. (See  [\ref=fig:tracks].) The stack Si is ordered from ci to di. We denote by [formula] its first element, so [formula] is the target point in Si that is closest to ci. At the beginning, we set Si  =  {si,di} for all i. New target points will be created in Case (3b) of our algorithm, as described below.

If motorcycle i has neither crashed nor stopped, then its tentative track ends at the first target point in Si, so [formula]. Otherwise, the tentative track and the confirmed track are the same, thus ti = ci. So after a motorcycle has crashed or stopped, the ray shooting data structure records its confirmed track.

An event (i,p) happens when a motorcycle i reaches a target point p. We process events one by one, and while an event is being processed, new events may be generated. After an event has been processed, we process the earliest available event. As [formula] is the closest target point to i in Si, it means that we always process the event (i,ti) such that τ(i,ti) is smallest. Note that it does not imply that our simulation is done in chronological order: When we process an event (i,ti), we may create a new event (j,p) such that τ(j,p)  <  τ(i,ti). (See Appendix [\ref=sec:example].)

We record in a priority queue Q the event (i,ti) for each motorcycle i that has not crashed or stopped. An event with earlier time τ(i,ti) has higher priority. As [formula], we can update the event queue Q in O( log n) time each time a stack Si is updated. So we can find the next available event in O( log n) time. The first n events are the events (i,si), [formula], and occur at time t = 0. We process these n events in an arbitrary order.

We now explain how to process an event (i,ti). To avoid confusion, for any motorcycle j, we use the notation cj,tj to denote the endpoints of its confirmed and tentative track just before processing this event, and we use the notation c'j,t'j for their position just after processing this event. We first extend the confirmed track of motorcycle i to ti, thus c'i  =  ti. We also delete ti from Si. We are now in one of the following cases:

If ti = di, then motorcycle i stops. In order to avoid processing irrelevant events in the future, we remove Si from Q.

If ti is a crossing point χij that lies in the confirmed track of j (that is, [formula]), then i crashes at ti. So we remove Si from Q.

Otherwise, we try to extend the tentative track to the next target point [formula]. So we perform a ray shooting query with ray [formula], which gives us the first track intersected by [formula], if any.

If [formula] does not cross any track, then t'i = q, and we do not need to do anything else to handle this event.

Otherwise, let j be the result of the ray-shooting query, so [formula] is the first track hit by segment [formula], starting from ti. We shorten the tentative track of i, which means that we insert the new target point χij into Si, as well as the point t'i = h(ti,χij) obtained by a halving query on [formula]. If the crossing point χij does not lie in the confirmed track of j, that is, if [formula], then we also shorten the tentative track of j, so we insert χij into Sj, and we insert t'j = h(cj,χij) into Sj.

After applying the rules above, we update the ray shooting data structure (if needed), and we move to the next available event.

Proof of correctness

Initially, we create the target points si,di for [formula]. After this, we create new target points only in Case (3b) of our algorithm. There are two types of such target points: the crossing points χij obtained by ray-shooting, and the points obtained by halving queries. We call χ-targets the first type of target points, and h-targets the latter. By our assumption that the result of a halving query is not a crossing point, a target point cannot be both a h-target and a χ-target.

We need the following lemma. Remember that we say that two segments cross if their relative interiors intersect.

During the course of the algorithm, no two tentative tracks cross.

For sake of contradiction, assume that two tentative tracks cross during the course of the algorithm. Let (i,ti) be the first event that generates such a crossing, so just before processing this event, the tentative tracks [formula], [formula] do not cross, and there is a crossing among the tracks [formula]. We must be in Case (3), because we do not extend any tentative track in cases (1) and (2). Besides, we only extend the track of motorcycle i in Case (3). So there must be another motorcycle k  ≠  i such that [formula] crosses [formula].

In Case (3a), the segment [formula] obtained by ray shooting does not cross any tentative track [formula], j  ≠  i, and since t'i = q, then the new portion [formula] of the track does not cross any other tentative track. The same is true in Case (3b), because t'i is in [formula], where track j is the first track hit by [formula]. So we just proved that, in any case, the new portion [formula] of the track does not cross any track [formula], j  ≠  i, and in particular, [formula] does not cross [formula].

By our assumption, we also know that [formula] cannot cross [formula]. So the only remaining possibility is that [formula] crosses [formula] at ti. Then ti is the crossing point χik. This point ti  =  χik cannot be in the confirmed track [formula], because that would be Case (2) of our algorithm, and we showed that we are in Case (3). Since χik is a χ-target of i, and it does not lie in the confirmed track of k, then it must have been inserted at the same time in Si and Sk while processing a previous event. Since χik is not on the confirmed track of k, then it must still be in Sk. So the tentative track [formula] cannot contain χik in its relative interior, a contradiction.

We want to argue that our algorithm computes the motorcycle graph correctly. So assume it is not the case. As our algorithm moves motorcycles forward until they either reach their destination point or crash, it could only fail if during the execution of our algorithm, the confirmed track of at least one motorcycle i goes beyond the point κi where it is supposed to crash in the motorcycle graph. Let us consider the event (i,ti) that is first processed by our algorithm, such that motorcycle i goes beyond κi. So κi is in the segment [formula]. Let j denote the motorcycle that i crashes into, in the (correct) motorcycle graph, so κi  =  χij.

When we process (i,ti), in the current graph constructed by our algorithm, motorcycle j cannot have reached dj, because it would mean that the tentative tracks [formula] and [formula] are crossing at κi  =  χij, which is impossible by Lemma [\ref=lem:invariant].

We now rule out the case where, when our algorithm processes (i,ti), motorcycle j has already crashed into some motorcycle k in the graph constructed by the algorithm. (See  [\ref=fig:correctness2].) For sake of contradiction, assume it did happen.

If we had i = k, then χij would have been created as a χ-target for j earlier. At this point, i had not gone past χij, because (i,ti) is the first such event. As τ(j,χij) < τ(i,χij), the algorithm would have moved j to χij before i moves further, and thus j would not crash at χij, a contradiction.

Thus we must have i  ≠  k. As ti is beyond κi  =  χij, and tentative tracks cannot cross, we must have [formula]. So j crashed into k at [formula]. As in the correct motorcycle graph, j does not crash into k, it means that the algorithm has already moved k past its (correct) crashing point, which contradicts our assumption that (i,ti) was the first such event.

We just proved that j has not stopped or crashed when the algorithm processes event (i,ti), so at this point there should be an event (j,tj) in the queue. By Lemma [\ref=lem:invariant], the tracks [formula] and [formula] cannot cross, so we must have [formula]. (See  [\ref=fig:correctness].) It implies that τ(j,tj)  ≤  τ(j,κi). But since i crashes into j in the (correct) motorcycle graph, we must have τ(j,κi) < τ(i,κi), thus τ(j,tj)  <  τ(i,κi). As [formula], we have τ(i,κi)  ≤  τ(i,ti), thus τ(j,tj)  <  τ(i,ti). But this is impossible, because our algorithm always processes the earliest available event, so it would have processed (j,tj) rather than (i,ti).

Analysis

Our algorithm uses two auxiliary data structures: for answering halving queries, and for ray shooting. The running time of our algorithm depends on their preprocessing time and query time. Let P(n) denote an upper bound on the preprocessing time of these two data structures, and let Q(n) denote an upper bound on the time needed for a query or update--so we can answer a ray-shooting query or a halving query in time Q(n), and we can update the ray shooting data structure in time Q(n). We now prove the following result:

We can compute a motorcycle graph of size n in time O(P(n) + n(Q(n) +  log n) log n).

Each time we handle an event, we perform at most two halving queries, one ray-shooting query, and we may update two tentative tracks in the ray-shooting data structure. We also pay an O( log n) time overhead to update the priority queue Q. So after preprocessing, the running time will be at most the number of events times Q(n) +  log n. Thus we only need to argue that our algorithm processes a total of O(n log n) events. In fact, at each event we process, a motorcycle reaches a target point, so we only need to show that O(n log n) target points are created during the course of the algorithm.

Initially, we create O(n) target points, which are si,di for [formula]. After this, we only create new target points in Case (3b) of the algorithm. In this case, we create one χ-target, and at most two h-targets obtained by halving. Thus we only need to bound the number of χ-targets. At the end of the algorithm, some of these χ-targets χij correspond to an actual crash, with motorcycle i crashing into j, or j crashing into i. In any case, there are at most n such χ-targets. We need to consider the other χ-targets, that do not correspond to an actual crash. In this case, either motorcycle i or j does not reach χij, so at the end of the computation, χij must appear in the stack Si or Sj of target points that have not been reached by motorcycle i or j, respectively. Thus, in order to complete the proof of Theorem [\ref=th:analysis], we only need the following lemma.

At the end of the execution of our algorithm, for any motorcycle i, the number of χ-targets in Si is O( log n).

In this proof, we only consider the status of the stack Si at the end of the algorithm, and we assume that it contains more than one χ-target. We denote by [formula] the χ-targets in Si, in reverse order, so [formula] is a subsequence of Si, where χm is closest to κi and χ1 is closest to di.

Each target χj was created in case (3b) of our algorithm. At the same time, an h-target hj = h(gj,χj) was created by a halving query using another target point gj. As the points χj, [formula] are in Si, motorcycle i never reaches these points during the course of the algorithm, so χ1 and h1 must have been created first, then χ2 and h2 and finally χm and hm.

For any 2  ≤  j  ≤  m, as χj is created after χj - 1, and these two points are created when motorcycle i reaches gj and gj - 1, respectively, it implies that gj - 1 is in [formula]. We also know that χj - 1 lies in [formula], because χj - 1 appears after χj in Si. So [formula], [formula] is a sequence of nested segments, that is, we have [formula] for all 2  ≤  j  ≤  m. More precisely:

If hj - 1 is in Si, then [formula], because χj is created after hj - 1, and motorcycle i never reaches hj - 1. (See  [\ref=fig:targets1].)

If hj - 1 is not in Si, then [formula]. (See  [\ref=fig:targets2].) It can be proved as follows. As hj - 1 is created at the same time as χj - 1, then χj is created after hj - 1. So χj must have been created after motorcycle i reaches hj - 1, otherwise we would have [formula], and since motorcycle i reaches hj - 1 later, χj would not be in Si. As χj is created after motorcycle i reaches hj - 1, we must have [formula].

Thus [formula] is contained in either [formula] or [formula], and since hj - 1 = h(gj - 1,χj - 1), it follows that the size |gjχj| decreases exponentially when j increases from 1 to m. As [formula] contains χm and χm - 1, we have |gm - 1χm - 1|  ≥  2. In addition, |g1χ1|  ≤  n, so we must have m = O( log n).

Auxiliary Data Structures

Our algorithm, presented in Section [\ref=sec:algorithm], requires two auxiliary structures. The first one is simply a ray-shooting data structure. As ray shooting is a standard operation in computational geometry, we will be able to directly use known data structures. The second data structure we need is for answering halving queries. We show below how to construct efficient data structures for this type of queries, and the corresponding time bounds for our motorcycle graph algorithm.

General case

In this section, we present the auxiliary data structures for the most general case, as presented in Section [\ref=sec:notation]. So motorcycles have arbitrary starting position, destination point and velocity.

For ray shooting, we can directly use a data structure by Agarwal and Matouek [\cite=agarwal1993ray], which requires preprocessing time O(n4 / 3 + ε), with update and query time O(n1 / 3 + ε), for any ε > 0.

For halving queries, we use known range searching data structures and parametric search, as in the work of Agarwal and Matouek on ray shooting: Our problem is an optimization version of range counting in an arrangement of lines, so we obtain the same bounds [\cite=agarwal1993ray].

Given the n supporting lines [formula], we can construct a data structure with O(n4 / 3 + ε) preprocessing time and O(n1 / 3 + ε) query time that answers the following queries (i,p,q). Assume there are k crossing points χij on [formula]. Then we return the median crossing point and the next: the ⌈k / 2⌉th and the (⌈k / 2⌉ + 1)th such crossing point, in the ordering from p to q along [formula].

With the two auxiliary data structures above, Theorem [\ref=th:analysis] yields the following result.

A motorcycle graph can be computed in O(n4 / 3 + ε) time, for any ε > 0.

It should be possible to replace the [formula] factor in the bounds of Lemma [\ref=lem:halving] with a polylogarithm using known range searching techniques [\cite=Chan12] [\cite=Matousek92], because we only need a static data structure for halving queries, but in any case we need a dynamic data structure for ray shooting queries, so it would not improve our overall time bounds.

C-Oriented Motorcycle Graphs

We consider the special case where motorcycles can only take C different directions [formula]. Eppstein and Erickson gave an O(n4 / 3 + ε)-time algorithm when C = O(1). We show that with appropriate auxiliary data structures, we can solve this case in time O(n log 3n). In the following, we do not assume that C = O(1), so our time bounds will also have a dependency on C.

We can compute a C-oriented motorcycle graph in O(Cn log 2(n) min (C, log n)) time.

We use the following data structures, and then the result follows from Theorem [\ref=th:analysis].

Ray shooting data structures.

A first approach to answer our ray shooting queries is to use C instances of a data structure for vertical ray shooting in a planar subdivision. Several data structures are known for this problem [\cite=ArgeBG06], we use a data structure by Cheng and Janardan [\cite=ChengJ92] that takes O( log 2n) time per update and O( log n) time per query. So overall, we get Q(n) = O(C log 2n) with the terminology of Theorem [\ref=th:analysis].

Alternatively, we can use C(C - 1) instances of a data structure for vertical ray shooting among horizontal segments. Each data structure is used to answer ray shooting queries with a given direction, into segments with another direction: We just need to change the two coordinate axis to these two directions. Using a recent result by Giyora and Kaplan [\cite=GiyoraK07], we obtain Q(n) = O(C2 log n).

Halving queries.

Our data structure for halving queries simply consists of a sorted list of motorcycles for each direction. So for each [formula], we have an array Ak of the motorcycles with direction [formula], sorted according to the intercept of their supporting lines with a line orthogonal to [formula]. We now explain how to answer a halving query [formula].

Without loss of generality, assume [formula] has direction [formula]. For each direction [formula], [formula], the subset of motorcycles whose supporting lines cross [formula] appear in consecutive positions in Ak. We can find the first and the last index of these lines in O( log n) time by binary search. So we obtain all the arrangement vertices in [formula] in C - 1 sorted subarrays. We then compute the median mk of each such subarray [formula], and the median of these points mk weighted by the number of points [formula] in the corresponding subarray. This gives a halving point h(p,q) with ρ = 3 / 4. The median of each subarray can be found in O(1) time, and their weighted median in O(C) time [\cite=CLRS], so the query time is dominated by the C binary searches. Thus, we can answer halving queries in O(C log n) time.

Bounded precision input

The data structure for answering halving queries in Section [\ref=sec:general] is quite involved. In practice, one would rather implement halving queries by simply halving the Euclidean length [formula] instead of approximately halving the number of crossing points. Unfortunately, in the infinite precision model that is commonly used in computational geometry, this would cause the analysis of our algorithm in Lemma [\ref=lem:targets] to break down, because a stack of target points Si may have size Ω(n) at the end of the algorithm.

Such a counterexample would require the distance between consecutive target points in Si to become exponentially small near the crashing point, which does not seem likely to happen in practice. To formalize this idea, we make the assumption that all input numbers (the coordinates of the starting points, the destination points, and the velocities) are rational numbers, whose numerator and denominator are in [formula] for some integer w. In other words, the input numbers are w-bit signed integers. We still assume that arithmetic operations between two numbers can be performed in constant time.

This model also allows us to handle the case where input coordinates are w-bit rational numbers, that is, rational numbers with w-bit numerator and denominator; we just need to scale up each coordinate by a factor 2w to obtain 2w-bit integers, losing only a constant factor in our time bounds. In the proofs below we assume the input numbers are integers, to simplify the presentation, but the results are stated with rational coordinates.

As the input coordinates are w-bit integers, the coordinates of a crossing point χij are rational numbers obtained by solving a 2  ×  2 linear system, their denominator being the determinant [formula]. Thus, the denominator is an integer between - 22w - 1 and 22w - 1. So any two distinct crossing points are at distance at least 2- 2w + 1 from each other.

Assume that we replace our halving operation, as defined in Section [\ref=sec:notation], with halving the Euclidean length. So h(p,q) is the midpoint of [formula], which can be computed in constant time. Then any nested sequence of segments obtained by successive halving, as in the proof of Lemma [\ref=lem:targets], consists of O(w) such nested segments, because a segment [formula] of length smaller than 2- 2w + 1 cannot contain another crossing point in its interior, and hence it cannot be further subdivided. So the bound on the size of Si becomes O(w), and we get the following result.

If the input coordinates are w-bit rational numbers, we can compute a motorcycle graph in time O(nw(Q'(n) +  log n)), where Q'(n) is the time needed for updates or queries in the ray-shooting data structure.

For bounded-precision input, the bottleneck of our algorithm has thus become the ray shooting data structure, whose update and query time bound is O(n1 / 3 + ε) in the most general case. Therefore, we obtain a faster motorcycle graph algorithm if we are in a special case where faster ray-shooting data structures are known. One such case is ray-shooting in a connected planar subdivision, which can be done in O( log 2n)-time per update and query using a data structure by Goodrich and Tamassia [\cite=goodrich1997dynamic]. We can use this data structure if, for instance, all motorcycles move inside a simple polygon P, starting from its boundary. (So for all i, [formula], and si is on the boundary of P.) Then we perform ray shooting in the union of the tentative tracks and the edges of P, which form a connected subdivision. It yields the following time bound.

We can compute a motorcycle graph in time O(n log 3n) for n motorcycles moving inside a simple polygon with O(n) vertices, starting on its boundary, and if the input has O( log n)-bit rational coordinates.

Application to Straight Skeleton Computation

In this section, we give new results on straight skeleton computation, using our new motorcycle graph algorithm.

Preliminaries and non-degenerate cases

As we mentioned in the introduction, the straight skeleton problem and the motorcycle graph problem are closely related. We now explain it in more details.

Consider the reflex (non-convex) vertices of a polygon P. When we construct the straight skeleton of P, these vertices move inward and may collide into edges, or other vertices. These events, called split events and vertex events, are the difficult part of straight skeleton computation, because they affect the topology of the shrinking polygon by splitting it, and because they are non-local: A reflex vertex may affect a chain of edges on the other side of the polygon. The other type of events, called edge events, where an edge shrinks to a point, are easily handled with a priority queue. So the interaction between reflex vertices is a crucial part in straight skeleton computation, and the motorcycle graph presented below helps to determine these interactions.

The motorcycle graph induced by a polygon P is such that each motorcycle starts at a reflex vertex, moves as the same velocity as the corresponding reflex vertex when we shrink P, and stops if it reaches the boundary ∂P of P. (See  [\ref=fig:mgss].)

If P is degenerate, then two reflex vertices may collide and create a new reflex vertex. In this case we need to create a new motorcycle after the collision. (See  [\ref=fig:degenerate].) So when two motorcycles collide in the induced motorcycle graph, we may have to create a new motorcycle [\cite=HuberH11]. Our motorcycle graph algorithm, as described above, does not apply directly to this case, because the proof of Lemma [\ref=lem:targets] breaks down. (The reason is that Si may hold a linear number of target points at the end of the execution of the algorithm, due to the newly created motorcycles. See  [\ref=fig:counterexample].) In Section [\ref=sec:bpss], we will explain how to compute these generalized motorcycle graphs efficiently on bounded-precision input. But the following theorem still holds in degenerate cases.

The straight skeleton of a polygon P with n vertices and h holes can be computed in expected time [formula] if we know the motorcycle graph induced by the vertices of P.

From the discussion above, and using our motorcycle graph algorithm from Theorem [\ref=th:general], we obtain the following result.

We can compute the straight skeleton of a non-degenerate polygon with n vertices and h holes in [formula] time for any ε > 0.

Bounded precision input

We use the same bounded precision assumptions as in Section [\ref=sec:bpmg], where the input coordinates are w-bit integers or, equivalently, w-bit rational numbers. Similarly, to simplify the presentation, we use the integer model in the proofs, but we state the results in the rational model.

Thus, the coordinates of the vertices of the input polygon P are w-bit integers. The supporting lines [formula] of the motorcycles are angle bisectors between two edges of the input polygon. In order to apply the same halving scheme as in Section [\ref=sec:bpmg], where the Euclidean length is used instead of the number of arrangement vertices, we need to argue that the separation between two vertices in this arrangement of bisectors cannot be too small. This distance can be shown to be at least 2- W, where W = 64(80w + 105) + 1 = O(w), by applying the separation bound by Burnikel et al. [\cite=burnikel1997strong]. So we obtain a result for induced motorcycle graphs that is analogous to Theorem [\ref=th:bpmotorcycle].

Given a polygon P whose input coordinates are w-bit rational numbers, we can compute the motorcycle graph induced by P in time O(nw(Q'(n) +  log n)), where Q'(n) is the time needed for updates or queries in the ray-shooting data structure.

In the lemma statement above, we do not exclude degenerate cases. This is another advantage of this bounded precision model. As the argument in our analysis only relies on the separation bound between two distinct crossing points, and not on the number of motorcycles crossing a given segment, a newly created motorcycle does not affect our analysis as it still obeys the same separation bound: A newly created motorcycle still lies on the bisector of two input edges, though these two edges are not adjacent in the input polygon [\cite=HuberH11]. (See  [\ref=fig:degenerate].)

We still need to describe an efficient ray-shooting data structure. As our input polygon has h holes, the boundary ∂P of P together with the tentative tracks form a collection of h + 1 disjoint simple polygons. We could directly use known ray-shooting data structures [\cite=AgarwalS96a] [\cite=HershbergerS95], which can be made dynamic at the expense of an extra [formula] factor in the running time [\cite=agarwal_geometric_1998]. In the following, we give a different approach, which leads to a better time bound when used as a subroutine of our algorithm. This approach takes advantage of the fact that the holes of P are fixed (only the tentative tracks are dynamic). We use a spanning tree with low crossing number, which is not a new idea in ray-shooting data structures [\cite=ChazelleEGGHSS94] [\cite=HershbergerS95].

We pick one point on the boundary of each hole of P, and on the boundary of P. We connect these h + 1 points using a spanning tree T with low stabbing number [\cite=agarwal1993applications], that is, a spanning tree such that any line crosses at most [formula] edges of T. This tree can be computed in O(n1 + ε) time [\cite=agarwal1993applications]. We maintain a polygonal subdivision which is the overlay of P with T and the tentative tracks. So at each intersection between an edge of T and an edge of P or a tentative track, we split the corresponding edges and tracks at the intersection point. This subdivision S is connected and has [formula] edges, and we maintain it in the ray shooting data structure by Goodrich and Tamassia [\cite=goodrich1997dynamic], which has O( log 2n) update and query time.

Each time a tentative track is extended or retracted, as a tentative track intersects [formula] edge of T, we can update the subdivision and the data structure by making [formula] updates in the ray shooting data structure. Similarly, when our motorcycle graph algorithm tries to extend a tentative track, we can find the first tentative track being hit by a query ray in [formula] time: We first perform a ray shooting query in S, which takes O( log 2n) time. If we hit an edge of T, we make another ray shooting query starting at the hitting point of the previous query, and in the same direction. We repeat this process as long as the result of the query is an edge of T, and by the low-stabbing number property, it may only happen [formula] times.

Overall, our ray shooting data structure has update and query time [formula]. So by Theorem [\ref=th:reduction] and Lemma [\ref=lem:bpinduced], we obtain the following result. Note that it still holds for degenerate input.

The straight skeleton of a polygon with n vertices and h holes, whose coordinates are O( log n)-bit rational numbers, can be computed in [formula] expected time.

Pseudocode

In this section, we give the pseudocode of our algorithm. It is more detailed than the algorithm description in Section [\ref=sec:algorithm], and it can handle degenerate cases. The proof of correctness and the analysis are essentially the same as in Section [\ref=sec:main], but they require a more detailed case analysis.

To deal with the degenerate cases where some supporting lines are concurrent, or two or more motorcycles reach a point at the same time, we record all the target points created so far in a dictionary data structure D. We can implement D as a balanced binary search tree, sorted in lexicographical order of the coordinates (x,y), which allows to retrieve a point in O( log n) time. We associate three fields with each point p stored in D:

A list M(p) records the motorcycles i such that p∈Si. So M(p) records all the motorcycles i that could possibly reach p, at a given point of the execution of our algorithm. The set M(p) itself is stored in a dictionary data structure, so that we can decide in O( log n) time whether a motorcycle i is in M(p).

Two motorcycles k,k' of M(p) such that τ(k,p),τ(k',p) are smallest. It will allow us to find out whether two motorcycles crash simultaneously at p.

A flag [formula] which is set to FALSE initially, and is set to TRUE as soon as a confirmed track has reached p, implying that any other motorcycle that reaches p must crash.

After the initialization stage, our algorithm handles repeatedly the earliest available event, according to the four cases (1), (2), (3a) and (3b) from Section [\ref=sec:algorithm].

Lines [\ref=line:check_0] and [\ref=line:check_1] deal with Case (1) and (2). The condition p = di corresponds to Case (1). The other two conditions check whether we are in Case (2). In particular, condition [formula] means that at least one other motorcycle has reached p, thus motorcycle i crashes. With degenerate input, it is possible that another (or several other) motorcycle reaches p at the same time as i, in which case [formula] if (i,p) is the first event involving p that has been processed. The condition at Line [\ref=line:check_1] checks whether we are in this situation. If so, i must crash. As (i,p) is the first event involving p that we process, there is no earlier event in M(p), so we can find another motorcycle that reaches p at the same time in constant time using the second field associated with p in D.

Case (3a) corresponds to a positive answer to the test at Line [\ref=line:check_2]. The condition [formula] detects whether the track of i to the next target points hits any other track. The other condition [formula] and j∈M(p'), checks for a boundary case, where [formula] falls on another tentative track. The test is positive if p' has already been identified as a target point of j before. In this case we only extend the tentative track of i, without doing any unnecessary halving.

Line [\ref=line:check_3] branches to Case (3b). Similar to Line [\ref=line:check_2], we do not perform an unnecessary halving operation when i∈M(p') or j∈M(p').

Our pseudocode does not handle explicitly the case where two motorcycles have same supporting line. These cases can be easily handled by ad-hoc arguments [\cite=ChengV07]. One way of doing it is to insert additional target points at initialization. For each supporting line shared by several motorcycles, between any two consecutive motorcycles i,j along this line that go toward each other, we insert their potential collision point, that is, we insert into Si and Sj the point p such that τ(i,p) = τ(j,p). For each motorcycle i along this line, if the first starting point sj in the ray [formula] is in [formula], we also update di to be sj.

Example

We give an example of the execution of our algorithm on a set of 4 motorcycles. (Confirmed tracks are solid, and tentative tracks are dotted.) It demonstrates two features of our algorithm, that were mentioned above.

A tentative track may be longer than the final track in the motorcycle graph. For instance, the tentative track [formula] in (b) is longer than the final track [formula] in (q).

Our algorithm does not construct the motorcycle graph in chronological order. For instance, in (i), motorcycle 2 is moved to χ12, which is its position at time τ(2,χ12) = 2.12072. Then in (k), motorcycle 3 is moved to p4, which is its position at time τ(3,p4) = 1.667206.

The four motorcycles 1,2,3 and 4 start at time 0 at initial points s1 = (0.8,3.3), s2 = (0.5,1), s3 = (5.7,0) and s4 = (6,3.4). Their velocities are [formula], [formula], [formula], and [formula].

We use the halving scheme as specified in Section [\ref=sec:notation] with ρ = 1 / 2. So for instance, we create p4 in (j) by halving [formula]. There are three crossings along this segment: χ13,χ23,χ34. Then p4 is created as a point between χ13 and χ34, in this case we just use the midpoint.