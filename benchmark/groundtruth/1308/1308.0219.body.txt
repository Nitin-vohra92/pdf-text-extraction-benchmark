Instruction Sequence Expressions for the Secure Hash Algorithm SHA-256

Introduction

SHA-256 is one of the hash functions defined in the Secure Hash Standard of the U.S. National Institute of Standards and Technology [\cite=NIST12a]. To phrase it more precisely, the standard describes an algorithm that computes the hash function SHA-256 by means of pseudo-code. In this paper, unlike the standard, an algorithm that computes a function is distinguished from the computed function. SHA-256 is called a secure hash function because it is a hash function for which it is expected to be computationally infeasible to find an input with a given hash value and to find two different inputs with the same hash value. SHA-256 is implemented in some widely used security applications and protocols, including Bitcoin [\cite=Nak08a], S/MIME [\cite=RT10a], TLS [\cite=DR08a], SSH [\cite=YL06a], and IPsec [\cite=KS05a].

To our knowledge, the starting point of studies of the security of SHA-256 keeps being the above-mentioned pseudo-code description of an algorithm that computes it (see e.g. [\cite=GH04a] [\cite=MNS11a] [\cite=MNS13a] [\cite=MPRR06a] [\cite=NB08a] [\cite=SS08a]). SHA-256 restricted to the bit strings of a given length can be computed by a finite single-pass instruction sequence that contains only instructions to set and get the content of Boolean registers, forward jump instructions, and a termination instruction (see [\cite=BM13a]). In this paper, we describe such instruction sequences for the restrictions to bit strings of the different possible lengths by means of uniform terms from an algebraic theory of single-pass instruction sequences. Thus, we provide a mathematically precise alternative to the pseudo-code description from the standard.

In computer science, the meaning of programs usually plays a prominent part in the explanation of many issues concerning programs. Moreover, what is taken for the meaning of programs is mathematical by nature. Yet, it is customary that practitioners do not fall back on the mathematical meaning of programs in case explanation of issues concerning programs is needed. They phrase their explanations from an empirical perspective. An attempt to approach the semantics of programming languages from the emperical perspective that a program is in essence an instruction sequence is made in [\cite=BL02a]. The groundwork for the approach is an algebraic theory of single-pass instruction sequences, called program algebra, and an algebraic theory of mathematical objects that represent the behaviours produced by instruction sequences under execution, called basic thread algebra.

As a continuation of the work on the approach to programming language semantics followed in [\cite=BL02a], (a) the notion of an instruction sequence was subjected to systematic and precise analysis using the groundwork laid earlier and (b) selected issues relating to well-known subjects from the theory of computation and the area of computer architecture were rigorously investigated thinking in terms of instruction sequences. This led among other things to expressiveness results about the instruction sequences considered, variations of the instruction sequences considered, an analysis of the autosolvability requirement implicit in Turing's result regarding the undecidability of the halting problem, and an analysis of the effects of the presence of indirect jump instructions in the instruction set of a computer on points such as instruction sequence size and instruction sequence performance (see e.g. [\cite=BM09i] [\cite=BM09k] [\cite=BM08h] [\cite=BP09a]).

The general aim of the above-mentioned continuation of the work on the approach to programming language semantics followed in [\cite=BL02a] is to bring instruction sequences as a theme in computer science better into the picture. This is the general aim of the work presented in the current paper as well. Different from usual in the work referred to above, the accent is this time on a practical problem, viz. devising instruction sequences that compute the restrictions of SHA-256 to the bit strings of the different possible lengths. As in the work referred to above, this work is carried out in the setting of program algebra.

This paper is organized as follows. First, we survey program algebra and the particular fragment and instantiation of it that is used in this paper (Section [\ref=sect-PGA]). Next, we describe how we deal with 32-bit words by means of Boolean registers (Section [\ref=sect-words]) and how we compute the basic and derived operations on 32-bit words that are used in the standard to define SHA-256 (Section [\ref=sect-opns-words]). Then, we give the description of instruction sequences that define SHA-256 (Section [\ref=sect-SHA-256]). Finally, we make some concluding remarks (Section [\ref=sect-concl]).

Program Algebra

In this section, we present a brief outline of  (ProGram Algebra) and the particular fragment and instantiation of it that is used in the remainder of this paper. A mathematically precise treatment can be found in [\cite=BM13a].

The starting-point of  is the simple and appealing perception of a sequential program as a single-pass instruction sequence, i.e. a finite or infinite sequence of instructions of which each instruction is executed at most once and can be dropped after it has been executed or jumped over.

It is assumed that a fixed but arbitrary set [formula] of basic instructions has been given. The intuition is that the execution of a basic instruction may modify a state and produces a reply at its completion. The possible replies are [formula] and [formula]. The actual reply is generally state-dependent. Therefore, successive executions of the same basic instruction may produce different replies. The set [formula] is the basis for the set of instructions that may occur in the instruction sequences considered in . The elements of the latter set are called primitive instructions. There are five kinds of primitive instructions, which are listed below:

for each [formula], a plain basic instruction a;

for each [formula], a positive test instruction [formula];

for each [formula], a negative test instruction [formula];

for each [formula], a forward jump instruction [formula];

a termination instruction [formula].

We write [formula] for the set of all primitive instructions.

On execution of an instruction sequence, these primitive instructions have the following effects:

the effect of a positive test instruction [formula] is that basic instruction a is executed and execution proceeds with the next primitive instruction if [formula] is produced and otherwise the next primitive instruction is skipped and execution proceeds with the primitive instruction following the skipped one -- if there is no primitive instruction to proceed with, inaction occurs;

the effect of a negative test instruction [formula] is the same as the effect of [formula], but with the role of the value produced reversed;

the effect of a plain basic instruction a is the same as the effect of [formula], but execution always proceeds as if [formula] is produced;

the effect of a forward jump instruction [formula] is that execution proceeds with the lth next primitive instruction of the instruction sequence concerned -- if l equals 0 or there is no primitive instruction to proceed with, inaction occurs;

the effect of the termination instruction [formula] is that execution terminates.

To build terms,  has a constant for each primitive instruction and two operators. These operators are: the binary concatenation operator [formula] and the unary repetition operator [formula]. We use the notation [formula], where [formula] are  terms, for the PGA term [formula].

The instruction sequences that concern us in the remainder of this paper are the finite ones, i.e. the ones that can be denoted by closed  terms in which the repetition operator does not occur. Moreover, the basic instructions that concern us are instructions to set and get the content of Boolean registers. More precisely, we take the set as the set [formula] of basic instructions.

Each basic instruction consists of two parts separated by a dot. The part on the left-hand side of the dot plays the role of the name of a Boolean register and the part on the right-hand side of the dot plays the role of a command to be carried out on the named Boolean register. For each [formula]:

[formula] serves as the name of the Boolean register that is used as ith input register in instruction sequences;

[formula] serves as the name of the Boolean register that is used as ith output register in instruction sequences;

[formula] serves as the name of the Boolean register that is used as ith auxiliary register in instruction sequences.

On execution of a basic instruction, the commands have the following effects:

the effect of [formula] is that nothing changes and the reply is the content of the named Boolean register;

the effect of [formula] is that the content of the named Boolean register becomes [formula] and the reply is [formula];

the effect of [formula] is that the content of the named Boolean register becomes [formula] and the reply is [formula].

Let [formula], let [formula], and let X be a finite instruction sequence that can be denoted by a closed  term in the case that [formula] is taken as specified above. Then X computes f if there exists a [formula] such that for all [formula]: if X is executed in an environment with n input registers, m output registers, and k auxiliary registers, the content of the input registers with names [formula] are [formula] when execution starts, and the content of the output registers with names [formula] are [formula] when execution terminates, then [formula].

Dealing with 32-Bit Words

This section is concerned with dealing with bit strings of length 32 by means of Boolean registers. It contains definitions which facilitate the description of instruction sequences that define SHA-256 in Section [\ref=sect-SHA-256]. In the sequel, bit strings of length 32 will mostly be called 32-bit words or shortly words.

Let [formula], let [formula], and let κ:i be the name of a Boolean register. Then κ and i are called the kind and number of the Boolean register. Successive Boolean registers are Boolean registers of the same kind with successive numbers. Words are stored by means of Boolean registers such that the successive bits of a stored word are the content of successive Boolean registers and the first bit of the word is the content of a Boolean register whose number is in the set [formula].

The words that form a part of the message to which SHA-256 is to be applied are stored in advance of the computation in input registers, starting with the input register with number 1, the words that form a part of the message digest that results from applying SHA-256 are stored during the computation in output registers, starting with the output register with number 1, and the words that form a part of intermediate results that arise during the computation, such as message schedules, hash values, and working values, are stored in auxiliary registers.

It is convenient to have available the names used in the standard for the words of the message blocks, the message schedule, the hash value, the working values, and the temporary values in the current setting for the Boolean registers that contain the least significant bit of these words. It is also convenient to have available the names [formula] for the Boolean registers that contain the least significant bit of the words of the message digest, the names [formula] for the Boolean registers that contain the least significant bit of the words of additional intermediate values that are temporarily stored, The Boolean registers with names [formula] are reserved for the least significant bit of intermediate values that arise when computing one of the derived operations on bit strings introduced in Section [\ref=sect-opns-words]. and the name [formula] for the Boolean register that contains the carry bit that is repeatedly stored when computing the addition operation. Therefore, we define: It is also convenient to have available the names used in the standard for the words of the initial hash value: and the names used in the standard for the "SHA-256 constants": All 64 definitions have been put into an appendix.

Computing Operations on 32-Bit Words

This section is concerned with computing operations on bit strings of length 32. It contains definitions which facilitate the description of instruction sequences that define SHA-256 in Section [\ref=sect-SHA-256].

The basic operations on bit strings that are relevant to SHA-256 are bitwise negation, bitwise conjunction, bitwise exclusive disjunction, shift right n positions, rotate right n positions (0  <  n  <  32), and addition. For these operations, we define parameterized instruction sequences computing them in case the parameters are properly instantiated (see below): where s,s1,s2 range over [formula], d ranges over [formula], and k,k1,k2,l range over [formula]. For each of these parameterized instruction sequences, all but the last parameter correspond to the operands of the operation concerned and the last parameter corresponds to the result of the operation concerned.

The intended operations are computed provided that the instantiation of the last parameter differs from the instantiation of each of the other parameters. We could have prevented this condition at the cost of longer instruction sequences. In this paper, the condition will always be satisfied.

In the standard, for SHA-256, six derived operations on bit strings are defined in terms of the above-mentioned basic operations. In the standard, basic operations and derived operations are called operations and functions, respectively. For these operations, we define parameterized instruction sequences computing them: where s,s1,s2,s3 range over [formula], d ranges over [formula], k,k1,k2,k3,l range over [formula].

We also define a parameterized instruction sequence by which the successive bits in a constant 32-bit word become the content of 32 successive Boolean registers and a parameterized instruction sequence by which the successive bits in a 32-bit word that are the content of 32 successive Boolean registers become the content of 32 other successive Boolean registers: where [formula] range over [formula], s ranges over [formula], d ranges over [formula], and k,l range over [formula].

Moreover, we use the abbreviation where [formula] are such that l  <  l', and [formula] are instruction sequences. We write [formula] instead of [formula] to emphasize that we have to do here with an abbreviation for the concatenation of two or more instruction sequences.

The calculation of the lengths of the parameterized instruction sequences defined above is a matter of simple additions and multiplications. The lengths of the instruction sequences corresponding to the basic operations on bit strings relevant to SHA-256 are as follows: the lengths of the instruction sequences corresponding to the derived operations on bit strings defined in the standard are as follows: and the lengths of the [formula] and [formula] instruction sequences are as follows:

SHA-256 Hash Computation

In this section, we give the description of instruction sequences that define SHA-256 using the definitions given in Sections [\ref=sect-words] and [\ref=sect-opns-words].

The padding of messages to a bit length that is a multiple of 512 is left out. It is assumed that messages are already padded. Thus, the bit length of a message is always a multiple of 512. Suppose that N is the bit length of a message divided by 512. Because the maximum bit length of a message is 264, we have that 1  ≤  N  ≤  255.

We write MN, where 1  ≤  N  ≤  255, for [formula], and we write M for [formula]. Moreover, we write D for [formula]. SHA-256 is a function from M to D. We write N for the restriction of SHA-256 to MN. Clearly, SHA-256 is the unique function from M to D such that, for each N with 1  ≤  N  ≤  255, for each w∈MN, (w)  =  N(w).

In Table [\ref=table-inseq-SHA-256], an instruction sequence [formula] is uniformly described for all N with 1  ≤  N  ≤  255. Because SHA-256 is not formally defined in the standard, we cannot formally prove this claim. However, we follow the standard so precisely in the description of [formula] that the claim is unlikely to be wrong unless the pseudo code from the standard should not be interpreted as to be expected.

An easy calculation leads to the following result.

For each N with 1  ≤  N  ≤  255, the length of the instruction sequence [formula] is [formula].

The calculation is a matter of simple additions and multiplications, using the lengths of the parameterized instruction sequences defined in Section [\ref=sect-opns-words]: The left-hand side of this equation is laid out in such a way that the structure of the description in Table [\ref=table-inseq-SHA-256] is clearly reflected.

Recall that the instruction sequence [formula] (1  ≤  N  ≤  255) contains only instructions to set and get the content of Boolean registers, forward jump instructions, and a termination instruction. It is shown in [\cite=BM13a] that, in the case of instruction sequences of this kind, instruction sequence length is a computational complexity measure closely related to non-uniform time complexity. Notice that, if the message has the maximum bit length ([formula]), the length of the instruction sequence is [formula].

The maximum number of input registers needed is 264 and the number of output registers needed is 256. The number of auxiliary registers used is 2945. We expect that number of auxiliary registers used by instruction sequence is a computational complexity measure closely related to non-uniform space complexity. Notice that the number of auxiliary registers used here does not depend on the length of the message.

Concluding Remarks

We have described instruction sequences that compute the restrictions of the secure hash function SHA-256 to the bit strings of the different possible lengths by means of uniform terms from the algebraic theory of single-pass instruction sequences known as . Thus, we have provided a mathematically precise alternative to the pseudo-code description of an algorithm that computes SHA-256 found in the standard.

In previous work that is carried out in the setting of , the work always concerns rigorous investigation of theoretical issues thinking in terms of instruction sequences (see e.g. [\cite=BM12b]). This may give the impression that  is only suitable for such work. The use of  in the work presented in this paper shows that it is more versatile. However, this work has also shown that scalability calls for extension of  to an instruction sequence calculus that includes among other things a variable binding generalized concatenation operator and a suitable definition mechanism.

It is shown in [\cite=BM13a] that, in the case of instruction sequences of the kind that we have dealt with in this paper, instruction sequence length is a computational complexity measure closely related to non-uniform time complexity. An option for future work is investigating the possible role of this complexity measure in issues concerning the complexity of the different kinds of attack on secure hash functions like SHA-256.

Acknowledgements

We thank Bob Diertens from the University of Amsterdam for carefully reading an earlier version of this paper, pointing out annoying errors in it, and developing programs by which the description of [formula] given in this paper can be transformed into an instruction sequence that can be executed by means of the PGA toolset [\cite=Die03a].

Definitions of the SHA-256 constants