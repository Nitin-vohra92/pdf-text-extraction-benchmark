= 1

TRASA: TRaffic Aware Slot Assignment Algorithm in Wireless Sensor Networks

Context and motivations

A typical application in Wireless Sensor Networks (WSNs) is data gathering. Sensor nodes are deployed in the region of interest to periodically collect and report sensed data to a sink node. To achieve this many-to-one communication, sensor nodes form a data gathering tree rooted at the sink. This communication paradigm is also known as "convergecast" [\cite=FASTDATA_Collec].

Depending on the application requirement, different objectives have to be taken into account in the design of MAC protocols. For instance, reliability is required mainly in critical applications like fire detection. In this disaster scenario, reducing the end-to-end delays is also a major requirement. Energy-efficiency is an important concern specially when sensors are operating for a long period of time. It has been proved that, under heavy traffic conditions, contention-free medium access based on TDMA outperforms contention-based protocols.

The main task of TDMA-based MAC protocols is to assign time slots to sensor nodes and to schedule the medium access based on these slots. The transmission schedule allows nodes to send and receive data packets without collision. Further, any node can enter into sleep mode during inactive periods, thus achieving low duty cycle and saving energy. Although the use of TDMA requires synchronization between cooperating sensors, it is an efficient way of mitigating the limitations of CSMA based networks. However, the performance of the TDMA-based medium access protocols may dramatically decrease if the TDMA parameters are not aware of the application requirements [\cite=TDMA-DESIGN]; for example, a very long frame may increase the latency. Moreover, traditional MAC protocols tend to give nodes equal channel access, while the sensor traffic demands may differ. Indeed, nodes close to the sink forward more data than leaf nodes in the data gathering tree. This is the "funneling effect" [\cite=FUNN]. Allocating equal numbers of time slots to sensor nodes may lead to congestion, packet loss, and inefficient use of the bandwidth. Consequently, channel access should be proportional to the sensor demand. That is why we investigate in this paper the Time Slot Assignment problem, denoted TSA, regarding the application requirements. We propose TRASA, TRaffic Aware Slot Assignment algorithm for WSNs. Assuming a sensor network where each node has a specific number of packets to transmit to its parent in the data gathering tree, TRASA assigns each node a number of slots proportional to its traffic demand, and schedules its activity. Moreover, TRASA allows the allocation of slots to nodes with heterogeneous demands. Consequently, the algorithm addresses the funneling effect and ensures a fair medium access. TRASA builds a schedule and ensures that data reach the sink in one cycle. TRASA takes into account both tree communication links and other interfering links. Via simulations, we evaluate the impact of interfering links on TRASA algorithm, and show that as the spatial reuse decreases, the schedule length increases. Since the time slot assignment problem is NP-complete as we will prove hereafter, TRASA relies on an heuristic determining the priority of each node. We compare this heuristic with another heuristic and justify that TRASA ensures an optimized schedule length and a good tradeoff between the schedule length, the average end-to-end delay and the maximum buffer size required by each node. The remainder of this paper is organized as follows. In section [\ref=stateArt:sec], we provide a state of the art about the TSA problem. In section [\ref=pbDef:sec] we describe the assumptions adopted and define the problem statement. In section [\ref=complexity:sec], we prove that the TSA problem is NP-complete, assuming that two nodes that are h-hop away, with h a positive integer > 1 interfere. Section [\ref=TRSADesc:sec] describes the TRASA algorithm and its properties. In section [\ref=performance:sec], we present the performance evaluation of TRASA and conclude in section [\ref=conclusion:sec].

State of the art

Despite the existence of a variety of scheduling schemes, few of them allocate a number of slots proportional to node demand. In this section, we present a state of the art of existing schemes classified according to their awareness of the traffic demand. This classification is illustrated in Figure [\ref=taxonomy].

[formula] Protocols that do not depend on the traffic demand, or assume that nodes aggregate all the data they have to transmit in a single time slot: With these protocols, any node receives exactly one slot. For space reasons, we do not detail here this class of algorithms. [formula] Traffic aware protocols: In these protocols, the number of slots received by a node depends on its traffic demand. We present some examples of TSA algorithms classified according to their main objective. Notice that one algorithm may satisfy more than one objective. 1) Maximizing throughput of received data at the sink: In [\cite=FUNN], Gahng et al. presented Funneling-MAC to mitigate the funneling effect and boost application fidelity in WSNs. Funneling-MAC is hybrid, TDMA is used within small number of hops from the sink (called the intensity region), and CSMA/CA elsewhere. The sink is responsible for the scheduling of the nodes in this intensity region. Funneling-MAC allows the slot reuse between nodes distant more than 2 hops. The main goal of TreeMAC [\cite=Tree-MAC] is to achieve high throughput in real-time high-data-rate WSNs. Authors proved they achieve at least one-third of the optimum throughput assuming reliable links. In TreeMAC, slots are assigned from the root to the leaves, making it not suitable for large-scale networks. TreeMAC allows a slot reuse between nodes belonging to the same tree branch, but not between the subtrees. From energy point of view, authors show that TreeMAC outperforms CSMA and Funneling-MAC [\cite=FUNN]. However, nodes in Tree-MAC are assigned disjoint transmitting time slots, which means that if the node can sleep between its transmitting slots, it should awake up many times to transmit and receive its data. The transitions between radio states are energy-consuming, so should be reduced. 2) Minimizing latency: ROMAC [\cite=ROMAC] is a localized QoS-aware for high-fidelity data center sensing networks. Like TreeMAC, ROMAC divides the TDMA cycle into frames, each frame being composed of three slots and allocates slots to nodes proportionally to their demand. Compared to TreeMAC, ROMAC enhances the localization aspect, since each node can locally determine its frame and its time slots without relying on its parent like in TreeMAC. The node with identifier i transmits its own data in the frame i, and transmits the packets of any node j in its subtree in the jth frame. Unlike TreeMAC and Funneling-MAC, ROMAC automatically adapts to routes changes, any node updates its set of frames every TDMA cycle. Consequently, ROMAC achieves lower delivery latency than these two protocols as the network size increases. 3) Minimizing schedule length: Incel et al. [\cite=FASTDATA_Collec] aimed at reducing the delays of data collection by minimizing the schedule length. They studied scheduling nodes where each node generates a packet at the beginning of the TDMA frame, in convergecast scenario keeping tree interference links only. They proved that the lower bound on the schedule length is given by: (1) the maximum node degree when packet aggregation at each intermediate node is considered, and (2) max(2nk - 1,N) where nk is the maximum number of descendants of the sink children, otherwise. For this second case, authors proposed Local-TimeSlotAssigment algorithm in which the sink schedules an edge having the highest remaining number of packets, and any parent node with an empty buffer selects one child whose buffer is not empty at random respecting tree interfering links. This way, they ensure parallel transmissions among multiple branches of the tree, and keep the sink busy in receiving packets. In [\cite=Ergen10], authors proposed algorithms based on coloring. Two centralized solutions are described. First, in the node-based scheduling any slot is shared between nodes with the same color and any other node that does not conflict with them. Second, in the level-based scheduling, conflicts are defined between levels: the same color is assigned to two levels if they do not contain any couple of conflicting nodes. For each color, non conflicting nodes from all the levels having this color share the same slot. Besides other nodes that do not conflict with already scheduled nodes are scheduled simultaneously. This algorithm suffers from the energy waste because of the radio switches between active/sleep states. 4) Minimizing the energy consumption: In [\cite=SPR], Turau et al. proposed SPR, to schedule each path in the routing tree separately. The slots assigned to any node are the union of its slots in each path. Hence, the spatial reuse of time slots is restricted to a common path, which makes SPR not efficient in terms of schedule length for networks where the average number of children is high. Another example in this category is given in [\cite=scheSchemes07] where the energy efficiency is achieved by reducing the number of switches between the active and sleep states.

Time slot assignment problem

In this section we present the assumptions we adopt to study the time slot assignment problem TSA.

Assumptions and system model

[formula] Network model: The network is modeled as a graph G = (V,E), V is the set of vertices, and E is the set of edges representing the communication links. T is a spanning tree of G rooted at the sink node. We adopt the unit disk model, where nodes are modeled as a set of points in the 2-dimensional plane. Besides, there is no message losses. A node u receives a message sent by another node v, if and only if, their distance is lower than a given uniform transmission range R. Nodes u and v are then 1-hop neighbors. For any integer h > 1, any two nodes u and v are h-hop neighbors if and only if u is (h - 1)-hop away from a 1-hop node of v. [formula] Interfering links: Usually, in a data gathering application, the communications of a node are limited to its parent and its children. However, any node may have communication links with other nodes. If these links are not taken into account in node scheduling, collisions may occur. Hence, for a given node, we include all its interfering links, those in the tree and other ones. In the literature, solutions to the TSA problem for data gathering applications tend to limit the interferences to 2 hops. However, in real wireless networks, interferences may exceed this distance. Consequently, to generalize our study, we assume that two nodes that are p-hop away with 1  ≤  p  ≤  h are interfering. h being a given positive integer > 1 which is a parameter of our algorithm. Hence, we denote the studied problem h_TSA. [formula] Application data: We consider a data gathering application. In each TDMA cycle, each node except the root has its own data to transmit in addition to the data received from its children. Some nodes (for example, the children of the sink), need more than one slot to transmit their data.

Problem statement

We study the slot assignment problem under the assumptions introduced in Section [\ref=assump:sec]. The slot assignment problem consists in assigning slots to nodes in G, such that no two nodes that are p-hop away with 1  ≤  p  ≤  h are scheduled in the same slot while minimizing the schedule length. Besides, this scheduling must ensure that each node transmits its own packets, and the packets generated in its subtree.

Lower and upper bounds

The number of slots required by the TSA problem meets:

[formula]

where depth(u) is the depth of node u in the tree.

Complexity of the h_TSA problem

It has been proved in [\cite=Choi07] and [\cite=Ergen10] that the TSA problem is NP-complete. In this paper, we generalize the study and prove that the h_TSA problem is NP-complete for any positive integer h where any two nodes that are less than or equal to h-hop away are not scheduled simultaneously.

The h_TSA problem, for any positive integer [formula] is NP-complete.

TRASA Algorithm: design and properties

Overview and algorithm

The requirements of data gathering applications are various: a short TDMA cycle, a high throughput at the sink, small delays and low energy consumption. TRASA addresses these issues by maximizing the slot reuse in a cycle. Moreover, by favoring nodes with a high number of descendants, TRASA tends to minimize the TDMA cycle length and then saves energy. Figure [\ref=TRASAExample] shows the slots computed by TRASA applied to the graph in Figure [\ref=graph].

As the h_TSA problem is NP-complete, heuristics must be used. In TRASA, sensor nodes are sorted according to their priority. The priority of a node is given by the number of its descendants in the data gathering tree. Which means that the nodes close to the sink have the highest priority. The reasons for this choice are threefold: (1) Nodes with many descendants need to forward more packets than others, so scheduling them as soon as they have data avoids the congestion, and allows them to use less buffers. (2) The children of the sink are interfering, only one child can be active in a slot. They are the most determining factors of the schedule length (their number represents the lower bound of the number of slots). We believe that scheduling them first achieves a higher flexibility. (3) The probability of the sink to be in receive state each time slot is high, and similarly the throughput measured at the sink increases. The pseudo-code of TRASA is given by algorithm [\ref=algo]. Once the nodes are sorted, the node u with the highest priority is given a number of slots equal to its packet demand. This is because we assume for simplicity reasons that a time slot contains only one packet. Notice that TRASA is able to take into account sensor nodes with heteregeneous data rates. TRASA assigns node u du slots between indices lastEndingSlot and endingSlot. Aiming at reducing the schedule length, TRASA achieves an optimized slot reuse. That is, a new time slot is added to the TDMA frame, if and only if, nodes having remaining data, could not be scheduled in the last time slot. The only limiting factor of the parallelism is the interferences which have to be considered to achieve a collision-free schedule. So to schedule other nodes simultaneously with the node u, TRASA iterates on the nodes having data to transmit according to the descending order of their priority. If a node v has packet(s) to send and is not interfering with nodes already scheduled between lastEndingSlot and endingSlot, v is scheduled in parallel with these nodes. The number of slots assigned to v is equal to its demand dv. Notice that dv may be higher than endingSlot - lastEndingSlot, in this case, the TDMA cycle is extended. TRASA stops when all nodes have transmitted all data they generated, and all data they received from their children.

TRASA properties

In this section, we discuss the properties of TRASA, and explain how it takes into account various performance criteria. P1. Fair Access: The first key design of TRASA is to ensure a fair medium access to all nodes. A time slot being associated to a unique packet, a node has as many slots as packets to transmit. In a data gathering tree, any node traffic demand is the sum of the packets it generates and the packets generated in its subtree. TRASA assigns each node as many slots as its traffic demand. Hence, TRASA addresses the funneling effect and avoids congestions. P2. Optimized spatial reuse: assigns slots to nodes in the order of their priority. When any node is scheduled, all non interfering nodes are scheduled simultaneously. Hence, the slot reuse is optimized, it is not restricted to a common branch, like [\cite=Tree-MAC], or inter-branches, like [\cite=SPR]. This spatial reuse provides an efficient use of the bandwidth. P3. Optimized schedule length: In TRASA, the TDMA frame is extended by a time slot if and only if the nodes with a packet demand cannot be scheduled in the last added slot, because of the interferences. This behavior reduces considerably the schedule length. For instance, applied to the graph of Figure [\ref=graph] for h = 2, TRASA gives a cycle length of 7 slots as illustrated by Figure [\ref=TRASAExample]. The cycle length would be 12 slots with TreeMAC. P4. Optimized energy consumption: Minimizing the number of slots in a cycle reduces the activity periods and allows nodes to save energy. Besides, when any node is scheduled, it is allowed to send all data it has, which reduces the switches between the active and sleep states which are energy-consuming. With TRASA, any node is awake during its slots to transmit data and the slots of its children to receive data they transmit, it sleeps the remaining time to save energy. P5. Optimized buffer usage: In WSNs, nodes have low capacity of storage. Accumulating many packets in a node may lead to buffer overflow and packet losses. In TRASA, the buffer usage is balanced during the TDMA frame. Indeed, only nodes having packets to transmit compete for a given time slot. Since the priority used is the number of descendants, the priority of any node is higher than the priority of all its children. Consequently a parent having data to transmit is in general scheduled before its children, so does not accumulate much data. P6. Optimized delays and throughput: The optimized slot reuse of TRASA can be seen as a parallel progress of packets toward the sink, and in a balanced way between tree levels and subtrees, as much as allowed by the interference constraints. Consequently, the end-to-end delays are reduced. Furthermore, nodes close to the sink have the highest priority. This increases the probability that the sink receives data in a time slot, and hence enhances the data throughput. By construction of the cycle, TRASA guarantees that all data generated by nodes reach the sink in one cycle.

Performance evaluation

Simulation setup

Using a graph generator, we generate random graphs for a given number of nodes deployed in a 2D area (1mx1m), the transmission range is set to 0.4m. The number of nodes ranges from 20 to 100. For each graph, we build a spanning tree defined by a maximum number of children per node. Notice that if the graph is disconnected, the construction of the tree is not possible. The corresponding graph is then not considered in the simulation process. The tree is built by adding children nodes consecutively. The first added node is the root. Any neighbor u of the root selects it as a parent if the maximum number of children (which is set to 3) is not reached by the sink. Otherwise, such a node u tries to associate to another node. This process continues until all nodes have a parent. Notice that implicitly, each node selects the parent with the minimum number of hops toward the sink, provided that this parent can accept further children. We assume that interferences are limited to 2-hops (h = 2), as usually assumed in TSA problems. Each node generates only one packet, and forwards packets it receives from its children. For simplicity reasons, we also assume that a slot contains only one data packet. Each result is the average of 40 simulation runs.

Simulation results

Choice of the heuristic

In TRASA, nodes are sorted according to their priority which is given by their number of descendants. This heuristic is denoted heuristic = 1. To validate this design choice, we compare this heuristic with another one, denoted heuristic = 2, where nodes with the highest number of descendants have the smallest priority. Figure [\ref=nbSlotH] shows that heuristic = 1 outperforms heuristic = 2 in terms of slot number. This is because the slot reuse is increased, as illustrated in Figure [\ref=slotReuseH]. Figure [\ref=maxBufferSizeH] shows that the maximum size of buffers required by a node in heuristic = 1 is lower than in heuristic = 2. Indeed, when leaf nodes are scheduled first, a node is likely to accumulate packets before being able to transmit them. Whereas heuristic = 1 gives opportunity to nodes to send data as soon as possible, which considerably reduces average end-to-end delays as illustrated in Figure [\ref=avgDelayH]. However, nodes may access the medium more frequently during one TDMA cycle, which adds an energy cost when the number of switches between active and sleep state increases. For these reasons, heuristic = 1 is preferable and is selected in the following.

Impact of interference links

To evaluate the impact of the interference links on TRASA performance, we simulate two cases: (1) when all interfering links are considered; (2) when only tree links are considered. As expected, the schedule length in the first case is higher. For instance the number of slots raises from 88 to 135 for 50 nodes. The difference increases with the number of nodes as illustrated in Figure [\ref=nbSlotV]. For the same density, any node has more interfering links, so less nodes can be scheduled in the same slot. This justifies the fact that the slot reuse is higher in the second case, as illustrated in Figure [\ref=slotReuseV]. So, to avoid interferences and achieve collision-free schedule in any real wireless environment, the cost is the schedule length.

Impact of the number of nodes, the node data rate and the maximum number of children

For the results illustrated in Figure [\ref=impactNodeNbRate], the density of nodes (average number of neighbors per node) varies between 4 and 20. The Figure [\ref=nbSlotRate] shows that the number of slots increases with the number of nodes. This is because the density increases with the number of nodes, which reduces the spatial reuse of the slots. However, as the maximum number of children per node increases, the number of slots decreases (see Figure [\ref=nbSlotForDifferentMAxChildren]). Indeed, when the maximum number of children increases, the tree depth decreases. Consequently, the number of slots required by each node which is proportional to its subtree size decreases. TRASA is able to schedule nodes with heterogeneous data rates. Figure [\ref=nbSlotRate] shows that the schedule length increases linearly with the data rate.

Conclusion

In this paper we proved that the time slot assignment problem is NP-complete for any integer h > 1. We presented TRASA an algorithm that takes into account the application requirements to schedule nodes using an optimized number of slots. We have shown its excellent performance on representative scenarios by simulation. We plan to extend this work by defining a distributed version of TRASA.