Proposition Definition

Design Pattern-Based Extension of Class Hierarchies to Support Runtime Invariant Checks

Introduction

Several, if not most, mainstream languages include features to support object-oriented programming, yet most of these (C++, C#, Java, Python, etc.) lack any native language support for the specification and runtime checking of class invariants. While it is usually easy enough to implement the invariant predicates themselves, manual addition imposes further requirements in order to implement the operational requirements of invariant checking and to handle the interplay of invariant specification and inheritance. Class invariants are further troublesome in that they involve direct access to an object's attributes. This makes manual addition particularly unappealing, as the available choices are invasive with respect to the original interface and implementation (to which we may not have access), compromise encapsulation, and are error-prone if done manually.

This paper presents a lightweight, non-invasive technique for automatically extending a collection of class definitions with a corresponding collection of structural invariant checks. The invariants are given as a stand- alone specification, which is woven together with the original source files to produce a new collection of drop- in replacement classes that are behaviorally indistinguishable from the originals in the absence of invariant- related faults but will expose such faults in a way that the original classes do not. Each replacement is defined to be a subclass (indeed, a subtype [\cite=liskov94toplas]) of the original class whose functionality it extends, and it can thus be substituted in any context in which the original occurs. The generation is itself completely automatic, and the incorporation into a test harness or other program is nearly seamless. We focus here on the Java language, a choice that complicates the overall strategy in some ways while simplifying it in others.

Background and Related Work

A class invariant is a conjunction of predicates defined on the values of an object's individual attributes and on the relationships between them. It characterizes an object's "legal" states, giving the predicates that must hold if the object is to represent an instance of that abstraction. Usually, a class invariant is given in conjunction with the contracts for each publicly-visible method of a class, i.e., the preconditions that must hold on arguments to each method call and the consequent guarantees that are made as postconditions upon the method's return. Unlike the contracts, however, a class invariant is a property concerning only an object's data values, even (especially) when those values are not publicly visible. An invariant must hold at every point between the object's observable actions, i.e. upon creation of any object that is an instance of this class and both before and after every publicly-visible method call [\cite=liskov01pdj] [\cite=meyer97oosc]. At other points, including non-visible method calls, it need not hold, and runtime checks are disabled in this case. Further, since runtime invariant checks can impose a non-trivial performance penalty on a system, in general, it is desirable to have a mechanism for leaving the checks in place during testing, while removing them from a final, production system. Finally, there is an important interplay between the subtype relation (which determines when one object can safely be substituted in a context calling for another [\cite=liskov94toplas]) and class invariants: if B is a subtype of A (as well as a subclass) then the invariant for B must include all of the constraints in A's invariant [\cite=liskov01pdj] [\cite=meyer97oosc].

Some languages offer native support for invariant checking, but for Java and other languages that lack this, including such checks is challenging. A common approach is to make use of the language's assertion mechanism, by including assertions of the invariant at the end of each constructor body and at the beginning and end of the body of each public method [\cite=liskov01pdj]. If the language's assertions mechanism is used, disabling the checking functionality after testing is usually quite easy. However, this approach carries the disadvantage of requiring the class designer to code not only the predicates themselves but also an explicit handling of the inheritance requirements and the full execution model, discussed above. Both of these tasks must be implemented for each invariant definition, in each class.

To avoid the implementation burden of the assertions approach, we can use a tool that generates the invariant checks from either specialized annotations of the source code [\cite=flanagan02pldi] [\cite=leavens06sen] [\cite=liu03sea] or reserved method signatures [\cite=karaorman98techrep] [\cite=prasetya07techrep] [\cite=prasetya08issta]. Essentially, such tools offer language extensions to resemble native support for invariant definitions. In comparison to assertion-based approaches, they eliminate the requirement of implementing the execution model, a clear advantage. As with the assertions approach, annotation approaches are invasive, in that they require modification of the original source code. More substantially, the approach generally requires the use of a specialized, nonstandard compiler, whose development may not keep up with that of the language.

Instead, we can view the addition of runtime invariant checking across a class hierarchy as a kind of cross-cutting concern, i.e. code that is defined across several classes and hence resists encapsulation. Under this view, it is natural to approach this problem as one of aspect-oriented programming (AOP) [\cite=kiczales97ecoop], in which we can use a tool such as AspectJ [\cite=AspectJGuide] to define the checks separately as aspects. The entry and exit points of each method become the join points, the point cuts are inferred from a class's method signatures, and the invariant check itself becomes the advice [\cite=briand05icsm] [\cite=skotiniotis04oopslac]. Unlike annotation-based approaches, aspect weaving can be done without the need for a non-standard compiler, either through source code transformation or byte code instrumentation [\cite=czarnecki00gpBook]. However, the AOP approach also presents several difficulties. For example, Balzer et al. note that mainstream tools such as AspectJ lack a mechanism to enforce the requirement that the definition of a class's invariant include the invariant of its parent class [\cite=balzer05rise]. It is possible to write invariant checking "advice" so that it correctly calls the parent class's invariant check, but this must be done manually ( e.g. [\cite=briand05icsm]). A similar problem occurs in implementing the correct disabling of checks on non-public calls. Lastly, because aspects cannot in general be prevented from changing an object's state, the weaving of additional aspects may compose poorly with the aspect that provides the invariant check [\cite=agostinho08splat] [\cite=balzer05rise] [\cite=klaeren00gcse]. It is possible that another aspect could break the class invariant, and since interleaving of multiple aspects is difficult to control, it is possible the two aspects could interleave in such a way as to make the invariant failure go undetected.

The work closest in spirit to our own is the design pattern approach of Gibbs, Malloy, and Power ([\cite=gibbs02ase] [\cite=malloy06stvr]. Targeting development in the C++ language, they present a choice of two patterns for weaving a separate specification of invariant checks into a class hierarchy, based on the well known decorator and visitor patterns [\cite=gamma95designpatterns]. However, the decorator approach involves a fairly substantial refactoring of the original source code. Moreover, the authors note that this technique interacts poorly with the need to structure invariant checks across a full class hierarchy. The refactoring in this case is complex, and it requires the use of multiple inheritance to relate the decorated classes appropriately, making it unsuitable for languages such as Java, which support only single inheritance. Their alternative is an application of the visitor pattern, in which the invariant checks are implemented as the visit methods in a single Visitor class. This pattern usually requires that the classes on the "data side" implement an accept method, which is used to dispatch the appropriate visit method, but in their use of it, only the top of the class hierarchy is modified to be a subclass of an "invariant facilitator", which handles all accept implementations. However, successful implementation of the visit methods rests on the assumption that all fields are either publicly visible or have their values readily available through the existence of accessor ("getter") methods. Unless the language simply lacks a mechanism to hide this representation ( e.g. Python), such exposure is unlikely to be the case, as it violates encapsulation, permitting uncontrolled manipulation of an object's parts, either directly or through aliasing [\cite=liskov01pdj].

The central thesis of our work is that, under assumptions common to Java and other statically-typed OO languages, these limitations--source code modification, multiple inheritance, and public accessibility of fields--are unnecessary for a design-pattern approach. The remainder of the present paper shows how to relax them.

Weaving Invariant Checking from Specifications

Our approach draws from the Gibbs/Malloy/Power design pattern efforts and from ideas in AOP in the treatment of invariant specifications as a cross-cutting concern. We begin with an assumption that the class invariants are given in a single specification file, separate from classes that they document. Each constraint is a boolean- valued Java expression, with the invariant taken to be the conjunction of these expressions. We assume (though do not hope to enforce) that these expressions are free of side effects, and that the invariant given for a child class does not contradict any predicates in inherited invariants. Otherwise, the particulars of the specification format are unimportant. The current version of our tool uses JSON [\cite=json12website], but any format for semi-structured data will do.

We focus on the Java programming language, which means that we assume a statically-typed, object-oriented language, with introspective reflection capabilities, support for type parameters in class definitions, single inheritance (though implementation of multiple interfaces is possible), and a uniform model of virtual method dispatch. We make some simplifications of the full problem. Specifically, we work only with synchronization- free, single-threaded, non- final class definitions, and we consider only instance methods of a class that admit overriding, i.e., non- static, non- final method definitions. We do not consider anonymous inner class constructs nor the lambda expressions planned for Java 8 [\cite=java12jsr335]. Finally, we assume a class's field visibility grants at least access through inheritance ( i.e. protected accessbility or higher). This last is made purely for the sake of simplifying the technical presentation, since, as discussed in section [\ref=concl], introspection makes it easy to handle variables of any accessibility.

An Inheritance-Based Approach

As a first effort, we will try an approach that leverages the mechanism of inheritance and the redefinition of inherited method signatures through subtyping polymorphism. The idea is to derive from a class and its invariant a subclass, in which we wrap the invariant in a new, non-public method (perhaps with additional error reporting features), similar to the " repOK" approach advocated by Liskov and Guttag [\cite=liskov01pdj]. To this new subclass, we also add methods φ1 and φ2 to handle the checking tasks at (respectively) method entry and exit points, and we use these to define constructors and overridden versions of every public method.

Let A be a class, with parametric type expression TA defined on type parameters SA, field declarations [formula], invariant ρA, constructor definition [formula] and public method [formula].

We extend A with runtime checking of ρA by generating the subclass in Fig. [\ref=fig:naive-inh], where TA' and SA' are identical to TA and SA (respectively), except perhaps for renaming of type parameters ( i.e., they are α-equivalent).

For each constructor in A', the body executes the "real" statements of the corresponding superclass constructor, followed by a check of ρA, whose execution is itself controlled by the φ2 method. Likewise, the body of each public method fA wraps a call to the superclass's version between checks of ρA, with execution controlled by the φ1 and φ2 methods. If fA returns a value, then this value is captured in the overridden version in a "result" variable, χ. A method or constructor call is publicly-visible precisely when the call stack depth on a given A' object is 0, and this value is tracked by the additional integer-valued field δ. The φ1 and φ2 methods increment/decrement δ as appropriate, evaluating ρA only if δ  =  0.

The inheritance-based approach suggests an easy mechanism for reusing code while adding the necessary invariant checks and capturing the distinction between publicly-visible and inner method calls. For the user, the burden consists of replacing constructor calls to A with the corresponding calls for A'. This may be an excessive requirement when A objects are used in production-level code, but in many settings where invariant checking is desirable, such constructor calls are limited to only a handful of sites. In the JUnit framework, for example, integration of A' objects into unit tests for A is likely quite simple, as object construction occurs mainly in the body of a single method, setUp.

Note the assumptions of uniform polymorphic dispatch and non- final declarations here. If a class cannot be extended ( e.g. String and other objects in the java.lang package), then construction of a subclass that implements the invariant checks is obviously impossible. Similarly, a method whose dispatch is statically determined cannot be transparently overridden, and if declared final, it cannot be overridden at all. In many languages (notably, C# and C++) the default convention is static dispatch, with dynamic binding requiring an explicit virtual designation; in such cases, the inheritance construction is far less convenient and may be impossible without some refactoring of the original source code.

Unfortunately, our first attempt fails in two critical ways, which becomes apparent when we attempt to construct the invariant-checking extension across a hierarchy of class definitions. First of all, the inheritance hierarchy of a collection of objects requires a corresponding structure in the composition of invariant checks. This problem is very similar to the one encountered in the "decorator" approach of [\cite=malloy06stvr], but the multiple-inheritance solution given there is unavailable in a single-inheritance language such as Java. Consider a class B that is a subtype of A (written [formula]):

Figure [\ref=fig:naive-limit] depicts the problem. The invariant for a B object, invB, must include the A invariant-- i.e., [formula]. However, a B' object cannot access the fields of its associated B object through inheritance and also reuse the functionality of the invA method. We might choose to have B' descend from A' instead, but this only works if all fields in B are publicly accessible. As discussed above, this is unlikely to be the case.

The second, related failure is that inheritance does not facilitate a correct binding of the type parameters. Again, this is clear from Fig. [\ref=fig:naive-limit]. An instantiation of B supplies a type τ to the parameters SB, which is used in turn to bind the parameters SA with argument [formula]. When we instantiate B' instead, this same τ binds the parameters SB', with the resulting chain of arguments binding A's parameters SA as [formula]. For correct use of the A' invariant check in this B'〈τ〉 object, we would need to bind the type parameter of A', SA', in the same way we do A's parameter, SA; i.e. with argument [formula], a binding that cannot be ensured, unless B' is a subclass of A'.

Exposing the Representation

Though unsuccessful on its own, we can use the inheritance approach of Section [\ref=invcheck:inh-approach] as the basis for an auxiliary pattern, which we call an exposure pattern. The idea is to construct from the original hierarchy a corresponding set of classes that offers the interface of the original collection and in addition, a controlled exposure of each object's representation. The machinery for checking the invariants is factored into separate classes, as discussed in Section [\ref=invcheck], below.

Consider a class definition

We derive the exposure interface

and exposed class

where TA', TA'' and SA', SA'' are α-equivalent to TA and SA, as above. Note that the fields [formula] include all of the original [formula] and perhaps others, as discussed on page , below. The constructors and public methods in AE are overridden in exactly the same manner as in the A' class of Section [\ref=invcheck:inh-approach], and likewise the implementation of the φ1() and φ2() methods. The representation exposure happens through the γai(), a set of raw "getter" methods that expose each of the object's fields. In the presence of inheritance, the corresponding structure is realized not in the derived class but in the derived interfaces. Thus, for example,

gives rise to the interface and class definitions

The construction is illustrated in Fig. [\ref=fig:exposure-pattern].

Correctness

Since the type expressions in a class definition are copied to its exposed class and interface (perhaps with α-renaming of the parameters), it is easy to see that

For any type expression τ, an instance of a class A has type AT(τ) if and only if AE and IAE have types AET(τ) and IAET(τ), respectively.

The construction of the accessor methods is less obvious. While we construct γai() for each of the fields [formula], we may need to construct others, as well, in case the invariant ρA makes reference to any inherited fields for which we have not already constructed an interface. This can happen in the case of an incomplete specification of the class hierarchy and invariants. The simplest way to handle this is to include in the interface a γai() for each declared field in the corresponding A classes and also for each variable that occurs without explicit declaration in the the predicate ρA. However, we can leverage the inheritance of interfaces to eliminate redundant declarations (though not implementations, as discussed below).

To make the construction precise, we denote the free variables of the predicate ρA by FV(ρA), i.e. those variables that occur in ρA without being explicitly declared in ρA. Conversely, the bound variables in a class A, BV(A), are the instance fields declared in A. The following definition captures the notion of variables that are "free" in A through inheritance:

Let P be a specification of a collection of classes and their associated invariants. For a class A, the set of fields exposed through inheritance in A, [formula], is defined by

[formula]

We use this to define the necessary method signatures in each exposure interface.

Given class A and invariant ρA, the body of IAE consists of the the signatures

[formula]

where each τai is the declared type of ai.

For a field, τai ~ ai, either declared in or inherited by a class A, we say that ai is successfully exposed for A if either

there is an interface IAE and subclass

class AE  ~   ~ A ~  ~ IAE

such that IAE includes a method interface

τ  ~  γai();

and for every AE object o, o.γai() ~ o.ai

A is a subclass of C, and ai is successfully exposed for C.

Given A and ρA, the construction for IAE in Definition [\ref=defn:exp-interface] and the accompanying implementation AE combine to give us the representation exposure we need for ρA. In particular,

If x∈FV(ρA), then x is successfully exposed for A.

Space Requirements

The primary difference between the exposure pattern construction and the inheritance-based effort of Section [\ref=invcheck:inh-approach] in the construction of the exposure interfaces, whose inheritance structure is congruent to that of the original collection of classes. Like the earlier attempt, however, the collection of exposed classes does not share this same relation, and as a consequence, both approaches are subject to some unfortunate redundancy consequences. In particular, we cannot reuse code between distinct exposed classes, even when the classes they expose are related by inheritance. For example, if a class A contains fields a1 and a2 and public method f() then the exposed class AE must override f(), and it must include exposure methods γa1 and γa2, according to the interface IAE. If [formula] contains fields b1, b2, and method g(), then it must override not only g() but also f(), with the body of the overridden f() identical to that in AE. Likewise, it must implement not only the γb1 and γb2 methods from the IBE interface, but also γa1 and γa2.

Happily, all of this is easily automated, and it is reasonable to suppose the space overhead manageable. Note first that, with the exception of classes at the top of a specified hierarchy, the size of the interface generated for a class is proportional to the number of fields in that class. Recalling Definitions [\ref=defn:inh] and [\ref=defn:exp-interface], we can see that this is so because

Let C be a class included in a specification P. For every class [formula], [formula].

In other words, only for classes specified at the top of an inheritance hierarchy will we ever need to generate additional γ declarations in the corresponding interfaces. In all other cases, the accessor interfaces for inherited fields are inherited from the corresponding parent interfaces. Hence, the space required to extend a collection of classes depends only on the size of each class and the depth of the inheritance relationship in the collection. Specifically, if we assume a bound of n new field and method definitions on each class and an inheritance depth of h, then the overall space growth is given by

[formula]

It is difficult to give a general characterization of either n or h, but there is reason to suspect that both are manageable values in practice. McConnell recommends a limit of 7 new method definitions in a class [\cite=mcconnell04codecomplete]. Shatnawi's study [\cite=shatnawi10tse] finds no significant threshold value for h. Classes in the JDK's java.* and javax.* libraries implement anywhere from less than 10 to over 100 new methods, while the largest depth of any inheritance tree is 8.

Adding the Invariant Checks

As in Gibbs/Malloy/Power [\cite=malloy06stvr], we implement the runtime invariant checks themselves through an application of the visitor pattern [\cite=gamma95designpatterns], in which the methods implementing the invariant checks are aggregated into a single class (the "visitor"), with the appropriate method called from within the class being checked (the "acceptor"). Unlike their approach, however, our exposure pattern allows us to do this without modification of any part of the original source files, not even at the top of the inheritance hierarchy.

Suppose we have a class ATA, with invariant ρA. From these, we generate the exposed class AETA' and the exposure interface IAETA'', as in Section [\ref=ssec:exposure]. The specification of ρA and the access methods defined for IAE are used to generate an invariant checking "visitor" class:

where TAI and SAI are equivalent to TA and its parameters SA, as above.

Runtime checking of ρA is invoked in the AE methods through calls to that class's inv method, which serves as the "accept" method, handling dispatch of the appropriate invariant check:

Note that each vA() method in InvV takes an argument of type IAE and not AE. This is necessary, because of the need to compose an invariant check with that of the object's superclass in each invariant method. For example, if we have [formula], we define vB() as

Since AE and BE are not related by inheritance, it would not be possible to directly cast obj to its superclass's exposed version. Fortunately, the interface is all we need.

Finally, although we structure our solution here according to the traditional visitor pattern conventions, we do not really need the full generality of that pattern. In particular, it is unnecessary to support full double dispatch, as we only need one instance of InvV, and no vi() method will ever invoke a call back to the inv() method of an object (not even indirectly, since the φ1 and φ2 methods in a class prevent a call to inv() if one is already running). Our implementation of this approach as an Eclipse plugin instead drops the InvV parameter from every inv method, relying instead on a single, static instance of the invariant visitor:

Example: Unit Testing

Method contracts and class invariants are particularly useful in testing. In combination with test oracles, the use of runtime invariant and pre/post-conditions checks improves the exposure of faults as well as the diagnosability of faults when they are detected [\cite=briand03spe] [\cite=letraon06tse]. Our implementation as an Eclipse plug has proven useful in diagnosing invariant-related faults.

For example, a simple List interface provides an abstraction for the list data type. A standard way to implement this is with an underlying doubly-linked list, in which we keep a pair of "sentinel" head and tail nodes, with the "real" nodes in the list linked in between:

Among other predicates, the invariant for DLinkedList requires that [formula], n.next.prev  =  n.

This was given as part of a project for the first author's data structures course, and among the student submissions received was this implementation of remove(), in which the cur.prev pointer is not correctly updated:

A JUnit test suite failed to uncover this fault, passing this and the tests for 12 other methods:

From the original source code and a specification of invariants our tool generates the classes and interfaces

Objects in a JUnit test suite are constructed in the setUp() method, and a simple modification was all that was needed to cause testRemove() to fail appropriately:

Conclusion and Future Work

The design pattern given here provides a fairly seamless approach for adding correct runtime invariant checking to a class hierarchy, through the construction of drop-in replacements that can be removed as easily as inserted. In addition to the core material presented here, there are a number of extensions possible.

For example, the presentation in this paper relies on the assumption above that all fields in a class are accessible through inheritance. Happily, this is an easy if tedious limitation to overcome. If instead the field is declared with only intra-object or intra-class access ( e.g. Java's " private"), we can use the introspective capabilities of the language to manufacture a locally-visible get method. To access a private field x, for example, our implementation generates a γx that handles the unwieldy details of Java introspection:

Other extensions, such as the inclusion of anonymous inner classes, concurrency, or final classes/methods, remain as open challenges.

Finally, the work described here incorporates only the invariant checks, rather than full contracts, and it would clearly be useful to extend our design pattern to support this. While we conjecture that our technique is easily extendable to this purpose, the invariant checks present the most interesting problems, owing to their need for attribute access and hierarchical definition. Philosophically, ordinary unit testing already performs at least the behavioral components of contract checking, i.e. the checks of pre and post-conditions. What unit testing cannot do is determine whether the invariant continues to hold, as it is often impossible to access an object's fields. The difference lies in the fact that both pre and post conditions are inherently extensional specifications. They impose requirements on method arguments and return values, but on the object itself, all constraints are made upon the abstraction of the object, not the concrete implementation. That implementation-- whose consistency with the abstraction is the core assertion of a class invariant--is by definition opaque to an object's user.

Acknowledgments

The ideas in this paper began with an assignment in the first author's Spring 2010 Software Construction class, and the students there provided valuable feedback. Our thanks also to Prof. Peter Boothe of Manhattan College, for help in analyzing the inheritance and method complexity of the JDK.