Quantum Key Distribution with Qubit Pairs

Quantum cryptography [\cite=qkd] is a field which has matured since the first protocol, BB84, given by Bennett and Brassard in 1984 [\cite=bb84]. The idea is to generate a secret key between two remote parties, traditionally called Alice and Bob using a quantum channel. The secret key may then be used in sending encrypted messages through the so-called Vernam Cipher [\cite=vernam] or one-time pad. Vernam cipher has been proved to be very secure, under the condition that one shared key is to be used only once.

In principle, BB84 is proven to be hundred percent secure [\cite=shor]. However, when implemented in real life with non-ideal sources and detectors, several attacks have been successfully demonstrated against commercial QKD systems [\cite=qkdbreak] [\cite=qkdbreak1].

In the traditional BB84 scheme, Alice sends a stream of single qubits to Bob which eventually leads to the generation of a secure key. Here we propose a new QKD scheme in which Alice sends a stream pairs of qubits to Bob. We will show that this scheme introduces an additional feature over the standard BB84 protocols, which should make it more difficult to break.

To set the ball rolling, we describe the BB84 QKD protocol [\cite=bb84].

Alice sends single qubits to Bob randomly in one of the following states: |0〉, ~ |1〉, ~ | + 〉 and | - 〉, where [formula].

Bob measures the incoming qubit's state by randomly choosing a measurement of either the x-component of the qubit or the z-component, with equal probability. Let us say, |0〉, ~ |1〉 are eigenstates of the z-component of the qubit, and |  ±  〉 are the eigenstates of the x-component.

Bob publicly tells Alice which bases he used for each qubit he received (but, of course not the result of his measurement).

Alice publicly tells Bob which basis she sent each qubit in.

Alice and Bob keep only the data from those measurements for which their bases are the same, discarding all the rest.

This data is interpreted as a binary sequence according to the coding scheme |0〉x = 0, |1〉x = 1, | + 〉z = 1, | - 〉z = 0.

Alice announces the results of a small subset of her measurements. Bob checks if he has identical results. Any discrepency here indicates a possible evesdropping attempt.

If there is no discrepancy, the rest of the binary sequence is treated as the new key, and is identical for both Alice and Bob.

In our new scheme, Alice sends pairs of qubits to Bob, randomly chosen to be in one of the following states,

[formula]

where [formula]. For Alice, the key bits associated with each state she sends are as follows:

[formula]

In addition, she calls the first two states as z-basis, and the other two as x-basis.

Bob uses one qubit for his secure key and one for the auxiliary key. For generating the secure key, he randomly measures the x-component or the z-component of the qubit. For the auxiliary key he measures only the x-component. For his secure key measurement results, he uses the following convention for key bit values: |1〉  →  1, |0〉  →  0, | + 〉  →  1, | - 〉  →  0. For his auxiliary key measurement results, he uses the following convention for key bit values: | + 〉  →  1, | - 〉  →  0, if he measured x-component for the secure key; | + 〉  →  0, | - 〉  →  0, if he measured z-component for the secure key.

Alice and Bob announce their bases for secure key publicly, and discard those qubits for which their bases do not match. Various measurement results for rest of the cases where the bases agree, will be correlated in the following fashion. If Alice sends z-basis, the secure key bits of Alice and Bob will be identical. If Alice sends x-basis, the secure key bits of Alice and Bob will be identical if the auxiliary key bit is 0; the secure key bits of Alice and Bob will be different if the auxiliary key bit is 1.

Thus,for a sequence of qubit pairs sent, Alice and Bob's secure key bits will be identical if the corresponding auxiliary bit is 0. Alice and Bob's secure key bits will not match for cases where the auxiliary bit is 1. So, Bob just needs to add his final auxiliary key to his secure key bit by bit, modulo 2. This way, his auxiliary bit 1 added to his non-matching secure key bit will make it identical to Alice's bit.

An evesdropper trying to figure out the shared key in between, will have his task made difficult in more ways than it is in BB84. For correctly figuring out the auxiliary key, the evesdropper has to know which of the two qubits was used for the auxiliary key for each and every pair, an impossible task. If we assume that the evesdropper is able to correctly guess which of the two qubits is used for the auxiliary key, he can simply make an x-basis measurement on those qubits, and generate the correct auxiliary key without Bob's knowledge. However, even in this near impossible circumstance, the rest of the communication still remains as the standard BB84.

In conclusion, we have introduced a new QKD scheme in which Alice sends pairs of qubits to Bob in four possible states. Bob randomly chooses one of the pair for his secure key and one for the auxiliary key. The auxiliary key has to be added to Bob's secure key in order to get the correct shared key. An evesdropper job is made more difficult as he has to correctly predict which particle Bob is going to use for secure key and which one for auxiliary key, for every pair used in the communication. Even if the evesdropper manages to acheive this near impossible feat, he is still left with the job of cracking the BB84 security. We believe this scheme should be easily implementable in practice.