Sampling from a polytope and hard-disk Monte Carlo

Introduction

The hard-disk system is a fundamental model of statistical and computational physics. During more than a century, the model and its generalization to d-dimensional spheres have been central to many advances in physics. The virial expansion is an example: Boltzmann's early calculations of the fourth virial coefficient [\cite=Boltzmann_1896] ultimately led to Lebowitz and Onsager's proof of the convergence of the virial expansion up to finite densities [\cite=Lebowitz_1964] for all d and to the general and systematic study of virial coefficients. The theory of phase transitions provides another example for the lasting influence of the hard-disk model and its generalizations. Kirkwood and Monroe [\cite=Kirkwood_1940] first hinted at the possibility of a liquid-solid transition in three-dimensional hard spheres. This prediction was surprising because of the absence of attractive interactions in this system. The depletion mechanism responsible for the effective-medium attraction was also first studied in hard spheres, by Asakura and Oosawa [\cite=Asakura_1954]. In two dimensions, the liquid-solid phase transition was first evidenced by Alder and Wainwright [\cite=Alder_1962]. It lead to far-reaching theoretical [\cite=KTHNY], computational [\cite=Mak_2006] [\cite=Bernard_2011] and experimental [\cite=Zahn_1999] work towards the understanding of 2D melting. In mathematics, hard disks and hard spheres have also been at the center of attention [\cite=Diaconis_2010]. A rigorous existence proof of the melting transition in hard spheres is still lacking, but the ergodicity of the molecular dynamics evolution of this system has now been established rigorously [\cite=Sinai_1970] [\cite=Simanyi_2003].

Arguably the most important role for the hard-disk model has been in the development of numerical simulation methods. Molecular dynamics [\cite=Alder_1957] [\cite=Rapaport_1980] and Markov-chain Monte Carlo [\cite=Metropolis_1953] were first formulated for hard disks. The early algorithms have continued to be refined: Within the molecular dynamics framework, this has lead to highly efficient event-scheduling strategies [\cite=Rapaport_1980] [\cite=Isobe_1999] and, for Monte Carlo, to the development of cluster algorithms [\cite=Dress_2005] [\cite=Jaster_1999] [\cite=Bernard_2009]. Even the modern simulation algorithm remain slow, however, and revolutions like the cluster algorithms for spin systems [\cite=Swendsen_1987] [\cite=Wolff_1989] have failed to appear. Moreover, rigorous mathematical bounds for the correlation time (mixing time) of Monte Carlo algorithms were obtained in the thermodynamic limit only for small densities [\cite=Kannan_2004] [\cite=Wilson_2000] [\cite=Chanal_2010], which are far inside the liquid phase. At higher densities, close to the liquid-solid transition, many numerical calculations have suffered from insufficient simulation times until recently [\cite=Mak_2006] [\cite=Bernard_2011].

In the present article, we discuss computational aspects of the hard-disk model, starting with an introduction (Section [\ref=s:algos]). In particular, we reinterpret hard-sphere Monte Carlo in terms of the sampling of points from high-dimensional polytopes (Section [\ref=s:polytope]). Local Monte Carlo amounts to random walks in a sequence of such polytopes, while event-chain Monte Carlo is equivalent to molecular dynamics evolutions with particular initial conditions for the velocities. We analyze the convergence properties of the algorithms in these polytopes for the hard-disk case. Parallel event-chain algorithms emerge naturally as molecular dynamics with more general initial conditions (Section [\ref=s:parallel]). We describe several parallelization strategies and report on implementations.

Local Monte Carlo and event-chain Monte Carlo

We consider N equal hard disks of unit radius σ = 1 in a square box of size L  ×  L. In the following, we assume without mentioning periodic boundary conditions for positions and pair distances. The statistical weights πa are equal to unity for configurations a without overlaps (all pair distances larger than 2) and zero for illegal configurations (with overlaps). The phase diagram of the system depends only on the packing fraction η: = Nπσ2  /  L2. In the following, the letters a, b, c, , label hard-disk configurations of N disks, given by the coordinates of the disk centers [formula]. The letters i, j, k number disks.

Balance conditions

Markov-chain Monte Carlo algorithms are governed by balance conditions for the flows Pa  →  b: = πa  pa  →  b from configuration a to configuration b (see Fig. [\ref=f:flows_detailed_global]); pa  →  b is the conditional probability to move from a to b, given that the system is in a. To converge towards the stationary distribution πa, the global balance condition must be satisfied: The total flow onto configuration a must equal the total flow out of a,

[formula]

The local Monte Carlo algorithm, introduced by Metropolis et al. in 1953 [\cite=Metropolis_1953] (see Fig. [\ref=f:event_chain_move]), uses the more restrictive detailed balance condition Pa  →  b  =  Pb  →  a for which the net flow between each pair of configurations a and b is zero. Moving from configuration [formula] to [formula] involves sampling the disk i to be displaced and the displacement [formula]. For detailed balance, the probability to sample [formula] at [formula] must equal the probability to sample [formula] at position [formula]. In order to be ergodic, the displacements [formula] are chosen such that each disk can eventually reach any position in the system.

Unlike the local Monte Carlo algorithm, a single move of the event-chain algorithm [\cite=Bernard_2009] may displace several disks. An event-chain move is parametrized by a total displacement [formula] and a direction [formula], which together form a vector [formula]. The move starts by sampling a disk i and "sliding" it in the direction until it hits another disk j, or at most for the distance [formula]. The disk j is then displaced in its turn, also in the [formula] direction, see Fig. [\ref=f:event_chain_move]. This process continues until the displacements of the individual disks sum up to [formula]. After this, a new disk and possibly a new direction are sampled for the next move. With periodic boundary conditions, no rejections occur in this algorithm. For a given displacement vector [formula], any disk configuration a can reach N other configurations, using each of the N disks to start an event chain. Likewise, a can be reached from N other configurations which may be reconstructed by event chains with displacement vector [formula]. This implies that the event-chain satisfies the global balance condition, Eq. ([\ref=e:globalbal]). If the vectors [formula] are equally likely, it also satisfies detailed balance. In order to be ergodic, the displacements [formula] must span space: By choosing [formula], the event-chain algorithm realizes the maximal global balance (see Fig. [\ref=f:flows_detailed_global]), where flow between two configurations is possible only in one direction. This version is more efficient than detailed balance versions (for example, [formula] and [formula]) [\cite=Bernard_2009]. It is again possible to alternate repeated moves in the [formula] direction with repeated moves in [formula] without destroying the correctness of the algorithm. For displacements [formula] smaller than the mean free path lmfp, the event-chain algorithm is roughly equivalent to the local Monte Carlo algorithm. It accelerates for increasing [formula], and for [formula] much larger than the mean free path, it is about two orders of magnitude faster than the local Monte Carlo method, and about ten times faster than the best current implementations [\cite=Isobe_1999] of event-driven molecular dynamics (see Ref. [\cite=Anderson_2012b]).

Correlation times and orientational order

The characteristic challenge of numerical simulations for the hard-disk model resides in the extremely long correlation time. This is illustrated in Fig. [\ref=f:orientation_movie] using snapshots of configurations obtained during a long simulation run. The system is quite small and not extremely dense, yet correlations in the orientation of the system persist over millions of Monte Carlo moves. To quantify the orientations and their correlations, we consider the local orientational field

[formula]

where Nj is the number of Voronoi neighbors of disk j. The wj,k (with [formula]) are normalized weights according to the length of the Voronoi interface between disks j and k, and φj,k is the angle of the vector between the disk centers [\cite=MickelKapfer_2013]. The average of Eq. ([\ref=e:local_psi]) over all disks yields the global orientational order parameter,

[formula]

In a square box, the mean value of Ψ6 is zero because of the φj,k  →  φj,k  +  π symmetry, and its correlation function

[formula]

decays to zero for infinite times Δt. We conjecture that Ψ6 is the slowest observable in the system. For large times, global orientational correlations decay exponentially, [formula], and we obtain the empirical correlation time τ from an exponential fit to C6.

Polytope representation of event-chain moves

Event-chain moves along a single direction [formula] sample a restricted configuration space. For the remainder of this section, we take the chains to move in the positive x direction, unless specified otherwise, to simplify the notation. Since all y coordinates are fixed, two disks whose y coordinates differ by less than 2 radii cannot slide across each other, and their relative order is fixed. Furthermore, while in x collision mode, any disk can collide with not more than six other disks, at most three in the forward direction, and at most three in backward direction (see Fig. [\ref=f:polytope_ballistics_plus_graph]). The collision partners of a disk may include itself, because of boundary conditions. The relations among disks constitute a constraint graph, which expresses the partial order between them (see Fig. [\ref=f:polytope_ballistics_plus_graph]). This graph remains invariant while performing event-chain moves in the [formula] direction. Each directed edge from i to k corresponds to a linear inequality for the x coordinates of the disks i and k:

[formula]

with [formula]. The constant bi,k can be adjusted to also account for periodic boundary conditions in the x direction. The inequalities Eq. ([\ref=e:polytopeEquations]) imply that no more than three forward collision partners can be present.

The system of linear inequalities Eq. ([\ref=e:polytopeEquations]) delimit a subset of the N-dimensional space of x coordinates [formula]), an N-dimensional polytope, bounded by at most 3N hyperplanes. This convex object is easier to analyze than the highly intricate 2N-dimensional configuration space of the full hard-disk problem. The polytope is unbounded in the [formula] direction in consequence of the periodic boundary conditions, since uniform translation of all the disks is always permitted. Also, since the constraint graph is invariant under event-chain moves in the x direction, so is the polytope. However, the polytope becomes bounded by taking a section orthogonal to [formula].

In the invariant polytope, an event chain of total displacement [formula] corresponds to a molecular dynamics evolution of duration [formula]: Displacing the i-th disk corresponds to the "particle" X moving in the i-th coordinate direction, and each collision event (the transfer of momentum from one disk to another) to a right-angle reflection at the facets of the polytope (see Fig. [\ref=f:polytope_ballistics_plus_graph]). The construction of the event-chain move is finished at time [formula]. The next move involves the sampling of a new starting disk and possibly of one of the [formula] directions. In the invariant polytope, this is the choice of new velocities. Local Monte Carlo on the other hand, if restricted to moves in x direction, implements diffusive motion in the invariant polytope.

The invariant constraint graph allows for fast lookup of possible collision partners, and may even replace the customary cell grids (see, for example, Section 2.4 of Ref. [\cite=SMAC]). While computation of the actual constraint graph requires depth search, a superset sufficient for practical computations can be computed efficiently, see the footnote on page .

Correlation functions in the invariant polytope

Although the sampling problem from the invariant polytope concerns a convex body, it is notoriously nontrivial [\cite=PolytopeComplexity]. The inequalities Eq. ([\ref=e:polytopeEquations]) essentially amount to a system of coupled one-dimensional hard-disk problems. To study the relaxation behavior effected by the event-chain algorithm in the polytope, we consider the cross-covariance of the disk coordinates,

[formula]

where i(t) is the x coordinate of the disk i, compensated for the overall translation of the system due to the event-chain moves,

[formula]

Here, α is 1 for the global balance version of the event-chain algorithm (chains only in + x direction), and 0 for the detailed balance version (±  x). The eigenvectors of U(0) are the polytope's normal modes mi, [formula], in the sense of principal component analysis. The nature of the modes mi depends on the structure of the invariant polytope and captures the relative order of colliding disks and their frozen-in y coordinates. The normal modes to the largest eigenvalues are large-scale cooperative rearrangements of the disks (see Fig. [\ref=f:eigenmodes]). They are the slowest modes to decay under both local and event-chain Monte Carlo and govern the global decorrelation of the disk configuration. In particular, two modes dominated by antiparallel flow bands are very slow to decay (mode 1 and 2 in Fig. [\ref=f:eigenmodes]).

At delay times Δt > 0, the cross-covariance Uij(Δt) captures residual correlations among the disk coordinates. The event-chain moves couple more efficiently to the longitudinal modes of the system, and we find that after Δt  ≈  N, the event-chain algorithm has virtually erased longitudinal correlations. The most prominent residual correlations carry a transverse band structure (see Fig. [\ref=f:eigenmodes]). The result is a substantial decrease in efficiency of the algorithm for simulated duration in a single direction larger than ≈  N.

To estimate the convergence time, we study the projection of the system's evolution X(t) onto a single mode, X(t)  ·  mi. The autocorrelation function

[formula]

is, for short chain lengths [formula], monotonously decaying. Larger chain lengths accelerate the decay, as the coupling to large-scale modes is improved (Fig. [\ref=f:eigenmodes]). For chains spanning several times the box, however, the autocorrelation functions Cmi develop oscillations with very weak damping, offsetting the benefits of longer chains. The detailed balance version of event-chain Monte Carlo is generally slower and less prone to oscillations. For optimal performance, the global balance version should thus be used with [formula] larger, but on the order of [formula], and for times θ  ≈  N (see Fig. [\ref=f:eigenmodes]). For disk configurations larger than the correlation length, [formula] can be reduced appropriately.

Convergence of the full hard-disk problem

The invariant polytope representation allows us to interpret the convergence of the full hard disk sampling problem. The conceptually simplest Monte Carlo algorithm for hard disks consists entirely in polytope sampling: One iteration amounts to direct sampling a new configuration an + 1 from the invariant polytope of the starting configuration an, and exchanging the x and y coordinates of all the disks. This Markov-chain algorithm satisfies detailed balance. In our experiments, the timescale τ, measured in iterations, for relaxation to equilibrium increases only as N1 / 4 for large systems, implying that most of the complexity of the hard-disk sampling problem resides in the polytope sampling.

Since direct sampling is a hard problem for high-dimensional polytopes (see Section [\ref=s:generalpolytope]), we replace it by Markov chains of a fixed number of event-chain moves, in effect performing molecular dynamics in the invariant polytopes for fixed duration θ:

[formula]

This algorithm satisfies detailed or global balance depending on the version of the event-chain algorithm that is used for polytope sampling.

We study the influence of the switching interval θ on convergence properties. In Fig. [\ref=f:switchingAndMixing], the autocorrelation function C6 of the complex order parameter Ψ6 is plotted vs. cumulative molecular dynamics time. C6 decays most quickly when the switching interval θ is small, but the decay speed deteriorates very slowly with θ. Only at θ  ≈  N (corresponding to about 6-7 collisions per disk at these densities), the algorithm becomes notably less efficient. The efficiency drop thus follows the decay of longitudinal (in x direction) correlations in the invariant polytope, and is to be expected from the results in Section [\ref=s:polytope].

In the limit θ  →    ∞  , the event-chain algorithm realizes direct sampling in the invariant polytope. The approach to this limit is illustrated in Fig. [\ref=f:switchingAndMixing] by plotting C6 against the number of x/y switching cycles [formula]. As the switching interval θ increases, the autocorrelation functions approach an asymptotic curve [formula], where τ is the correlation time of the direct sampling algorithm. We find that for practical purposes, event-chain Monte Carlo reaches the asymptotic regime for θ  ≈  N, and thus samples an approximately independent point in the invariant polytope in O(N) operations. Importantly, the correlation time τ(N) increases rapidly only for small system size N. After the system size surpasses the correlation length, τ grows only as N1 / 4.

Application to general polytopes

The invariant polytope is bounded by hyperplanes which are normal to N - 2 coordinate axes and have unit derivative along the remaining axes. By choice of the [formula], the molecular dynamics evolution is aligned with the coordinate axes at all times, and computations of intersections are of complexity O(1). As shown in Section [\ref=s:fullharddisk], the event-chain algorithm seems to achieve an effective mixing time of O(N) collision events, so that the cost of sampling the hard-disk polytope appears as O(N).

The event-chain algorithm also allows to sample general polytopes. Direct sampling from polytopes is straightforward only in low dimensions N, especially in N = 2: A two-dimensional polytope with n edges (a convex n-sided polygon), can be decomposed into n triangles, using an interior point. Triangles may then be sampled according to their areas, and a random point may be sampled inside the sampled triangle (see, e. g. chap. 6.2 of [\cite=SMAC]). In higher dimensions N, triangulation by simplices generalizes this decomposition. Since polytopes such as the invariant hard-disk polytope have an exponential number of facets, direct sampling algorithms are no longer practical. Markov-chain sampling [\cite=Smith_1984] [\cite=Rubin_1984] [\cite=Dyer_1991] [\cite=Kannan_2012] achieves mixing times of O(MN) steps, where M is the number of bounding hyperplanes (M  ≤  3N for hard disks), and where each move may be implemented in O(M) steps. It will be interesting to see how event-chain polytope sampling compares with existing polytope sampling methods, in particular the 'hit-and-run' algorithms.

Parallel Monte Carlo algorithms for hard disks

In view of the long running times of Monte Carlo simulations and of the current standstill in computer clock speeds, it is essential to develop parallel Monte Carlo methods which distribute the work load among several threads performing independent computation with as few communication as possible. Such methods will allow to study not only the standard hard disk ensemble, but also related systems such as soft disks and polydisperse disk packings. However, parallel Monte Carlo algorithms for continuum systems pose many more problems than for lattice models, for example the Ising spins, where straightforward parallel application of local Metropolis updates converges to the Boltzmann distribution [\cite=Berg_2004].

Parallel implementation of local Monte Carlo

A massively parallel implementation of the local Monte Carlo algorithm was applied recently to the hard-disk melting problem [\cite=Anderson_2012a] [\cite=Anderson_2012b]. It sets up square cells according to a four-color checkerboard pattern. Disks in same-color cells can be updated simultaneously, but moves across cell boundaries are rejected. To ensure ergodicity, a new cell grid must be sampled periodically. Massive parallelism of ~  1500 threads on a graphics card offsets the slowness of local Monte Carlo compared to event-chain algorithm Monte Carlo [\cite=Anderson_2012b]. These calculations confirmed the first-order liquid-hexatic phase transition in hard disks [\cite=Bernard_2011].

Parallel implementations of event-chain Monte Carlo

For parallel implementations of event-chain Monte Carlo, we consider only parallel threads that run chains in the same direction [formula]. This minimizes the chance that two chains cross each other and move the same disks. It also allows us to apply the invariant polytope framework of Section [\ref=s:polytope]. It is instructive to realize that the effects of an event-chain move can be summarized in the difference vector of the new and old x coordinates: [formula], with [formula]. Moreover, if two chains are independent, meaning their sets of disks touched are disjoint, the net effect of running both chains is the sum of their individual difference vectors, [formula]. If, however, any disk is touched by both chains, the chain reaching this disk earlier in MD time has precedence, the later chain sees a modified environment, and consequently takes a different evolution. Thus, interdependent chains cannot be added arithmetically. The primary obstacle in parallelizing event-chain Monte Carlo consists in preserving the correct causal relations between subsequent chains, as required for the convergence to correct equilibrium distribution.

In the following, we discuss three strategies to parallelize event-chain Monte Carlo. The predict/execute algorithm distributes work among threads for a model of chains that follow each other chronologically. The effects [formula] of several chains are predicted in advance from the current disk configuration. The effects of the chains are then applied to the system state in the chronological order in which the starting disks were sampled. To detect conflicts, it is sufficient to compute the intersection of the set of disks touched by the current chain and of the chains that ran since the beginning of planning; if this intersection is not empty, the chain has to be recomputed from the updated state of the disk configuration. Planning and execution of chains can proceed in parallel on a shared-memory machine. Using lock-free data structures, we attain collision rates in excess of 1011 per hour in x collision mode on a four-processor machine. Due to its serial nature, this algorithm does not scale well beyond a few threads, however; with too many chains predicted in advance, the probability for recomputations rises. Moreover, switching between x and y collision modes requires reinitialization of the data structures and is rather expensive.

A variation of the four-color scheme adapted to the event-chain algorithm partitions the system in horizontal stripes, separated by frozen isolation layers of thickness ≥  2 disk radii (see Fig. [\ref=f:stripescheme]). Disks with their centers in the isolation layers are kept fixed, and thus guarantee the independence of chains running in neighboring stripes. To preserve the isolation layers, chains colliding with a frozen disk are rejected. As there are rejected moves, the global balance condition is no longer guaranteed: the number of accepted forward chains can be different from the number of accepted backward chains (see Section [\ref=s:balances]). When allowing chains in both the [formula] directions, however, the isolation layer algorithm satisfies detailed balance. Furthermore, in order to limit the rejection rate, the per-chain total displacement [formula] has to be kept lower than in the serial algorithm. In view of the discussion of Section [\ref=s:polytope], these necessities reduce somewhat the efficiency of the method. Due to the isolation layers, the accessible configuration space is restricted, and for ergodicity, the layer boundaries have to be resampled periodically, as in the four-color version of local Monte Carlo.

We have implemented the isolation layer algorithm in parallel on a shared-memory machine. Using several cores in parallel, it is possible to achieve effective collision rates which are 10-30 times the single-core performance (see Fig. [\ref=f:stripescheme]), for systems of sufficient size. For systems too small, less threads can be used without shrinking the active strips to a point where the acceptance ratio becomes a limiting factor. Systems of physical interest, however, are on the order of N = 10242, and allow to use 10-20 cores with moderate [formula]. At this time, the algorithm is not bound by rejection rates, but by communication between threads.

Finally, the event-chain scheme is not fundamentally limited to a single moving disk at any time. We may indeed launch multiple concurrent chains, which run at the same simulated MD time, and interact with each other. This is different from the parallel simulation of chains which interact in sequential manner. In the invariant polytope picture, multiple concurrent chains correspond to choosing more general initial conditions, where more than one disk is given an initial velocity of 1. After time [formula], multiple chains have executed, and possibly interacted with each other; there is no rejection in this algorithm. The problem has some resemblance with event-driven molecular dynamics, because the scheduling of collisions must be foreseen, but there are several simplifications: all velocities are in the same direction and of magnitude 0 or 1. As a consequence, two moving disks cannot collide with one other; however, the faithful simulation of chains close by and possibly interacting requires careful synchronization among threads. In our experiments, this limits the speedup by parallelization. Our most efficient method at this point is the isolation layer algorithm.

Conclusion

We have reached in this paper a better understanding of the event-chain Monte Carlo algorithm for the hard-disk sampling problem. By restricting the algorithm to chains in a single direction, a connection appears to the well-known problem of sampling random points from a polytope: A move of the event-chain algorithm consists in performing a finite-time molecular dynamics simulation in the invariant polytope of the disk configuration. This connection offers new strategies to solve the hard-disk sampling problem in terms of polytope sampling; it also suggests to investigate the utility of event-chain methods for the sampling of general polytopes. Finally, it will be interesting to study the combinatorial structure of the typical invariant polytope, and its dependence on thermodynamical parameters.

By the study of correlation functions, we have shown that the Monte Carlo relaxation process in the invariant polytope separates into two phases: A rapid longitudinal relaxation, followed by a much slower relaxation of the transverse degrees of freedom. We have given recommendations for the parameters of the algorithm based on these results. Finally, we have discussed several strategies for parallelizing Monte Carlo algorithms for hard disks, alleviating the problem of the long simulation times in hard disk Monte Carlo. The parallelization of the hard-disk ensemble remains challenging due to its unique combination of very little actual computation and long correlation times. Efficient methods to tackle the hard-disk ensemble are, however, crucial in order to treat related systems such as soft disks with the same level of success as the hard disks. New concepts such as the link to polytope sampling will be essential in this effort.

Acknowledgment

We thank P. Diaconis, E. P. Bernard, S. Leitmann and M. Hoffmann for fruitful discussions.

References