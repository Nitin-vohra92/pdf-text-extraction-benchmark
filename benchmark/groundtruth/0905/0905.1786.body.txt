Une CNS pour l'acheminement de messages instantanément stabilisant

Introduction

De nombreux concepts de tolérance aux pannes ont été introduits en systèmes distribués. Par exemple, l'auto-stabilisation ([\cite=D74]) assure que le système, indépendament de son état initial, retrouve un comportement répondant à ses spécifications en un temps fini sans intervention externe. L'état initial quelconque peut permettre de modéliser l'effet de fautes transitoires sur le réseau. Un autre concept, la stabilisation instantanée ([\cite=BDPV07]), garantit que le système, indépendament de son état initial, a toujours un comportement répondant à ses spécifications. Dans un système distribué, il est classiquement supposé que tout processeur ne peut communiquer directement qu'avec ses voisins. Pourtant, ce processeur peut avoir besoin de communiquer avec tout processeur du réseau. Dans ce but, il y a en réalité deux problèmes à résoudre : la détermination du chemin à suivre par les messages (problème du routage) et la gestion des ressources du réseau réservées au transport des messages (problème de l'acheminement). Ces ressources sont des espaces mémoire (appelés buffers) utilisés pour stocker temporairement les messages durant leur acheminement. Ces deux problèmes ont été largement étudiés (cf. [\cite=T01] [\cite=CDV09a] pour les références). Nous disposons de nombreuses solutions stabilisantes pour le premier problème. C'est pourquoi dans cet article, nous nous intéressons aux solutions stabilisantes pour le deuxième. [\cite=CDV09a] démontre qu'il existe des algorithmes d'acheminement instantanément stabilisants (à condition qu'un algorithme de calcul de table de routage auto-stabilisant s'exécute simultanément). Cela implique que nous pouvons demander au système de commencer à acheminer des messages même si les tables de routage sont initialement corrompues. Dans la suite, nous appellerons message valide tout message qui a été généré par un processeur (par conséquent, un mesage invalide est un message présent dans la situation initiale). Nous pouvons alors spécifier le problème de l'acheminement de la fa�on suivante : (1) Tout message peut être émis en un temps fini et (2) Tout message valide sera délivré à son destinataire en un temps fini. L'objectif de cet article est de présenter une condition nécessaire et suffisante pour obtenir un algorithme d'acheminement instantanément stabilisant. Il s'inspire d'un résultat similaire obtenu dans un environnement sans fautes ([\cite=MS78] [\cite=TS81]). La suite de l'article est structurée comme suit : dans un premier temps, nous présentons le résultat obtenu dans [\cite=MS78] [\cite=TS81] pour un environnement sans fautes (section [\ref=sec:theoreme]) puis nous donnons notre contribution dans la section [\ref=sec:contribution].

Théorème dans un environnement sans fautes

Dans cette section, nous nous pla�ons dans un système distribué qui ne peut pas subir de fautes. La configuration initiale est définie : les tables de routage sont correctes et il n'y a aucun message invalide dans les buffers. Dans cet article, nous nous pla�ons dans un réseau à commutation de message (cf. [\cite=T01]). Chaque processeur dispose de [formula] buffers de taille suffisante pour contenir tout message. La méthode de commutation est composée de trois types de mouvements : - Génération : c'est la "création" d'un nouveau message. Nous supposons que celle-ci est autorisée dès qu'un buffer du processeur émetteur est libre. - Transmission : c'est la copie d'un message dans un buffer du processeur suivant sur le chemin calculé par l'algorithme de routage. Nous supposons que ce mouvement est autorisé dès qu'un buffer sur le processeur en question est libre. En conséquence de ce mouvement, le buffer initial se libère en un temps fini. - Consommation : c'est le mouvement qui libère un buffer occup� par un message à destination du processeur sur lequel est situé ce buffer. Le message est alors délivré à son destinataire. Nous supposons que ce mouvement est toujours autorisé. Cependant, si nous n'effectuons aucun contrôle supplémentaire sur les mouvements de message, le réseau peut atteindre des situations inacceptables comme des interblocages. Il est alors impossible d'assurer les spécifications du problème. C'est pourquoi, il est nécessaire de définir un algorithme (appelé contrôleur) qui autorise ou interdit dynamiquement (en fonction de l'occupation courante des buffers) certains mouvements. Si la réponse à la question "Est-ce qu'un contrôleur C empêche le réseau d'atteindre un interblocage quelle que soit l'exécution issue de la configuration initiale ?" est affirmative, alors C est dit sans interblocage. En assurant l'absence de famine et de perte de messages, nous pouvons constater qu'un tel algorithme répond au problème de l'acheminement de messages. Nous allons présenter une classe de contrôleurs sans interblocage bas�e sur le concept de graphe de buffers, introduit par [\cite=MS78]. Plus précisément, la structure choisie est un DAG pour la raison suivante : un interblocage provient du fait qu'il existe un circuit d'attente de libération de buffer. L'idée de base est alors de définir un DAG sur l'ensemble des buffers du réseau de manière à ce que les messages suivent les chemins de ce DAG. Ainsi, il ne peut pas se former de circuit d'attente de libération de buffer. Posons la notation suivante : G = (V,E) est le graphe modélisant le réseau (V est l'ensemble des processeurs et E l'ensemble des liens de communications).

Un graphe de buffers BG = (B,BE) sur un graphe G muni d'un ensemble B de buffers et d'un ensemble P des plus courts chemins (induit par l'algorithme de routage) est défini de la manière suivante : (1) BG est un graphe orienté, (2) pour tout chemin p∈P, il existe un chemin dans BG dont la contraction est p, (3) pour chaque noeud u de G et pour chaque message m possible, il existe un buffer adéquat de BG noté fb(m,u) sur u, (4) pour chaque buffer b de B situé sur un processeur u et pour chaque message m (non destiné � u) possible, il existe un unique buffer adéquat, situé sur u ou sur un de ses voisins, noté nb(m,b) et (5) BE est l'ensemble des arcs (b,nb(m,b)) pour tout buffer b∈B et pour tout message m (non destin� au processeur sur lequel est b) possible.

La notation fb(m,u), signifiant "first buffer", représente le buffer dans lequel est placé le message m généré par le processeur u. De même, la notation nb(m,b), signifiant "next buffer", représente le buffer dans lequel sera transmis le message m qui occupe le buffer b. Une fois un tel graphe de buffer défini, il est possible de lui associer un contrôleur selon la définition suivante :

Etant donné un graphe de buffers BG = (B, BE) sur un graphe G muni d'un ensemble B de buffers et d'un ensemble P des plus courts chemins (induit par l'algorithme de routage), nous définissons le contrôleur CBG de la manière suivante : - La génération d'un message m sur un noeud u est autorisé si et seulement si fb(m,u) est libre. m est alors placé dans ce buffer. - La transmission d'un message m contenu dans le buffer b est autorisée si et seulement si nb(m,b) est libre, m est alors placé dans ce buffer et b est libéré.

Nous sommes � présent en mesure de donner le résultat fondamental suivant ([\cite=MS78] [\cite=TS81]) :

Le lecteur pourra trouver des exemples de tels contrôleurs dans [\cite=T01].

Contribution

Dans cette section, nous nous pla�ons dans un système distribué sujet à des fautes transitoires. La configuration initiale est donc quelconque : les tables de routage sont incorrectes et il y a des messages invalides dans les buffers. Nous reprenons les notations et définitions introduites dans la section 2. Soit C un contrôleur répondant à la définiton 2 pour un graphe de buffers BG. Nous supposons que, pour tout message m occupant un buffer b, le buffer nb(m,b) est calculé au moment de la transmission du message en fonction des tables de routage à cet instant. Nous supposons exister un algorithme A de calcul de table de routage auto-stabilisant et silencieux. Cet algorithme s'exécute de manière simultanée mais prioritaire par rapport à C (noter que cet algorithme ne nécessite que des communications entre voisins, il n'est donc pas utile qu'il utilise les buffers de communication distante gérés par C). Nous posons les notations suivantes : FB et NB représentent respectivement l'ensemble des buffers fb(m,u) pour tout processeur u et pour tout message possible m associés � BG et l'ensemble des buffers nb(m,b) pour tout buffer b et pour tout message m (non destiné au processseur sur lequel se situe b) associés � BG. Nous donnons à présent notre théorème :

Le lecteur peut trouver un algorithme répondant à ces propriétés dans [\cite=CDV09a]. Nous allons à présent donner les idées de la preuve de ce résultat.

Preuve de la nécessité de la condition

Nous souhaitons montrer que si C répond au problème de l'acheminement de messages de manière instantanément stabilisante (à condition que A s'exécute de manière simultanée) alors C vérifie les cinq propriétés du théorème 2. Pour cela, nous allons raisonner par contraposée. Supposons donc que C ne vérifie pas une des propriétés du théorème 2. 1) Si BG possède un circuit une fois A stabilisé, nous pouvons construire un circuit d'attente sur un ensemble de messages et donc un interblocage. 2) Si C n'est pas équitable pour la génération ou la transmission, cela signifie qu'il peut mettre un message en famine et donc l'empêcher d'être délivré. 3) S'il existe un message valide m, non délivré pendant la stabilisation de A, tel qu'aucune copie n'occupe un buffer adéquat pour m une fois A stabilisé, cela signifie que ce message ne pourra pas être délivré. 4) S'il existe un message ne libérant jamais un buffer de FB ou de NB qui ne lui est pas adéquat une fois A stabilisé, cela signifie qu'il existe un message qui peut être mis en famine pour sa génération (cas de FB) ou une de ses transmissions (cas de NB). Dans ce cas, ce message ne pourra pas être délivré. 5) S'il existe un message valide m tel que C ne maintienne pas une copie tant qu'il n'est pas délivré, cela signifie que m a été perdu. Ce message ne pourra pas être délivré. Dans tous les cas, nous constatons que C ne répond pas au problème de l'acheminement de messages de manière instantanément stabilisante, ce qui était le résultat à prouver.

Preuve de la suffisance de la condition

Nous souhaitons montrer que si un contrôleur C vérifie les cinq propriétés du théorème 2 alors il répond au problème de l'acheminement de messages de manière instantanément stabilisante (à condition que A s'exécute de manière simultanée).

Pour prouver ce résultat, il faut reprendre la preuve du théorème 1 (le lecteur pourra se reporter à la preuve du théorème 5.7 dans [\cite=T01]), ce qui nécessite la propriété 1 du théorème 2 (en constatant que la propriété du théorème 2 4 permet d'assurer que les messages invalides ne perturberont pas la preuve). Cela permet de prouver que C est sans interblocage dans le cas considéré. Les propriétés 2 et 5 du théorème 2 permettent alors de déduire le résultat.

Par hypothèse, A est un algorithme de calcul de table de routage auto-stabilisant et silencieux. Cela signifie que les tables de routage seront construites et correctes en un temps fini (grâce au fait que A soit prioritaire sur C). Or, C s'exécute de mani�re simultanée, l'occupation des buffers va donc être modifiée (acceptation de nouveaux messages et acheminement de messages). Nous pouvons appliquer le lemme 1 une fois A stabilisé. Nous savons donc que C répond au problème de l'acheminement de messages de manière instantanément stabilisante lorsque les tables de routage sont correctes et constantes (ce qui est assuré par le fait que A est silencieux). C répondra donc � la spécification du problème à partir de cette configuration. C est donc auto-stabilisant.

Il s'agit d'une conséquence directe des propriétés 3 et 5.

Les lemmes 2 et 3 nous permettent de déduire trivialement que si C vérifie les cinq propriétés du théorème 2, alors il répond au problème de l'acheminement de messages de manière instantanément stabilisante à condition que A s'exécute simultanément.

Conclusion

Dans cet article, nous avons donné un ensemble de propriétés nécessaires et suffisantes pour obtenir un acheminement de messages instantanément stabilisant. En ce sens, notre résultat généralise celui obtenu dans [\cite=MS78] [\cite=TS81]. Il serait possible d'appliquer notre résultat pour démontrer plus simplement l'algorithme de [\cite=CDV09a].