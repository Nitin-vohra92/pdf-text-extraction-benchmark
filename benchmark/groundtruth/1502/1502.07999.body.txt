On the Energy Complexity of LDPC Decoder Circuits

Submitted for publication on February 25th, 2015. Presented in part at the 2014 IEEE North American School of Information Theory, June 18-21, Toronto, Canada.

Christopher Blake and Frank R. KschischangDepartment of Electrical & Computer EngineeringUniversity of Toronto christopher.blake@mail.utoronto.ca frank@comm.utoronto.ca

Introduction

Low density parity check codes are a class of codes first introduced by Gallager in [\cite=GallagerLDPC]. This paper finds fundamental lower bounds on the energy of VLSI implementations of capacity-approaching LDPC decoders. Central to the construction and analysis of LDPC codes is the randomly generated Tanner graph with a given degree distribution. A widely used method of analysis involves analyzing an ensemble of LDPC codes whose Tanner graphs are generated according to some distribution. It has been shown that there exist degree distributions that result in LDPC codes and decoders that can get arbitrarily close to capacity for an erasure channel [\cite=OswaldCapacityApproachingLDPCErasureChannel]. The first main result of this paper is an "almost-sure" scaling rule for the energy of capacity-approaching LDPC decoders whose Tanner graphs are generated according to a uniform configuration model. The second main result of this paper is a scaling rule for the energy of all, as opposed to almost all, capacity-approaching LDPC decoders. What we mean by an "almost sure" and "sure" scaling rule will be made more precise later in the paper.

To find energy-complexity lower bounds on a class of algorithms a computation model is needed. We use a standard circuit model that was first presented by Thompson in [\cite=Thompson]. In this model, we consider the energy of a circuit implementation of an algorithm to be the area of the circuit multiplied by the number of clock cycles required to execute the algorithm. We will give a more detailed discussion of this model later in the paper. The authors of [\cite=groverFundamental] used the Thompson model to analyze the energy complexity of all decoding algorithms by showing that as the target block error probability approaches 0, the total energy must approach infinity. In [\cite=BlakeKschischangFundamentalLowerBoundArxiv] the authors showed that any fully-parallel decoding scheme that asymptotically has block error probability less than [formula] must have energy complexity which scales as [formula]. These results, though general, do not suggest the existence of any decoder implementations that reach these lower bounds. In this paper, we in particular show that the energy of LDPC decoding schemes that directly-implement their Tanner graphs cannot reach the [formula] energy lower bound, and in fact must have energy that scales at least as [formula].

We begin the paper in Section [\ref=sec:Background] with a discussion of the graph theory used in the paper, and we also discuss some prior work that reaches similar conclusions to our paper. Then, in Section [\ref=sec:Definitions-and-Main-Lemmas] we introduce graph theory definitions and the circuit model that we will use. We also present some important lemmas that will be used in our theorems. Then, in Section [\ref=sec:Main-Theorem], after defining some properties of node degree distributions, we present the main theorem which shows that almost all LDPC Tanner graphs have minimum bisection width proportional to the number of vertices. We proceed to show how this theorem allows us to find scaling laws for the energy of directly-implemented LDPC decoders in Section [\ref=sec:Almost-Sure-Bounds-on-LDPC-Circuits]. The results presented in these sections are true for almost all LDPC decoders (i.e., for a set of decoders with probability approaching one), but it is not clear whether there is a set of LDPC decoders of probability approaching 0 that can approach capacity. Thus, in Section [\ref=sec:Bounds-for-All] we present a theorem that relates the number of edges and vertices in a graph to the area of its circuit instantiation to show a scaling rule that is applicable to any LDPC decoding algorithm that approaches capacity. This results in a sure as opposed to almost sure scaling law for the energy per iteration of a directly-instantiated LDPC decoder of [formula].

Background

Related Work on LDPC Scaling Rules

There are some results on fundamental limits on wiring complexity of LDPC decoders. In particular, in [\cite=GanesonGroverLDPCLowerBound], the authors assume that the average wire length in a VLSI instantiation of a Tanner graph is proportional to longest wire in an asymptotic sense, and that the longest wire is proportional to the diagonal of the circuit upon which the LDPC decoder is laid out. The implication of these assumptions is an [formula] scaling rule for the area of directly-implemented LDPC circuits, which is the same result of this paper. However, these assumption are taken as axioms without being fully justified; there certainly can exist bipartite Tanner graphs that can be instantiated in a circuit without such area. The result of this paper suggests that, in fact, the [formula] scaling rule is justified for almost all VLSI instantiations of LDPC Tanner graphs as the block length of these LDPC codes grow large, where the Tanner graphs are generated from a uniform configuration model and a sufficient condition on the node degree distributions is satisfied. This scaling rule is an implication of the main theoretical contribution of this paper: a result in random graph theory that we present as Theorem [\ref=thm:MainTheorem]. In addition to this, we provide a super-linear energy scaling rule for all directly-implemented LDPC decoders, even if the Tanner graph of such decoders is not generated according to the uniform configuration model.

Related work on Graph Theory

In graph theory, there are a number of results that study the minimum-bisection width of graphs. Often this work looks at a graph's Laplacian, which is a matrix equal to the difference in the graph's degree matrix and adjacency matrix. In [\cite=FiedlerBisectionWidthLowerBound] a graph's Laplacian is analyzed and it is shown that the second largest eigenvalue, λ2, can be used to find a lower bound of [formula] on the graph's minimum bisection width. In [\cite=BezrukovSpectralLowerBounds], the authors find some bounds on the bisection width of graphs that are related to this λ2 value. The authors in [\cite=DiazBisectionWidthBoundsRegularGraphs] provide almost sure upper bounds for the bisection width of randomly generated regular graphs. Our result does not consider the second greatest eigenvalue of the Laplacian of a graph to bound the minimum bisection width. Instead, we use a unique purely combinatorial approach to reach our almost sure lower bounds. Furthermore, our analysis is of random bipartite graphs, as opposed to random regular graphs. As well, our result makes only weak assumptions on the node degree distribution to get our lower bound, without requiring a degree-regularity assumption. The generality of the result allows us to apply the theorem to find a scaling rule for the area of almost all capacity-approaching directly-implemented LDPC decoding circuits.

Definitions and Main Lemmas

Graph Theory Definitions

The main result of our paper involves the minimum bisection width of a graph. The minimum bisection width is a property of any graph. A bisection is a set of edges that once removed divides the graph into two subgraphs that have the same number of vertices. A formal definition is given below.

Consider a graph G with vertices V and edges E. Let Es  ⊆  E be a subset of the edges. Then Es bisects G if removal of Es cuts V into unconnected sets V1 and V2 in which [formula]. A minimal bisection is a bisection of a graph whose size is minimal over all bisections. The minimum bisection width is the size of a minimal bisection.

Generally speaking, finding the minimum bisection width of a graph is a difficult problem (it is in fact NP-Complete [\cite=Garey1976237]). The diagram in Fig.  [\ref=minimumBisectionWidth] shows minimal bisections of a few simple graphs. Associated with a bisection Es of a graph G are two unconnected graphs [formula] and [formula] induced by the bisection. We will refer to the set of vertices V1 and V2 each as a bisected set of vertices induced by a bisection or, more compactly, a bisected set of vertices, where the association with the particular bisection is to be implicit.

Note that in this paper we will often consider dividing the vertices of a subset into two disjoint sets V1 and V2 in which [formula]. For convenience of discussion, we call this process dividing the vertices in half. We make particular note of this to avoid in every case having to distinguish between if the cardinality of the set of vertices in question is even or odd.

Circuit Model

Central to our discussion is the relation between minimum bisection width of a graph and the area (and thus energy) of a circuit that implements that graph. Our discussion applies directly to LDPC decoders, and within our model we must define an LDPC decoder, as well as a more general circuit. In this paper, the definition of a circuit is adapted from Thompson [\cite=Thompson] and is considered to be a mathematical object consistent with the following circuit axioms. This model was also used in [\cite=groverFundamental] to find bounds on the energy complexity of encoding and decoding algorithms. We also provide a diagram of an example circuit in Figure [\ref=fig:circuit].

A circuit is a collection of nodes and wires laid out on a planar grid of squares. Each grid square can be empty, can contain a computational node (sometimes referred to more simply as a node), a wire, or a wire crossing. A circuit also has some special nodes called input nodes and also output nodes. The purpose of a circuit is to compute a function [formula]. Such a circuit is said to have n inputs and k outputs. The computation is divided into τ clock cycles. The inputs into a computation are to be loaded into the input nodes, and the outputs are to appear in the output nodes during some set clock cycle of the computation.

Each grid square has width [formula], known as the wire width and thus has area [formula]. It is in this parameter that this circuit model subsumes different VLSI implementation techniques. In real circuits, this parameter may be a value like 14 nanometers. Our concern in this paper is not what this value is, but rather in providing scaling rules in terms of the VLSI implementation technology used.

The computational nodes are the "computing" parts of the circuit. A node has at most 4 bidirectional wires connected to it, which are used to feed in bits into the node and feed out the bits computed by the node. Each node is capable of computing a fixed function of the bits fed into it by the wires connected to them during each clock cycle. In particular, a node with [formula] wires leading into it can compute any function [formula]. However, a computational node is restricted to only be able to compute the same function at each clock cycle. We note, of course, that the output of a particular node could change with each clock cycle because, in general, the inputs into the function could change with each clock cycle.

The wires are the "communication" part of a circuit. Wires in a circuit are connections between computational nodes, and are assumed in our model to be bidirectional. At each clock cycle a wire can carry one bit in each direction. The bits communicated are an output of the function computed by the computational node to which the wire is connected. A wire can be placed in a grid square in a way that connects one edge of the grid square to some other edge. Thus, grid squares containing wires can be connected to form a wire leading from one node to another node.

An input node is a special node in the circuit. In addition to being able to compute any fixed function mapping its [formula] inputs to its [formula] outputs, this node is also given an input bit into the circuit. In general, at each clock cycle an input node can have as its input a new input into the function. Thus, we say that inputs, in general, can be serialized; that is, they can be injected into the circuit at different clock cycles of the computation. Usually it is assumed that the inputs into an input node are chosen from the set [formula]; however, sometimes (especially for the purpose of lower bound) we can assume that the inputs into an input node are chosen from a larger set of values. In [\cite=BlakeKschischangFundamentalLowerBoundArxiv] it was assumed that an input node that is attached to f wires can compute any function [formula], {i.e., the node can perform any function of its 4-bit input from the wires connecting to it, as well as its input, taken from the symbols [formula], where in the case of this assumption ? is considered an erasure symbol. In our analysis we can assume that an erasure is a valid input as well, however this is not a central assumption of this paper and the results apply to inputs being taken from the set [formula].

An output node is another special node in a circuit. It is permitted to, like any other node, compute any function of its inputs, but it is given an additional output. Thus, in the case of an output node with [formula] wires leading from it, the output node can perform any function [formula] where one of the bits in the output is distinguished as an output bit. The output node is required to hold in its output bit some circuit output during set clock cycles. In a fully parallel computation the output node is required to hold one output bit of the computation at the end of the computation, but in general the outputs may be serialized, and one output node can be responsible for outputting a number of the outputs of the computation, where each output has a specified clock cycle during which it is to appear.

A wire crossing in a circuit is a grid square that contains two wires that "cross" each other. An example of a circuit with computational nodes, wires, and a wire crossing is given in Fig. [\ref=fig:circuit].

The normalized area of a circuit is the number of grid squares occupied, and it is denoted with the symbol [formula]. The number of grid squares occupied with nodes/wires is the normalized area of the nodes/wires of the circuit, and is denoted [formula]/[formula]. Thus, the actual area of the circuit is [formula] and the area of the nodes/wires are defined similarly by multiplying the normalized value by [formula], the area of a unit grid square.

The energy of a computation is proportional to the product of the area of the circuit, times the number of clock cycles. Real VLSI circuits are made of conducting material laid out essentially flat; thus, in our model, we say that the capacitance of a circuit is proportional to its area. A circuit works by, at every clock cycle, charging or discharging its wires. It is thus assumed that the energy of a computation is proportional to [formula] where [formula]. Thus, we can denote the energy of a computation as [formula] where [formula] is a constant that varies depending on the technology used to implement the circuit. For decoder circuits we often denote the energy of computation as [formula] where the subscript indicates the type of computation performed by the circuit under consideration.

Note that the restriction that each node has at most four inputs and four outputs is somewhat arbitrary; it is also arbitrary that each node is permitted to compute any function of its inputs all at the same cost. In real VLSI implementations it may be that an arrangement of transistors can compute some functions more efficiently than others. However, our model does not consider what gains could be made if certain functions are cheaper in an energy sense to compute. On the other hand, the model subsumes the interconnection complexity of the inputs of the function to their outputs. In the field of error control codes, this interconnection complexity has been shown to be a significant factor in the energy of a computation in, for example, [\cite=1023755] [\cite=groverOverDesigning].

Relationship Between Circuit Model and Graphs

This paper analytically characterizes a relationship between the energy of LDPC decoders as a function of block length and gap to capacity. To understand this we must first define what is meant by an LDPC decoder implemented according to the Thompson VLSI model. To understand this we must first understand the connection between a circuit and the graph corresponding to a circuit.

Note that a circuit is a collection of nodes connected by wires. Each of the computational nodes of a circuit can be thought of as the vertices of a graph, [formula]. The wires of a circuit correspond to the edges of a graph. In particular, two vertices v1 and v2 are connected in the graph G by an edge if and only if there is a wire connecting the two computational nodes that correspond to v1 and v2. Thus, any circuit can be considered a graph. As well, any graph can be implemented as a circuit (although of course there may be many ways to implement a particular graph on a circuit). Note that although a circuit, according to our model, must be planar, since we also allow wire crossings, any graph can be implemented, though it may be that more complex graphs require far more circuit area.

Note that saying that a circuit has a corresponding graph is a slight abuse of terminology: a graph, according to common definitions, does not allow for two edges between the same nodes, but obviously two computational nodes are permitted to have two or more wires connecting them. More precisely, we mean that a circuit has a corresponding multi-graph. However, for the sake of simplicity we simply call a circuit's corresponding multigraph a graph, and we hope that this does not cause confusion for the reader.

Sometimes in our discussion we may want to refer not to a particular node of the circuit (corresponding to the node of a graph), but rather to the nodes associated with a subcircuit, which leads to the following definition.

A subcircuit is a circuit corresponding to a subset of nodes of the graph and the wires connecting them. In particular, it is the circuit induced by deleting all wires not connecting the nodes of interest and by deleting all the other nodes in the graph. Any subcircuit has associated with it both internal wires (the wires connecting the nodes of this circuit) and also external wires, the wires leading from nodes within the subcircuit to nodes from outside the subcircuit. Note that the notion of a subcircuit corresponds to a particular subgraph of the graph of the circuit. In the language of graph theory [\cite=douglasb.west2001], we can say that a subcircuit with computational nodes corresponding to some subset of V'  ⊆  V corresponds to the subgraph induced by the vertices in V'. Note that any subset of the computational nodes of a graph induces a subcircuit and also a subgraph of the circuit's graph.

LDPC Decoders

An LDPC code is a linear code first invented by Gallager in [\cite=GallagerLDPC]. All linear codes can be specified by a parity check matrix. Central to the construction LDPC codes is the Tanner graph of the code corresponding to a parity check matrix of the code. A Tanner graph is a bipartite graph. Thus, such a graph has two partite sets, or sets of unconnected vertices which are referred to as the check nodes and the variable nodes. An [formula] LDPC code has associated with it a Tanner graph with n variable nodes and at least n - k check nodes (we say at least because it may be that some of the linear constraints induced by the check nodes are not linearly independent). The n variable nodes correspond to the n symbols of a block length n codeword in the LDPC code. A codeword [formula] is in the LDPC code generated by a Tanner graph if, for each check node in the Tanner graph of the code, the mod 2 sum of the values of the variable nodes to which they are connected is 0. The association of a set of linear constraints with a Tanner graph leads to natural and very efficient methods of decoding that exploit the sparse nature of the Tanner graph.

An LDPC decoding algorithm associated with a Tanner graph is a message-passing procedure. Each variable node is thought conceptually to be connected to their check nodes, and each check node correspondingly to their variable nodes. In general, a variable node has as its inputs a message passed to it from each of the check nodes to which it is connected, as well as the output of a noisy channel. A variable node, in general, is able to compute any function of these inputs and pass the outputs of this computation to its adjacent check nodes. The check nodes are similarly allowed to compute any function of their inputs (which will be in general the outputs of the variable nodes to which they are connected). An iteration of an LDPC decoder is one instance of this procedure: the variable nodes computing a function that is then passed to the check nodes, and then the check nodes computing a function of these messages and passing the output of these functions back to the variable nodes to which they are connected. A good LDPC decoding algorithm should choose these functions well, so that, at the end of a certain number of clock cycles τ, the variable nodes hold within them an estimate of the original input into a noisy channel. In the most general case, we allow the check and variable nodes to compute different functions of their inputs during different iterations (i.e., the function they compute in general may vary in time). Gallager discussed a variety of these message passing procedures in [\cite=GallagerLDPC].

To instantiate an LDPC decoding algorithm in a circuit, we consider two possible paradigms, a directly-implemented technique in which the Tanner graph of an LDPC code is directly instantiated in some sense by the circuit, and a complete-check node serialized technique, in which the Tanner graph is not necessarily directly implemented, but there are subcircuits in the graph corresponding to each check node and an LDPC message passing procedure is performed.

A directly-instantiated LDPC decoder can be thought of as a circuit that has a graph that is an implementation of a Tanner graph of the underlying LDPC code. To be precise, we will use terminology borrowed from graph theory regarding the subdivision of a graph.

Suppose a graph has an edge, e, connecting vertices v1 and v2. Then a subdivision of edge e in a graph is a process that takes the graph G and forms a new graph G' with an additional vertex v' and two additional edges connecting v1 and v2 to v' by replacing e with two edges. A subdivision of a graph G is a graph obtained by the successive subdivisions of edges in the graph.

If a graph G has a subgraph that is a subdivision of a graph G', then we say that the graph G contains graph G'. This leads to an important lemma that will allow us to connect bounds on graph properties of a Tanner graph to the area of directly-implemented LDPC decoders.

A directly-implemented LDPC decoder is a circuit associated with an LDPC code with a Tanner graph T. Consider the graph associated with the circuit. Then a circuit is a directly-implemented LDPC decoder if its graph contains T.

This means that a circuit is a directly-implemented LDPC decoder if there are subcircuits corresponding to each variable node and edges leading from these "black boxes" that connect to subcircuits that correspond to the check nodes of the Tanner graph.

Associated with any graph G is a quantity that we will call the minimum area of a circuit implementation of G, or, to be more concise, the area of G. The area of a graph G is the circuit with corresponding graph G with the minimum number of grid squares occupied. We denote this quantity as [formula].

If a graph G contains a graph G', then [formula].

This is a very intuitive idea. If a graph contains another graph, then naturally one would regard the original graph as "larger" in some sense then the graph that it contains. This notion will be used to connect a bound on the area of a circuit implementing the Tanner graph of an LDPC code to a bound on directly-implemented LDPC decoders.

There is a key result attributed to Thompson [\cite=Thompson] that relates a graph's minimum bisection width to the area of a circuit implementing that graph, presented in the following lemma.

If a graph has minimum bisection width ω, then the area of a circuit implementing this graph is lower bounded by

[formula]

Currently, our definition of a directly-implemented LDPC decoder subsumes many practical implementations of LDPC decoding algorithms, but in practice circuits can be implemented that perform an LDPC decoding algorithm and do not directly instantiate the Tanner graph of the code. This thus motivates the following definition of a more general type of LDPC decoder.

An [formula] complete-check-node LDPC decoder associated with Tanner graph T is a circuit with n separate subcircuits each corresponding to a variable node in T and one subcircuit corresponding to each check node in T. During one iteration a message must be passed from each variable-node subcircuit to each adjacent check-node subcircuit, and also from each check-node subcircuit to each adjacent variable-node subcircuit. To be precise, the check-node subcircuits that are adjacent to a variable-node subcircuit are those check-node subcircuits that correspond to check nodes in T that are adjacent to the variable node that corresponds to the variable-node subcircuit of interest. The variable-node subcircuits that are adjacent to a check-node subcircuit are defined similarly.

Note that for such a circuit we do not require that a wire exists in the circuit for each edge in the Tanner graph. Thus, it is possible that a complete-check-node LDPC decoder can use the same wire multiple times, but in different clock cycles to communicate information during an iteration.

Our results rely on the evaluation of some limits, which we present as lemmas below.

Suppose [formula] for some k > 0 and is positive for sufficiently large n, and there is a sequence [formula] that increases without bound. Then:

[formula]

For any two positive integers m and n in which

[formula]

for an integer Y > 0 where Y  ≤  Z and both m  ≤  Z and n  ≤  Z,

[formula]

Main Theorem

Our main theorem is fundamentally graph-theoretic in nature and applies to graphs generated according to a standard uniform random configuration model. We present this theorem in a general form and then specialize it to create an "almost sure" scaling rule for capacity-approaching LDPC codes.

Consider the set of bipartite graphs [formula] in which [formula], [formula], and with left node degree sequence [formula] and right node degree sequence [formula]. In other words, for a particular graph in this set, λi is the degree of vi∈VL, the ith left node in the graph, and ρi is the degree of ri∈VR, the ith right node in the graph. Without loss of generality, assume that the degree sequences are ordered, i.e. that [formula] and [formula], and also, without loss of generality, assume n  ≥  m. Denote this set [formula]. Note that the number of edges in each particular graph in [formula] is [formula].

For convenience of counting, we will consider not the set of graphs with a particular degree sequence, but rather the set of configurations with this degree sequence. We can associate each node in a graph with a number of sockets equal to its degree. Then, we can label each socket, so that, for example, the first node in the left side of the bipartite graph would have sockets labelled [formula], where the symbol Lij is used to denote the jth socket on the ith left node. Thus, the ith left node would have λi sockets labelled [formula]. Also, the right nodes would have sockets labelled Rij, where Rij denotes the jth socket on the ith right node. This node and socket configuration model is a standard way to consider the set of bipartite graphs that form the Tanner graphs of LDPC ensembles, and in particular is discussed in length in [\cite=Richardson:2008:MCT:1795974]. A multigraph together with a labelling of the sockets of each node is called a configuration. Any particular left and right degree sequences Λ and P have associated with them the set of all configurations with these node degree sequences, and this set is called the configuration space associated with the degree sequences. Clearly, a configuration is determined by a permutation mapping the [formula] left node sockets to the [formula] right node sockets. Note that there are [formula] configurations within the space of configurations with degree sequences Λ and P. Let the set of configurations with degree sequences Λ and P be denoted [formula]. Since a configuration is merely a graph with a labelling of sockets for each node, graph properties can be extended to describe configurations in the natural way, including minimum bisection width.

Define

[formula]

or in other words let Ba be the set of configurations in [formula] that have a bisection of size a. Note that Ba does not represent the set of configurations in [formula] with minimum bisection width a, but rather the set of graphs with any bisection of size a. Define B*a to be the set of all configurations in [formula] that have a bisection of size a or less, or in particular

[formula]

Define

[formula]

(a function of a particular left degree sequence) and let

[formula]

We define these quantities so that any subset of half the left nodes can have at most δn "sockets" leading from these nodes. Similarly, define

[formula]

and

[formula]

The quantities [formula] and [formula] are functions of the left degree distribution. As well, [formula] and [formula] are functions of the right degree distribution. For convenience, we may sometimes denote these quantities as δL, σL,δR and σR, and their dependence on the degree distributions is to be implicit. Thus, it is clear that the total number of edges in such a configuration is δLn + σLn = δRm + σRm. Define

[formula]

and define

[formula]

For notational convenience we will abbreviate these two quantities as δ and σ and their dependence on the node degree distribution under discussion is to be implicit. Note that [formula]. These quantities are defined so that in any subset of half the nodes [formula] of a configuration in [formula], the minimum of the number of left sockets and right sockets cannot exceed δn. This observation will be useful in deriving the bounds in this and will be made more formal in Lemma [\ref=lem:SubsetOfHalfNodesBound].

Consider a given set of nodes N  ⊆  V for a bipartite multigraph as defined above, with left degree sequences Λ and right degree sequences P. For a given subset of vertices N we can thus divide this set into two disjoint sets, NL and NR, where NL is the set of all those vertices in N that are left nodes, and NR all those vertices in N that are right nodes. Let [formula] and [formula] be the number of "sockets" attached to the left nodes in N and right nodes in N respectively.

For any bipartite multigraph [formula] with left degree sequences Λ and right degree sequences P, for any collection N of [formula] vertices, [formula].

We will use this lemma in a counting upper-bounding argument. Specifically, we will count the number of graph configurations that have a bisection of size a by dividing the vertices that form a graph into two equally-sized sets. The quantity [formula] will be important for our counting bounds.

If a configuration [formula] with degree sequences P and Λ is generated according to the uniform configuration model, then the probability that this configuration is in the set B*a and hence has a bisection of size a or less, when

[formula]

is upper bounded by

[formula]

This lemma can be used to prove our main theorem which shows that if a sequence of node-and-socket configurations is generated uniformly over all such configurations, and the quantities δ and σ (quantities that could in general change with each element of the sequence) scale according to a particular condition, then the probability that a configuration in this randomly generated sequence has a small bisection (proportional to n or less) approaches 0.

Our main theorem concerns sequences of random configurations. Specifically, we concern ourselves with a sequence of random configurations [formula] where each Gi in the sequence is a configuration generated according to the uniform configuration model, in which the ith configuration is drawn according to node degree distributions Λi and Pi. Note that the randomness for each element of such a sequence does not come from the degree distributions: we are assuming that these distributions are fixed. It is the interconnections between nodes that is random. We specifically concern ourselves with a sequence in which the number of left nodes n increases without bound. For such a sequence, denote the number of left nodes of the ith configuration as ni. We will abbreviate the quantities [formula] and [formula] with the symbols δi and σi respectively, where we recall their definitions in ([\ref=eq:deltaDefinition]) and ([\ref=eq:sigmaDefn]). When the dependence on i is clear, the subscript for these symbols may be omitted for convenience.

Suppose that there is a sequence of randomly generated bipartite configurations with a series of degree sequences in which in which the number of left nodes approaches infinity, and if

[formula]

then there exists some β > 0 in which

[formula]

and in particular, this occurs for any value of 0 < β  <  σ that satisfies:

[formula]

This theorem says that subject to some condition on the average edge degrees of the configurations, as these configurations get larger the probability that the configuration generated has a bisection proportional to n or less gets vanishingly small. We will use this result to show that for capacity-approaching LDPC degree distributions, the minimum bisection width must be large in some sense, implying that circuit implementations of these LDPC Tanner graphs must grow quickly as well, with high probability. The condition in ([\ref=eq:sufficientCondition]) recognizes that for a sequence of such graphs, the quantities δ and σ could change with increasing n. If the condition is satisfied (which we will see for capacity-approaching LDPC degree sequences it must) then with high probability the graphs do not have a "small" bisection.

As we are considering a sequence of configurations, we let ωi be the minimum bisection width of the ith configuration. This Theorem has an obvious corollary.

If there is a sequence of configurations as described in Theorem [\ref=thm:MainTheorem], in which the condition in ([\ref=eq:sufficientCondition]) is satisfied then [formula].

Application to a Specific Sequence of Random Configurations

Our result in Theorem [\ref=thm:MainTheorem] can be directly applied to the Tanner graphs of specific sequences of LDPC codes. For example, consider a regular LDPC ensemble with variable node degree 6 and check node degree 3. A randomly generated Tanner graph with this degree distribution would have [formula] and [formula]. In this case we can compute that the condition in ([\ref=eq:sufficientCondition]) evaluates to:

[formula]

which we see is less than 1. Thus, applying our theorem means that since the condition ([\ref=eq:sufficientCondition]) is satisfied, if random Tanner graphs are generated with this degree distribution, with probability approaching 1 the minimum bisection width of these graphs will be proportional to n.

Almost Sure Bounds on Capacity Approaching LDPC Circuits

We will use the result above to find an "almost sure" scaling rule for the energy of a capacity-approaching directly-implemented decoding scheme in which the Tanner graph of each decoder is generated according to a uniform configuration model with a set node degree distribution.

Consider a decoding scheme [formula] in which each of the decoders in the scheme are directly-implemented LDPC decoders, as in Definition [\ref=Definition:DirectlyImplementedLDPCDecoder]. We associate a scheme with a channel that the decoders are to decode. Let the capacity of that channel be C. Let the ith decoder have associated block length ni. Let the rate associated with the ith decoder be Ri. Let the gap to capacity associated with the ith decoder be [formula]. Let the area of the ith decoder be Ai, and the energy of the ith decoder be Ei. Let the minimum bisection width of the Tanner graph of the ith decoder be ωi. We consider a family of LDPC decoding schemes in which the Tanner graph of each decoder in the scheme is generated according to a uniform configuration model. Thus, we say that the Tanner graph of decoder i is generated uniformly from a family [formula] of configurations. We can thus discuss the probability of the ith decoder having certain properties. In particular, in the corollary below, we will analyze [formula], the probability that the ith decoder has a Tanner graph with minimum bisection width greater than βni, and show that this approaches 1, resulting in an almost sure energy scaling rule for capacity-approaching LDPC decoders. We let the event that the ith decoder has a bisection of size a or less to be B*i,a

For a family of capacity-approaching directly-implemented LDPC decoding schemes where the Tanner graph of each decoder is generated according to a uniform configuration model, [formula] for some constant c > 0. Similarly, [formula] for a constant c' > 0.

Applicability of this Result

There is a minor detail that needs to be dealt with for this theorem to be truly useful. Our results assume that a Tanner graph is directly implemented in wires. This is indeed a practical way to create a decoding circuit. However, according to our configuration model, it is possible that two or more edges can be drawn between the same two nodes. This type of conflict is usually dealt with by deleting even multi-edges and replacing odd multi-edges with a single edge (see definition 3.15, the Standard LDPC Ensemble in [\cite=Richardson:2008:MCT:1795974]). This leads to a potential problem with the applicability of our theorem: what happens if the edges that we delete form a minimum bisection of the induced graph? In that case it is possible that the graph we instantiate on the circuit has a lower minimum bisection width than that which we calculated, and thus could possibly have less area. However, this is resolved by the fact that in the limit as n approaches infinity for a standard LDPC ensemble, the graph is locally tree-like (Theorem 3.49 in [\cite=Richardson:2008:MCT:1795974]) with probability approaching 1. This implies that the probability that the number of multi-edges in a randomly generated configuration is some fraction of n must approach 0 (or else the graph would not be locally tree-like, contradicting the theorem). Hence, even if we did delete these multi-edges from the randomly generated configuration, this could at most decrease the minimum bisection width by the number of deletions, but this number of deletions, with probability 1, cannot grow linearly with n. Hence, the minimum bisection width must still, with probability 1, grow linearly with n, and our scaling rules are still applicable.

Energy Complexity of Capacity Approaching Complete-Check-Node LDPC Decoders

Below we will consider a sequence of capacity-approaching, complete-check-node serialized decoders. Recall that these decoders do not directly instantiate their Tanner graph in wires, but they do have subcircuits corresponding to each check and variable node. In each iteration, possibly over several clock cycles, messages are to be passed from each variable node subcircuit to their corresponding check node subcircuit and similarly for the check node subcircuits passing messages to their corresponding variable node subcircuits. It may be that the same wire is used to transmit different messages during different clock cycles of the same iteration of the computation. It is thus possible that such a method can decrease wiring area (by not requiring a wire for each edge of the Tanner graph) at the cost of more clock cycles. We prove below that such a method still results in a super-linear almost sure lower bound on energy complexity. So there is no ambiguity, a sequence of decoders for a channel with capacity C with rates [formula] is capacity-approaching if lim i  →    ∞Ri = C.

For a sequence of capacity-approaching, complete-check-node serialized LDPC decoders whose Tanner graphs are generated according to the uniform configuration model, [formula] for some c > 0. Also, [formula] and [formula].

Limitations of Result

A goal of this research is to find fundamental bounds on the "energy complexity" of capacity-approaching decoders as a function of [formula]. The result presented here does not quite do this, but it does advise engineering by suggesting that if n is very large, one can be reasonably sure that the area of a circuit that instantiates a randomly generated Tanner graph will have area that scales as [formula]. Of course, we have assumed that this Tanner graph has been generated by going to each socket of the left nodes and randomly finding a connection to a remaining right socket. This is of course a very natural way to generate Tanner graph, and is in fact used in the analysis of LDPC codes [\cite=Richardson:2008:MCT:1795974].

This is not to say, of course, that there don't exist good LDPC coding schemes with slower scaling laws. Creating a sequence of LDPC codes that avoids this scaling law with probability greater than 0 would be possible if the random generation rule for the LDPC graph was somehow altered. For example, perhaps the variable nodes and check nodes could be placed uniformly scattered through a grid and then the randomly placed edges, instead of being chosen uniformly over all possible edges, are chosen uniformly over a choice of edges connecting variable and check nodes that are "close" to each other.

In practice, a Tanner graph is often modified to prevent interconnections that are "too far" between check and variable nodes that result in long wire length and thus higher energy [\cite=RothEtAl]. Simulation in a particular case can analyze whether this technique is worth the possible code performance trade-off. Currently, however, the common technique of generating an LDPC ensemble and analyzing average code performance does not consider energy complexity as a fundamental parameter to be traded-off with other code parameters. It seems likely that if "neighbors" of a variable node are restricted to those check nodes that are spatially close by, an LDPC code could still have good asymptotic performance if block lengths grow large. An analysis challenge of such a scheme may be to show that asymptotically a Tanner graph generated from such a distribution is locally tree-like. Furthermore, analysis of the required block length using such a technique to get good performance would be needed: even if asymptotically such schemes perform well, it may be that much longer block lengths are required for the same performance. The cost of possibly larger block length for such a scheme would have to be considered to determine whether it is worth it to have a slower scaling rule as a function of block length if it comes at a cost of much longer block length.

Whether or not such a sequence of LDPC codes would give good performance is unclear. However, in the following section we can use known bounds on the average node degree of an LDPC decoder as well as bounds on the area of graphs instantiated on a circuit to get scaling rules that are true for all directly-implemented capacity-approaching LDPC decoders, not just almost all.

Bounds for All LDPC Decoder Circuits

We can find bounds for the energy complexity for all capacity-approaching directly-implemented LDPC codes (and not just almost all) by using the following Theorem:

If a circuit contains a graph [formula] that has no loops, according to the standard VLSI model, the total area of a circuit that contains that graph is bounded as:

[formula]

where we recall that [formula] is the wire width in the circuit, and [formula] and [formula] are the number of edges and vertices in the graph, respectively.

The proof of this theorem uses a similar approach as used by Grover et al. in [\cite=groverFundamental], in which the [formula] complexity of circuits is related to the bits communicated within the circuit. The result of this paper, however, is a bound on the area of a circuit instantiation of a graph as a function of the number of edges and vertices in the graph. We use a similar nested bisection technique as the Grover et al. paper. The proof is given in the appendix.

This result, combined with the results in [\cite=Sason] on the average edge degree as a function of gap to capacity, results in the following corollary:

The energy of any directly-instantiated LDPC decoder must have asymptotic energy that is lower bounded by:

[formula]

and average energy per bit decoded that scales as

[formula]

where N is the number of iterations required to decode.

Note that the number of iterations N in the above Corollary in general may be a function of the particular decoding algorithm instantiated and possibly the particular received vector. Our discussion does not analyze the number of iterations required, so we simply write our scaling rules in terms of this quantity.

We note that this lower bound on directly-implemented Tanner graphs contrasts with the lower bounds in [\cite=BlakeKschischangFundamentalLowerBoundArxiv], which show an [formula] lower bound for the per bit energy complexity of fully-parallel decoding algorithms as a function of gap to capacity. This result means that directly-instantiated LDPC decoders are necessarily asymptotically worse than this lower bound (albeit a lot closer than the [formula] almost sure lower bound of Corollary [\ref=cor:LDPCDirectlyScalingRule]). Of course, it is not known whether the lower bounds of the paper in [\cite=BlakeKschischangFundamentalLowerBoundArxiv] are tight, but Corollary [\ref=cor:LDPCSureBound] proves that directly instantiated LDPC decoders cannot reach these lower bounds in an asymptotic sense.

Conclusion

The main contribution of this paper is graph theoretic in nature. We have shown that subject to a mild condition on node degree distributions, almost all Tanner graph instantiations have a minimum bisection width that scales as [formula] where n is the number of left nodes. The minimum bisection width of a graph is related to the area of circuit implementations of these graphs. We have used this result to show that almost all LDPC decoders that directly instantiate their Tanner graph must have circuit area, and thus energy, that scales as [formula]. We can use this result to provide a scaling rule for the energy complexity of almost all capacity-approaching LDPC decoders. We have further presented a general theorem on the area of circuits that instantiate any graph to further bound the area of any LDPC decoder that approaches capacity. These results are summarized in Table [\ref=tab:SummaryOfResults]. Note that our results show that directly-instantiated LDPC codes cannot reach the lower bounds presented in [\cite=BlakeKschischangFundamentalLowerBoundArxiv], thus indicated that either the lower bound cited is not tight, or directly-instantiated LDPC codes asymptotically not optimal from this energy perspective. It may also be that both are true, namely that known lower bounds are not tight and LDPC codes are not asymptotically optimal. This remains an open question.

Proof Of Lemma [\ref=lem:LemmaLabel]

Proof of Theorem [\ref=thm:CircuitEdgeNodeBound]

In this section we will prove Theorem [\ref=thm:CircuitEdgeNodeBound], which states that if a circuit implements a graph [formula] that has no loops, according to the standard VLSI model, the total area of that circuit is bounded by:

[formula]

where [formula] is the wire width in the circuit, and [formula] and [formula] are the number of edges and vertices in the graph, respectively.