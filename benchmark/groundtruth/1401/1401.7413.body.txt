Smoothed Low Rank and Sparse Matrix Recovery by Iteratively Reweighted Least Squares Minimization

Introduction

n recent years, the low rank and sparse matrix learning problems have been hot research topics and lead to broad applications in computer vision and machine learning, such as face recognition [\cite=SRC], collaborative filtering [\cite=weimer2007cofirank], background modeling [\cite=RPCA], and subspace segmentation [\cite=lu2013correlation] [\cite=LRR]. The [formula]-norm and nuclear norm are popular choices for sparse and low rank matrix minimizations with theoretical guarantees and competitive performance in practice. The models can be formulated as a joint low rank and sparse matrix minimization problem as follow:

[formula]

where [formula] and i can be either vectors or matrices, Fi is a convex function (the Frobenius norm [formula]; nuclear norm [formula], the sum of all singular values of a matrix; [formula]-norm [formula]; and [formula]-norm [formula], the sum of the [formula]-norm of each column of a matrix) and [formula] is a linear mapping. In this work, we further consider the nonconvex Schatten-p norm [formula], [formula]-norm [formula] and [formula]-norm [formula] with 0 < p < 1 for pursuing lower rank or sparser solutions.

Problem ([\ref=Eq_general]) is general which involves a wide range of problems, such as Lasso [\cite=lasso], group Lasso [\cite=yuan2006model], trace Lasso [\cite=lu2013correlation], matrix completion [\cite=candes2010matrix], Robust Principle Component Analysis (RPCA) [\cite=RPCA] and Low-Rank Representation (LRR) [\cite=LRR]. In this work, we aim to propose a general solver for ([\ref=Eq_general]). For the ease of discussion, we focus on the following two representative problems,

[formula]

[formula]

where [formula] is a given data matrix, Z and E are with compatible dimensions and λ > 0 is the model parameter. Notice that these problems can be reformulated as unconstrained problems (by representing E by Z) as that in problem ([formula]).

Related Works

The sparse and low rank minimization problems can be solved by various methods, such as Semi-Definite Programming (SDP) [\cite=jaggi2010simple], Accelerated Proximal Gradient (APG) [\cite=APG], and Alternating Direction Method (ADM) [\cite=ALMlin]. However, SDP has a complexity of O(n6) for an n  ×  n sized matrix, which is unbearable for large scale applications. APG requires that at least one term of the objective function has Lipschitz continuous gradient. Such an assumption is violated in many problems, e.g., problem ([\ref=Eq_RPCA]) and ([\ref=Eq_LRR]). Compared with SDP and APG, ADM is the most widely used one. But it usually requires introducing several auxiliary variables corresponding to non-smooth terms. The auxiliary variables may slow down the convergence, or even lead to divergence when there are too many variables. Linearized ADM (LADM) [\cite=LADMAP] may reduce the number of auxiliary variables, but suffer the same convergence issue. The work [\cite=LADMAP] proposes an accelerated LADM with Adaptive Penalty (LADMAP) with lower per-iteration cost. However, the accelerating trick is special for the LRR problem. And thus are not general for other problems. Another drawback for many low rank minimization solvers is that they have to perform the soft singular value thresholding:

[formula]

as a subproblem. Solving ([\ref=Eq_svt]) requires computing the partial SVD of Y. If the rank of the solution is not sufficiently low, computing the partial SVD of Y is not faster than computing the full SVD of Y [\cite=ALMlin].

In this work, we aim to solve the general problem ([\ref=Eq_general]) without introducing auxiliary variables and also without computing SVD. The key idea is to smooth the objective function by introducing regularization terms. Then we propose the Iteratively Reweighted Least Squares (IRLS) method for solving the relaxed smooth problem by alternately updating a variable and its weight. Actually, the reweighting methods have been studied for the [formula] ([formula]) minimization problem [\cite=lu2014proximal] [\cite=chartrand2008iteratively] [\cite=candes2008enhancing]. Several variants have been proposed with much theoretical analysis [\cite=foucart2009sparsest] [\cite=zhaoreweighted]. Usually, IRLS converges exponentially fast (linear convergence) [\cite=IRLSconvergencerate], and numerical results have indicated that it leads to a sparse solution with better recovery performance. The reweighting method has also been applied for low rank minimization recently [\cite=lu2014generalized] [\cite=lu2015generalized] [\cite=IRLSrank]. However, the problems that can be solved by iteratively reweighted algorithm are still very limited. Previous works are only able to minimize the single [formula]-norm only or nuclear norm only with squared loss or an affine constraint. Thus they cannot solve ([\ref=Eq_general]) whose objective function contains two or more non-smooth terms, such as robust matrix completion [\cite=hsu2011robust] and RPCA [\cite=RPCA]. Also, previous convergence proofs, based on the special properties of [formula]-norm and Schatten-p norm, are not general, and thus limit the application of IRLS. Actually, many other different nonconvex surrogate functions of [formula]-norm have been proposed, e.g. the logarithm fcuntion [\cite=candes2008enhancing]. We will generalize IRLS for solving problem ([\ref=Eq_general]) with more general objective functions.

Contributions

In summary, the contributions of this paper are as follows.

For solving problem ([\ref=Eq_general]) with the objective function as the low rank and sparse matrix minimization, we first introduce regularization terms to smooth the objective function, and solve the relaxed problem by the Iteratively Reweighted Least Squares (IRLS) method. This is actually one of the future works mentioned in [\cite=IRLSrank].

We take the Schatten-p norm and [formula]-norm regularized LRR problem as a concrete example to introduce the IRLS algorithm and theoretically prove that the obtained solution by IRLS is a stationary point. It is globally optimal when [formula]. Based on our general proof, we further show some other problems which can also be solved by IRLS.

Numerical experiments demonstrate the effectiveness of the proposed IRLS algorithm by comparing with the state-of-the-art ADM family algorithms. IRLS is much more efficient since it avoids SVD completely.

Smoothed Low Rank Representation

In this section, to illustrate the smoothed low rank and sparse matrix recovery by Iteratively Reweighted Least Squares (IRLS), we take the LRR problem as a concrete example. The reason of choosing this model as an application is twofold. First, LRR is a low rank and (column) sparse minimization problem, so solving LRR is more difficult than solving RPCA by the ADM family algorithms. It is easy to extend IRLS for other low rank plus sparse matrix recovery problems based on this example. Second, LRR has become an important model with various applications in machine learning and computer vision. A fast solver is important for real applications.

The LRR problem ([\ref=Eq_LRR]) can be reformulated as follows without the auxiliary variable E:

[formula]

where [formula] denotes the Schatten-p norm of M, [formula] denotes the [formula]-norm of M. Our solver can handle the case 0 < p,q < 2. Problem ([\ref=Eq_LRR]) is a special case of ([\ref=Eq_LRR2]) when p = q = 1. The major challenge for solving ([\ref=Eq_LRR2]) is that both two terms of the objective function are non-smooth. A simple way is to smooth both two terms by introducing regularization terms:

[formula]

where μ > 0, [formula] is the identity matrix and [formula] is the all ones vector. The terms μI and [formula] make the objective function smooth (see ([\ref=Eq_SmoothLRR2])). The above model is called Smoothed LRR in this work. Solving the Smoothed LRR problem instead of LRR brings several advantages.

First, J(Z,μ) is smooth when μ > 0. This is the major difference between LRR and Smoothed LRR. Usually, a smooth objective function makes the optimization problem easier to solve.

Second, if [formula], J(Z) is convex, and so is J(Z,μ). This guarantees a globally optimal solution to ([\ref=Eq_SmoothLRR1]).

The above theorem can be easily proved by using the convexity of Schatten-p norm and [formula]-norm when [formula].

Third, J(Z,μ)  ≥  J(Z), where the equality holds if and only if μ = 0. Indeed, where λi(M) denotes the i-th (ordered) eigenvalue of a matrix M. That is to say, J(Z) is majorized by J(Z,μ) with a given μ. Decreasing J(Z,μ) tends to decrease J(Z).

Furthermore, for any given ε > 0, there exists μ > 0, such that J(Z,μ)  ≤  J(Z) + ε. Suppose Z*o and Z* are the optimal solutions to ([\ref=Eq_LRR2]) and ([\ref=Eq_SmoothLRR1]), respectively. Then we have We say that the solution Z* to ([\ref=Eq_SmoothLRR1]) is ε-optimal to ([\ref=Eq_LRR2]).

IRLS Algorithm

In this section, we show how to solve ([\ref=Eq_SmoothLRR1]) by IRLS. By the fact that [formula], ([\ref=Eq_SmoothLRR1]) can be reformulated as follows:

[formula]

where (M)i or Mi denotes the i-th column of matrix M. Let [formula] and [formula]. Then J(Z,μ) = L(Z) + λS(Z).

The derivative of L(Z) is where [formula] is the weight matrix corresponding to L(Z). Note that M can be computed without SVD [\cite=higham2008functions].

For the derivative of S(Z), consider the column-wise differentiation for each [formula], That is to say, [formula], where N is the weight matrix corresponding to S(Z). It is a diagonal matrix with the i-th diagonal entry being [formula].

By setting the derivative of J(Z,μ) with respect to Z to zero, we have or equivalently,

[formula]

Eqn ([\ref=Eq_lyap]) is the well known Sylvester equation, which cost O(n3) for a general solver. But if XTX has certain structure, the costs may likely be O(n2) [\cite=benner2009adi]. We use the Matlab command to solve ([\ref=Eq_lyap]) in this work.

Notice that both M and N depend only on Z. They can be computed if Z is fixed. If the weight matrices M and N are fixed, Z can be obtained by solving ([\ref=Eq_lyap]). This fact motivates us to solve ([\ref=Eq_SmoothLRR2]) by iteratively updating Z and {M,N}. This optimization method is called Iteratively Reweighted Least Squares (IRLS), which is shown in Algorithm [\ref=Alg_IRLS]. IRLS separately treats the weight matrices M and N, which correspond to the low rank and sparse terms, respectively.

It is easy to see the per-iteration complexity of IRLS for the smoothed LRR problem ([\ref=Eq_SmoothLRR1]) is O(n3). Such cost is the same as APG, ADM, LADM, and LADMAP. APG solves an approximated unconstraint problem of LRR. Thus its solution is not optimal to (5) or (6) [\cite=LADMAP]. The traditional ADM does not guarantee to converge for LRR with three variables. Both LADM and LADMAP lead to the optimal solution of LRR. But their convergence rates are sublinear, i.e., O(1 / K), where K is the number of iterations. Usually, IRLS converges much faster than the ADM type methods and it avoids computing SVD in each iteration. Though the convergence rate of IRLS is not established, our experiments show that it tends to converge linearly. The state-of-the-art method, accelerated LADMAP [\cite=LADMAP], costs only O(n2r), where r is the predicted rank of Z. It may be faster than our IRLS when the rank of Z is sufficiently low. However, the rank of Z depends on the choice of the parameter λ, which is usually tuned to achieve good performance of the application. As observed in the experiments shown later, IRLS outperforms the accelerated LADMAP on several real applications.

It is worth mentioning that though we present IRLS for LRR, it can also be used for many other problems, including the structured Lassos (e.g., group Lasso [\cite=yuan2006model], overlapping/non-overlapping group Lasso [\cite=jacob2009group], and tree structured group Lasso [\cite=kim2010tree]), robust matrix completion [\cite=hsu2011robust] and RPCA [\cite=RPCA]. Though it is difficult to give a general IRLS algorithm for all these problems. The main idea is quite similar. The first step is to smooth the objective function like that in ([\ref=Eq_SmoothLRR1]). Table [\ref=tab_norms] shows the smoothed versions of some popular norms. Other related norms, e.g., overlapping group Lasso, can be smoothed in a similar way. Then we are able to compute the derivatives of the smooth functions. The derivatives can be rewritten as a simple function of the main variable Z or z by introducing an auxiliary variable, i.e., the weight matrix W as shown in Table [\ref=tab_norms]. This will make the updating of the main variable much easier. Iteratively updating the main variable Z and the weight matrix W leads to the IRLS algorithm which guarantees to converge. More generally, one may use other concave function, e.g., the logarithm function [\cite=candes2008enhancing], to replance the [formula]-norm in Talbe [\ref=tab_norms]. The induced problems can be also solved by IRLS.

Algorithmic Analysis

Previous iteratively reweighted algorithm minimizes the sum of a non-smooth term and squared loss, while we minimize the sum of two (or more) non-smooth terms. In this section, we provide a new convergence analysis of IRLS for non-smooth optimization. Though based on Algorithm [\ref=Alg_IRLS] for solving LRR problem, our proofs are general. We first show some lemmas and prove the convergence of IRLS.

Our proofs are based on a key fact that xp is concave on (0,  ∞  ) when 0 < p < 1. By the definition of concave function, we have

[formula]

The following proofs are also applicable to other concave functions, e.g., log (x), which is an approximation of the [formula]-norm of x.

Assume each column of [formula] and [formula] is nonzero. Let gi(x), [formula], be concave and differentiable functions. We have

[formula]

where [formula] is a diagonal matrix, with its i-th diagonal element being [formula].

By letting [formula], 0 < q < 2, as a special case in ([\ref=eq_inlem1]), we get

[formula]

where [formula].

[formula] is concave on Sn+  + (the set of symmetric positive definite matrices) when 0 < p < 1.

Assume that h(X) is concave and differentiable on Sn+  +. For any X,Y∈Sn+  +, we have

[formula]

By letting [formula] with 0 < p < 2 in ([\ref=eq_concaveh]), we get

[formula]

Based on the above results, we have the following convergence results of the IRLS algorithm.

Though for the convenience of description, we fixed μ > 0 in Algorithm [\ref=Alg_IRLS] and the convergence analysis. In the implementation, we decrease the value of μ in each iteration, e.g., μt + 1  =  μt  /  ρ with ρ > 1. The intuition is that it shall make the Smoothed LRR problem ([\ref=Eq_SmoothLRR1]) close to the LRR problem ([\ref=Eq_LRR2]). It is easy to check that our proofs also hold when μt  →  μ* > 0.

It is worth mentioning that our IRLS algorithm and convergence proofs are much more general than that in [\cite=IRLSconvergencerate] [\cite=IRLSrank] [\cite=laiimproved], and such extensions are nontrivial. The problems in [\cite=IRLSconvergencerate] and [\cite=IRLSrank] are sparse or low rank minimization problems with affine constraints. The work in [\cite=laiimproved] considers the unconstrained sparse or low rank minimization problems with squared loss. Our work considers an unconstrained joint low rank an sparse minimization problem. We need to update a variable and two (can be more) weight variables, while previous IRLS methods update only one variable and one weight. Note that it is usually easy to prove the convergence with two updating variables, but difficult with more than two updating variables. Also, the proofs are totally different. In [\cite=IRLSconvergencerate] [\cite=IRLSrank], due to the affine constraints (i.e. y = Ax), the optimal solution can be written as x* = x0 + z, where x0 is a feasible solution and z lies in the kernel of A. This key property is critical for their proofs but cannot be used in our proof, and we do not rely on it. The least square loss function plays an important role in the convergence proof in [\cite=laiimproved] (easy to see this from equations (2.12) and (2.13) in [\cite=laiimproved]). Our proof has to handle at least two non-smooth terms (and without smooth squared loss function) simultaneously. Also previous IRLS methods use a special property of xp (0 < p < 1) based on Young's inequality, while we use the concavity of xp (see ([\ref=eq_inlem1]) and Lemma [\ref=Lem_ineq1], [\ref=Lem_ineq2]), which involves more general functions. Thus, IRLS can be also used if xp is replaced with other concave functions, e.g., log (x).

Experiments

In this section, we conduct numerical experiments on both synthetic and real data to demonstrate the efficiency of the proposed IRLS algorithm. We use IRLS to solve LRR and Inductive Robust Principle Component (IRPCA) [\cite=bao2012inductive] problems. To compare with previous convex solvers for LRR, we set p = q = 1 in ([\ref=Eq_LRR2]). We first examine the behaviour of IRLS and its sensitivity to the regularization parameter μ, and then compare the performance of IRLS with state-of-the-art methods.

Selection of Regularization Parameter μ

IRLS converges fast and leads to an accurate solution when the regularization parameter μ is chosen appropriately. We decrease μ by μt + 1  =  μt  /  ρ with ρ > 1. μ0 is initialized as μ0  =  μc||X||2, where ||X||2 is the spectral norm of X. Thus the choice of μ depends on μc and ρ. We conduct two experiments to examine the sensitivity of IRLS to μc and ρ, respectively. The first one is to fix ρ = 1.1 and examine different values of μc. The second one is to fix μc = 0.1 and examine different values of ρ. The experiments are performed on a synthetic data set.

The synthetic data is generated by the same procedure as that in [\cite=LRR] [\cite=LADMAP]. We generate k = 15 independent subspaces {Si}ki = 1 whose bases {Ui}ki = 1 are computed by Ui + 1 = TUi, 1  ≤  i  ≤  k, where T is a random rotation matrix and [formula] is a random orthogonal matrix. So each subspace has a rank of r = 5 and the data dimension is d = 200. We sample ni = 20 data vectors from each subspace by Xi = UiQi, 1  ≤  i  ≤  k, with Qi being an r  ×  ni i.i.d N(0,1) matrix. We randomly chose 20% samples to be corrupted by adding Gaussian noise with zero mean and standard deviation 0.1||x||2.

Figures [\ref=fig_conv_curve_parameters] (a) and (b) show the convergence curves of IRLS with different values of μc and ρ. It is observed that a small value of μc will lead to an inaccurate solution in a few iterations. But a large value of μc will delay the convergence. Similar phenomenon can be found in the choice of ρ. A large value of ρ will lead to fast convergence, while a small value of ρ will lead to a more accurate solution. For an accurate solution, μ should not converge to 0 too fast. Thus μc cannot be too small and ρ should not be too large. We observe that μc = 0.1 and ρ = 1.1 work well.

LRR for Subspace Segmentation

In this section, we present numerical results of IRLS and the other state-of-the-art algorithms, including APG, ADM, LADM [\cite=LADM], LADMAP and accelerated LADMAP [\cite=LADMAP] (denoted as LADMAP(A)) to solve the LRR problem for subspace segmentation. All the ADM type methods use PROPACK [\cite=larsen1998lanczos] for fast SVD computing. We implement IRLS algorithm by Matlab without using third party package. For LADMAP(A), we set the maximum iteration number as 10000 (the default value is 1000). This is because LADMAP(A) is usually fast but not able to converge within 1000 iterations in some cases. Except this, we use the default parameters of all the competed methods in the released codes from Lin's homepage. For IRLS, we set μ0  =  μc||X||2 = 0.1||X||2, μt + 1  =  μt  /  ρ and ρ = 1.1. All experiments are run on a PC with an Intel Core 2 Quad CPU Q9550 at 2.83GH and 8GB memory, running Windows 7 and Matlab version 8.0.

Synthetic Data Example

We use the same synthetic data as that in Section [\ref=sec_expregu]. We emphasize on the performance with different LRR model parameter λ. Usually a larger λ leads to lower rank solution. This experiment is to test the sensitiveness of the competed methods to different ranks of the solution. Figure [\ref=fig_conv_curve_parameters] shows the convergence curves corresponding to λ = 0.1,0.5 and 1, respectively (only the results within 1000 iterations are plotted). Table [\ref=Tab_Toydata] shows the detailed results, including the achieved minimum at the last iteration, the computing time and the number of iterations. It can be seen that IRLS is always faster than APG, ADM and LADM. IRLS also outperforms LADMAP and LADMAP(A) except when λ = 0.1. We find that the linearized ADM methods need more iterations to converge when λ increases. That is because when λ is not small enough, the rank of the solution will be not small. In this case, partial SVD may not be faster than the full SVD [\cite=ALMlin]. Hence using PROPACK may be unstable. Compared with LADMAP(A), IRLS is a better choice for the small-sized or high-rank problems because it completely avoids SVD.

Face Clustering

We test the performance of all the competed methods for face clustering on the Extended Yale B database [\cite=YaleBdatabase]. Some example face images are shown in Figure [\ref=fig_example_faces]. There are 38 subjects in this database. We conduct two experiments by using the first 5 and 10 subjects of face images to form the data X [\cite=lu2012robust]. Each subject has 64 face images. These images are resized into [formula] and projected onto a 30-dimensional subspace by PCA for 5 subjects clustering problem and a 60-dimensional subspace for 10 subjects clustering problem. The affinity matrix is defined as (|Z*| + |(Z*)T|) / 2, where Z* is the solution to the LRR problem obtained by different solvers. Then the Normalized Cut [\cite=NormaCut] is used to produce the clustering results based on the affinity matrix. The LRR model parameter is set to λ = 1.5 which leads to the best clustering accuracy.

Figure [\ref=fig_conv_curve_YaleB5_10] and Table [\ref=Tab_YaleB] show the performance comparison of all these methods. It can be seen that IRLS is the fastest and the most accurate method. ADM also works well but needs more iterations. The linearized methods are not efficient since they do not converge within 1000 iterations.

Motion Segmentation

We also test all the competed methods for motion segmentation on the Hopkins 155 database. This database has 156 sequences, each of which has 39 to 550 data points drawn from two or three motions. In each sequence, the data are first projected onto a 12-dimensional subspace by PCA. LRR is performed on the projected subspace, the best LRR model parameter is set to λ = 2.4. Table [\ref=Tab_hop] tabulates the comparison of all these methods. It can be seen that IRLS is the fastest method. LADMAP(A) is competitive with IRLS but it requires much more iterations.

Inductive Robust Principal Component Analysis

Inductive Robust Principal Component Analysis (IRPCA) [\cite=bao2012inductive] aims at finding a robust projection to remove the possible corruptions in data. It is done by solving the following nuclear norm regularized minimization problem

[formula]

Here we use the [formula]-norm ||E||1,2, sum of the [formula]-norm of each row of E instead of [formula]-norm in [\cite=bao2012inductive] to handle the data with row corruptions (caused by continuous shadow, e.g., face with glass or scarf).

The [formula]-norm can be smoothed as [formula], where Ei denotes the i-th row of E. Thus IRLS solves ([\ref=eq_irpca]) by iteratively solving where [formula] and Nt is a diagonal matrix with [formula]. We test our IRLS by comparing with ADM in [\cite=bao2012inductive] and LADMAP(A) [\cite=LADMAP] for face recognition. After the projection P is learned by solving ([\ref=eq_irpca]) from the training data, we can use it to remove corruption from a new coming test data point. We perform experiments on two face data sets. The first one is the Extended Yale B, which consists of 38 subjects with 64 images in each subject. We randomly select 30 images for training and the rest for test. The other one is the CMU PIE face dataset [\cite=sim2003cmu], which contains more than 40,000 facial images of 68 people. The images were acquired across different poses. We use the one near frontal pose C07, which includes 1629 images. All the images are resized to 32  ×  32. For each subject, we randomly select 10 images for training, and the rest for test. The support vector machine (SVM) is used to perform classification. The recognition results are shown in Figure [\ref=fig_fr_accuracy_time]. It can be seen that the recognition accuracies are almost the same by different solvers. But the running time of ADM and LAMDAP(A) is much larger than our IRLS algorithm. Figure [\ref=fig_face_recovery] plots some test images recovered by IRPCA obtained by our IRLS algorithm. It can be seen that IRPCA by IRLS successfully removes the shadow and corruptions from faces.

Conclusions and Future Work

Different from previous Iteratively Reweighted Least Squares (IRLS) algorithm which simply solved a single sparse or low rank minimization problem. We proposed a more general IRLS to solve the joint low rank and sparse matrix minimization problems. The objective function is first smoothed by introducing regularization terms. Then IRLS is applied for solving the relaxed problem. We provide a general proof to show that the solution by IRLS is a stationary point (globally optimal if the problem is convex). IRLS can also be applied to various optimization problems with the same convergence guarantee. An interesting future work is to use IRLS for solving nonconvex structured Lasso problems (e.g., [formula]-norm regularized group Lasso, overlapping/non-overlapping group Lasso [\cite=jacob2009group], and tree structured group Lasso [\cite=kim2010tree]).

Appendix

Proof of Lemma [\ref=Lem_ineq1]

Proof. By the definition of concave function, we have [formula]

[\cite=laiimproved] Given X,Y∈Sn+  +. Let [formula] and [formula] be ordered eigenvalues of X and Y, respectively. Then [formula].

Proof of Lemma [\ref=Lem_ineq2]

Proof. By using Lemma [\ref=Lem_eng], for any X,Y∈Sn+  +, we have Then we deduce

[formula]

The last inequality uses the concavity of xp with 0 < p < 1 on (0,  ∞  ) in ([\ref=eq_conca]). Thus [formula] is concave from ([\ref=eq_prooflm2]). [formula]

Proof of Theorem [\ref=theo_pro]

Proof. We denote Et = XZt - X. Since Zt + 1 solves ([\ref=Eq_upZ]), we have

[formula]

A dot product with Zt - Zt + 1 on both side of ([\ref=eq_proof00]) gives This together with ([\ref=eq_lem2r]) gives

[formula]

By using ([\ref=eq_inlem11]), we have

[formula]

Now, combining ([\ref=eq_proof111]) and ([\ref=eq_proof222]) gives

[formula]

The above equation implies that J(Zt,μ) is non-increasing. Then we have

[formula]

Thus the sequence {Zt} is bounded. Furthermore, ([\ref=eq_proofeng]) implies that the minimum eigenvalues of Mt and Nt satisfy By using Lemma [\ref=Lem_eng], ([\ref=Eq_lempr]) implies that Summing all the above inequalities for all [formula], we get

[formula]

In particular, ([\ref=Eqn_tempppp]) implies that [formula]. The proof is completed. [formula]

Proof of Theorem [\ref=theo_con]

Proof. If [formula], problem ([\ref=Eq_SmoothLRR1]) is convex. The stationary point is globally optimal. Thus we only need to prove that Zt converges to a stationary point of problem ([\ref=Eq_SmoothLRR1]).

The sequence {Zt} is bounded by Theorem [\ref=theo_pro], hence there exists a matrix Ẑ and a subsequence {Ztj}, such that [formula]. Note that Ztj + 1 solves ([\ref=Eq_upZ]), i.e.,

[formula]

Let j  →    ∞  , ([\ref=Eq_firstorder]) implies that Ztj + 1 also converges to some [formula]. From the fact that [formula] in Theorem [\ref=theo_pro], we have That is to say Ẑ  =  . Denote Ẑ as Z*, and let j  →    ∞  , ([\ref=Eq_firstorder]) can be rewritten as where M* and N* are defined in ([\ref=Eq_upMM])([\ref=Eq_upNN]) with Z* in place of Zt + 1. Therefore, Z* satisfies the first-order optimality condition of problem ([\ref=Eq_SmoothLRR1]). [formula]