50pt 5pt

An Experimental Evaluation of List Coloring Algorithms

Andrew Ju and Patrick Healy

Department of Computer Science, University of Limerick, Limerick, IRELAND a.ju@acm.org

Abstract

The list coloring problem is a variant of vertex coloring where a vertex may be colored only a color from a prescribed set. Several applications of vertex coloring are more appropriately modelled as instances of list coloring and thus we argue that it is an important problem to consider. In spite of its importance few published algorithms exist for list coloring, however. In this paper we review the only two existing ones we could find and propose a branch-and-bound based one. We conduct an experimental evaluation of those algorithms.

Introduction

In the classical vertex coloring problem one asks if one may color the vertices of a graph G  =  (V,E) with one of k colors so that no two adjacent vertices are similarly colored; the corresponding optimization problem seeks to find the minimum value k for a graph that admits a legal k coloring. In 1976 Vizing [\cite=vizing-76:list-col] proposed an additional restriction on the coloring by supplying for each vertex a list of permissible colors (in this paper we refer it as the color availability list).

Many problems that rely on vertex coloring might be modelled more appropriately using list coloring. For example, exam timetabling is frequently modelled as a vertex coloring problem where graph edges represent subjects that may not be scheduled simultaneously. Other constraints, such as preference for the times an exam may be scheduled, are often considered to be soft constraints [\cite=QuBur2009]. By supplying a list of (in)appropriate hours for each exam one may model the problem more accurately as an instance of list coloring. Similarly, the frequency assignment problem for cellular telephone networks and WLANs may be modelled more accurately by restricting the coloring of vertices (transmitters or routers) to a specified set [\cite=borndorfer-etal-98:FreqAss].

The list coloring problem is defined to be the search for a proper vertex coloring of a graph of minimum size such that each vertex is colored a permissible color. Thus, an instance of the list coloring problem is a graph accompanied by a list attached to each vertex of at most length n.

Closely related to the list coloring problem is the weighted vertex coloring or vertex multicoloring problem [\cite=malaguti2010] [\cite=mehrotra-trick-07:multicol-BP] [\cite=journals/dmgt/CaramiaF04] [\cite=NET:NET1028]. In this problem each vertex has a weight associated with it and the graph G  =  (V,E) must be multicolored so that vertex v∈V is assigned a set of colors Cv where [formula]; the objective is to find χ(G,w), the minimum number of colors required to color G and that satisfies the vertex weight requirement. When, further, each vertex is supplied with a list of permissible colors one arrives at the list multicoloring problem [\cite=DBLP:journals/corr/abs-1202-4842].

Clearly the list coloring problem is as hard as vertex coloring, for the latter reduces to the former (in polynomial time) through supplying, for every vertex, all colors as its permissible list. Few published algorithms exist for the list coloring problem in its most general form. In the context of frequency assignment Borndörfer et al. [\cite=borndorfer-etal-98:FreqAss] present several heuristics that incorporate problem-specific requirements. Likewise with Garg et al. [\cite=Garg96distributedlist] though their interest is in developing a distributed solution.

In this paper we investigate the performance of three list coloring algorithms. The first we consider is the greedy, random algorithm k-GL (Greedy List) proposed by Achlioptas and Molloy [\cite=Achlioptas97theanalysis]. Our second algorithm from the literature is a maximal independent set-based heuristic algorithm [\cite=tsouros-satratzemi-05]. Finally we propose a new branch-and-bound based algorithm ELC. While the running time of the latter cannot be expected to be competitive with the former two it does provide a useful reference point against which one may consider their performance.

In the following section we describe the three algorithms we have implemented and the context of our experiments. Following that, in Section [\ref=sec:expers] we provide the outcome of our experiments. In Section [\ref=sec:concls] we conclude the paper and suggest areas of further research.

Experimental Context

We implemented two algorithms from the literature as well as a newly developed branch-and-bound algorithm ELC. Of the two previously published algorithms one is randomised and the second is deterministic; both are heuristic. We describe these algorithms in the following sections.

The k-GL algorithm

Achlioptas and Molloy propose a greedy algorithm they call k-Greedy-List or k-GL [\cite=Achlioptas97theanalysis]. Each vertex is supplied with a permissible color list Lv  =  {1,2,3,...,k} (the contiguous sequence of integers between 1 and k) in order to facilitate their analysis. However, it would not be difficult to modify the algorithm in order to cater for a) lists of varying lengths and, b) non-contiguous sequences.

The algorithm proceeds by picking a vertex v that is deemed most critical as measured by the number of remaining colors on its permissible list, Lv, with ties broken randomly. If set Lv is not empty, a color randomly chosen from it is assigned to v and since that color can no longer be used in v's neighbourhood it is removed from each neighbour's permissible list; if Lv is empty, then the algorithm fails in finding a solution.

The algorithm we implemented is a modification of the original [\cite=Achlioptas97theanalysis] so that it accepts lists of non-contiguous sequences. We discuss its performance in Section [\ref=sec:heur-evaluation].

The LC algorithm

Tsouros and Satratzemi [\cite=tsouros-satratzemi-05] propose a deterministic heuristic algorithm that centres around finding a maximal independent set S where all vertices in S share a common permissible color c at each iteration. Since the subgraph induced by the independent set S is edgeless all vertices in the set S may be colored with the common color c.

The algorithm proceeds by determining Qi  =  {qi1,qi2,...} the set of vertices that can be colored i (v∈Qi  ⇔  i∈Lv) and ordering elements of Qi in a way that deg(qij)  ≤  deg(qij + 1) (line 5-6). Then amongst all those Qis a search is made for S, the largest maximal independent set (line 10; code not shown); the vertices in S  ⊆  Qj are colored j and color j is removed from LL ([formula]). Data structures are then updated appropriately. The algorithm fails in finding a solution if LL is empty when there are still uncoloured vertices. The algorithm makes little effort to compute a "good" maximal independent set: it initialises the independent set S by adding the first element in Qi, and then performs a linear scan over the remaining elements in Qi, if the element is not in S's neighbourhood, it is then being added in S. There are three nested loops (one not shown) with each iterating over, at worst, the set of vertices and set of colors, and thus the overall running time is O(n3). We report on its performance in Section [\ref=sec:heur-evaluation].

ELC - New Algorithm

We developed a branch-and-bound (BB) based algorithm, ELC. With sufficient time ELC will find the minimum coloring subject to the supplied list constraints for each vertex. At each step the algorithm selects the "next up" (most critical) vertex and considers all of its permitted colors in turn. If all vertices are colored the search has reached a leaf node of the search tree, and therefore a feasible coloring has been found. If the total of colors used is equal to the lower bound, the search is terminated as the optimal solution is found; otherwise, if the number of colors used to date exceeds that of a previous feasible solution (named UB - upper bound) then the search path is abandoned and another color possibility is examined. If the number is less, then a new upper bound is determined. This upper bound is used to prune the search tree if the total colors used in the current coloring process is greater than or equal to the current upper bound. This makes ELC a branch and bound algorithm.

In the following section we discuss the heuristics that we have investigated for determining the next up vertex for coloring and also describe the initial coloring procedure that we have determined to be useful in a branch-and-bound setting. We evaluated its performance in Section [\ref=sec:elc].

Branch-and-bound Issues

At each step, ELC picks the "next up" vertex from the uncolored subgraph and colors it accordingly. It is clear that with a proper coloring order (the sequence of picking each vertex for coloring and assigning color to it), the algorithm will arrive at a tighter upper bound earlier. Therefore, a proper vertex selecting rule shall be deployed in ELC as it can pick the next up vertex for coloring more carefully.

We considered a very effective yet simple vertex selecting rule for vertex coloring, DUA-h. We denote deg uav the unavailable degree as defined in Definition [\ref=def:sd] and deg u(v) as the number of vertices in the uncoloured subgraph of G to which vertex v is adjacent. The vertex selection rule is then described as: at each step pick the uncolored vertex v∈V where deg ua(v) is maximal; if there a tie then pick the vertex amongst the set of ties where deg u(v) is maximal; if there is still a tie after the second comparison, pick a vertex v amongst these ties lexicographically. The ELC algorithm we present in this section is based on this vertex selection rule.

Prior to implementing the ELC algorithm, various heuristics for finding proper initial upper bounds were investigated. During our investigation, we found that by simply providing a tighter upper bound initially will not make difference in later stage since the algorithm simply can not reach the corresponding leaf node that confirms the bound. With regard to the initial lower bound, we simply use size of the clique as the bound; this is also mentioned below.

When branching the search tree, the algorithm traverses on the very left branch of the tree and tries to reach the leaf node with a result of "either a feasible solution or no solution", and then backtrack in the search tree to reach its parent node, and start branching the next branch with another permissible color. Therefore, the very left branch is critical to the whole search as it affects almost all the remaining searches, we call this the "search order" of the tree. Now the question is, how to obtain a good search order. For this, "initial coloring" is the answer we suggest. This is discussed further below.

Initial coloring

In vertex coloring problems, both DSATUR[\cite=Bre79] and PASS algorithms [\cite=PASS] start with the procedure of trying to find a clique as large as possible and then color the clique as the initial coloring. The initial coloring of the clique can generate initial data which can be used to determine the next up vertex for coloring and therefore make the search order better. For the same purpose, we use clique coloring as the initial coloring in list coloring, and also the clique size can be used as the lower bound for the BB search . In vertex coloring since each color is identical if the coloring is given in a tight manner, the assignment of each color to each of the vertices in the clique can be done lexicographically, but in list coloring each of the colors is different from each other (due to the color availability list), the assignment can not be done lexicographically, and to keep the solution completeness, we need to make sure the use of the initial clique coloring doesn't miss any potentially optimal results.

In list coloring, each of the feasible clique colorings can be used as an initial coloring, and each of the initial colorings can be regarded as the "early level" branches of the BB tree after pruning the unnecessary branches. Now, since each of the initial colorings are different, and yet we don't know which clique coloring may lead to the branches where optimal colourings exist, a safe way is all of them should be used as the initial coloring. But the reality is, depending on the graph size, it could still be difficult to complete the BB search with the initial coloring; this can be evidenced by our initial investigation which shows that ELC only managed to complete a small portion of feasible clique colorings. To avoid the case mentioned above, therefore in this paper we implemented the algorithm as for each the upcoming BB search there is a limitation of 5,000 iterations. With this, we managed to let the algorithm try each of the possible clique coloring to benefit from the initial clique coloring, therefore we didn't miss any "good" branches.

Double clique coloring

Seeing the improvements made by doing an initial single clique coloring, we extend the idea by applying an extra clique coloring(therefore, find two cliques first, and then use the clique coloring as the initial coloring to conduct the BB search), this will 1) prune more unnecessary branches before the BB search, 2) give more information for selecting the next up vertex to avoid ties, and 3) provide a tighter lower bound. Based on this idea, we implemented dcc - another variant of ELC. The result from our investigation shows that this is a useful technique that can reduce the gap between the heuristic result and the optimal. The result is reported and discussed in Section [\ref=sec:expers].

Experimental Evaluation

To facilitate a preliminary experimental analysis of the algorithms it is reasonable that we focus on small graph sizes |V| and list lengths k.

For tested graphs we used both randomly generated graphs and DIMACS [\cite=dimacs] graphs. For random graphs in our experiments we generated graphs with |V| = {50,100,150,200} vertices and for each we randomly generated edges (uniformly) between vertices so that the density of edges, d, was one of {0.1,0.2,0.3,0.4,0.5}; for each pair of (|V|,d) 10 random instances were generated. Therefore, for random graphs, there is a total of 200 graph instances being generated.

When assigning color restrictions to each vertex we considered lists restricted to five different color ranges. That is, the randomly assigned colors were drawn from the range of colors

[formula]

Evaluation of the k-GL and LC

Tables [\ref=tab:random50100] and [\ref=tab:dimacs] show the solution quality of the two existing heuristic algorithms, k-GL and LC, as well as the two newly developed ones, ELC and dcc, on both random graphs with |V|  =  {50,100} and DIMACS graphs with |V|  ≤  100.

In view of the performance of each algorithm, not surprisingly, k-GL provides a poorer solution quality than LC if the latter finds a feasible solution. But it's surprising to see that k-GL succeed in finding a feasible solution over the 85% of the instances in a single run as shown in the tables. More surprising, though, is the poor showing of LC, the independent set-based heuristic. Of the 190 instances where feasible solutions exist the algorithm failed to find a solution (shown as empty entries below where "χk = x" is not "n/s") 163 times (over 85%). These failures, generally, correlate with small color ranges.

We conducted another experiment additionally to investigate the poor performance of LC phenomenon. We considered graphs with |V| = {50,100} vertices and d one of {0.1, 0.2, 0.3, 0.4, 0.5}. For the color availability list the randomly assigned colors were drawn from the range of colors

[formula]

ELC and dcc Evaluation

Tables [\ref=tab:random50100] and [\ref=tab:dimacs] compare the solution quality of the two newly developed branch-and-bound based algorithm, ELC and dcc on both random graphs with |V|  =  {50,100} and DIMACS graphs with |V|  ≤  100.

Again, the three tables show the experimental results of each algorithm on a total of 250 run instances. Among the 250 instances there are 60 instances where feasible solution doesn't exist (shown as "n/s" under "χk = x" ). The two algorithms, ELC and dcc, managed to find a feasible solution in 189 of the 190 instances where feasible solutions exist.

In regard to the solution quality, when |V|  =  50 ELC managed to reach the optimal result over 39 of the 60 instances where feasible solutions exist, and dcc managed over 49 of the 60; when |V|  =  100, ELC found 5 while dcc found 10 of 60. For the set of DIMACS graphs, ELC found 32 optimal solutions while dcc found 26 of 70. For g1, g2, g3 in Table [\ref=tab:dimacs_set], the edges in the graphs are distributed unevenly and this may somehow explains why the performance of the algorithms on g1, g2, and g3 is not consistent with the performance on random graphs where |V|  =  100 and d  =  0.1, though they have a similar (|V|,d).

The best solution found by dcc is always better or equal to the one found by ELC when both completed the run. When |V|  =  50, both the two algorithms found the same result on 45 of the 60 instances. For the remaining 15 instances, dcc won 13 while ELC won 2(dcc didn't complete the run on the two graphs). When |V|  =  100, there are 25 instances with a tie, for the remaining 35 instances, dcc won 25 while ELC won 10(again, for the 10 graphs, dcc didn't complete the run). Meanwhile, in comparison with LC, dcc provides better results than LC for nearly all the graphs that dcc completed the run and LC found a feasible solution.

In summary, the results shown in Tables [\ref=tab:random50100] and [\ref=tab:dimacs] confirm the trends below

for greater value of list length - k, more running time is required to list color a graph, generally;

for greater graph densties, more running time is needed to color the graph.

Further, in view of the performance of ELC and dcc, when |V|  =  100 ELC fail to complete the run on over 38% of the 60 instances where feasible solutions exist, and dcc fails on 77% of the 60 instances, not even considering the cases of when |V|  =  {150,200}. To facilitate the improvement of exact algorithms, it is reasonable, we suggest, that further research focus on |V| between

[formula]

Conclusions

We have implemented and investigated the only two existing list coloring algorithms known to us in the literature and have proposed a branch-and-bound based algorithm with additional data structure support through the use of a priority queue. The performance of each has been investigated and reported on.

Further algorithm tuning opportunities exist: there will be at least one initial feasible clique coloring that could lead to the optimal solution eventually, and it may need more than 5,000 iterations to reach the final optimal coloring during the BB search, therefore it would be nice if such initial clique coloring can be identified and then the BB search based on the 'good' initial coloring is given more time to compute a tighter bound. This, and also identifying other opportunities for code optimization are our next priorities.

Acknowledgments

The research is jointly funded by the Irish Research Council (IRC), and the China Scholarship Council (CSC). Thanks are also due to three anonymous referees for feedbacks in improving the paper, CSIS Department for providing the experimental facilities, Fen Chen and Yijun Yin for assistance in setting up the experiments.