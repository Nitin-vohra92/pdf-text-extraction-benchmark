Proposition Corollary Lemma

A Polynomial Time Attack against Algebraic Geometry Code Based Public Key Cryptosystems

Introduction

At the end of the seventies, only a couple of years after the introduction of public key cryptography, McEliece proposed an encryption scheme [\cite=mceliece:1978] whose security reposes on the difficulty of decoding a random code. Compared to RSA and discrete logarithm based schemes, McEliece has the advantage to resist to quantum attacks so far. In addition, its encryption and decryption are far more efficient. On the other hand, its major drawback is the huge size of the keys required to have a good security level. The original algorithm uses binary Goppa codes. In the sequel, several proposals based on other families of algebraic codes appeared in the literature. For instance, Generalized Reed-Solomon codes are proposed in [\cite=niederreiter:1986], subcodes of them in [\cite=berger:2005] and Binary Reed-Muller codes in [\cite=sidelnikov:1994]. All of these schemes are subject to polynomial or sub-exponential time attacks [\cite=sidelnikov:1992] [\cite=minder:2007] [\cite=wieschebrink:2010].

Another attempt, suggested by Janwa and Moreno [\cite=janwa:1996] was to introduce Algebraic geometry codes or codes derived from them by operations like subfield restriction or concatenation. Due to Faure and Minder, this scheme was broken for codes on curves of genus g  ≤  2, [\cite=MinderThesis] [\cite=faure:2008]. However, this attack has several drawbacks which makes it impossible to extend to higher genera. Indeed, their attack requires the curve to be hyperlliptic, which is non generic for genus higher than 2. Moreover, even for hyperellic curves, the first step of their attack consists of the computation of minimum weight codewords and such a computation is exponential in the curve's genus. Another attempt of breaking this scheme in the high genus case appeared in [\cite=marquez:2012b] [\cite=marquez:2013b] where the authors describe an algorithm for retrieving an equivalent representation of the code C from the single knowledge of the public key. Unfortunately, the efficient construction of a decoding algorithm from this code's representation is still lacking. Indeed, the obtained embedding of the curve lies in a high dimensional projective space making difficult the computation of Riemann Roch spaces.

In this article, we use another approach based on the use of the Schur product, that is the component wise product of vectors. Our attack is inspired from the the attacks developed in [\cite=CGGOT12] [\cite=COT14]. Thanks to Schur products of codes, we are able to compute an Error Correcting Pair [\cite=pellikaan:1992] in O(n4) operations in [formula], allowing us to decrypt any encrypted message in O(n3) under the assumption that the users also use error correcting pairs. Compared to Faure and Minder's attack, ours does not require the computation of minimum weight codewords and its complexity is polynomial in the code length with no exponential contribution of the genus. This allows us to break schemes based on high genus algebraic geometry codes. It should be pointed out that our attack is neither a generic decoding attack like Information Set Decoding, nor a structural attack as the structure of the code is not retrieved.

Thanks to this alternative attack we are for instance able to break an AG

[formula]

Algebraic Geometry Codes

For basic notions on algebraic curves and algebraic geometry (AG) codes, such as curves, function fields, valuations, divisors and Riemann-Roch spaces we refer the reader to [\cite=stichtenoth:2009] [\cite=TVN].

Notation

Let X denote a smooth projective geometrically connected curve over a finite field [formula]. The function field of X is denoted by [formula] and for all point P∈X the valuation at P is denoted by vP. Given an [formula]-divisor E on X, the corresponding Riemann Roch space is denoted by L(E). Given an n-tuple [formula] of pairwise distinct [formula]-points of X, we denote by DP the divisor [formula]. For [formula], the divisor of f is denoted by (f). Given a divisor E with support disjoint from that of DP, the code CL(X,P,E) is defined as

[formula]

Finally, from now on the dimension of a linear code C will be denoted by k(C) and its minimum distance by d(C).

Some classical results in algebraic geometry coding theory

Let X, P and E be respectively a smooth projective geometrically connected curve over [formula], an n-tuple of rational points of X and an [formula]-divisor of degree m on X. Then, we have the following well-known statements.

If deg (E) = m < n then

[formula]

Moreover, if n > m > 2g - 2 then CL(X,P,E) has dimension m - g + 1.

Let ω be a differential form with a simple pole and residue 1 at Pj for all [formula]. Let K be the divisor of ω. Then [formula] where [formula] and [formula].

If m > 2g - 2 then

[formula]

Moreover, if n > m > 2g - 2, then [formula] has dimension n - m - 1 + g.

The McEliece encryption scheme

Let F be any family of linear codes with an efficient decoding algorithm. Every element of this family is represented by the triple (C,AC,t) where AC denotes a decoding algorithm for C∈F which corrects up to t errors.

The McEliece scheme can be summarized as follows:

Key generation: Consider any element (C,AC,t)∈F. Let G be a non structured generator matrix of C. Then the public key and the private key are given respectively by

[formula]

Encryption: [formula] where [formula] is the message and [formula] is a random error vector of weight at most t.

Decryption: Using Ksecret, the receiver obtain [formula].

Context of the present article

Until the end of this article, X denotes a smooth projective geometrically connected curve over [formula] of genus g, [formula] denotes an n-tuple of mutually distinct [formula]-rational points of X, DQ denotes the divisor [formula] and F denotes an [formula]-divisor of degree [formula] with m > 3g - 1 (see Remark [\ref=rem:m] further) and support disjoint from that of DQ.

We assume that our public key is a generator matrix [formula] of the public code [formula] and the largest number t of errors introduced during the encryption step.

We take [formula] where d* = m - 2g + 2 is called the designed minimum distance of the public code [formula]. This correction capability seems reasonable if the secret key of the scheme is a decoding algorithm based on the so-called error correcting pairs (ECP). However, this value is smaller than the actual error-correction capability of C which is defined as [formula]. This case will be considered in a longer version of this article.

Thus,

[formula]

Our attack will consist in the computation of an ECP in order to decode [formula]. The following section is devoted to the theory of error correcting pairs.

The lower bound m > 3g - 1 is chosen in order to have t  >  0.

Decoding by Error Correcting Pairs

Given two elements [formula] and [formula] in [formula], the Schur product is defined by coordinatewise multiplication, that is

[formula]

while the standard inner product is defined by [formula]. In general, for two subsets A and B of [formula] the set A * B is given by

[formula]

Notice that, in contrast with the usual definition, we take the vector space generated by all [formula] with [formula] and [formula]. For B = A, then A * A is denoted as A(2). Furthermore, we denote by [formula] if [formula] for all [formula] and [formula].

Let C be a linear code in [formula]. A pair (A,B) of linear codes over [formula] of length n is called a t-error correcting pair (ECP) for C if the following properties hold:

[formula],

k(A)  >  t,

[formula],

d(A)  +  d(C)  >  n.

The notion of error correcting pair for a linear code was introduced by Pellikaan [\cite=pellikaan:1988] [\cite=pellikaan:1992] and independently by Kötter [\cite=koetter:1992] [\cite=koetter:1996]. It is shown that a linear code in [formula] with a t-error correcting pair has a decoding algorithm which corrects up to t errors with complexity [formula].

The existence of ECP's for GRS and AG codes was shown in [\cite=pellikaan:1988] [\cite=pellikaan:1992]. For many cyclic codes Duursma and Kötter in [\cite=duursma:1994] [\cite=koetter:1992] [\cite=koetter:1996] have found ECP's which correct beyond the designed BCH capacity.

The Schur product is also used for cryptanalytic applications in [\cite=wieschebrink:2010] [\cite=marquez:2012b] [\cite=CGGOT12]. Many other applications of this product such as multy party computation, secret sharing schemes, oblivious transfer or construction of lattices are summarised in [\cite=Hugues].

ECP for AG codes

In the context of § [\ref=sec:context], the pair of codes (A,B) defined by

[formula]

with m >  deg (E)  ≥  t + g is a t-ECP for [formula]. Such a pair (A,B) for [formula] always exists whenever m > 2g - 2.

Let us define [formula]. Then (A0,B) is a t-ECP for [formula].

The above corollary is central to our attack. It asserts that, it is sufficient to compute a generator matrix of a code of the type CL(X,Q,F  -  E) for some divisor E with deg (E)  ≥  t + g, in order to determine a t-ECP for the code CL(X,Q,F).

The product of the spaces L(F) and L(G) in L(F + G)

Let F,G be two divisors on X such that deg (F)  ≥  2g and deg (G)  ≥  2g + 1. Then

[formula]

See [\cite=mumford:1970].

Let F,G be two divisors on X such that deg (F)  ≥  2g and deg (G)  ≥  2g + 1. Then,

[formula]

From the single knowledge of a generator matrix of CL(X,Q,F), one can compute deg (F) = m and the genus g of X using the following statement.

If [formula]. Let k1 and k2 be the dimension of C  =  CL(X,Q,F) and C(2), respectively. Then,

[formula]

The P-Filtration

Let P be a point of the n-tuple Q. We focus on the sequence of codes

[formula]

This sequence provides a filtration of CL(X,Q,F). The first step of our attack consists of the computation of some elements of this filtration.

Notice that for i > 0, the codes Bi are degenerated.

Which elements of the sequence do we know?

From a generator matrix of [formula] one can compute CL(X,Q,F) by Gaussian elimination. Then, B0 is nothing but the code CL(X,Q,F) punctured at position P and B1 is the code CL(X,Q,F) shortened at this position which can also be computed by Gaussian elimination. Thus, from now on, we assume that B0 and B1 are known.

Effective computations

The only information available to the attacker is exactly a generator matrix of [formula] and its error correcting capability t.

From Remark [\ref=rem:fundamental], attacking the scheme reduces to compute a generator matrix of a code of the form B  =  CL(X,Q,F  -  E) for some E of degree t + g and disjoint support from Q.

In this section we present a polynomial time method to compute a generator matrix of B. Then, a t-ECP (A,B) can be deduced from B and the public code using Corollary [\ref=Corollary::1].

Let G be a divisor and P be a rational point on the curve X. An integer γ  ≥    -   deg (G) is called a G gap at P if L(G + γP)  =  L(G + (γ - 1)P).

If s  ≥  1 and [formula], then Bs + 1 is the solution space of the following problem

[formula]

Let S be the solution space of Problem ([\ref=Problem::1]). Corollary [\ref=cor-power:Asym] entails Bs + 1  ⊆  S.

Conversely, assume the existence of [formula]. Then there exists [formula] such that [formula]. From Riemann-Roch Theorem, if deg (F) - s  ≥  2g + 1, then any integer γ  ≥   - s is an F non-gap at P. Thus, there exists [formula], i.e. such that [formula]. Since [formula], we have [formula], but [formula], which yields a contradiction.

This result gives rise to Algorithm [\ref=Algorithm::1] for determining the code Bt + g, which consists of (t + g) repeated applications of Theorem [\ref=Proposition::1].

Actually, we can do better by decreasing the number of iterations of the above algorithm and relaxing the parameters conditions. The following theorem yields to a nice improvement giving rise to Algorithm [\ref=Algorithm::2]. We omit its proof which is very similar to that of Theorem [\ref=Proposition::1].

If [formula], then Bs is the solution space of the following problem

[formula]

Extending the attack

We have been working under the assumption that [formula]. In the remainder of this section we will see how this condition can be weakened.

Let J be a subset of [formula] consisting of m integers. We define the code C(J) as the set of codewords of C that have a zero in the J-locations, a similar notion may be found in the concept of shortened codes.

Let I be a subset of [formula] with i elements and [formula] be n different rational points. Take the code

[formula]

If [formula], then [formula].

Let [formula] be n different rational points. Define C  =  CL(Y,Q,F  -  Q1). Let [formula] be different subsets of [formula] such that

[formula]

Then [formula].

Suppose there exists i > 1 such that

[formula]

Then, to compute Bt + g, it suffices to find different subsets [formula] of [formula] with at least i elements and each satisfying the assumptions of Lemma [\ref=Lemma::Enlarging]. Then, Algorithm [\ref=Algorithm::1] or [\ref=Algorithm::2] will provide the codes Bt + g(Ij) with [formula] from which we obtain the desired code using Lemma [\ref=Lemma::Enlarging].

From degenerate to non degenerate codes

In summary, from the single knowledge of [formula] we are able to compute a subcode CL(X,Q,F  -  E) of CL(X,Q,F) for some positive divisor E. Unfortunately, since E is supported by elements of Q, the code CL(X,Q,F  -  E) is degenerated and hence not suitable for the construction of an ECP using Corollary [\ref=Corollary::1]. In what follows, we explain how to compute another code CL(X,Q,F  -  E'), where E' is linearly equivalent to E, i.e. E'  =  E + (h) for some rational function on X and such that E' has disjoint support with DQ. It should be pointed out that we do not need to compute h but just prove its existence.

On the following, we explain how to compute a generator matrix of

[formula]

knowing generator matrices of Bt + g and Bt + g + 1.

Let [formula] be a generator matrix of Bt + g of the form

[formula]

where [formula] and [formula] and [formula] is a generator matrix of Bt + g + 1. Then, there exists a rational function h on X such that the matrix

[formula]

is a generator matrix for CL(X,Q,F  -  (t  +  g)P  -  (h)).

Let P be any Qi, for simplicity take i = 1.

Let [formula] be such that [formula]. By definition, vQ1(f)  =  t + g. From the weak approximation Theorem [\cite=stichtenoth:2009], there exists a rational function [formula] such that

[formula];

vQ1(h) =  - t - g and hf(Q1) = 1.

Such a function h yields the result. Details are left to the reader.

The Attack

The algorithm

Recall that the attacker knows a generator matrix of the public code [formula] and the integer t.

If [formula], then the attack summarizes as follows. Otherwise we have to apply techniques from §[\ref=Subsection::Enlarging].

Determine the values g and m using Proposition [\ref=Prop:genus].

Compute CL(X,Q,F) by Gaussian elimination.

Compute the code B = CL(X,Q,F  -  (t  +  g)P1), using one of the algorithms described in § [\ref=Section::6].

Deduce from B a non degenerated code B̂  =  CL(X,Q,F  -  (t  +  g)P1  -  (h)) using § [\ref=sec:degnondeg].

Apply Corollary [\ref=Corollary::1] to deduce an ECP from B̂.

Complexity

The costly part of the attack is the computation of the code B = CL(X,Q,F  -  Q1) such that (A0,B) forms an t-ECP for C  =  CL(X,Q,F). For that purpose we can apply one of the algorithms proposed in § [\ref=Section::6]. Take notice that computing a generator matrix of C(2) and then apply Gaussian elimination to such matrix has complexity:

[formula]

Roughly speaking the cost of our attack is about [formula] where λ denotes the number of linear systems to solve depending on the chosen algorithm from § [\ref=Section::6]. The term λ + 1 is due to Theorem [\ref=Theorem::degenerated].

It seems logical to chose Algorithm [\ref=Algorithm::2], which has a better complexity and works for a larger set of possible m. However Algorithm [\ref=Algorithm::1] allows to compute a sequence of codes (called GAP-filtration)

[formula]

In a longer version of this article, we expect to provide an attack allowing the correction of up to [formula] errors. This attack will use the concept of error correcting arrays [\cite=kirfel:1995],[\cite=pellikaan:1993] or well-behaving sequences [\cite=geil:2013].

Parameters under attack

The following tables provides comparison between an average work factor of attacking the McEliece-cryptosystem using Information Set Decoding (ISD) attacks (denoted by [formula]) and an approximate work factor of our attack (denoted by [formula]) when introducing [formula] errors. Recall that ISD's average complexity is [formula].

The Hermitian curve Hr over [formula] with q = r2 is defined by the affine equation Yr  +  Y  =  Xr + 1. This curve has P∞ = (0:1:0) as the only point at infinity.

Take F = mP∞ and let Q be the [formula] affine [formula]-rational points of the curve. Table [\ref=Table::1] considers different codes of type [formula] with n > m > 2g - 2.

The Suzuki curves are curves X defined over [formula] by the following equation Yq  -  Y  =  Xq0(Xq - X) with q = 2q20  ≥  8 and q0 = 2r This curve has exactly q2 + 1 rational places and a single place at infinity P∞. Let F = mP∞ and Q be the q2 rational points of the curve. Table [\ref=Table::2] considers several codes of type [formula] with n > m > 2g - 2.

Conclusion

We constructed a polynomial-time algorithm which breaks the McEliece scheme based on the AG codes whenever the number of errors introduced is [formula], that is whenever the decoding algorithm chosen by the users is based on ECP's.

It would be desirable to have an attack for [formula] errors which will be considered in a long version of this article using the concepts of error correcting arrays or well-behaving sequences. This algorithm runs in [formula] and is based on an explicit computation of a GAP-filtration of the public code.

Acknowledgment

The authors express their deep gratitude to Jean-Pierre Tillich for inspiring discussions.