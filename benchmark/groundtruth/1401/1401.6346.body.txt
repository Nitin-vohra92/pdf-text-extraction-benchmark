On Combinatorial Generation of Prefix Normal Words

Introduction

A binary word of length n is prefix normal if for all 1  ≤  k  ≤  n, no substring of length k has more 1s than the prefix of length k. For example, 1001010 is not prefix normal because the substring 101 has more 1s than the prefix 100. These words were introduced in [\cite=FL11], where it was shown that each binary word w has a canonical prefix normal form w' of the same length: w and w' are equivalent in a certain sense.

The study of prefix normal words, and prefix normal forms, is motivated by the string problem known as binary jumbled pattern matching. In that problem, we are given a text of length n over a binary alphabet, and two numbers x and y, and ask whether the text has a substring with exactly x 1s and y 0s. While the online version can be solved with a simple sliding window algorithm in O(n) time, the offline version, where many queries are expected, has recently attracted much interest: here an index of size O(n) can be generated which then allows answering queries in constant time [\cite=CFL09]. However, the best construction algorithms up to date have running time O(n2  /   log n) [\cite=BCFL10] [\cite=MR10]. Several recent papers have yielded better results under specific assumptions, such as word level parallelism or highly compressible strings [\cite=MR12] [\cite=BFKL13] [\cite=GG13] [\cite=CGGLLRT13], or for constructing an approximate index [\cite=CLWY12]; but the general case has not been improved. It was demonstrated in [\cite=FL11] [\cite=BFKL13] that prefix normal forms of the text can be used to construct this index. See the Appendix for a brief explanation of this connection.

Jumbled Pattern Matching (JPM), over an arbitrary alphabet, is a variant of approximate pattern matching: We are given a text and a pattern, and want to answer the question whether the text has a substring which is a permutation of the pattern (existence), or find one or all occurrences of such substrings (occurrence, listing). This problem has also been studied under the terms Abelian pattern matching, Parikh vector matching, and permutation matching. A closely related problem is that of Parikh fingerprints [\cite=AALS03]. Applications in computational biology include SNP discovery, alignment, gene clusters, pattern discovery, and mass spectrometry data interpretation [\cite=Boecker07] [\cite=Benson03] [\cite=BoeckerJMS08] [\cite=DuhrkopLMB13] [\cite=Parida06].

For one query, the JPM problem can be solved in optimal linear time with a classical sliding window approach [\cite=BEL04], while recently, interest has turned towards the indexing problem [\cite=CFL09] [\cite=KRR13]. Moreover, several variants of the original problem have recently been introduced: approximate JPM [\cite=BCFL12_TOCS], JPM in the streaming model [\cite=LLZ12], JPM on trees and graphs [\cite=GHLW13] [\cite=CGGLLRT13].

Bubble languages are an interesting new class of binary languages defined by the following property: L is a bubble language if, for every word w∈L, replacing the first occurrence of 01 (if any) by 10 results in another word in L [\cite=RSW12] [\cite=Ruskey12] [\cite=SW12]. A generic generating algorithm for bubble languages was given in [\cite=SW12], leading to Gray codes for each of these languages, while the algorithm's efficiency depends only on a language-dependent subroutine. In the best case, this leads to CAT (constant amortized time) generating algorithms. Many important languages are bubble languages, among them necklaces, binary Lyndon words, and k-ary Dyck words.

In this paper, we show that prefix normal words form a bubble language and present an efficient generating algorithm which runs in O(n) amortized time per word, and which yields a Gray code for prefix normal words. The best previous generating algorithm for prefix normal words ran in O(2n  ·  n2) time, and consisted simply in testing each binary word for the prefix normal property (unpublished). Based on experimental evidence, we conjecture that the running time of our algorithm is in fact [formula] amortized. We also give a new characterization of bubble languages in terms of a closure property in the computation tree of a certain generating algorithm for binary words. We prove new properties of prefix normal words and present a linear time testing algorithm for words which have been obtained from prefix normal words via a simple operation. This could lead to a better understanding of prefix normal words and in the long run, to faster computation of prefix normal forms, and thus contribute to the goal of strongly subquadratic algorithms for binary jumbled pattern matching.

Basics

A binary word (or string) [formula] over Σ  =  {0,1} is a finite sequence of elements from Σ. Its length n is denoted by |w|. For any 1  ≤  i  ≤  |w|, the i-th symbol of a word w is denoted by wi. We denote by Σn the words over Σ of length n, and by [formula] the set of finite words over Σ. The empty word is denoted by ε. Let w∈Σ*. If w = uv for some u,v∈Σ*, we say that u is a prefix of w and v is a suffix of w. A substring of w is a prefix of a suffix of w. A binary language is any subset L of Σ*.

In the following, we will often write binary words w  ≠  1n in a canonical form w = 1s0tγ, where [formula] and [formula]. In other words, s is the length of the first, possibly empty, 1-run of w, t the length of the first 0-run, and γ the remaining, possibly empty, suffix. Note that this representation is unique. We call 1s0t the critical prefix of w and cr(w) = s + t the critical prefix length of w. We denote by |w|c the number of occurrences in w of character c∈{0,1}, and by Bnd the set of all binary strings w of length n such that |w|1  =  d (the density of w is d).

Given a string w, we can obtain another string w'  =  (w,i,j), the string obtained from w by exchanging the characters in positions i and j.

Prefix Normal Words

Let w∈Σ*. For [formula], we set

[formula], the number of 1s in the i-length prefix of w.

[formula], the maximum number of 1s over all substrings of length i.

A binary word w is prefix normal if, for all 1  ≤  i  ≤  |w|, F(w,i)  =  P(w,i). In other words, a word is prefix normal if no substring contains more 1s than the prefix of the same length.

For example, 1001010 is not prefix normal because the substring 101 has more 1s than the prefix 100. We denote by [formula] the language of prefix normal words. In [\cite=FL11] it was shown that for every word w there exists a unique word w', called its prefix normal form, or [formula], such that for all 1  ≤  i  ≤  |w|, F(w,i)  =  F(w',i), and w' is prefix normal. Therefore, a prefix normal word is a word coinciding with its prefix normal form.

Note: In [\cite=FL11], the property 'prefix normal' was defined both with respect to 1 and with respect to 0. Here we restrict ourselves to prefix normal words w.r.t. 1.

In Table [\ref=table:classes5] we list all prefix normal words of length 5, and, for each [formula], the set of binary words w such that [formula] (i.e., its equivalence class). Several methods were presented in [\cite=FL11] for testing whether a word is prefix normal; however, all ran in quadratic time. One open problem given there was that of enumerating prefix normal words (counting). The number of prefix normal words of length n can be computed by checking for each binary word whether it is prefix normal, i.e. altogether in O(2n  ·  n2) time. In this paper, we present an algorithm that is far superior in that it generates only prefix normal words, rather than testing every binary word; it runs in O(n) time per word; and it generates prefix normal words in cool-lex order, constituting a Gray code (subsequent words differ by a constant number of swaps or flips).

Bubble Languages and Combinatorial Generation

Here we give a brief introduction to bubble languages, mostly summarising results from [\cite=RSW12] [\cite=SW12]. We also give a new characterization of bubble languages in terms of the computation tree of a generating algorithm (Obs. [\ref=obs:tree]).

A language L  ⊆  {0,1}* is called a bubble language if, for every word w∈L, exchanging the first occurrence of 01 (if any) by 10 results in another word in L.

For example, the languages of Lyndon words, necklaces and pre-necklaces are bubble languages. A language L  ⊆  {0,1}n is a bubble language if and only if each of its fixed-density subsets [formula] is a bubble language [\cite=RSW12]. This implies that for generating a bubble language, it suffices to generate its fixed-density subsets.

Next we consider combinatorial generation of binary strings.

Let w be a binary string of length n. Let d be the number of 1s in w, and let [formula] denote the positions of the 1s in w. Clearly, we can obtain w from the word 1d0n - d with the following algorithm: first swap the last 1 with the 0 in position id, then swap the (d - 1)st 1 with the 0 in position id - 1 etc. Note that every 1 is moved at most once, and in particular, once the k'th 1 is moved into the position ik, the suffix [formula] remains fixed for the rest of the algorithm.

These observations lead us to the following generating algorithm (Fig. [\ref=algo:bubble]), which we will refer to as Recursive Swap Generation Algorithm (like Alg. 1 from [\cite=SW12], which in addition includes a language-specific subroutine). It generates recursively all binary strings from Bnd with fixed suffix γ, where [formula], starting from the string 1s0tγ. The call Generate(d,n - d,ε) generates all binary strings of length n with density d.

The algorithm swaps the last 1 of the first 1-run with each of the 0s of the first 0-run, thus generating a new string each, for which it makes a recursive call. During the execution of the algorithm, the current string resides in a global array w. In the subroutine Visit() we can, but do not have to, print the contents of this array; we may just want to increment a counter (for enumeration), or check some property of the current string. The main point of Visit() is that it touches every object once.

Let Tnd denote the recursive computation tree generated by a call to Generate(d,n - d,ε). As an example, Fig. [\ref=fig:example1] illustrates the computation tree T74.

The depth of the tree equals d, the number of 1s; while the maximum degree is n - d, the number of 0s. In general, for the subtree rooted at v  =  1s0tγ, we have depth s and maximum degree t; in particular, the number of children of v is exactly t. In fact, v's ith child has the form 1s - 10i10t - iγ. Moreover, the suffix γ remains unchanged in the entire subtree, and the computation tree is isomorphic to the computation tree of 1s0t. This γ is called fixed suffix [\cite=RSW12]. Note also that the critical prefix length s + t strictly decreases along any downward path in the tree.

The algorithm performs a post-order traversal of the tree, yielding an enumeration of the strings of Bnd in what is referred to as cool-lex order [\cite=Wi09] [\cite=SW12] [\cite=RSW12]. A pre-order traversal of the same tree, which implies moving line 4 of the algorithm before line 1, would yield an enumeration in co-lex order. A crucial property of cool-lex order is that any two subsequent strings differ by at most two swaps (transpositions), thus yielding a Gray code [\cite=RSW12]. This can be seen in the computation tree Tnd as follows. Note that in a post-order traversal of Tnd, we have:

[formula]

Let u,u' both be children of v. This means that for some [formula] and [formula], we have v = 1s0tγ, u = 1s - 10i10t - iγ, and u' = 1s - 10j10t - jγ. Let v' be a descendant of v along the leftmost path, i.e. v'  =  1k01s - k0t - 1γ for some k. Then

[formula]

We now state a crucial property of bubble languages with respect to the Recursive Swap Generating Algorithm which follows immediately from the definition of bubble languages:

A language L is a bubble language if and only if, for every [formula], its fixed-density subset [formula] is closed w.r.t. parents and left siblings in the computation tree Tnd of the Recursive Swap Generating Algorithm. In particular, if [formula], then it forms a subtree rooted in 1d0n - d.

Using this property, the Recursive Swap Generating Algorithm can be used to generate any fixed-density bubble language L, as long as we have a way of deciding, for a node w = 1s0tγ, already known to be in L, which is its rightmost child (if any) that is still in L. If such a child exists, and it is the kth child u = 1s - 10k10t - kγ, then the bubble property ensures that all children to its left are also in L. Thus, line 2. in the algorithm can simply be replaced by "for [formula]". Moreover, the Recursive Swap Generating Algorithm, which visits the words in the language in cool-lex order, will yield a Gray code, since because of this closure property, next(u) will again either be the parent, or a node on the leftmost path of the right sibling, both of which are reachable within two swaps, see [\eqref=eq:swap].

In [\cite=SW12], a generic generating algorithm was given which moves the job of finding this rightmost child k into a subroutine Oracle(s,t,γ). If Oracle(s,t,γ) runs in time O(k), then we have a CAT algorithm. In general, this will not be possible, and a generic Oracle tests for each child from left to right (or from right to left) whether it is in the language. Because of the bubble property, after the first negative (positive) test, it is guaranteed that no more children will be in the language, and the running time of the algorithm is amortized that of the membership tester. The crucial trick is that it is not necessary to have a general membership tester, since all we want to know is which of the children of a node already known to be in L are in L; moreover, the membership tester is allowed to use other information, which it can build up iteratively while examining earlier nodes.

Combinatorial Generation of Prefix Normal Words

In this section we prove that the set of prefix normal words [formula] is a bubble language. Then, by providing some properties regarding membership testing, we can apply the cool-lex framework to generate all prefix normal words of a given length n and density d in O(n)-amortized time. By concatenating the lists together for all densities in increasing order, we obtain an O(n)-amortized time algorithm to list all prefix normal words of length n.

The language [formula] is a bubble language.

Let w be a prefix normal word containing an occurrence of 01. Let w' be the word obtained from w by replacing the first occurrence of 01 with 10. Then w = u01v, w' = u10v for some u,v∈Σ*. Let z be a substring of w'. We have to show that |z|1  ≤  P(w',|z|).

Note that for any k, P(w,k)  ≤  P(w',k). In fact, P(w',|u| + 1)  =  P(w,|u|) + 1, and for every k  ≠  |u| + 1, P(w,k)  =  P(w',k). Now if z is contained in u or in v, then z is a substring of w, and thus |z|1  ≤  P(w,|z|)  ≤  P(w',|z|). If z = u'10v', with u' suffix of u and v' prefix of v, then |z|1 = |u'01v'|1  ≤  P(w,|z|)  ≤  P(w',|z|). If z = 0v', with v' prefix of v, then |z|1 < |1v'|1, and 1v' is a substring of w, thus |z|1  ≤  P((w,|z|)  ≤  P(w',|z|). Else z = u'1, with u' suffix of u. We can assume that u' is a proper suffix of u. Let z' be the substring of w' of the same length as z and starting one position before z (in other words, z' is obtained by shifting z to the left by one position). Since u does not contain 01 as a substring, we have u = 1n0m for some n  ≥  1,m  ≥  0. If z' is a power of 0's, then |z|1 = 1 and the claim holds. Else, |z|1 = |z'|1, and z' is a substring of w. Thus |z|1  ≤  P(w,|z|)  ≤  P(w',|z|).

In Fig. [\ref=fig:example2], we give the computation tree T74 and highlight the subtree corresponding to [formula]. Since [formula] is a bubble language, by Obs. [\ref=obs:tree] it is closed w.r.t. left siblings and parents. However, we still have to find a way of deciding which is the rightmost child of a node that is still in [formula].

The following lemma states that, given a prefix normal word w, in order to decide whether one of its children in the computation tree is prefix normal, it suffices to check the PN-property for one particular length only: the critical prefix length of the child node. Moreover, this check can be done w.r.t. γ only. This fact will be crucial in the generating algorithm.

Let [formula], with w = 1s0tγ, with [formula]. Let   =  γ0s + t, i.e. γ padded with 0s to length n. Let w'  =  (w,s,s + i). Then [formula], unless one of the following holds:

[formula] has a substring of length s + i - 1 with at least s 1s, or

the string [formula] has at least s 1s.

Moreover, the latter is the case if and only if P(,s  +  2(i - 1)  -  t)  ≥  s - 1 (where by convention, we regard a prefix of negative length as the empty word).

Let's assume that [formula]. Then there is a substring u of w' s.t. |u|1  >  P(w',|u|). Let m be the length of u.

Case 1. u is a substring of w. Since [formula], therefore |u|1  ≤  P(w,m). Since also |u|1  >  P(w',m), this implies s  ≤  m  ≤  s + i - 1, because for all other arguments, P(w,  ·  ) and P(w',  ·  ) coincide. Note that u must have an occurrence in w' which contains neither of the swapped bits, else it would not be a substring of w. Thus u starts at some position to the right of s + i. Therefore we can write u  =  0rv, with v a substring of γ; in particular, if u is a substring of γ, then r = 0 and v = u; otherwise, v is a prefix of γ. Now set u'  =  vv', with v' the substring of [formula] of length s + i - 1 - m + r following v. Then u' has length s + i - 1, and since |v'|1  ≥  0  =  |0r|1, it contains at least s many 1s.

Case 2. u is not a substring of w. Therefore it contains at least one of the two swapped bits. It cannot contain the swapped 0 (in position s) because then it would be preceded only by 1s, in which case the prefix of w' of length m could not have fewer 1s than u. Thus, u contains the swapped 1 only (in position s + i). If m > s + i - 1, then the prefix of w' of length m overlaps with u, i.e. we can write [formula] and u = v'u' for some non-empty v' containing the swapped 1. Since |u|1  >  P(w',m), this implies that also u' has more 1s than the prefix of the same length. Since u' is a substring of w, we are back in Case 1.

So we have m  ≤  s + i - 1. We can write u = 0r10t - iv, with v prefix of γ. Now remove the starting 0s from u and extend it to the right to get u'  =  10t - iv', with v' be the prefix of [formula] of length k = s + 2(i - 2) - t. Then |u'|  =  s + i - 1 and |u'|1  ≥  |u|1  >  P(w',|u|)  =  s - 1. Moreover, |u'|1  =  1  +  P(,s + 2(i - 1) - t).

Given [formula]. If we know F(γ,  ·  ) and P(γ,  ·  ), then it can be decided in constant time whether w'  =  (w,s,s + i) is prefix normal.

Let γ'  =  10rγ, with [formula]. Then for all [formula],

[formula]

A substring of length i either uses the new 1 in the first position, or it does not. If it does, then it is a prefix of γ' and its number of 1s is given by P(γ',i). Else it is a substring of 0r - 1γ, and its number of 1s is given by F(γ,i) for i up to the length of γ, or by the number of 1s in γ, F(γ,|γ|), if i spans all of γ.

The F-function of γ for node w = 1s0tγ can be computed in linear time based on the F-function of w's parent node.

By applying these results, the algorithm GeneratePN(d,n - d,ε) can be used to generate [formula] in cool-lex Gray code order. Starting from the left child and proceeding right (with respect to the computation tree Tdn), the algorithm will make a recursive call until a child is no longer prefix normal. The membership test is done in the subroutine isPN, which uses the conditions of Lemma [\ref=lemma:isPNF]. The algorithm maintains an array F which contains the maximum number of 1s in i-length substrings of γ (the F-function of γ), and a variable z. Before testing the first child, in update(F,s + t), it computes the current γ's F-function based on the parent's (Corollary [\ref=coro:F]). Note that it is not necessary to compute all of the F-function, since all nodes in the subtree have critical prefix length smaller than s + t, thus this update is done only up to length s + t. After the recursive calls to the children, the array is restored to its previous state in restore(F,s + t). The variable z contains the number of 1s in the prefix of γ which is spanned by the substring of case 2. of Lemma [\ref=lemma:isPNF], for the first child. It is updated in constant time after each successful call to isPN, to include the number of 1s in the two following positions in γ.

By concatenating the lists of prefix normal words with densities [formula], we obtain an exhaustive listing of [formula].

As an example, a call to GeneratePN(5) produces the following list of prefix normal words of length 5:

[formula]

These strings are also given in Sec. [\ref=sec:pnw]. Since the fixed-density listings are a cyclic Gray code (Theorem 3.1 from [\cite=RSW12]), it follows that this complete listing is also a Gray code. In fact, if the fixed-density listings are listed by the odd densities (increasing), followed by the even densities (decreasing), the resulting listing would be a cyclic Gray code.

Algorithm GeneratePN(n) generates all prefix normal words of length n in amortized O(n) time per word.

Since 1d0n - d is prefix normal for every d, we only need to show that the correct subtrees of Tnd are generated by the algorithm. By Lemma [\ref=lemma:isPNF], only those children will be generated that are prefix normal; on the other hand, by the bubble property (Obs. [\ref=obs:tree]), as soon as a child tests negative, no further children will be prefix normal. The running time of the recursive call on [formula] consists of (a) updating and restoring F (lines 2 and 9): the number of steps equals the critical prefix length of w, which is O(n); (b) computing z (line 3): again cr(w)  ≤  n, the critical prefix length of w, many steps, so O(n); and (c) work within the while-loop (lines 5 to 8), which, for a word with k prefix normal children, consists of k positive and 1 negative membership tests, of k updates of z, and the recursive calls on the positive children. The membership tests take constant time by Corollary [\ref=coro:isPNF], so does the update of z. Since w has k prefix normal children, we charge the positive membership tests and the z-updates to the children, and the negative test to the current word. So for one word [formula], we get 3  ·  O(n)  +  O(1)  +  2  ·  O(1)  =  O(n) work.

Experimental results

In this section we present some theoretical and numerical results about the number of prefix normal words and their structure. These have become available thanks to the algorithm presented, which allowed us to generate [formula] up to length 50 on a home computer. Let [formula]. The following lemma follows from the observation that 1⌈n / 2⌉w is a prefix normal word of length n for all words w of length ⌊n / 2⌋.

The number of prefix normal words grows exponentially in n. We have that [formula].

The first members of the sequence [formula] are listed in [\cite=sloane2], and these values suggest that the lower bound above is not sharp. We turn our attention to the growth rate of [formula] as n increases. Note that [formula]. The lower bound follows form the fact that all prefix normal words can be extended by adding a 0 to the end, and the upper bound is implied by the prefix-closed property of [formula]. Fig. [\ref=figGrowth] (left) shows the growth ratio for small values of n. The figure shows two interesting phenomena: the values seem to approach 2 slowly, i.e., the number of prefix normal words almost doubles as we increase the length by 1. Second, the values show on oscillation pattern between even and odd values. We have so far been unable to establish these observations theoretically.

The structure of prefix normal words is also relevant for the generation algorithm, since the amortized running time of the algorithm is bounded above by the average value of the critical prefix length s + t taken over all prefix normal words. This differs from the expected critical prefix length of the prefix normal form of a uniformly random word. For the latter we have the following result.

Given a random word w, let [formula]. Let Z denote the critical prefix length of w'. Then for the the expected value of Z we have E(Z)  =  Θ( log n).

Write w'  =  1s'0t'γ' in the usual form, i.e. with [formula], and consider the random variables S' = s' and T' = t'. It is known that the expected maximum length of a run of 1s in a random word is Θ( log n)[\cite=GO80]. Clearly, S' equals the length of the longest run of 1s of w, thus Exp(S')  =  Θ( log n). To determine E(T'), consider a 1-run of w of maximum length s'. If w has at least another occurrence of 1, then there is a substring of w consisting of the maximal 1-run and one more 1; the number of 0's in this substring is an upper bound on t'. Since these 0s form a single 0-run, their number is again O( log n) in expectation. If on the other hand, all occurrences of 1 in w are in the maximal run, then w'  =  1s'0n - s', so t'  =  n - s'  ≤  n. The number of words with at most one 1-run is [formula]. So we have:

[formula]

The expected value of the critical prefix length for prefix normal words is shown in Fig. [\ref=figSTGrowth] (right) for n  ≤  50, on a loglinear scale. We conjecture that E(S + T) is polylogarithmic for prefix normal words. The linear alignment of the data points together with lemma [\ref=lemma:random_pnf_st] seems to support that.

Conclusion and Open Problems

We presented a new generating algorithm for prefix normal words, which produces all prefix normal words of length n in amortized linear time per word. Notice that the number of words that are not prefix normal also grows exponentially and greatly dominates prefix normal words (e.g., [formula]), so the gain of any algorithm that runs in amortized time per word, over brute-force testing of all binary words, is considerable. We believe, moreover, that our algorithm actually runs in time [formula] per word. This could be proved by showing that the expected critical prefix length of a prefix normal word is polylogarithmic in n.

In Sec. [\ref=sec:combgenpnw] we gave a linear time testing algorithm for words which are derived from a word w already known to be prefix normal, via a particular operation (swapping the last 1 of the first 1-run with a 0 in the first 0-run). This testing algorithm relies both on the knowledge that w is prefix normal, and on the presence of a data structure for w (the F-function). We pose as an open problem to find a strongly subquadratic time testing algorithm for arbitrary words. Another open problem is the computation of prefix normal forms. Solving this problem would lead immediately to an improvement for indexed binary jumbled pattern matching.

The observation that our language is a bubble language has opened up completely new roads. An efficient implementation of the generating algorithm led to new experimental results which were not available with our previous approach. The obtained data led to new conjectures and results. We are confident that the connection to bubble languages will also help in establishing theoretical results about the number and structure of prefix normal words, and could hopefully lead to a strongly subquadratic testing algorithm.

Appendix: Connection between prefix normal forms and binary jumbled pattern matching

The linear space solutions for binary pattern matching all rely on a simple property of binary strings, which we refer to as Interval Lemma (folklore): For a binary string w and any fixed length 1  ≤  k  ≤  |w|, if w has two substrings of length k, with one containing x 1s, and the other y 1s, where x < y, then, for any x  ≤  z  ≤  y, w also contains a substring of length k with exactly z 1s. In other words, all Parikh vectors of substrings of the same length build an interval. The lemma implies that in order to be able to answer existence jumbled pattern matching queries, it suffices to store, for every length k, the maximum and minimum number of 1s in any substring of length k: When querying whether w has a substring with Parikh vector (x,y), we can simply ask whether x lies between the maximum and minimum number of 1s for length x + y. This list of minima and maxima for every length is the linear size index used. The big open question is how to compute it faster than the current O(n2  /   log n) time.

Now, prefix normal forms of a word w can be used to compute this index. We know that two words have the same Parikh set (Parikh vectors of substrings) if and only if they have the same prefix normal forms both w.r.t. 1 and to 0 (see [\cite=FL11], Thm. 2).

In Fig. [\ref=fig:esempio], we present the word w = 10011011001001 and its prefix normal forms in a standard representation for binary words: Draw in the Euclidean plane the word w by representing each letter 1 by an upper unit diagonal and each letter 0 by a lower unit diagonal, starting from the origin (0,0). The region between [formula] and [formula] forms exactly the Parikh set of w. For example, all substrings of length 6 have one of the Parikh vectors (4,2),(3,3),(2,4).