Lemma Algorithm Corollary Conjecture Definition Example Problem Remark Proposition Why?

Cryptanalysis of Shifted Conjugacy Authentication Protocol

Introduction

Let Bn be the group of braids on n strands given by its standard Artin presentation and let B∞ be the group of braids on infinitely many strands generated by an infinite family [formula] subject to the same relations. There are several normal forms available for elements of Bn, e.g., Garside normal form [\cite=Epstein], or the Birman-Ko-Lee normal form [\cite=BKL]. For the purposes of this paper it is convenient to define the length of an element x∈Bn to be the length of its Garside normal form and denote it by |x|Δn.

For a braid word [formula] over the group alphabet of B∞ define a braid word

[formula]

The mapping w  ↦  d(w) induces a monomorphism of B∞ and is referred to as a shift operator. Now, for braids a,b∈B∞ define a braid a * b by

[formula]

The operator * :B∞  ×  B∞  →  B∞ is called the shifted conjugacy operator.

The Dehornoy authentication protocol is the following sequence of steps. First, Alice prepares her public and private keys. She randomly chooses elements s,p∈Bn, and computes [formula]. The element s is called her private key (to be kept secret) and the pair (p,p') is called her public key (to be published).

The protocol is a Fiat-Shamir-style [\cite=FS] authentication protocol in which a single round of the protocol is performed as follows:

Alice chooses a random r∈Bn and sends a pair (x,x') (called the commitment) to Bob, where x  =  r * p and x'  =  r * p'.

Bob chooses a random bit b (called the challenge) and sends it to Alice:

If b = 0 then Alice sends y = r to Bob, and Bob checks that the equalities x = y * p and x' = y * p' are satisfied.

If b = 1 then Alice sends y = r * s to Bob, and Bob checks that the equality x' = y * x is satisfied.

Noting that u * (v * w) = (u * v) * (u * w), it is straightforward to check that a correct answer y to a challenge leads to a successful check.

To break the system it is sufficient to find any s'∈Bn satisfying [formula]. Hence the security of this protocol is, in particular, based on the difficulty of the Shifted Conjugacy Search Problem (ShCSP) which is the following algorithmic question:

For a pair of braids p,p'∈B∞ find a braid s∈B∞ such that p'  =  s  *  p (provided that such s exists).

Similarly one can formulate the Shifted Conjugacy Decision Problem (ShCDP):

For a pair of braids p,p'∈B∞ determine if there exists a braid s∈B∞ such that p'  =  s  *  p.

These problems first appeared in [\cite=d] and were not explored enough to give a precise answer about their time complexity or even decidability (for the decision problem). Despite the resemblance to the conjugacy decision problem (CDP) which is decidable and suspected to have polynomial-time solution (see [\cite=BGM1], [\cite=BGM2]), it is not clear if ShCDP is solvable.

It is not discussed in Dehornoy's original paper [\cite=d] how to generate public and private keys, the author just proposes a primitive and provides some intuition on why the primitive might be hard. In this paper we use the easiest method of key generation: keys are chosen uniformly from the ambient free group and then considered as words in the braid group.

Fix the rank of the braid group n. It is an important parameter in the scheme, efficiency of all the operations depends on it.

Fix numbers L and K, the key lengths. These numbers are the main security parameters. (In all our experiments L = K.)

Pick randomly and uniformly a braid word p (resp. s) from the set of all braid words of length L (resp. K.)

Finally, compute [formula].

To summarize the results of our work:

Even though it seems unlikely that ShCSP can be deterministically reduced to CSP we argue that ShCSP can be reduced to CSP generically (for most of the inputs) and present the reduction.

We present the results of actual experiments. The following table shows the percentage of success in our experiment. The number of successes where the result was equal to the original key is in brackets. For instance, if the key length is 100 and the platform group is B40 then, using our attack, in 24% of cases we recovered an element s∈Bn such that p' = s * p and hence broke the protocol. In 10% of the cases the obtained element was equal to the original s∈Bn generated by Alice.

We analyze the results and make several recommendations on how to generate hard instances of ShCSP.

The paper is organized as follows. In Section [\ref=se:attack] we describe our heuristic algorithm and argue that it works for most inputs. In Section [\ref=se:exper_results] we present more detailed results of experiments (than in the table above), discuss the reasons for success/failure, and make suggestions on the generation of hard keys.

All the algorithms described in this paper are available at [\cite=CRAG].

The attack

In this section we present the mathematical background for the attack. For [formula] define braids

[formula]

[formula]

It is easy to check that for any [formula] the following equality holds in Bn + 1:

[formula]

Let p,p',s∈Bn. Then s satisfies the shifted conjugacy equation for p and p'

[formula]

if and only if it satisfies the conjugacy equation for p'δ- 1n + 1 and d(p)σ1δ- 1n + 1

[formula]

Follows from ([\ref=eq:equat0]).

Let p,p',s∈Bn be braids satisfying p' = Bn + 1s * p, and let s'∈Bn + 1. Then

[formula]

where [formula] denotes the centralizer of d(p)σ1δ- 1n + 1 in Bn + 1.

Obvious.

Now, it follows from Propositions [\ref=pr:problem_equivalence] and [\ref=pr:problem_solving] that the ShCSP can be solved in two steps:

Find a solution s'∈Bn + 1 of the equation p'δ- 1n + 1  =  Bn + 1s'  ·  d(p)σ1δ- 1n + 1  ·  s'- 1. This can be done using the ultra summit set technique invented in [\cite=G].

"Correct" the element s'∈Bn + 1 to obtain a solution s∈Bn of ([\ref=eq:equat1]), i.e., find a suitable element [formula] such that t  =  s'c∈Bn satisfies ([\ref=eq:equat1]). We refer to this step as a centralizer attack.

The description of ultra summit sets is out of the scope of our paper, so we omit details on step (S1). Step (S2) requires some elaboration. To be able to work with elements of [formula] efficiently we need to describe C in some convenient way, for instance, by providing a set of generators. Hence, step (S2) itself consists of two smaller steps: capturing C and finding the required element c∈C.

The only known algorithm [\cite=GM-centr] for computing a generating set for a centralizer reduces to the construction of so-called super summit sets, the size of which is not known to be polynomially-bounded, and which is usually hard in practice. Hence, the approach of describing the whole generating set does not seem feasible. Instead, we can work with the subgroup of [formula] considered in Proposition [\ref=pr:subgp_C]. For p∈Bn define braids:

[formula]

and

[formula]

Let p∈Bn and [formula]. The following holds:

c1,c2,c3∈C,

[formula] is an abelian subgroup of Bn + 1 and, hence, has polynomial growth.

Observe that the equality

[formula]

holds in Bn + 1 and the element [formula] involves generators [formula] only. It is intuitively obvious that c2 commutes with c3 when you observe that in the braid diagram for c3 none of strands 2 to n cross over. Furthermore, c1 generates the center of Bn + 1. Thus, the subgroup C' is abelian.

Now, having fixed the subgroup [formula] we can describe the heuristic procedure for finding the required c∈C'. For any braid t∈Bn define

[formula]

and observe that t  =  s'c satisfies [formula] if and only if lt  =  0 and the value of lt can be used to guide our heuristic search, the smaller lt the "closer" t to the actual solution.

We summarize the ideas of this section into an heuristic algorithm (Algorithm [\ref=al:attack]) which for a pair of braids p,p'∈Bn attempts to find s∈Bn such that [formula]. The algorithm starts out by finding a solution s' to the conjugacy equation ([\ref=eq:equat2]). It keeps two sets: S (elements in working) and M (worked out elements) of pairs (t,lt) where t∈Bn + 1 is a possible solution and [formula]. Initially, we have S  =  {(s',ls')}, where s' is found in step (S1) and [formula]. On each iteration we choose a pair (t,lt) from S with the smallest value lt (the "fittest" one). If lt  =  0 then t is a solution. If lt  ≠  0 then compute new possible solutions ti  =  tci and add corresponding pairs (ti,lti) into S. After all (ti,lti) are added to S the current pair (t,lt) becomes worked out.

Experimental results

Algorithm [\ref=al:attack] always produces the correct answer when it halts, though it does not always stop. There are two possible reasons for a failure.

Failure on step A. The precise complexity of the ultra summit set algorithm is not known, though it is proved that for certain classes of braids it is polynomial. But even if it is polynomial, the degree of a polynomial can be too large to be used in practical computations.

Failure in the loop C. There are two possible reasons for this. The first reason is that we use a subgroup C' of [formula] which can be a proper subgroup and it might not contain the required element.

The second reason is that the heuristic based on the length [formula] might be bad.

To test the efficiency of the algorithm we performed a series of experiments in which we limited the time allowed for each part: 1 hour for step A and 15 minutes for step C on a personal computer (CPU 2.66 GHz). The percentage of success in experiments for different parameters is shown in Table [\ref=tb:success]. Below we present detailed information on each step of computations.

Recall that in step A we solve the conjugacy search problem for braids p'δ- 1n + 1 and d(p)σ1δ- 1n + 1 in Bn + 1. The percentage of failure on step A is shown in Table [\ref=tb:failure_A]. We see that the shorter the length of the key p relative to the rank of the braid group the harder it becomes to solve the conjugacy search problem. We cannot explain this phenomenon, the method of ultra summit sets is very difficult to analyze. We suspect that the reason for such behavior is that shorter words are less likely to be rigid (expose free-like behavior when cycling.)

The percentage of failure in loop C of Algorithm [\ref=al:attack], given that step A was successfully completed, is shown in Table [\ref=tb:failure_C]. Essentially, we see the same pattern of failure as in the solution of the conjugacy problem in Table [\ref=tb:failure_A]. The shorter the length of the key relative to the rank of the braid group the harder it is to find a suitable element of the centralizer. These results are easier to explain. Basically the shorter the key the bigger the centralizer. Hence, for shorter elements it is more likely that C' is a proper subgroup of [formula] and less likely that C' actually contains the required element c.

Conclusions

In this section we discuss methods of key generation invulnerable to the attack proposed in Section [\ref=se:attack]. Recall that the success of the attack relies on two properties of braids p, p':

the conjugacy search problem is easy for the pair (p'δ- 1n + 1,d(p)σ1δ- 1n + 1) in Bn + 1;

the centralizer CBn + 1(d(p)σ1δ- 1n + 1) is "small" (isomorphic to an Abelian group of small rank.)

If either of the two properties above is not satisfied then the attack is likely to fail. Even though there is no known polynomial time algorithm solving CSP for braids, recent developments of [\cite=BGM1] and [\cite=BGM2] suggest that CSP might be easy for generic braids (pseudo-Anosov type) and it might be difficult to randomly construct hard instances for CSP. Though there is no proof yet that the pseudo-Anosov type of braids is generic it is a common belief that this is so. Another interesting recent development is [\cite=KLT] where the authors present a few braids with very large ultra summit sets.

The only part which can be controlled is the growth and structure of the centralizer C. As we mentioned above the only known algorithm for computing a generating set for a centralizer reduces to construction of super summit sets which is not known to be polynomially hard and is usually very inefficient practically. We can choose p so that C(d(p)σ1δ- 1n + 1) is a large non-Abelian group. For more on the structure of centralizers see [\cite=GMW]. For ideas on how to generate elements with large centralizers see [\cite=su].