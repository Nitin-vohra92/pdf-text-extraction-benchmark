Lemma Claim Corollary

.sty

Bounded-Contention Coding for Wireless Networks in the High SNR Regime

Massachusetts Institute of Technology, Computer Science and Artificial Intelligence Laboratory and Research Laboratory of Electronics. ckeren@csail.mit.edu, haeupler@mit.edu, lynch@csail.mit.edu, medard@mit.edu.

Efficient communication in wireless networks is typically challenged by the possibility of interference among several transmitting nodes. Much important research has been invested in decreasing the number of collisions in order to obtain faster algorithms for communication in such networks.

This paper proposes a novel approach for wireless communication, which embraces collisions rather than avoiding them, over an additive channel. It introduces a coding technique called Bounded-Contention Coding (BCC) that allows collisions to be successfully decoded by the receiving nodes into the original transmissions and whose complexity depends on a bound on the contention among the transmitters.

Introduction

Handling interference in wireless networks is a fundamental challenge in designing algorithms for efficient communication. When two devices that are near each other transmit at the same time the result is a collided signal. In order to enable the receivers to obtain the original information that was sent, thereby achieving efficient communication that allows the design of fast algorithms for wireless networks, much important research has been invested in scheduling the transmissions in a way that avoids collisions as much as possible.

Avoiding collisions basically requires some type of symmetry breaking among the nodes that want to transmit, to prevent them from transmitting at the same time. Simple solutions like Time Division Multiple Access (TDMA), which assigns predetermined slots according to node IDs, are expensive in situations where not all of the nodes want to transmit, since their costs depend on the total number of nodes rather than on the number of actual transmitters. One can improve this solution by allowing nodes that cannot interfere with each other to share a slot, so that the number of slots depends on the node degrees in the network graph rather than on the total number of nodes. However, this requires the nodes to have information regarding the topology of the network, and is still expensive in cases where the contention is less than the node degrees. One successful approach for avoiding collisions in wireless networks is to allow each node to use a schedule of probabilities to decide whether to transmit at each time slot [\cite=BarYehudaGI87] [\cite=KowalskiP2005] [\cite=CzumajR2003]. These algorithms typically guarantee a high probability of successful transmissions after some bounded number of attempts.

In this paper we provide a coding framework for coping with collisions in a wireless communication model abstraction called the finite-field additive radio network model, where a collision of transmissions optimally coded for an Additive White Gaussian Noise (AWGN) channel with multiple-user interference is represented to be equivalent to the element-wise XOR of a string of bits representing the original transmissions. More generally, collisions can be modelled as being equivalent to the sum, symbol-wise, of the elements of vectors over a finite field, where the transmission of a user is represented as a vector in that finite field, the XOR case being the special case where the field is [formula]. Such a model has been shown to be approximately valid in a high SNR (signal-to-noise ratio) regime, abstracting away the effect of noise in the channels and allowing us to concentrate on the theoretical aspects of the interference among transmissions. Such a model in effect replaces the traditional information-theoretic setting of Gaussian inputs for an AWGN channel with an approximate finite algebraic construct [\cite=KimEYM2011] [\cite=AvestimehrDT2011]. Such additive models have been shown, albeit without a finite field construct, to be effective in high SNR settings even in the absence of underlying capacity-achieving codes, for instance in such systems as zig-zag decoding [\cite=GollakotaK08], which can be modelled algebraically [\cite=ParandehGheibiS10].

In this case, the transmissions are considered to be, instead of vectors, polynomials in delay (say a D-transform or z-transform of the transmission). The receivers then see, after collision, a linear combination of the inputs ponderated by various powers in delay (say powers in D or z), corresponding to the delays that arise from asynchronous starting times for the transmissions. A number of such linear combinations equal to the number of initial transmissions allows decoding, which then becomes simple solving simultaneous equations.

In this additive model, our key observation is that only if not all messages are valid transmissions then a sum representing a collision might indeed be uniquely decodable. However, we do not wish to restrict the information the users may send in the wireless system. Instead, we propose encoding the information sent into restricted sets of signals that do allow unique decoding when they collide. A node receiving a collision can then uniquely decode the signal to obtain the original unrestricted messages. Clearly, for information-theoretic reasons, we cannot hope to restrict the transmissions without the cost of some overhead in the amount of information sent. The challenge, then, is to find codes that allow unique decoding in the above setting with the shortest possible codewords. Under our high SNR assumption, we consider both half-duplex (sometimes termed time-division duplex - TDD) and full-duplex channels. While the TDD model is by far the most common current mode of operation, high SNR conditions can allow full-duplex operation.

Our contributions

The Bounded-Contention Coding (BCC) Framework:

We define a new class of codes, which are designed for settings in which the number of transmitters is bounded by a known constant a. Each such code consists of an individual code for each node, and has the desirable property that, when codewords from at most a different transmitting nodes are summed up, the result can be uniquely decoded into the original transmissions. This decoding process does not require that the nodes know the identities of the transmitters. Moreover, the active nodes may change from round to round. We show simple constructions of Bounded-Contention Codes, where the length of the codewords depends on both the known contention bound and the total number of nodes, but the dependency on the total number of nodes is only logarithmic.

Distributed computation using BCC:

Using the new Bounded-Contention Coding technique, we show how to obtain local and global broadcast in both single-hop and multi-hop networks. BCC enables deterministic local broadcast in a network with n nodes and at most a transmitters with information of [formula] bits each within [formula] bits of communication with full-duplex radios, and [formula] bits, with high probability, with half-duplex radios. When combined with random linear network coding, BCC gives global broadcast within [formula] bits. These results also hold in highly dynamic networks that can change arbitrarily over time under the control of a worst-case adversary.

Further, we show how to remove the assumption that the nodes know a bound a on the contention, by developing a method for handling unknown contention (or contention that varies over space and time), which is common in wireless networks. Also, while it may be reasonable to assume a bound on the contention, it is often the case that the actual contention is much smaller.

Related work

The finite-field additive radio network model of communication considered in this paper, where collisions result in an addition, over a finite field, of the transmitted signals, was previously studied in [\cite=AvestimehrDT2011] [\cite=KimEYM2011], where the main attention was towards the capacity of the network, i.e., the amount of information that can be reliably transmitted in the network. While the proof of the validity of the approximation [\cite=AvestimehrDT2011] is subtle, the intuition behind this work can be readily gleaned from a simple observation of the Cover-Wyner multiple access channel capacity region. Under high SNR regimes, the pentagon of the Cover-Wyner region can, in the limit, be decomposed into a rectangle, appended to a right isosceles triangle [\cite=KimEYM2011]. The square can be interpreted as the communication region given by the bits that do not interfere. Such bits do not require special attention. In the case where the SNRs at the receiver for the different users are the same, this rectangle vanishes. The triangular region is the same capacity region as for noise-free additive multiple access channel in a finite field [\cite=EffrosM03], leading naturally to an additive model over a finite field.

Note that, while we consider an equivalent additive finite-field additive model, this does not mean our underlying physical network model is reliant on symbol-wise synchronization between the senders. Asynchrony among users does not affect the behavior of the underlying capacity region [\cite=HH85], on which the approximate model is predicated. Nor are users required to have the same received power in order to have the finite-filed equivalence hold - differences in received power simply lead to different shapes of the Cover-Wyner region, but the interpretation of the triangular and rectangular decomposition of the Cover-Wyner region is not affected. Moreover, our assumption of knowing the interfering users is fairly standard in multiple access wireless communications. Issues of synchronization, SNR determination and identification of users are in practice handled often jointly, since a signature serves for initial synchronization in acquiring the signal of a user, for measuring the received SNR and also for identification of the transmitting user. Finally note that, as long as we have appropriate coding, then the Cover-Wyner region represents the region not only for coordinated transmissions, but also for uncoordinated packetized transmissions, such as exemplified in the classical ALOHA scheme [\cite=Metal04]. This result, which may seem counterintuitive, is due in effect to the fact that the system will be readily shown to be stable as long as the individual and sum rates of the Cover-Wyner region will exceed the absolute value of the derivative of an appropriately defined Lyapunov function based on the queue length of a packetized ALOHA system.

There has been work on optimization of transmissions over the model of [\cite=AvestimehrDT2011]. These approaches [\cite=GoemansI09] [\cite=AmaudruzF09] [\cite=ShiR10] generally provide algorithms for code construction or for finding the maximum achievable rate, for multicast connections, over a high SNR network under the model of [\cite=AvestimehrDT2011]. The approach of [\cite=KimEYM2011] [\cite=ErezX10] [\cite=KimM10] considers a more general finite-field model and reduces the problem to an algebraic network coding problem [\cite=KoetterM03]. Random code constructions, inspired from [\cite=HoM06] are then with high probability optimal. These approaches differ from our work in this paper in that they are interested in throughput maximization in a static model rather than completion delay when multiple transmission rounds may occur. We are interested in the latter model and, in particular, in how long it takes to broadcast successfully a specific piece of information.

There are many deterministic and randomized algorithms for scheduling transmissions in wireless networks. They differ in some aspects of the model, such as whether the nodes can detect collision or cannot distinguish between a collision and silence, and whether the nodes know the entire network graph, or know only their neighbors, or do not have any such knowledge at all. Some papers that studied local broadcast are [\cite=KomlosG1985] [\cite=CzyzowiczGKP2011], where deterministic algorithms were presented, and [\cite=Martel94] [\cite=JurdzinskiS2002] [\cite=BienkowskiKKK2010], which studied randomized algorithms.

In the setting of a wireless network, deterministic global broadcast of a single message was studied in [\cite=KowalskiP2005] [\cite=DeMarco2010] [\cite=CzumajR2003], the best results given being O(n log n) and O(n log 2D), where D is the diameter of the network. Bar-Yehuda et al. [\cite=BarYehudaGI87] were the first to study randomized global broadcast algorithms. Kowalski and Pelc [\cite=KowalskiP2005] and Czumaj and Rytter [\cite=CzumajR2003] presented randomized solutions based on selecting sequences, with complexities of [formula]. These algorithms match lower bounds of [\cite=KushilevitzM1993] [\cite=AlonBNLP1991] but in a model that is weaker than the one addressed in this paper. The algorithms mentioned above are all for global broadcast of one message from a known source. For multiple messages, a deterministic algorithm for k messages with complexity O(k log 3n + n log 4n) appears in [\cite=ChlebusKPR2011], while randomized global broadcast of multiple messages was studied in [\cite=Bar-yehuda93multiplecommunication] [\cite=KKKL-DialM] [\cite=KhabbazianKowalski-podc11]. We refer the reader to an excellent survey on broadcasting in radio networks in [\cite=Peleg_2007].

Wireless networks are not always static; for example, nodes may fail, as a result of hardware or software malfunctions. Tolerating failed and recovered components is a basic challenge in decentralized systems because the changes to the network graph are not immediately known to nodes that are some distance away. Similarly, nodes may join and leave the network, or may simply be mobile. All of these cases result in changes to the network graph that affect communication. Depending on the assumptions, these changes can be quite arbitrary. Having a dynamic network graph imposes additional challenges on designing distributed algorithms for wireless networks. Dynamic networks have been studied in many papers. The problems addressed include determining the number of nodes in the network, gossiping messages, data aggregation, and distributed consensus [\cite=KuhnLO2010] [\cite=CN10] [\cite=KuhnOshman-disc11] [\cite=KMO-podc11]. For global broadcast, some papers assume restrictions on the changes made in each round. For example, [\cite=ClementiMPS2009] consider graph changes that are random. They also consider the worst-case adversary, as do the studies in [\cite=KuhnLO2010] [\cite=ODellW2005]. In [\cite=KuhnLO2010] collisions are abstracted away, so that edges of the network graph do not represent nodes that hear the transmissions, but nodes that actually obtain the message. In [\cite=HaeuplerKarger], the authors show how to use network coding in order to obtain more efficient algorithms for global broadcast in this dynamic model.

Network Abstraction

We consider a wireless network where the transmission of a node is received at all neighboring nodes, perhaps colliding with transmissions of other nodes. Formally, the network is represented by an undirected graph G = (V,E), where |V| = n. We denote by N(u) the subset of V consisting of all of u's neighbors in G and by D the diameter of the network. The network topology is unknown.

We address two different radio models. One is the full-duplex model, in which nodes can listen to the channel while transmitting. The second is the half-duplex mode, in which at every time, a node can either transmit or listen to the channel. A transmission of a node v∈V is modeled as a string of bits s̄v. The communication abstraction is such that the information received by a listening node u∈V is equal to [formula], where the operation [formula] is the bit-wise XOR operation.

The model is further assumed to be synchronous, that is, the nodes share a global clock, and a fixed slot length (typically [formula]) is allocated for transmission.

Most of the paper assumes a bound a  ≤  n on the contention that is known to all nodes. However, the actual contention in the network, which we denote by a', may be even smaller than a. Each node has a unique ID from some set I of size |I| = N, such that N = nO(1).

Bounded-Contention Codes

To extract information from collisions, we propose the following coding technique for basic Bounded-Contention Coding, in which each node encodes its message into a codeword that it transmits, in such a way that a collision admits only a single possibility for the set of messages that produced it. This enables unique decoding.

An

[formula]

As a warm-up, we start by giving an example of a very simple BCC-code. This is the code of all unit vectors in {0,1}M, i.e., [formula]. It is easy to see that C is an

[formula]

-BCC-codes works as follows.

BCC construction: Let D be a linear code of words with length M and Hamming weight at least 2a + 1. Let [formula] be a basis for the dual code [formula] of D. Let H be the m  ×  M parity-check matrix of D, i.e., the matrix whose rows are [formula], and let C be the set of columns of H. We claim that C is the desired BCC-code.

The code C constructed above is an

[formula]

It is clear from the construction that there are M codewords in C, each of length m. Assume that C is not an

[formula]

-BCC-code.

As the following sections will show, we need

[formula]

-BCC code with m = O(a log M).

The Gilbert-Varshamov bound [\cite=Roth2006] says that [formula] for codes of length M, dimension k, and minimum Hamming distance d. This implies that [formula] which is [formula]. In our notation, this gives m  =  O(a log M). A greedy algorithm that repeatedly adds as a codeword an element of {0,1}M that is not in a ball of distance d around any previously chosen codeword clearly attains the Gilbert-Varshamov bound. A slight modification also produces such a code that is also linear (see, e.g., [\cite=Roth2006]). By Lemma [\ref=lemma:dual-code], using this in the above BCC construction gives an

[formula]

Lemma [\ref=lemma:code-exist] implies, for example, that there are BCC-codes with a = Θ( log M) and m = O( log M  ·   log M) = O( log 2M). As explained earlier, for solving the problem of local broadcast, the parameters a and m correspond to the contention and the transmission length, respectively. As we show in the next section, such BCC-codes with polylogarithmic parameters are well-suited for the case of bounded contention, hence we refer to them as Bounded-Contention Codes.

In fact, the BCC-codes presented above are optimal, since Ω(a log M) is a lower bound for m. The reason for this is that each XOR needs to uniquely correspond to a subset of size at most a out of a set of size M. The number of such subsets is [formula], therefore each codeword needs to have length [formula].

Local Broadcast

This section shows how to use BCC-codes for obtaining local broadcast in the additive radio network model. The simplest way to illustrate our technique is the following. Assume that in every neighborhood there are at most a participants, and each node needs to learn the IDs of all participants in its neighborhood. The nodes use an

[formula]

Single-hop Networks

For the case of a single-hop network, the graph G is a complete graph: in each time slot every listening node receives an XOR of all the strings transmitted in this slot by all other nodes in the network. We assume a bound a on the contention, but our approach allows a slight improvement by being adaptive to the actual number of transmitters, a', rather than only depending on its bound, a. We do this by assigning a few slots for the purpose of just finding out which are the nodes that want to transmit and agreeing on an allocation of slots for them in which each transmitter v will transmit alone, guaranteeing that all other nodes receive its data sv successfully. We start with the full-duplex model, which means that nodes can listen and transmit at the same time.

Since this is a single-hop network, all nodes receive [formula], where S∈V is the set of nodes that want to transmit. Recall that we are assuming only small contention in the network, which means formally that |S|  =  a'  ≤  a. Since C is an

[formula]

-BCC code C and every node v is assigned [formula] codewords [formula] for it to use. This implies that the length of the codewords is [formula]. Notice that this is optimal since a log n is required in order to distinguish subsets of size a among n nodes, and the [formula] term cannot be avoided if a nodes transmit [formula] bits each.

With half-duplex radios, we let each node choose whether it listens or transmits (if needed) with probability 1 / 2. This gives that for every message and every node v, in each round there is probability 1 / 4 for the message to be transmitted and heard by v. In expectation, a constant number of rounds is needed for v to hear any single message, and using a standard Chernoff bound implies that O( log n) rounds are needed with high probability. Finally, a union bound over all n nodes and all messages gives the following theorem.

In a multi-hop network with at most a transmitters with information of [formula] bits each in each N(u), local broadcast can be obtained within [formula] bits, with high probability.

Global Broadcast

In this section we show how to obtain global broadcast by combining BCC and network coding. We assume that at most a nodes have a message of [formula] bits each that needs to be received by all nodes of the network. We first briefly introduce random linear network coding (RLNC) as a solution to the global broadcast problem in additive radio networks and then, in Subsection [\ref=subsec:RLNC+BCC], show how BCC can significantly reduce the coding coefficient overhead of RLNC when a <  < n.

Random Linear Network Coding

RLNC is a powerful method to achieve optimal global broadcast, in particular in distributed networks in which nodes cannot easily coordinate to route information through the network. Instead of sending pieces of information around directly, RLNC communicates (random) linear combinations of messages over a finite field Fq. In this paper we will choose the field size q to be 2 which allows us to see vectors in Fq simply as bit-vectors and linear combinations of vectors as XORs.

We denote with [formula] the message sent out by node u and denote with S the set of at most a nodes that initially have a message. Given this, any packet sent out during the RLNC protocol has the form [formula] where μ∈FN2 is a coefficient vector indicating which messages are XOR-ed together in the second portion of a packet, i.e., a characterizing vector. We call packets of this form valid. A node u that initially starts with a message mu treats this message as if it received the packet (eu,mu) before round one, where eu is the standard basis vector corresponding to u (that is, with a one at the coefficient corresponding to u, and zeros otherwise). During the protocol, each node that is supposed to send a packet takes all packets it has received so far and includes each of them independently with probability 1 / 2 in the new packet. The new packet is formed by taking the XORs of all packets selected in this way (if no packet is selected the node remains silent or alternatively sends the all zero vector). Nodes decode by using Gaussian elimination. This can be done if and only if a node has received a valid packets with linearly independent coefficient vectors. We note that, because of linearity, all initial packets and all packets created during the RLNC protocol are valid. More importantly, if multiple neighbors of a node send valid packets then the XOR of these packets which is received is also valid since the coefficient vectors and the message part XOR separately and component-wise. This makes RLNC a simple but powerful tool for exploiting the linear and additive nature of the additive radio networks we study in this paper.

We analyze the complexity of this RLNC scheme when used on top of an additive radio network. As in Section [\ref=sec:local-bcast], nodes can either transmit or listen to the channel at any given round since they have half-duplex radios. We use the above RLNC algorithm together with the strategy of choosing in each round whether to transmit or listen at random with probability 1 / 2.

We show that the RLNC protocol achieves an optimal round complexity of O(D  +  a  +   log n) with high probability. Our proof is based on the projection analysis technique from [\cite=Haeupler2011] but we give a simple, self-contained proof here. The reason that the analysis carries over from a message passing model to the radio networks considered here so easily is their additivity. In particular, we use the effect that the XOR of randomly selected packets sent out by several neighbors which get XORed in the air are equivalent to the XOR of a random selection of packets known to at least one neighbor.

RLNC disseminates all a messages, with high probability, in O(D  +  a  +   log n) rounds in which messages of [formula] bits are sent in each round.

We say a node knows a coefficient vector μ∈FN2 if it has received a packet with a coefficient vector that is non-perpendicular to μ (over GF(2)). We claim that for any non-zero vector μ the probability that any fixed node v does not learn μ within O(D  +  a  +   log n) rounds is at most 2- (a  +  2 log n). Then, a union bound over all nodes and all 2a coefficient vectors in μ∈Fa2 initially shows that, with high probability, all nodes know all vectors in the span of the messages given away initially. Finally, it is then easy to conclude that all nodes can decode.

To prove this claim we look at a shortest path P from v to a node that initially knows μ (i.e., starts with a message with a non-zero coefficient in μ). At any round t, let node u be the closest node to v on P that knows μ. There is a 1 / 2 chance that u sends and an independent 1 / 2 chance of 1 / 2 that u sends out a packet with a coefficient vector that is non-perpendicular to μ. Thus, in any round independently with probability at least [formula] knowledge of μ makes progress on P. Therefore, in 32(D  +  a  +   log n) rounds the expected number of rounds that make progress is 8(D  +  a  +   log n). A standard Chernoff bound shows that the probability that less than D progress is made in these 32(D  +  a  +   log n) rounds is at most 2- (a  +  2 log n) as claimed.

Reducing the Overhead of Random Linear Network Coding via BCC-Codes

Note that shows that RLNC has an essentially optimal round complexity. In particular, Ω(D) is a trivial lower bound since information passes at most one step in the network per round and Ω(a) is a lower bound too since in each round at most [formula] bits worth of information messages are received while [formula] bits need to be learned in total. Lastly, the Ω( log n) factor is tight for the proposed algorithm, too, because of the randomness used. On the other hand, the packets sent around have size [formula] while carrying only [formula] bits of information about the messages. Note that N  >  n and in many cases [formula] for some constant c which renders the standard RLNC implementation highly inefficient.

The reason for this is that we use an N bit vector as a header to describe the set of IDs of nodes whose message is coded into the packet. This vector is always extremely sparse since at most n <  < N nodes are present and at most a <  < n nodes are sending a message. Instead of writing down a vector as is one could thus try to use a short representation of these sparse vectors. Writing down only the IDs of the non-zero components would be such a sparse representation (with almost optimal bit size a log N) but does not work here, because when multiple neighbors of a node send sparse coefficient vectors their received XOR cannot be uniquely decoded. BCC-codes solve exactly this problem, by providing a sparse vector representation:

Let I be an ID set of size N and a be a sparseness parameter. Any

[formula]

The following two properties make this representation so useful (in particular in this context):

Let I be an ID set of size N, a be a sparseness parameter and s be a sparse vector representation induced by a BCC-code C. For any two vectors μ,μ'∈FN2 with at most a non-zero components we have:

Unique Decodability: [formula].

Homomorphism under addition: s(μ)  +  s(μ')  =  s(μ  +  μ').

Replacing the coefficient vectors μ in the RLNC scheme with their sparse representation leads to the much more efficient RLNC+BCC scheme.

As in the RLNC protocol, we denote with [formula] the message sent out by node u and denote with S the set of at most a nodes that initially have a message. Any packet sent out during the RLNC+BCC protocol has the form [formula] where μ∈Fa log N2 is a coded coefficient vector indicating which messages are XOR-ed together in the second portion of a packet, i.e., it holds the XOR of the BCC-codewords of the IDs of the messages. As before, each node that is supposed to send a packet takes all packets it has received so far and includes each of them independently with probability 1 / 2 in the new packet. The new packet is formed by taking the XORs of all packets selected in this way, preceded by the corresponding coded coefficient vector. Nodes decode by using Gaussian elimination, which can be done if and only if a node has received a valid packets with linearly independent coefficient vectors. We note that, because of linearity, all initial packets and all packets created during the RLNC protocol are valid. Unlike having a list of IDs as a sparse representation of the coefficient vector, the power of BCC here is that if multiple neighbors of a node send valid packets then the XOR of these packets which is received is also valid since the BCC-coded coefficient vectors and the message part XOR separately and component-wise. Formally, the algorithm is identical to RLNC, except that the set Su of messages received by node u is initialized to (C(u),mu) instead of (eu,mu), and the node listens for [formula] bits, rather than [formula].

RLNC+BCC disseminates all a messages, with high probability, in O(D  +  a  +   log n) rounds in which messages of [formula] bits are sent in each round.

Dynamic Networks

In this section, we consider the case of a highly-dynamic network with a worst-case adversary: in every round, that is, between the times nodes send packets, the network graph is determined by the adversary, which observes the entire computation so far when deciding upon the graph for the next round. Notice that all of the above results for local broadcast hold for such dynamic networks, given that a slot length is sufficiently long in order to contain the required information. This is, for example, [formula] bits in the full-duplex model, which is reasonable to assume if a and [formula] are not too large. We get absolute guarantees for local broadcast in this highly dynamic setting, while existing work on avoiding collisions in radio networks cannot achieve this since they require probabilistic transmissions.

Next, we generalize the RLNC+BBC framework for the case of this highly-dynamic network with a worst-case adversary. The only restriction is that the graph has to be connected in every round. The proof of the resulting theorem is essentially the same as for the static case but instead of arguing that every message makes progress over a shortest path P, we argue that it makes some progress since the graph is always connected. Hence D is replaced by n in the number of rounds needed.

In a dynamic additive radio network controlled by an adaptive adversary subject to the constraint that the network is connected at every round, RLNC+BCC achieves global broadcast of a messages, with high probability, in O(n  +  a  +   log n) rounds using a packet size of [formula] bits.

Let S be a set of a messages. We first analyze the algorithm given that a is known, and then use the same estimation technique as before to address the case of an unknown a. For a coefficient vector μ∈Fa2 we measure progress by counting how many nodes know about it. Clearly, initially at least one node knows about μ, while we want all n nodes to know about it in the end. If in a round r this is not achieved yet, we claim that there is a probability of at least 1 / 4 for at least one more node to learn μ. This is true because the graph is connected and hence there is at least one node v that knows μ which is connected to a node u that does not know μ. As before, the node u has a probability of at least 1 / 4 to learn μ in this round r. As in the proof of , a Chernoff bound shows that the probability that there were not enough (less than n - 1) such successes in 32(n  +  a  +   log n) rounds is at most 2- (a  +   log n). Finally, a union bound over all 2a vectors completes the proof. For an unknown a, the same estimation technique works here since we only require progress through some path to every node, which is promised since the graph is connected at every round.

Estimating the Contention

We have given an almost optimal scheme for achieving global broadcast when the number of senders a (or a good upper bound on it) is known a priori. This assumption is not an unreasonable one, for example, if network statistics show such behavior. However, in many cases, local contention may differ at different places throughout the network, or vary over time. It may also be that the known bound is pessimistic, and the actual contention is much smaller than this bound. In this section, we show a method for removing this assumption by using BCC-codes to quickly determine a (and also reveal the identity of all senders).

The mechanism we present allows for estimating the current contention and then using a code that corresponds to that estimate. A standard way to obtain a good estimation of contention is by having the nodes double a small initial guess until they succeed in local broadcast. In our BCC framework, the tricky part of this approach is to identify success. Specifically, using a bounded-contention code with parameter a for a set S of k > a transmitters may produce an XOR that is a valid XOR of some set S' of k'  ≤  a transmitters. Hence, the nodes need to be able to distinguish between such a case and the case where S' is the true set of transmitters.

The idea behind our algorithm is simple. We use an

[formula]

Discussion

This paper presents a coding technique for additive wireless networks, which allows efficient local and global broadcast given a bound on the amount of contention. It also shows how to estimate the contention when it is not known in advance. The results hold also for dynamic networks whose arbitrary changes are controlled by a worst-case adversary. For full-duplex radios, it gives a deterministic framework providing absolute guarantees.

Directions for further research include using BCC-codes for solving additional distributed problems in the additive wireless network model, and handling extensions to the model, such as noise and asynchrony.