Direct deconvolution of radio synthesis images using L1 minimisation

Introduction

There has been significant interest and activity in new algorithms for the synthesis of images from radio interferometric measurements over the last 10 years, driven by the conceptualisation, design and partial commissioning of several new radio observatories that have significantly different scale and coverage than those in the past. New facilities such as the Australian Square Kilometre Array Precursor (ASKAP), the Low Frequency Array, the Murchison Widefield Array (MWA) all share the characteristic of generating huge amounts of observational data, as well as each having unique challenges due to their individual design choices.

One of the basic challenges shared by each of these facilities is the non-coplanar baseline effect. This effect is present for any radio interferometer that has baselines that are not aligned in the E-W direction. For these baselines, the rotation of the earth moves the baselines of the telescopes into planes that are tilted with respect to their initial orientation. This introduces a component of the baseline in the direction of the source (the w-component) that leads to a defocus effect that must be compensated for during image processing. This effect becomes more important for wider fields of view, longer baselines and lower frequencies (due to the wider field of view). There are a variety of established methods for dealing with the non-coplanar base effect, for instance, the W-projection algorithm ([\cite=Cornwell:2005p1977]) and W-snapshots ([\cite=Cornwell:2012p1785]).

Another important effect, particularly for the low frequency instruments, is that of direction dependent gains. In most radio telescopes, the gain of the antenna is largely a function of the direction angles relative to the pointing direction. This is described by the pattern of the primary beam, A(l,m), where l and m are direction cosines relative to the pointing direction. However, there is also some dependence on the absolute pointing direction of the telescope relative to the ground, making the pattern of the primary beam a function of the zenith angle, Z, and parallactic angle, χ, as well. For electronically steered low frequency telescopes such as the MWA, highly accurate compensation for this effect is a key issue.

In this paper we introduce an algorithm for synthesis image deconvolution called SL1M (Synthesis through L1 Minimisation), that can deal with arbitrary collections of non-zero coplanar baselines and direction dependent gains.

Three major approaches to image deconvolution in radio synthesis astronomy have been taken in the past. By far the most prevalent of these is the family of algorithms based on the work of [\cite=Hogbom:1974p2738] called CLEAN. For this family of algorithms, it is assumed that the image can be represented as a small set of sources, either points sources in the original approaches, or extended sources as is the case in multi-scale CLEAN ([\cite=Cornwell:2008p1783]). For the classic CLEAN algorithm, the image is reconstructed by iteratively determining the point source that best fits the observed visibilities and adding some fraction of best fit flux from that source to the image. This process is repeated until some convergence requirement is met. It was shown by [\cite=Marsh:1987uc] that for sufficiently separated point like sources, the CLEAN algorithm is equivalent to solving the deconvolution problem by fitting the observed visibilities while minimising the total reconstructed flux intensity (that is, the sum of the pixels intensities of the image). The SL1M algorithm represents an alternate direct method for fitting the observed visibilities while minimising the total reconstructed flux intensity.

A second set of algorithms is based on the constraint that the entropy should be maximised, for example in [\cite=Narayan:1986p3297]. These algorithms are of less relevance to this work and will not be discussed further.

A third, more recent, set of algorithms is based around the ideas of compressive sampling (CS). Compressive sampling was introduced to radio synthesis astronomy in [\cite=Wiaux:2009p3076], where the Basis Pursuit algorithm was applied to reconstruct images from visibilities with coplanar base-lines. This work was extended in [\cite=Wiaux:2009p3050] to the case of baselines that had a constant non-coplanar component and that demonstrated how this component introduced a spread spectrum effect that improved the Basis Pursuit reconstruction. This was further extended in [\cite=McEwen:2011p3034] where the Basis Pursuit reconstructions were performed for a wide-field on a non-rectangular grid, but still under the constraint of a constant w for all baselines. Most recently, [\cite=Carrillo:2012ho] have introduced the SARA (Sparsity Averaging Reweighted Analysis) algorithm that optimises the data fit while regularising with respect to the average signal sparsity simultaneously in multiple wavelet bases.

The SL1M algorithm solves a similar problem to the CS reconstruction problem introduced by [\cite=Li:2011p1778]. In [\cite=Li:2011p1778], it is assumed that the image is sparse (few non-zero components) in some basis, and L1 minimisation is used to determine the image that best agrees with the observed visibilities and has the minimum L1 norm in the selected basis. Their technique was demonstrated for the Dirac basis and for the isotropic undecimated wavelet basis and showed image quality improvements over reconstruction with the CLEAN algorithm. Note that [\cite=Carrillo:2012ho] demonstrated substantially better reconstruction performance using SARA compared to reconstructions with the isotropic undecimated wavelet transform. [\cite=Wenger:2010p2327] have also explored solutions to the sparse reconstruction problem based on total flux minimisation, and demonstrated improvements over the CLEAN algorithm in a Daubechies wavelet basis. We make a brief comparison of the theoretical basis of this work and these other approaches in Section [\ref=sec:compare].

Rather than operate on gridded visibilities and use the Fourier transform to transform between the visibility domain and the image domain, as is done in [\cite=Li:2011p1778], the SL1M algorithm works with raw visibilities and uses the full matrix transformation between visibility space and image space to switch domains. While this method is highly computational, it has some benefits in terms of flexibility - in particular it can model direction dependent gains explicitly, naturally deals with non-coplanar baselines, and also allows sampling on non-rectangular grids. It is also based on L1 minimisation, and uses the same L1 minimisation algorithm as used in [\cite=Li:2011p1778].

To describe this method and its relationship to existing algorithms, we first make a brief introduction to the deconvolution problem in radio synthesis imaging and then outline the basic approach taken in SL1M for solving the problem for point source and Gaussian pixels. We then describe the implementation details, particularly the parallelisation strategy necessary to make the algorithm computable in a reasonable amount of time. Next, we apply SL1M to some simple simulated datasets to illustrate the features and constraints of the approach, and then apply it to two real datasets which demonstrate the efficacy of the algorithm. In the following section we demonstrate a version of the algorithm with improved algorithmic performance based on multi-scale analysis using the Gaussian pixel basis. After this we make a theoretical comparison to existing work, followed by concluding remarks and possible future avenues of investigation.

Defining the direct solution to the deconvolution problem

To begin, we define the coordinate systems for the problem. Consider the visibilities measured by a two element radio interferometer with baseline [formula], pointing at the sky in a direction [formula]. The baseline, [formula], can be represented in terms of rectilinear coordinates (u,v,w), so that [formula], where the orthonormal basis vectors [formula] are defined such that [formula] and [formula] and [formula] are aligned with a convenient axes, such as East and North. Sky coordinates, (l,m,n), are defined where l and m are parallel to u and v respectively and n is parallel to w. As the sky coordinates are restricted to the celestial sphere, [formula].

Given some brightness distribution on the sky, I(l,m), and a receptive pattern of the primary beam, A(l,m;Z,χ), the spatial coherence of the radiation field observed by an interferometer (the visibilities) with a baseline represented by (u,v,w) can be expressed as

[formula]

Note that ([\ref=eq:fullvis]) is also a function of observed frequency and polarisation, in that the visibilities are generally measured at many different frequencies, and in different polarisations. Dependence on frequency and polarisation will not be described here - the algorithms for deconvolution can be applied to either line or continuum channels and each polarisation independently.

When the relation (l,m)  ≪  1 holds, then ([\ref=eq:fullvis]) reduces to a Fourier transform of the sky brightness distribution multiplied by the primary beam (dropping the direction-dependence), as given by

[formula]

and all dependence on the w factor is lost in the relationship. However, as noted above, the w term for many observations is significant, and neglecting it can lead to artefacts and inaccuracies in the the deconvolved image.

Examining equation ([\ref=eq:ftvis]) is instructive as it highlights the basic problem of radio synthesis imaging. To reconstruct an image I(l,m) to a given resolution, it is necessary to know all the visibilities in the plane (u,v) out to the Nyquist frequency of the image that is to be reconstructed. However, only a fraction of the visibilities are observed, and so the inverse problem for equation ([\ref=eq:ftvis]) is under-constrained. This under-constrained problem can then only be solved by introducing new constraints, based on a-priori knowledge or assumptions about the properties of the image.

To proceed, we discretise the visibility equation ([\ref=eq:fullvis]). Firstly, if the Nv observed visibilities are written as Vj(uj,vj), then the relation between the measured visibilities and the observed image is

[formula]

where the dependence of the zenith and parallactic angles on the visibility being observed has been included (as different sets of visibilities will be observed at different times, and hence at different angles on the sky).

Modelling the image as a sum of functions, fk(l,m), then we may write equation ([\ref=eq:samuvw]) as

[formula]

and the relationship between the visibilities and the image can be evaluated for different classes of functions.

Delta function pixels

As a first approach, the sky brightness is modelled as a weighted sum of delta functions. To facilitate changing between a 2 dimensional image coordinate system and a 1 dimensional image coordinate systems (for the use of linear algebra), we introduce a list of two dimensional coordinates (lk,mk) indexed by a linear index k which enumerates each pixel being modelled.

As a simple example, (lk,mk) may describe an Nl by Nm grid of sample points. The lk and mk are integer coordinates ranging from - Nl / 2 to Nl / 2 - 1, and the relationship with linear index k, which ranges from 0 to NlNm - 1 is given by

[formula]

[formula]

where Δ is the grid spacing in sine coordinates. Note that nothing in the following requires that the pixels be placed on a grid, hence the SL1M algorithm may be used for irregularly distributed pixels.

Using this approach, each function contributing to the image may be written as fk(l,m)  =  Ilkmkδ(l - lk)δ(m - mk), and equation ([\ref=eq:samlm]) becomes

[formula]

where A(j)lkmk  =  A(lk,mk;Zj,χj).

Equation ([\ref=eq:samdelta]) has been arranged to highlight that there is a linear relation between the model image intensities, Ilkmk, and the observed visibilities, [formula]. Denoting vectors and matrices with bold uppercase type, this may be written simply as

[formula]

where

[formula]

Generally the dimension of [formula] is larger than that of [formula], that is, the number of pixels is larger than the number of observed visibilities, so equation ([\ref=eq:sme]) is under-constrained. To constrain the problem an additional constraint must be added to the system based on a priori knowledge. In this case it is assumed that the solution will be sparse, that is, have many zero components, and this assumption will be expressed by requiring that the solution have a minimal L1 norm while still agreeing with the observed visibilities. To do this, a regularised error function is introduced of the form

[formula]

the deconvolution task is to search for the [formula] that minimises this error function.

Note that while equation ([\ref=eq:cme]) was formulated in terms of point sources, it can also be evaluated for any pixel shape for which an analytic Fourier transform of the pixel shape multiplied by a quadratic phase function may be found. We now derive the form for [formula] for Gaussian shaped pixels for narrow field and wide field application.

Gaussian pixels in the paraxial approximation

To model Gaussian shaped sources, a new class of pixel shapes is defined by

[formula]

which have been normalised so that the integral under the gaussian is one. We substitute equation ([\ref=eq:gaus]) into equation ([\ref=eq:samlm]), and a pre- and post-multiply by quadratic phase terms, leading to

[formula]

We then Taylor expand the first phase term around the phase centre, leading to

[formula]

where l and m are assumed of size ε. Thus, to second order in l and m,

[formula]

This approximation is equivalent to the well known paraxial approximation in optics, and leads to a phase error in the integrand of ([\ref=eq:samlm]). For a representative wj = 1000 this is a phase error of 10- 3 approximately 3 degrees from the pointing centre. It is also well known in Fourier optics that the quadratic phase term in equation ([\ref=eq:samlm2]) represents a defocus - thus the w-term relates to a defocus between the dishes spaced at different depths relative to the pointing direction. Inserting the definition for the gaussian pixels, equation ([\ref=eq:gaus]), into equation ([\ref=eq:samlm2]), and making a further assumption that the direction dependent gains and projection factor do not vary significantly over a single Gaussian, we write

[formula]

This integral may be performed analytically, leading to and expression for [formula] in equation ([\ref=eq:cme]) for Gaussian pixels given by

[formula]

The three exponential terms in equation ([\ref=eq:samlm4]) may be understood as follows. The first term is a modified linear phase term that corresponds to the spatial offset from the phase centre of the k-th gaussian pixel. The second term is a modified quadratic phase term, corresponding to the defocus due to the w value of the k-th gaussian pixel. The final term is a modified gaussian, with scale 1 / σk corresponding to the Fourier transform of the k-th gaussian pixel. In all cases, there is a modification by the denominator of 1 - iwkσ2k, which mixes the real and imaginary parts of each term according to the amount of defocus and the scale of the gaussian. Taking the limit of equation ([\ref=eq:samlm4]) with wj  →  0, this leads to the Fourier transform of a Gaussian, as predicted from equation ([\ref=eq:ftvis]). Taking the limit as σk  →  0 for all k, leads to the paraxial approximation of equation ([\ref=eq:samlm]), as is to be expected.

Equation ([\ref=eq:samlm4]) allows the prediction of the contribution of a extended source of emission to the visibilities measured by any baseline, taking into account the non-coplanar baseline effect and direction dependent antenna gains. The assumptions made are that the source has a Gaussian profile, and that the source is not so extended that the gains and the coordinate projection term vary significantly over the source.

Gaussian pixels in a wide field

The approximation in equation ([\ref=eq:taylorexp]) limits the field of view of the image that the algorithm can be applied to. To avoid this, the phase offset at the centre of the Gaussian pixel may be preserved in the Taylor series expansion. In this case we have that

[formula]

This form of [formula] will be suitable for any field of view and is only limited by the Taylor expansion of the Gaussian pixel itself, i.e. as long as a single Gaussian pixel does not subtend an angle over which [formula] varies significantly. Equation ([\ref=eq:samlm5]) requires more computation than equation ([\ref=eq:samlm4]), however it is the form of the equation required for all-sky coordinate systems.

Implementation of SL1M

The SL1M algorithm is an algorithm for image deconvolution which is represented as the solution of equation ([\ref=eq:cme]) with [formula] given by either equation ([\ref=eq:deltam]) for delta function pixels or by equations ([\ref=eq:samlm4]) or ([\ref=eq:samlm5]) for Gaussian pixels.

Equation ([\ref=eq:cme]) is equivalent to the minimisation problem treated in [\cite=Li:2011p1778]. However in Li et al. the transformation between measured visibilities and source pixels is made through a Fourier transform of gridded visibilities which requires that the pixels be regularly spaced, and that the visibilities be transformed into the w = 0 plane through a gridding operation. In contrast, for SL1M, the matrix M represents an arbitrary mapping between source pixels and antenna gains and is explicitly evaluated for each visibility and pixel pair.

Because the minimisation problems are of the same form, the same numerical methods for solving the minimisation, namely the Fast Iterative Shrinkage-Thresholding Algorithm (FISTA) from [\cite=Beck:2009p2984], may be used. Given the maximum eigenvalue of the matrix [formula] the FISTA algorithm guarantees 1 / k2 convergence, where k is the number of iterations of the algorithm. This is unlike deconvolution algorithms based on CLEAN, where no such guarantee of convergence can be made. Furthermore, the parameter λ in equation ([\ref=eq:cme]) is the only major free parameter (excluding parameters related to the sampling pattern in the image space). This parameter controls the trade-off between errors in reconstructing the observed visibilities, and enforcing the sparsity of the reconstructed solution, and may be set based on the expected brightness of the sources and the noise in the sampled visibilities. Note that other algorithms exist for performing this minimisation, some of which show faster convergence for a variety of applications ([\cite=Becker:2011p3142]). As the FISTA algorithm is considered a gold standard for L1 minimisation problems, and because it has previously been shown to work in the radio synthesis context ([\cite=Li:2011p1778]), we adopt it here, though other minimisation approaches may be faster. For a detailed examination of many algorithms related to L1 minimisation, the reader is referred to [\cite=Bach:2011p3079].

The FISTA algorithm which produces a sequence of estimates, [formula], is shown here:

This algorithm can be terminated when an iteration leads to a sufficiently small change in the total error E, given by equation ([\ref=eq:cme]), or when there is a sufficiently small change in the number of non-zero entries in [formula]. The positivity enforcing thresholding operation is defined by

[formula]

There are three key parts to the algorithm. The first key part of the algorithm is the step which performs the L2 minimisation. This is a gradient descent step, where the derivative of [formula] with respect to [formula] is evaluated. This derivative is [formula], which essentially back projects the residual visibility errors into the image domain. This term is scaled by 1 / L, where L is the maximum eigenvalue of [formula], which ensures that the step is small enough not to diverge from the correct solution. Hence L determines how quickly the algorithm converges.

The second key part to the algorithm is the threshold-shrinkage step. This moves the solution closer to the L1 minimised solution by removing small (and negative) values from the solution. The third key part of the algorithm is the update step, where a particular linear combination of the previous steps is used to guarantee convergence at a rate of 1 / k2.

Finally, it is also important to note that the FISTA algorithm is not monotonic. That is, an iteration may lead to an increase in the value of the error term, and this is not indicative of the convergence of the algorithm. A monotonic version of FISTA, MFISTA, is presented in [\cite=Beck:2009p3004], but it is not used here as it requires an additional evaluation of the matrix [formula].

On-the-fly computation versus in-memory computation

Direct application of the FISTA algorithm to equation ([\ref=eq:cme]) requires requires repeated evaluation of the matrix [formula] and its transpose. For the case where the pixels are on a rectangular grid, the matrix [formula] is of dimension Nv  ×  NlNm, which, for a reasonable size observation can be 500,000  ×  1,000,000. If this matrix were to be stored in memory using a 4-byte floating point number to represent the real and imaginary elements it would require over 4 terabytes of RAM. Thus, while this matrix has a simple form, using it in an iterative algorithm represents a very large numerical problem.

However, there is an alternative approach to storing all this data. In this approach the elements of the matrix are recalculated as they are needed and are not stored. This technique turns the solution of equation ([\ref=eq:cme]) from a large memory, high memory-bandwidth task into a low-memory, processor intensive computational task that is extremely well suited to modern multi-core hardware due to the highly parallelisable nature of the problem.

We have implemented the SL1M algorithm through this method of explicit evaluation of the components of [formula] from their analytical representation (given by equations ([\ref=eq:deltam]), ([\ref=eq:samlm4]) or ([\ref=eq:samlm5])). This involved implementation of the FISTA algorithm using C++ and CUDA on GPGPU hardware, along with an algorithm to calculate the largest eigenvalue of [formula]. The specific hardware used to run this code were 2 Fermi class M2050 GPUs attached to a cluster processor available on Amazon Web Services Elastic Cloud Compute platform. The GPUs have a maximum floating point performance of 500GFLOPs each. An evaluation of a single term of [formula] takes approximately 30 FLOPS using single precision floating point arithmetic and fast sincos and sqrt primitives. This means theoretical peak performance in evaluation of entries of [formula] is around 33 billion entries per second. Real world performance is 99 per cent of the theoretical maximum due to the independence of the entries, and the low amount of memory bandwidth required for the calculation. For this architecture, the calculation is distributed across approximately 21,000 threads on each GPU. For the case of a matrix of size 500,000  ×  1,000,000, evaluation of a single FISTA step takes 30 seconds. An image deconvolution may take hundreds of steps of the FISTA algorithm to converge, leading to run times in the order of hours, depending on the nature of the problem.

The parallelisation scheme used for two GPUs on a single host is shown diagrammatically in Fig. [\ref=fig:parallel] for a multiplication between the image vector and the matrix [formula]. Half the calculation is done on each GPU, and the image vector is divided into blocks to aid efficient memory access. Further parallelisation of the algorithm is possible by distributing to multiple machines. This may be achieved by extending the scheme of Fig. [\ref=fig:parallel] where the entire image to be updated is shared between machines via the network, or by splitting the image pixels between hosts. In this case, each host on the network has a subset of the image that it calculates with, and for each matrix multiply, it only calculates the elements of the matrix corresponding to the pixels it contains and then distributes the results to the host node over the network. Scaling to a cluster of GPU machines is feasible with this technique and would reduce the computing time per iteration roughly linearly in the number of machines, with some overhead for the network communication. This approach has not yet been implemented. The code which calculates the results shown here is freely available online.

As this is a new algorithm, an emphasis has been placed on demonstrating the accuracy and reliability of the deconvolution result, and not on the performance of the code. As such, all results reported here are run over many hundreds, and sometimes thousands, of steps of the FISTA algorithm. This is not always required, particular for real noisy data as shown in Sections [\ref=sec:ngc5921] and [\ref=sec:ngc2403]. Further work in algorithmic optimisation is discussed in Section [\ref=sec:accel].

The approach used here of calculating the explicit transformation between the image pixels and the observed visibilities as they are required for the calculation, rather than pre-calculating and storing them in RAM, could be applied to other deconvolution algorithms. The requirements are that there is an analytic form for the transformation, and that the algorithm require only evaluations of [formula] or its transpose. Methods that require the solution of sets of linear equations as part of their optimisation algorithms cannot make use of these techniques.

Results

Synthetic data

To begin the evaluation of the performance of SL1M, we initially test it on synthetic data, both with and without noise. This is followed by the analysis of two real data sets drawn from observations of NGC5921 and NGC2403 by the VLA telescope.

Point sources

The initial synthetic dataset consists of data generated by simulating 50 point sources randomly distributed over a 7 degree field of view which is represented by a 1024 ×   1024 image with 30" pixel spacing. The sources are distributed over the inner 80 per cent of the image, and have strengths ranging from 0.2 to 2.0 in arbitrary units. Visibilities are generated by simulating the dish distribution of the full ASKAP telescope ([\cite=Deboer:2009p3117]), with 36 dishes, but for only the central beam, a single polarisation and a single channel at the HI wavelength. The primary beam of the telescope is also not modelled. Visibilities are calculated for a one hour period, sampling every minute, leading to a total of 37,800 visibility records. The centre of the field is assumed to be at a declination - 22.5o and at zenith at the start of the observation.

Initially, we test the effectiveness of the algorithm in the absence of measurement noise. To do this we run SL1M on the simulated visibilities for a variety of values of λ until the total error changes no more than 1 part in 106 or until 7000 iterations were reached. The results of these tests are shown in Table [\ref=tab:pointsourcenonoise]. Note that for the λ  =  1.0 test, the reconstruction error for the 50 non-zero sources was less that 4  ×  10- 4. This demonstrates similar accuracy to previous applications of compressive sensing (e.g. [\cite=Candes:2005p3330] ). It is worth noting that while the number of observed visibilities (37,800) is larger than the number of non-zero samples being reconstructed (50), the number of pixels in the solution is larger still (1,048,576).

Next the effectiveness of the algorithm in the presence of noise is tested on the same dataset, but with additive noise combined with the visibility data. We added gaussian noise with zero mean and a specified standard deviation to both the real and imaginary parts of all the visibilities, and the reconstruction algorithm was run for 5 different values of λ. The standard deviations were specified so that the signal to noise ratios were 100, 31.6, 10, 3.16 and 1. To evaluate the performance of the deconvolution algorithm, the RMS difference between the reconstructed image and the original image is plot as a function of λ, for the different noise levels, in Fig. [\ref=fig:pointreconerror]. This figure shows that good reconstruction results are possible to a signal to noise ratio of at least 1. Even for this case the RMS error is 0.017, which is much smaller than the non-zero pixels which have amplitudes of between 0.2 and 2.0. It is also important to note that, as the noise becomes progressively worse, the best reconstruction is obtained with a higher value of λ. This is because the L2 term in equation ([\ref=eq:cme]) increases relative to the L1 term as the noise increases, so λ must be increased to avoid fitting the noise. The second panel of Fig. [\ref=fig:pointreconerror] shows the RMS error for the non-zero pixels. This may be a better figure of merit than the total RMS error as these are the pixels that have physical significance in real data. In this case, the RMS is lower for lower values of λ than in the first panel. This may be explained, as the L1 term of equation ([\ref=eq:cme]) penalises higher values of the solution. Thus, there is a trade off between suppressing noise in background regions, and maintaining the accuracy of the solution in regions where there is signal.

Extended emission

The previous test cases were ideal for the algorithm under investigation - the source image consisted of delta-functions, which matched the emission model. In this section, a deconvolution task using a synthetic image with extended emission is investigated. The image used is shown in Fig. [\ref=fig:synthim]. It consists of a number of gaussian shaped sources, supplemented with two rings. Visibilities for the ASKAP telescope are simulated under the same conditions as section [\ref=sec:ps], and noise is added to the visibilities giving a signal to noise ratio of 1. The performance of the algorithm in reconstructing the image is investigated in for six different data lengths, ranging from 25000 to 150000 visibilities.

The results of the RMS accuracy of the reconstruction are shown in Fig. [\ref=fig:rmsvis] as a function of λ for each of the data lengths. Note that the minimum error occurs at increasing values of λ as the data length increases. Similarly to the case for point sources, this is due to the increase in the L2 error as more data is introduced relative to the fixed L1 norm of the solution.

The actual reconstructed images are shown in Fig. [\ref=fig:reconims]. This figure shows that the algorithm over-smooths the data for higher values of λ and low numbers of visibilities (bottom left of the grid), and it over fits the noise for lower values of λ and higher numbers of visibilities. Reconstructions of increasingly better quality occur for larger datasets, corresponding to the minima of Fig. [\ref=fig:rmsvis].

NGC5921

To test with real data, we deconvolve the NGC5921 dataset that is distributed as a tutorial with the CASA radio astronomy software package. This dataset consists of 63 channels of LL and RR polarisations, taken with the 27 telescopes of the VLA in a band centred on HI with a total bandwidth of 1.6MHz. In total, 11,934 visibilities for each channel were measured. The visibilities were calibrated and continuum subtracted according to the recommendations in the CASA software tutorial and exported for analysis. Only unpolarised emission was considered, so the LL and RR polarisation data were added to produce the visibilities input to SL1M.

The result of applying the SL1M algorithm over all 63 channels of the data with λ = 120 are shown in Fig. [\ref=fig:reconngc5921]. The image is deconvolved to a 256 ×   256 grid with a pixel spacing of 7 arc seconds. Each channel was processed until the relative change in the total errors was less than 10- 9. Generally only around 200 iterations per channel were necessary, and this took around 30 seconds per channel. The first image shows the sum of the direct output of the SL1M algorithm for channels 10-50, and the second panel shows the same convolved with a gaussian approximation to the synthesised beam of the telescope. The third panel shows the corresponding CLEAN image generated using the CASA software using the default configuration, at the same pixel spacing as the SL1M algorithm.

A single channel of the result of the SL1M algorithm for 4 different values of λ is shown in Fig. [\ref=fig:channel30]. Increasing the value of λ increases the strength of the L1 minimisation term, thereby decreasing the noise in the reconstructed image.

NGC2403

As a larger test, we deconvolve the NGC2403 dataset that is also distributed with a tutorial for the CASA software. This dataset has 432,783 visibility records for 127 channels starting at 1418.25MHz with a channel bandwidth of 24.414kHz taken by the VLA. The synthesised beam size is around 12 arc seconds and the object is around 35 arc minutes across. For this test, the image is deconvolve onto a 1024 ×   1024 pixel grid with a pixel size of 2 arc seconds. Again, the data included LL and RR polarisation measurements which were summed before deconvolution. This dataset includes some records affected by interference, and the noisy records were flagged and removed before deconvolution. As per the CASA tutorial, calibration and continuum subtraction were performed, with channels 21-30 and 92-111 used for continuum estimation. The execution time for a single channel for this dataset is 1.5 hours, and the reduction time for the 61 line channels was around 90 hours.

The image generated from combining the deconvolved images from channels 31 to 91, and convolving with a 12 arc second Gaussian are shown in Fig. [\ref=fig:2403sum].

Analysis at different scales

To demonstrate processing at different scales, the NGC5921 dataset analysed in Section [\ref=sec:ngc5921] is deconvolved with gaussian basis functions of different sizes based on equation ([\ref=eq:samlm4]). The results of this analysis are shown in Fig. [\ref=fig:multiplescales]. Larger scale pixels show correspondingly less detail, as might be expected. Also, the largest scale clearly shows the emission in each channel is perpendicular to the rotation of the galaxy.

Multi-scale methods generally operate on multiple scales simultaneously, and this could be achieved here by having pixels with different scales in the same SL1M run. It is also possible to approximate the Isotropic Undecimated Discrete Wavelet transform used by [\cite=Li:2011p1778] as the difference of two Gaussian kernels.

Here, the ability to process with different scales allows is used to demonstrate an acceleration strategy that can greatly reduce the overall processing time for the method.

Acceleration strategies

For the SL1M algorithm, the flexibility in pixel placement and scale and the direct nature of the solution method come at a significant computational cost. Current methods such as CLEAN use the FFT to transform between the visibility and image domains, which involves two steps - gridding, which takes time proportional to the number of visibilities, Nvis; and the FFT itself, which scales with the number of pixels, Np, as Np log Np. On the other hand. SL1M scales as NpNvis. As Nvis >  >  log Np, this takes significantly more computation. However, due to the flexibility of the approach, a number of other strategies can be taken to improve the computational complexity.

The first method for reducing computational cost is to use the dirty image as the initial condition from the SL1M algorithm. This reduces the number of iterations required for each run to converge, though it does not improve the processing speed of each step.

A second method for reducing computational cost would be to work in a coarse-to-fine strategy. That is, to solve the equation on a coarse pixel grid, then to double the resolution and upscale the previously calculated solution. This method also reduces the number of iterations required to reach convergence, though does not change the order of complexity of the solution, as the final stage still requires a calculation of all the pixel against all of the visibilities.

A step further than this is to solve the system on an adaptive grid, such as a quad-tree. In this case, the system is solved at a low resolution, and pixels where emission is detected are then subdivided. This process continues until the resolution limit of the telescope is reached. As a divide-and-conquer method, this approach reduces the algorithmic complexity of the algorithm, but a detailed investigation of its convergence properties are necessary. To demonstrate its feasibility, we perform a deconvolution using an adaptive quad-tree strategy on a single channel of the NGC2403 dataset used in Section [\ref=sec:ngc2403] and the results are shown in Fig. [\ref=fig:refinement]. Processing time was around 7 minutes for the channel, a speed up around a factor of 13 compared to solving the system on the complete 1024x1024 grid.

Comparison with existing methods

CLEAN based methods

The CLEAN algorithm and its variants have been the primary deconvolution methods for radio interferometric imaging for over 40 years. As such, they are extremely mature algorithms and there is a great deal of experience in their use in the community.

The basic concept behind the CLEAN algorithm is that the image is modelled as a collection of point sources that are built up through an iterative greedy algorithm. This algorithm selects a new point source to be added to the model by determining the residual "dirty image" and selecting the maximum of this image as the location of the next candidate source. The dirty image is calculated from the residual visibilities through the use of the Fourier Transform. More recently, an extension to CLEAN to account for the non-coplanar baselines effect has been developed called W-projection [\cite=Cornwell:2005p1977]. This method uses a convolution kernel to project the calibrated visibilities to the w = 0 Fourier plane taking into account the blurring caused by the non-zero w term. Similarly, in the case of direction dependent gains, A-projection kernels were developed by [\cite=Bhatnagar:2005p1990] to account for the antenna primary beam patterns in visibility space before the Fourier transform is applied.

If we denote the calibration operation as [formula], the Fourier transform as F, the gridding operation as [formula], the model image as [formula], the visibilities as [formula], and the dirty image as [formula], then the simplest update step of CLEAN can be written as

[formula]

where γ is the gain of the CLEAN algorithm, and δ represents a Kronecker delta.

To contrast this to the SL1M algorithm, one can approximate the update step of the algorithm as

[formula]

Clearly there are some similarities to the structure of the two algorithms. In particular, there is an analog to the dirty image in SL1M which is calculated through [formula]. This pseudo dirty image could be used directly in a CLEAN style update step which would update only a single component of the model image, but instead the FISTA L1 minimisation step is used to update all of the image components in a single step.

Recently, [\cite=2012ApJ...759...17S] introduced the Fast Holographic Deconvolution method which was used to deconvolve an image created by the MWA 32 antenna prototype. For this CLEAN style algorithm, the update step can be written (loosely) as

[formula]

where [formula] now incorporates the projection effects due to the antenna beams and [formula], the holographic mapping function, is introduced. This function distributes the Fourier components of the model image to their correct locations, taking into account the direction dependent gains of the antennas. This Holographic mapping function can be related to the SL1M algorithm by making the identification [formula]. Sullivan et al. pre-calculate [formula] and store it as a sparse matrix - though they note that this may not be possible when the non-coplanar baseline effect becomes important. This is in contrast to the SL1M algorithm where [formula] is dense and calculated in place.

Compressive sampling

As mentioned earlier, the approach adopted for SL1M parallels closely the approach used in [\cite=Li:2011p1778] and [\cite=Wenger:2010p2327]. The same basic equations are being solved and the same or a similar L1 minimisation scheme, based on iterative shrinkage and thresholding, is used to solve them. If the update step for Li et al. is written in the same style as above, one has that

[formula]

The fundamental different in the approach in equation ([\ref=eq:li]) and SL1M in equation ([\ref=eq:slim]) is that the minimisation is done with respect to the calibrated visibilities using the general matrix [formula], not on visibilities gridded onto a Fourier plane. The matrix [formula] allows a more flexible representation of the relationship between the observed visibilities and the image pixels, at the cost of significantly more computation.

Bayesian compressive sensing

The minimisation problem solved in SL1M, given by equation ([\ref=eq:cme]), can be reinterpreted as a maximum a posteriori (MAP) estimate of the reconstructed image given the data. In this interpretation, the regularisation term represents the prior expectation of the distribution of the reconstructed image values. In this case this prior distribution is an exponential distribution, given by

[formula]

Given this interpretation, the shaped of the posterior distribution around the MAP estimate can be explored to determine the errors in the derived image. Approaches such the iterative hierarchical algorithm for solving sparse Bayesian problems as outlined in [\cite=Babacan:2010p3398] may be used. Furthermore, this approach includes a method of estimating the covariance of the MAP solution which could used to develop a parameter free algorithm for inverting radio synthesis images, as the noise in the measurements and the sparsity of the solution (represented by λ) may be inferred from the data using these techniques.

Conclusions

In this paper we present a new algorithm for deconvolving radio synthesis images based on direct inversion of the measured visibilities that can deal with the non-coplanar base line effect and can be applied to telescopes with direction dependent gains. We have outlined the basic method of the algorithm and demonstrated its application to several synthetic and real datasets showing good reconstruction performance.

While this algorithm is more computationally demanding than existing methods, it is highly parallelisable and will scale well to clusters of CPUs and GPUs. This algorithm is also extremely flexible, allowing the solution of the deconvolution problem on arbitrarily placed pixels.

More development and investigation of this method is required for its use in solving real-world problems. However, there are many interesting and potentially valuable avenues of investigation. Firstly, the method must be rigorously benchmarked against existing CLEAN implementations for both accuracy and speed and to understand the effect of the regularisation parameter λ on the deconvolution result in more detail. Also, minimisation methods other than FISTA should be investigated for faster convergence properties. Secondly, the method should be applied to data from telescopes with direction dependent gains to verify that its performance remains good in this case. Thirdly, including other established features of radio synthesis software such as multi-scale deconvolution, multi-frequency synthesis and also the inclusion of self-calibration should also be investigated. Finally, deconvolution directly on the HEALPIX grid should be demonstrated, as this is likely to be a valuable feature for future all-sky astrophysics research.