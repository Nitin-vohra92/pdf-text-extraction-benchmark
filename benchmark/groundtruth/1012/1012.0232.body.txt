hyperref

Lemma Proposition Remark

Kolmogorov-Loveland Sets and Advice Complexity Classes

Non-inclusion properties of Loveland sets result in hierarchy properties on the corresponding advice complexity classes;

Immunity properties of Loveland sets result in the non-existence of natural proofs between the corresponding advice complexity classes, in the sense of Razborov & Rudich [\citet=Razborov1997].

Introduction

Kolmogorov complexity is a measure of algorithmic randomness. If we consider words of length n over the boolean alphabet [formula], then [formula] is defined to be the length of the smallest input enabling a given universal Turing machine U to output x. It is possible to "hide" x in the input, so [formula] (where [formula] is the length of x). Since there are 2n - 1 words in Σ≤  n - 1 but 2n words in Σn, by the pigeonhole principle, at least one word of length n cannot be output with a smaller input. Such a word is called incompressible. Numerous applications of this result, known as the Incompressibility Method are given in the textbook of Li & Vitanyi [\citet=Li2008]. The same argument shows that almost all words are almost incompressible.

The Shannon-Lupanov theorem [\citet=Shannon1949] [\citet=Lupanov1958] states that any boolean function on n variables can be computed by a circuit of size at most [formula]. This bound is tight; moreover almost all boolean functions have almost this complexity. Trakthenbrot [\citet=Trakhtenbrot1984] drew a parallel between boolean functions having a circuit complexity of at least [formula] and words such that [formula]. Such an analogy suggests that there may be a connection between hard boolean functions and incompressible words.

Indeed, Karp & Lipton noticed that languages in [formula] could be computed by "small circuits with easy descriptions". Looking for some kind of reciprocal, Hermo & Mayordomo [\citet=Hermo1994] gave a nice characterization of the advice complexity class [formula] in terms of the resource-bounded Kolmogorov complexity of its circuits. Assuming that [formula] and [formula] are constructible functions, a sequence of words [formula] of length n belongs to the Kolmogorov set [formula] iff for each integer n, xn is computable by the universal Turing machine U with an input of length at most [formula] in time [formula], in space [formula] and with knowledge of some word [formula]. Using the P-completeness of the Circuit Value Problem, they proved that [formula] is the set of languages decidable by circuits belonging to [formula] or, equivalently, by circuits belonging to [formula].

Building on Hartmanis [\citet=Hartmanis1983], Longpr� [\citet=Longpre1986] stated many structural properties of the above Kolmogorov sets. However, the characterization of Hermo & Mayordomo does not make it possible to map the properties of the Kolmogorov sets to the advice complexity classes, since several different circuits may compute the same function and not all words encode circuits. To do so one needs a more narrow approach.

The purpose of the present work is to provide a characterization of some advice complexity classes by Kolmogorov sets enabling to map some of the properties of the latter to the former:

Non-inclusion properties of Kolmogorov sets result in hierarchies properties on the corresponding advice complexity classes;

Immunity properties of Kolmogorov sets result in the non-existence of natural proofs between the corresponding advice complexity classes, in the sense of Razborov & Rudich [\citet=Razborov1997].

In a breakthrough paper [\citet=Razborov1997], Razborov & Rudich identified some properties shared by all known proofs of lower bounds on the non-monotone circuit complexity of some individual boolean functions, which they called natural properties, and showed that such properties would not be sufficient to derive superpolynomial lower bounds for circuits (with some hardness assumption).

We believe that Kolmogorov sets are a convenient substitute for diagonalization, since they are more compact and explicit. In particular, the results presented in this paper may be viewed as resulting from diagonalization.

Connection between Kolmogorov Sets and Advice Complexity Classes

Framework

Kolmogorov-Loveland Complexity.

To make the connection as clear as possible we do not use simple Kolmogorov complexity KS but a variant introduced by Loveland [\citet=Loveland1969] called decision Kolmogorov complexity (KD) in the classification of Uspensky & Shen [\citet=Uspensky1996], and also referred to as uniform complexity in [\citet=An-Introduction-to-Kolmogorov-Complexity-and-Its-Applications::1997::LiVitanyi]. In this variant, the universal Turing machine U is not required to output the word x but to give [formula] (the [formula] bit of x) upon request. The input of U consists thus in a self-delimited tuple [formula] where p is the actual input, i is the number of the asked bit of x, and y is a word given for free as an auxiliary input. We take as usual [formula] and [formula].

Kolmogorov-Loveland Sets.

In the setting of Kolmogorov-Loveland complexity, the required output is a single bit, so it does not make sense to measure time and space with respect to the output. Instead we are going to measure them with respect to the input. This will allow a simpler connection with advice complexity classes. So we say that a sequence of words xn of length n belongs to [formula] iff for each integer n there exists a program [formula] of length at most [formula] such that for all i between 0 and n - 1, [formula] and the computation is done in time at most [formula] and in space at most [formula], where [formula]. The choice of u may seem rather strange at first glance, but we choose this definition so that the connection with advice complexity classes may be as simple as possible. Moreover bounding resources with respect to input size makes this complexity prefix-monotonic, in the sense that the program p and the word y used for a word x in time [formula] and in space [formula] can also be used for all of x's prefixes.

Advice Complexity Classes.

The advice complexity classes we are going to consider are of the form [formula]. Given two fully time and space constructible functions [formula] and [formula], a language L over the alphabet [formula] is in [formula] iff there exists a Turing machine deciding it in time [formula] and in space [formula]. Now the advice complexity classes are defined as follows: let C be a complexity class. [formula] iff there exists a language L' in C such that for all integer n, there exists a word wn (the advice) of length at most [formula] such that for any word x of length n, [formula].

Characteristic Words Sequence of a Language.

Given a language L, we consider its characteristic words sequence, defined as follows. First we recall that a word x of length n over the alphabet Σ can be considered (in the binary numeral system) as an integer [formula] between 0 and 2n - 1. We denote the inverse function from integers to words as [formula]. Note that [formula] will have length n and may begin by a sequence of zeros. In particular the word 0n corresponds to the integer 0 and the word 1n to the integer 2n - 1 (keep this in mind). Now the characteristic word of the language L for length n is a word of length N = 2n defined by [formula] (i.e. 1 if [formula] and 0 otherwise).

Connection Lemma

Let [formula], [formula] and [formula] be integer functions such that [formula] and [formula] are non-decreasing and fully time and space constructible, [formula] and [formula]:

if [formula], then [formula]

if [formula], then [formula].

The main idea is to switch from integers to strings of a given length and vice-versa.

if [formula], then there exists a language L' decided by a Turing machine M' in time [formula] and in space [formula] such that for all integer n, there exists an advice word wn of length at most [formula] such that [formula]. Now consider the Turing machine M which on input [formula] computes [formula] and [formula], and simulates M' on [formula]. By construction, [formula] and M runs in time [formula] and in space [formula]. Now M can be simulated by the universal Turing machine U (which has a fixed number of tapes) in time [formula] and in space [formula] thanks to the simulation method of Hennie & Stearns [\citet=Two-Tape-Simulation-of-Multitape-Turing-Machines::1966::HennieStearns].

if [formula], then for all integer n, there exists a program pn of length at most [formula] such that for all integer i between 1 and N, [formula]. Now pn can be used as an advice, as follows: consider the Turing machine M which on input [formula] computes [formula], i = x without the inital zeros, and simulates U on [formula]. Then [formula] and this computation is done in time [formula] and in space [formula].

Transfer of Properties

We are going to use the above Connection Lemma to transfer properties of Loveland sets to the corresponding advice complexity classes:

Non-inclusion properties of Loveland sets result in hierarchy properties on the corresponding advice complexity classes;

Immunity properties of Loveland sets result in the non-existence of natural proofs between the corresponding advice complexity classes.

So we shall first establish the properties of Loveland sets. They are very similar to the properties established by Longpr� in his thesis, but we must revisit them because we work with Loveland complexity instead of standard Kolmogorov complexity, and moreover we measure the resources with respect to the input instead of the output.

Non-Inclusions and Hierarchies

Sensitivity to Advice Length.

The following proposition is analogous to corollary 3.2 of Longpr�'s thesis [\citet=Longpre1986]. Here the proof is simpler because KD is prefix-monotonic.

If [formula], then there exists a constant c such that for all [formula] we have

[formula]

By counting, there exists some x of length [formula] incompressible with respect to [formula]; by prefix-monotonicity, [formula]. Now the program which on input [formula] prints [formula] if [formula] and 0 otherwise, has length [formula], works in time [formula] and in space [formula]. As above, this program can be simulated by U in time [formula] and in space [formula], where [formula]. So there exists a constant c such that [formula].

Now using this proposition together with our Connection Lemma yields the following result, which was already present in [\citet=Hermo1994] in a similar form. We denote by REC the class of recursive languages.

Let [formula] and [formula] be two integer functions such that [formula] and [formula] is non-decreasing and unbounded. Then

[formula]

By proposition [\ref=fac:KD-advice-length] and the fact that [formula] is non-decreasing and unbounded, we consider a sequence of words Ln of length N = 2n belonging to [formula] for some c and for n large enough. Now by the above Connection Lemma, the corresponding language L is in [formula]. Suppose by contradiction that [formula]. By the Connection Lemma, there exists a constant c' such that [formula] is in [formula]. For n large enough, [formula] and then [formula] is in [formula], a contradiction.

Sensitivity to Time and Space.

We give a proposition analogous to theorems 4.3 and 4.4 of Longpr�'s thesis [\citet=Longpre1986]. The main difference here is that we consider that resources are bounded with respect to the input rather than the output.

Let [formula], [formula] and [formula] be integer non-decreasing and constructible functions such that [formula], [formula] and [formula]. Then there exists some constant c such that if [formula] and [formula], for n large enough,

[formula]

By counting, there must exist some x of length [formula] incompressible with respect to n - 1 in time [formula] and in space [formula]; by prefix-monotonicity, [formula]. Finding the smallest such x in the lexicographic order can be performed by exhaustive search by running all programs of length at most [formula] in time [formula] and in space [formula]. Here we face a trade-off between time and space: if we choose to store all generated strings to avoid recomputations, this increases the required space; otherwise we may iterate the exhaustive search for each string of length [formula] until we find the desired one. The first option takes:

an overall advice of length [formula] (since n - 1 is given for free);

an overall time of [formula], since [formula] and [formula]; now [formula]. So the time bound is [formula]. Again there is an extra logarithmic factor due to the simulation by our fixed machine U;

an overall space of [formula], i.e. [formula].

Now using this proposition together with our Connection Lemma yields the following result.

Let [formula], [formula], [formula] and [formula] be integer non-decreasing and constructible functions such that [formula], g is unbounded, [formula] and [formula]. Let [formula] and [formula] be such that [formula] and [formula]. Then there exists some constant c such that if [formula] and [formula], then

[formula]

By proposition [\ref=fac:Time-Space], we consider a sequence of words Ln of length N = 2n belonging to [formula] for some c and for n large enough. Now by the Connection Lemma, the corresponding language L is in [formula]. Suppose by contradiction that [formula]. By the Connection Lemma, there exists a constant c' such that [formula] is in [formula]. For n large enough, [formula], [formula] and [formula], so [formula] is in [formula], a contradiction.

Immunity and Natural Proofs

Immunity of Kolmogorov Sets.

Immunity is an indication that a language is algorithmically very complex, in the sense that given a complexity class C, a language L is called C-immune iff L is infinite and does not have any infinite subset belonging to C. To this we add the notion of density: a language L has partial density δ iff there exist infinitely many n's such that L contains at least [formula] words of length n. Thus we generalize the notion of immunity using density: we say that a language L is C-immune for partial density δ iff L is infinite and does not have any infinite subset of partial density at least δ belonging to C.

As noted by Hartmanis [\citet=Hartmanis1983] and further developed by Longpr� [\citet=Longpre1986], the complements of Kolmogorov sets are immune. Longpr�'s results for immunity (theorems 3.7, 3.8 and 4.13 of [\citet=Longpre1986]) concern classical complexity classes and global density. Here we deal with advice complexity classes and partial density, as follows.

Let [formula], [formula], [formula] and [formula] be integer non-decreasing and constructible functions, such that [formula], [formula] is unbounded and [formula]. Let [formula] be a function to the real interval [formula] and [formula]. If [formula] and [formula] are non-decreasing, [formula] and [formula], then

[formula] is [formula]-immune for partial density δ.

Let us consider any infinite language [formula] with partial density δ. We argue that for n large enough, the lexicographically smallest word of length n belonging to A is in [formula]. Indeed there exists a Turing machine M working in time [formula] and in space [formula], and a sequence of advice [formula] of length [formula] such that for all x∈Σn, [formula]. Thus it suffices to simulate M with advice wn on all x's of length n in the lexicographic order.

This can be done by a program of length [formula] (since n - 1 is given for free).

For an n such that A contains at least [formula] words of length n, there are at most [formula] steps of simulation, each step requiring a time [formula] where [formula]. The simulation by our universal Turing machine U can thus be performed in time [formula]. Since [formula], this is [formula].

The above simulation can be performed in space [formula].

Non-Existence of Natural Proofs among Advice Complexity Classes.

We first recall the definitions of [\citet=Razborov1997] (section 2.2). A combinatorial property is a set of boolean functions. Each of the 22n boolean functions on n-bit inputs can be described by a binary word of length 2n (which in turn can be seen as the characteristic word of a language, see section [\ref=sub:Framework] above). Thus a combinatorial property can be seen as a language with words of length powers of 2. The question whether a given boolean function belongs to a combinatorial property is an algorithmic problem which requires some time and space depending on the length 2n of the boolean functions. Thus it is possible to group together combinatorial properties with respect to this algorithmic complexity, and such sets of combinatorial properties are some kinds of complexity classes. These complexity classes should not be confused with the complexity classes of the boolean functions themselves, i.e. the time and space (depending on n) required to compute the boolean functions on n-bit inputs!

Given a complexity class C, a combinatorial property Γ is called C-natural for partial density δ iff there exists Ξ  ⊆  Γ such that:

In fact the density considered in [\citet=Razborov1997] is global, but we refine it to use partial density. So, what does a non-natural property look like? It is a property without any large constructible sub-property. This looks very much like the aforementioned notion of immunity. Indeed:

Let Γ be a combinatorial property, C a complexity class and [formula]. Then Γ is not C-natural for partial density δ iff Γ is C-immune for partial density [formula].

Now what is the use of a combinatorial property? Given a complexity class D, an infinite combinatorial property Γ is called useful against D iff

Why is it called "usefulness"? Because in order to prove that L∉D, it is enough to prove that Ln∈Γ infinitely often. So Razborov & Rudich manage to prove that for various circuit complexity classes C and D there are no C-natural properties against D. Using proposition [\ref=prop:Immunity] together with our Connection lemma, we prove the following result:

Let [formula], [formula], [formula] and [formula] be integer non-decreasing and constructible functions, such that [formula], g is unbounded and [formula]. Let [formula] be a function to the real interval [formula] and [formula]. If [formula] and [formula] are non-decreasing, [formula] and [formula], then

Let Γ be a [formula]-natural property for partial density δ. It is important to notice that all words in Γ have lengths of the form N = 2n. There exists Ξ  ⊆  Γ such that [formula] and Ξ has partial density [formula]. Suppose by contradiction that [formula] is finite. Then [formula] is still infinite with partial density [formula] and is still in [formula], which contradicts proposition [\ref=prop:Immunity]. Thus Δ is infinite, and there are infinitely many n's such that we can pick in this set an element Ln of length N = 2n. Now by the Connection Lemma, the language L having these Ln's as characteristic words is in [formula]. Thus Γ is not useful against [formula].

Conclusion

We had to take resource bounds on Kolmogorov-Loveland complexity with respect to the input in order to make a straightforward connection with the advice complexity classes. This led to use both n and u in the complexity classes of the form [formula], and we had to make frequent and inelegant conversions between n and u. To make things clearer, we suggest that in the advice complexity classes, resource bounds on [formula] should be taken with respect to x only. This would not change the main classes [formula] and [formula].

One may object that our results relativize. They do as do all diagonalization results, since our results are some kinds of diagonalizations. That is also the reason why we think that it would be surprising if one could do better than exhaustive search in our simulations.

However we believe that it is important to exhibit separation results, even if they are simple. Indeed we want to recall for example that in the deep proof that DLIN  ≠  NLIN of [\citet=Paul1983], the only separation result invoked is a simple time hierarchy on alternating Turing machines obtained by diagonalization.

Acknowledgments

This research was done while the author was an intern student at LRI (Orsay, France) under supervision of Sophie Laplante. The author is very grateful to Sophie Laplante for many helpful discussions.