Corollary Lemma Observation Definition

An Approximation Algorithm for the Euclidean Bottleneck Steiner Tree Problem

Introduction

Consider a wireless communication network with n stations, each station has a limited power so that it can only communicate with stations within a limited range, and suppose that, in order to make the network connected and due to budget limits, we are only allowed to put at most k new stations in given potential locations in this network. Clearly, we would like to select locations such that distance between stations as small as possible. This application motivates the following problem:

The Bottleneck Steiner Tree (k-BST) problem. Given two sets in the plane, P of terminal points and S of Steiner points, and a positive integer k, one is asked to find Steiner tree T of P with at most k Steiner points, such that the bottleneck (i.e., length of the longest edge) of T is minimized.

In the classical Steiner tree (ST) problem, the goal is to find a Steiner tree T such the total length of edges of T is minimized. This problem has been shown to be NP-complete [\cite=Garey77] and many approximation algorithms have been proposed [\cite=Berman94] [\cite=Borchers97] [\cite=Hougardy99]. A general version of the k-BST, where k = |S|, has been studied by Sarrafzadeh and Wong [\cite=Sarrafzadeh92]. They showed that this version can be solved in polynomial time.

Another version, where S is the whole plane [formula], has been studied extensively in the last decade. In [\cite=Wang02], this version was shown to be NP-hard to approximate within ratio [formula]. The best known upper bound on approximation ratio is 1.866 [\cite=Wang02+]. Bae et al. [\cite=Bae10] presented an O(n log n) time algorithm to the problem for k = 1 and an O(n2) time algorithm for k = 2. Li et al. [\cite=Li04] presented a ([formula])-approximation algorithm with inapproximability within [formula] for a special case of the problem where there should be no edge connecting any two Steiner points in the optimal solution. These versions have many important applications in VLSI design, network communication and computational biology [\cite=Cheng01] [\cite=Du00] [\cite=Hwang92] [\cite=Kahng95].

We are not aware of any previous work studying our version. However, in this paper, we show that the k-BST problem is NP-hard and we present a polynomial-time algorithm with constant factor approximation ratio for the problem.

Hardness Result

Given a set P of n terminals in the plane, a set S of m Steiner points and an integer k  ≤  m, the goal in the k-BST problem is to find a Steiner tree with at most k Steiner points from S and bottleneck as small as possible. In this section we prove hardness of the problem.

The k-BST problem cannot be approximated within [formula] in polynomial time, unless P = NP.

The proof directly follows by a slight modification of the proof of Theorem 1 in [\cite=Wang02].

2-Approximation Algorithm

In this section, we develop a polynomial-time approximation algorithm for computing a Steiner tree with at most k Steiner points (k-ST for short) such that its bottleneck is at most 2 times the bottleneck of an optimal (minimum-bottleneck) k-ST.

Let G = (V,E) be the complete graph over [formula]. We assume, without loss of generality, that [formula] such that [formula]. It is not hard to see that the bottleneck of an optimal k-ST is a length of an edge from E. For an edge ei∈E, let Gi = (V,Ei) be the graph with Ei  =  {ej∈E:|ej|  ≤  |ei|}. The idea behind our algorithm is to devise a procedure that, for a given edge ei∈E, does one of the following:

It constructs a k-ST of P in G with bottleneck at most 2 times |ei|.

It returns the information that Gi does not contain any k-ST of P.

For two points p,q∈P, let δi(p,q) be a shortest Steiner path between p and q in Gi, i.e., a path connecting p and q with minimum number of Steiner points in Gi. Let GP = (P,EP) be the complete graph over P. For each edge (p,q) in EP, we assign a weight w(p,q) equal to the number of Steiner points in δi(p,q). Let T be a minimum spanning tree of GP under w. We define the normalized weight of T as [formula].

If Gi contains a k-ST of P, then C(T)  ≤  k.

Let T* be a k-ST of P in Gi. A Steiner tree is full if all terminals are leaves. We decompose T* into a union of full trees. For each full tree T*j of T*, we will construct a spanning tree T'j of the terminals of T*j in GP, such that the union of these tree is a spanning tree T' of P in GP with C(T')  ≤  k. We arbitrary select a Steiner point as the root of T*j; see Figure [\ref=fig:fig2](a). The construction of T'j is bottom-up by an iterative process. In each iteration, we select the deepest leaf p in the rooted tree, which is a terminal, and we connect it to its nearest terminal q by an edge of weight equal to the number of Steiner points between them. Let s be the first common parent of p and q. We then remove the Steiner points between p and s (in the last iteration, we may remove all of the remaining points).

In the example in Figure [\ref=fig:fig2](b), we first select the terminal a, which is the deepest one, we connect it to the terminal b by an edge of weight 3 and we remove the points s1 and s2. Next, we select the terminal d, we connect it to the terminal c by an edge of weight 2 and we remove the point s3. In the last iteration, we select the terminal b, we connect it to the terminal c by an edge of weight 3 and we remove all of the remaining points.

Notice that, since, in each iteration, we select the deepest terminal, we add an edge (p,q), of weight w(p,q), and we remove at least [formula] Steiner points from T*j. This implies that [formula], where kj is the number of Steiner points in T*j. Moreover, the union T' of the trees T'j is a spanning tree of G' and has C(T')  ≤  k. Thus, since T is a minimum spanning tree of G', we have C(T)  ≤  C(T')  ≤  k.

We now describe our approximation algorithm. We traverse the edges of E in the sorted order and, for each edge ei∈E, we construct a minimum spanning tree T of GP = (P,EP) and check whether C(T)  ≤  k. If so, we construct a k-ST of P, otherwise, we move to the next edge ei + 1.

The construction of a k-ST is done as follows. For each edge e = (p,q)∈T, we select [formula] Steiner points on any shortest Steiner path between p and q in Gi, such that, the path from p to q that passes through these points has a bottleneck at most 2|ei|, and we connect these points to form a path; see Figure [\ref=fig:fig3]. Clearly, the obtained Steiner tree contains at most k Steiner points and its bottleneck is at most 2|ei|.

The algorithm above constructs a k-ST of P with bottleneck at most 2 times the bottleneck of an optimal k-ST.

Let ei be the first edge satisfying the condition C(T)  ≤  k. Thus, by Lemma [\ref=lemma:lemma3.3], the bottleneck of any k-ST in G is at least |ei|, and, therefore, the constructed k-ST has a bottleneck at most 2 times the bottleneck of an optimal k-ST.

The algorithm above has a polynomial running time.

Gi can be constructed in O((n + m)2) time. In order to construct the graph GP, we can compute in O((n + m)3) time the shortest Steiner paths between each pair of points in P [\cite=Cormen01]. Once GP is constructed, computing a minimum spanning tree of GP can be done in O(n2) time, and selecting the relevant Steiner points can be done in O(k(n + m)) time.

By combining Lemma [\ref=lemma:lemma3.4] and Lemma [\ref=lemma:lemma3.5], we get the following theorem.

There exists a polynomial-time approximation algorithm with performance ratio 2 for the k-BST problem.

Conclusion

In this paper, we studied the problem of finding bottleneck Steiner trees in the Euclidean plane. We proved that the k-BST problem in the plane does not admit any approximation algorithm with performance ratio less than [formula], unless P = NP, and that there exists a polynomial-time approximation algorithm with performance ratio 2. It would be interesting to find better approximation algorithm for the k-BST problem. Another interesting question is how efficient can one solve the k-BST problem for a constant k > 0?