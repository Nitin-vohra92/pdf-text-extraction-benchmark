Lemma Claim Fact Corollary

Definition

Optimizing positional scoring rules for rank aggregation

This work was partially supported by the Caratheodory research grant E.114 from the University of Patras and by a Ph.D. Scholarship from the Onassis Foundation. Emails: {caragian, chatzigeorgiou, krimpas, voudouris}.

Introduction

Social choice theory [\cite=BC+16] studies voting rules (also known as social choice or social welfare functions) that compute a winning alternative or a ranking of the available alternatives from voter preferences. Typically, the preference of each voter is supposed to be a ranking over all available alternatives. We deviate from this assumption and, instead, we focus our attention to settings in which each voter (or, better, agent for our purposes) ranks only a small subset of the alternatives. Such incomplete rankings seem to be non-standard in the literature; [\cite=WGS16] [\cite=DKNS01] [\cite=S07] are some notable exceptions.

The setting we have in mind is motivated by crowdsourcing [\cite=LA11] and rating applications. For example, assume that a requester would like to rank a huge set of alternatives using expert opinions from a crowd of workers. Asking each worker for her opinion on the whole set of alternatives (i.e., for a full ranking) would rather result in poor information. Most probably, the worker will not be aware of most of the alternatives. Even if she tries to obtain additional information, coming up with consistent comparisons between alternatives that she knows well and alternatives that she has no idea about, would be rather impossible, given their huge number. Instead, this task would be much easier if workers focused on small sets of alternatives. The requester could give each worker a different set of few alternatives to rank. Then, processing smaller inputs would be easier for the requester as well.

This approach has been recently exploited in the context of ordinal peer grading in MOOCs; see [\cite=CKV15] [\cite=CKV16] [\cite=RJ14] [\cite=SBP+13] for approaches of this flavour. In such settings, the task of grading an exam with many participating students is outsourced to the students themselves. Each student is given a small number of exam papers to rank and the final grading (a ranking of all students) is obtained by aggregating the inputs provided by the students.

In a rating application we envision, users of a hotel booking system are asked to rank hotels they have stayed recently in a specific city and the rating application aims to compute a full ranking of the hotels (or, possibly, different rankings for different relevant criteria). Clearly, each user can provide meaningful feedback for just a few hotels. Again, in this scenario, the system might ask each user to focus only on a subset of the hotels she knows.

Besides the different sets of alternatives each individual is asked to rank in the above scenarios, another implicit feature is that there is an underlying true ranking of all alternatives (e.g., the ranking of exam papers in terms of their quality or the ranking of hotels in terms of their facilities) that we would like to compute when aggregating the individual preferences. Can we do so using simple voting-like rules? We follow an optimization approach which can be described with the following question: Assuming that we have partial knowledge of the underlying true ranking and access to sampled profiles, which is the rule that yields an outcome that is as consistent as possible to (our partial knowledge of) the underlying true ranking when applied to the sampled profiles?

We study the above question for positional scoring rules (or, simply, scoring rules), which have played a central role in social choice theory. Two factors that have led to this decision are their simplicity and effectiveness; simplicity follows by their definition and effectiveness is justified by our experimental results. In particular, we consider settings in which each agent is asked to rank the same number d of alternatives. A positional scoring rule in our setting is defined by a scoring vector (s1,s2,...,sd). It takes as input the incomplete individual rankings of the agents and computes scores for alternatives as follows. An alternative gets sk points each time it is ranked k-th by an agent and its score is its total number of points. The final ranking is obtained by ordering all alternatives in terms of their scores, in non-increasing order. Now, a profile of individual incomplete rankings and desired relations for pairs of alternatives (to be thought of as parts of the underlying true ranking) with corresponding weights indicating the importance of each relation, we would like to compute the positional scoring rule whose outcome when applied on the profile maximizes the total weight of the desired pairwise relations it satisfies. This is related to learning-theoretic studies where a scoring rule that as consistent as possible to given examples is sought; e.g., see the paper by Boutilier et al. [\cite=BCH+15] and Procaccia et al. [\cite=PZ+09]. The main difference of the current paper (besides our assumption on profiles with incomplete rankings) is its optimization flavour. We refer to this seemingly fundamental optimization problem as OptPSR.

Our technical contribution is as follows. We present an exact algorithm that solves OptPSR in time that depends exponentially only on the parameter d (Section [\ref=sec:constant]). Hence, our algorithm runs in polynomial time when d is constant. For instances with high values of d, we show that a simple t-approval voting rule (that uses the scoring vector with t 1s followed by d - t 0s) yields a 1 / d-approximate solution. We show that this bound is tight by constructing an instance in which any approval voting rule is 1 / d-approximate. We prove that OptPSR is hard to approximate and present an explicit inapproximability bound of 23 / 24. This result follows by an approximation-preserving reduction from the problem MAX-3LIN-2 of maximizing the number of satisfied equations in an over-determined system of linear equations modulo 2 and exploits a famous inapproximability result due to Håstad [\cite=H01]. These results can be found in Section [\ref=sec:apx-approval]. In Section [\ref=sec:exp], we describe experiments on real-world and synthetic profiles. Our experimental results show that scoring rules perform remarkably well and recover almost 100% of the desired constraints in many interesting scenarios; this justifies our choice to study scoring rules (and the optimization problem OptPSR) in the first place. We begin with preliminary definitions in Section [\ref=sec:problem] and conclude with open problems in Section [\ref=sec:open].

Problem statement

We consider settings with a set of agents N and a set of alternatives A. Agent i expresses her preference over a subset Ai  ⊆  A of alternatives; her preference is a ranking of the alternatives in Ai. A preference profile (or simply, a profile) consists of the preferences of all agents. In this work, we assume that all agents have the same number d  ≥  2 of alternatives in their preference, i.e., |Ai| = d for each agent i.

A social welfare function takes as input a profile Π and it outputs a ranking of all alternatives in A. A positional scoring rule (or, simply, a scoring rule) is a social welfare function that uses a scoring vector [formula] with si  ≥  si + 1 for i = 1,...,d - 1 and sd  ≥  0; the alternative at position k in each vote is assigned sk points and the ranking of the alternatives is produced by ordering them in monotone non-increasing order in terms of their total points (or score). Formally, for an alternative x, let νj(x,Π) denote the number of agents that rank x at position j in profile Π. Then, given a scoring rule [formula], the score of alternative x is defined as

[formula]

We also assume that we have access to a set of constraints C that represents our (possibly partial) knowledge to an objective set of pairwise relations between the alternatives. Each constraint in C is given by an ordered pair of alternatives (x,y), has a corresponding non-negative weight (of importance) w(x,y), and requires that alternative x is ranked higher than alternative y in the outcome of the scoring rule [formula]. For a pair of alternatives (x,y), let δj(x,y,Π)  =  νj(x,Π)  -  νj(y,Π). Now, observe that, in order for alternative x to be ranked above y with certainty in the final ranking, it must be [formula] and, equivalently,

[formula]

Using [formula], the above expression can be compactly written as the dot product [formula].

For our purposes, instead of thinking of a profile Π as the set of rankings provided by the agents, it is convenient to describe it using the quantities [formula] for every constraint (x,y) in C; we use the notation [formula] to denote the set of these quantities and will simply refer to it as the profile.

Now, problem OptPSR (standing for "optimizing positional scoring rules") is defined as follows. We are given a profile [formula] and a set C of constraints. The goal of OptPSR is to find the scoring rule [formula] that produces a ranking of all alternatives so that the total weight (or gain)

[formula]

of satisfied constraints is maximized. The quantity [formula] takes value 1 if X is true and 0 otherwise.

Let us now give an equivalent view of OptPSR. A scoring rule [formula] can be thought of as a point in [formula], and, in particular, in the region R0 of [formula] formed by the inequalities si - si + 1  ≥  0 for i = 1,...,d - 1 and sd  ≥  0 that define all valid scoring vectors. We can define subregions of R0 by considering any subset C'  ⊆  C of constraints and the inequality [formula] for every constraint associated with the pair of alternatives (x,y)∈C' and the inequality [formula] for every constraint [formula]. In this way, the collection of all subsets of constraints in C partition R0 into disjoint subregions (of course, some of them may be infeasible). Hence, in order to maximize [formula], it suffices to find any point [formula] in the non-empty subregion of R0 that satisfies the subset of constraints with maximum total weight.

To do so, we can enumerate all subsets of constraints of C, check feasibility of the corresponding regions using linear programming, and report any point in the subregion that yields the highest gain. This algorithm takes time polynomial in 2|C| and d, assuming that it receives [formula] and C as input. In the next section, we will present an algorithm that uses a more clever enumeration of the feasible subregions in order to get the one that yields the maximum gain.

An improved OptPSR algorithm

We will present another (exact) OptPSR algorithm whose running time depends exponentially only on the parameter d and, hence, is polynomial when d is a constant.

The algorithm computes a pool of non-empty subregions of R0, each of which satisfies a different subset of constraints. Initially, the pool consists of region R0 only and is updated as new constraints of C are considered. When a new constraint is considered, each region in the current pool can be split into two subregions consisting of the points that satisfy the constraint and those that do not satisfy it, respectively; the whole region is retained in the pool if all its points satisfy or (exclusively) do not satisfy the constraint.

In particular, the algorithm considers the constraints of C one by one. At each step t of the algorithm, a pool P of regions is kept; at the beginning of each step, all regions in the pool are active. For each region R in P, the algorithm keeps the gain [formula] that is obtained by the constraints which have been considered until step t and are satisfied by scoring vectors of region R. The algorithms begin its execution having only region R0 in the pool. When a new constraint (x,y) with weight w(x,y) is considered, the algorithm attempts to update each active region R of P as follows. It defines the candidate regions Rxy and [formula] such that

Rxy is defined by the inequalities that form R together with inequality [formula] (that defines the set of points that satisfy constraint (x,y)), and

[formula] is defined by the inequalities that form R together with inequality [formula] (that defines the set of points that do not satisfy constraint (x,y)).

If both Rxy and [formula] are non-empty (i.e., the corresponding sets of inequalities are feasible), the algorithm includes both Rxy and [formula] in P as inactive, sets their gains [formula] and [formula], and removes region R from the pool. If only Rxy is feasible (and [formula] is infeasible), [formula] is increased by w(x,y). If only [formula] is feasible, the algorithm does nothing. In the last two cases, no new region is added to the pool. Clearly, it cannot be the case that both Rxy and [formula] are infeasible. Note that feasibility can be checked efficiently by solving linear programs with d variables and up to |C| constraints. At the end of step t (i.e., when there is no other active region in the pool to be considered), the inactive regions become active and the algorithm proceeds with step t + 1.

When all constraints of C have been considered, the algorithm computes the active region R* with maximum [formula] and returns any scoring vector in R*. An example of an execution of the algorithm with d = 2 is depicted in Figure [\ref=fig:alg].

Given an instance of OptPSR consisting of a set of constraints C and a profile [formula], the algorithm above correctly returns a solution in time [formula].

The correctness of the algorithm should be apparent. It considers the whole space of points in [formula] which corresponds to scoring vectors and divides it into all (sub)regions defined for every inclusion-maximal subset of constraints that are satisfied simultaneously. Among all these regions, it finds the one with points that correspond to scoring vectors that satisfy constraints of C with maximum total weight.

Expanding R0 into the regions in the pool when the last constraint of C is considered can be thought of as a non-complete binary tree T with nodes corresponding to regions (see Figure [\ref=fig:alg] for an example). T is rooted at a node corresponding to R0 and is such that each node at level t - 1, corresponding to a region R, has two children at level t if the region R was split in and replaced by two subregions at step t and has one child otherwise (indicating that the region was retained in the pool during step t). The total time required to find all regions is proportional to the size of T. Since all non-leaf nodes have at least one child, the size of T is at most its height |C| times the number of leaves. The number of leaves is essentially the number of different non-empty regions, which is upper-bounded by the number of different sign patterns that the quantities [formula] define for each constraint (x,y) in C. Since these |C| quantities are linear functions over the d coordinates of vector [formula], a result due to Alon [\cite=A96] (see also Warren [\cite=W68]) yields that the total number of different sign patterns is at most [formula]. For each of the nodes of T, feasibility can be checked by solving two linear programs with d variables and at most |C| constraints in time [formula]. The theorem follows.

By Theorem [\ref=thm:improved-alg], we obtain the following corollary. For comparison, the naive algorithm presented at the end of the previous section is polynomial in the very special case where |C| is at most logarithmic in d.

The algorithm solves instances of OptPSR with constant d in polynomial time.

Approximating OptPSR

As the running time of the exact algorithm of the previous section depends exponentially on d, our aim here is to design much faster (i.e., polynomial-time) algorithms that compute approximate OptPSR solutions. As we will see, an extremely simple scoring rule achieves a 1 / d-approximation, i.e., the total weight of the constraints it satisfies is at least 1 / d times the total weight satisfied by an optimal OptPSR solution. For t∈[d], the t-approval rule is a positional scoring rule that uses the scoring vector that has 1 in the first t positions and 0 in the remaining ones.

For every instance of OptPSR with parameter d, there exists some t∈[d] so that t-approval is a 1 / d-approximate solution. This bound is tight.

For the upper bound, consider a profile [formula] and set of constraints C. We partition the constraints of C into d disjoint sets C1,C2,...,Cd so that the t-th set is defined as

[formula]

for t = 1,2,...,d. Observe that the t-approval rule satisfies all constraints in the set Ct. Actually, set Ct is defined as the set of constraints that are satisfied by t-approval but not by [formula]-approval for [formula]. Hence, the sets C1,...,Cd are disjoint and there exists t*∈[d] (with [formula] being the scoring vector of t*-approval) such that [formula]. As the maximum possible gain cannot exceed [formula], we have that t*-approval is 1 / d-approximate as desired.

For the lower bound, we will present an OptPSR instance such that any t-approval, with t∈[d], is (at least) 1 / d-approximate. The instance has d pairs of alternatives (xt,yt) as constraints with w(xt,yt) = 1 for t∈[d]. We will build a profile Π* so that the t-approval rule satisfies only constraint (xt,yt), while there exists a scoring rule that simultaneously satisfies all constraints. Consider quantities a1,a2,...,ad with positive integer values such that [formula]. The profile is defined as follows:

Alternative x1 appears a1 times in position 1, and alternative y1 appears 1 + a1 times in position 2. This means that δ1(x1,y1,Π*) = a1, δ2(x1,y1,Π*) =  - 1 - a1 and δj(x1,y1,Π*) = 0 for j  ≥  3.

For 2  ≤  t  ≤  d - 1, alternative xt appears 1 + at times in position t, and alternative yt appears once in position 1 and 1 + at times in position t + 1. This means that δ1(xt,yt,Π*) =  - 1, δt(xt,yt,Π*) = 1 + at, δt + 1(xt,yt,Π*) =  - 1 - at and δj(xt,yt,Π*) = 0 for [formula].

Alternative xd appears 1 + ad times in position d, and alternative yd appears once in position 1. This means that δ1(xd,yd,Π*)  =   - 1, δd(xd,yd,Π*) = 1 + ad and δj(xd,yd,Π*) = 0 for 2  ≤  j  ≤  d - 1.

The rest of the positions in the votes are filled with additional alternatives that do not appear in the constraints.

Observe that, for t∈[d], we have that [formula], [formula] and [formula] for [formula]. Hence, the t-approval rule satisfies only constraint t for a total weight of 1.

Now we will show that there exists a scoring rule [formula] that satisfies all constraints. Let ε > 0 be some arbitrary small constant and consider the scoring vector [formula] with [formula], [formula], and [formula] for [formula]. First, observe that this is a valid scoring rule since, it is clear that si  ≥  si + 1 for all i∈[d  -  1] and, furthermore, it can be easily seen that sd  ≥  0 as well. Moreover, this scoring rule satisfies all constraints since [formula] for every t∈[d]. Hence, any t-approval is 1 / d-approximate.

On the negative side, we show that our problem is not only hard, but also hard to approximate within some constant.

For every constant η > 0, OptPSR is hard to approximate within 23 / 24 + η.

We use a reduction from MAX-3LIN-2, the problem of maximizing the number of satisfied equations in an over-determined system of linear equations modulo 2. An instance of MAX-3LIN-2 consists of n binary variables xi∈{0,1} and m equations of the forms [formula] and [formula], where [formula] denotes addition modulo 2 and its objective is to find an assignment to the variables so that the number of satisfied equations is maximized. Below, we use the term α-equation to refer to an equation of the form [formula] (for α∈{0,1}).

Given an instance of MAX-3LIN-2, our reduction constructs in polynomial-time an instance of OptPSR that has a scoring rule that satisfies constraints of total weight 11m + L if and only if the MAX-3LIN-2 instance has an assignment satisfying L equations. A famous result by Håstad [\cite=H01] states that it is hard to distinguish in time polynomial in n and m whether a given instance of MAX-3LIN-2 has an assignment that satisfies at least (1 - η')m equations or any assignment satisfies at most (1 / 2 + η')m equations, for any constant η' > 0. As a consequence of our reduction, we obtain that it is hard to distinguish between instances of OptPSR that have a scoring rule that satisfies constraints of total weight at least (12 - η')m and instances of OptPSR in which the total weight of the constraints satisfied by any scoring rule is at most (23 / 2 + η')m. An inapproximability bound of 23 / 24 + η (for every constant η > 0) then follows by standard arguments.

Without loss of generality, we can assume that the scoring vectors [formula], that we seek for, have s1 = d and the remaining scores are defined in terms of d - 1 variables a1,a2,...ad - 1  ≥  0 as si + 1  =  si  -  ai (or, consequently, [formula]) for i = 1,...,d - 1 so that [formula]. Hence, a constraint (y,z) requiring that the score of y is higher than the score of z can be expressed as a linear inequality of the variables aj with j∈[d  -  1]. The assumption that s1 = d allows for inequalities that have non-zero constant terms. We define linear inequalities corresponding to constraints first; later, we also construct the profile and specify the constraints as pairs of alternatives and corresponding weights that are consistent to these linear inequalities. Let mi be the number of equations in which variable xi participates. We set ε to be a small constant such that 0 < ε  ≤  1 / d and 1 / ε is an integer. The instance of OptPSR can be expressed with the following inequalities that represent constraints:

For every variable xi, we have the four inequalities ai  >  0, ai  <  ε, ai  >  1 and ai  <  1 + ε of weight mi each.

For every equation, there are four inequalities of unit weight each:

if the equation is of the form [formula], the inequalities are ai  +  aj  +  ak  >  0, ai  +  aj  +  ak  <  ε, ai  +  aj  +  ak > 2 and ai  +  aj  +  ak  <  2 + ε, and

if the equation is of the form [formula], the inequalities are ai  +  aj  +  ak  >  1, ai  +  aj  +  ak  <  1 + ε, ai  +  aj  +  ak > 3 and ai  +  aj  +  ak  <  3 + ε.

These inequalities are implemented as follows. Let d = n + 1. For every variable xi, with i∈[n], we have four constraints (yti,zti), where t∈{1,2,3,4}, of weight mi each. In the profile, alternatives yti and zti appear in specific positions as follows:

Alternative y1i appears once in position i, and alternative z1i appears once in position i + 1. Then, the constraint (y1i,z1i) corresponds to the inequality si - si + 1 > 0 or, equivalently, ai  >  0.

Alternative y2i appears once in position 1 and d / ε times in position i + 1, and alternative z2i appears d / ε times in position i. The constraint (y1i,z1i) corresponds to the inequality si  -  si + 1  <  ε or ai  <  ε.

Alternative y3i appears d times in position i, and alternative z3i appears once in position 1 and d times in position i + 1. The constraint (y3i,z3i) corresponds to the inequality si  -  si + 1  >  1 or ai  >  1.

Alternative y4i appears 1 / ε  +  1 times in position 1 and d / ε times in position i + 1, and alternative z4i appears d / ε times in position i. The constraint (y4i,z4i) corresponds to the inequality si  -  si + 1  <  1 + ε or ai  <  1 + ε.

Observe that three of the four inequalities corresponding to variable xi can simultaneously be satisfied when [formula], and only two of them are satisfied for any other value of ai.

For every equation [formula], we have four constraints [formula], where t∈{1,2,3,4}, of unit weight each. In the profile, these alternatives appear in specific positions depending on whether equation [formula] is a 0- or a 1-equation. In the case where it is a 0-equation of the form [formula], we have:

Alternative [formula] appears once in positions i, j and k, and alternative [formula] appears once in positions i + 1, j + 1 and k + 1. Then, the constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  >  0 or, equivalently, ai  +  aj  +  ak  >  0.

Alternative [formula] appears d times in position 1 and d / ε times in positions i + 1, j + 1 and k + 1, and alternative [formula] appears d / ε times in positions i, j and k. The constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  <  ε or ai  +  aj  +  ak  <  ε.

Alternative [formula] appears d times in positions i, j and k, and alternative [formula] appears 2 times in position 1 and d times in positions i + 1, j + 1 and k + 1. The constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  >  2 or ai  +  aj  +  ak  >  2.

Alternative [formula] appears 2 / ε + 1 times in position 1 and d / ε times in positions i + 1, j + 1 and k + 1, and alternative [formula] appears d / ε times in positions i, j and k. The constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  <  2 + ε or ai  +  aj  +  ak  <  2 + ε.

Observe that three of the inequalities corresponding to a 0-equation can simultaneously be satisfied when [formula]; otherwise, exactly two inequalities are satisfied. In the case where equation [formula] is a 1-equation of the form [formula], we have:

Alternative [formula] appears d times in positions i, j and k, and alternative [formula] appears once in position 1 and d times i + 1, j + 1 and k + 1. Then, the constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  >  1 or, equivalently, ai  +  aj  +  ak  >  1.

Alternative [formula] appears 1 / ε + 1 times in position 1 and d / ε times in positions i + 1, j + 1 and k + 1, and alternative [formula] appears d / ε times in positions i, j and k. The constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  <  1 + ε or ai  +  aj  +  ak  <  1 + ε.

Alternative [formula] appears d times in positions i, j and k, and alternative [formula] appears 3 times in position 1 and d times in positions i + 1, j + 1 and k + 1. The constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  >  3 or ai  +  aj  +  ak  >  3.

Alternative [formula] appears 3 / ε + 1 times in position 1 and d / ε times in positions i + 1, j + 1 and k + 1, and alternative [formula] appears d / ε times in positions i, j and k. The constraint [formula] corresponds to the inequality si  -  si + 1  +  sj  -  sj + 1  +  sk  -  sk + 1  <  3 + ε or ai  +  aj  +  ak  <  3 + ε.

Again, for every 1-equation, we have three inequalities that can simultaneously be satisfied when [formula]; otherwise, exactly two inequalities are satisfied.

In order for this profile to be valid, we use sufficiently many agents and additional alternatives as placeholders, so that the alternatives mentioned above have the appropriate number of appearances in the rankings.

We now prove that there exists a variable assignment for the MAX-3LIN-2 instance that satisfies L of its equations if and only if there exists a scoring rule that satisfies constraints of total weight 11m + L. As we have discussed above, this is enough to complete the proof.

Consider an assignment that satisfies L of the equations. Then, the scoring rule defined by setting ai  =  xi  +  ε / 4 for i∈[d  -  1] satisfies:

three out of the four inequalities corresponding to any variable xi, since ai  =  ε / 4∈(0,ε) when xi  =  0 and ai  =  1 + ε / 4∈(1,1 + ε) when xi  =  1;

three out of the four inequalities corresponding to any satisfied 0-equation [formula] since ai  +  aj  +  ak  =  3ε / 4∈(0,ε) when xi  +  xj  +  xk  =  0 and ai  +  aj  +  ak  =  2 + 3ε / 4∈(2,2 + ε) when xi  +  xj  +  xk  =  2;

two out of the four inequalities corresponding to any unsatisfied 0-equation since [formula] in that case;

three out of the four inequalities corresponding to any 1-equation [formula] since ai  +  aj  +  ak  =  1 + 3ε / 4∈(1,1 + ε) when xi  +  xj  +  xk  =  1 and ai  +  aj  +  ak  =  3 + 3ε / 4∈(3,3 + ε) when xi  +  xj  +  xk  =  3;

two out of the four inequalities corresponding to any unsatisfied 1-equation since [formula] then.

Hence, the total weight of the constraints satisfied is [formula] since [formula] due to the fact that all equations have 3 variables and the sum accounts for the total number of appearances of all variables.

Conversely, assume that we are given a scoring rule that satisfies constraints of total weight 11m + L; we will show that there exists an assignment to the variable of the MAX-3LIN-2 instance that satisfies L equations. First, we show that we can transform the scoring rule into a (possibly) different one with ai  =  ε / 4 or ai = 1 + ε / 4 for i∈[d  -  1], without decreasing the total weight of the satisfied constraints.

For a variable [formula] we have that the satisfied inequalities are the following: exactly two out of the four variable inequalities and at most three out of the four inequalities for each of the mi equations in which the variable xi appears. This gives a weight of at most 2mi + 3mi = 5mi. By setting ai: = ε / 4, exactly three out of the four variable inequalities and at least two out of the four equation inequalities in which xi appears are satisfied, for a total weight of at least 5mi. Clearly, there is no loss in weight after this change in the value of ai.

Now, we slightly modify the variable values as follows: for all variables ai∈(0,ε) we set ai: = ε / 4 and for all variables ai∈(1,1 + ε) we set ai: = 1 + ε / 4. The set of inequalities containing ai that were satisfied before the modification are still satisfied after the update as well. This is trivial for the variable inequalities. For an equation inequality of the form ai + aj + ak  <  α  +  ε (respectively, ai + aj + ak  >  α) that was satisfied before the modification, at most α (respectively, at least α) of the three variables have values in (1,1 + ε) before the modification. Clearly, the inequality is satisfied after the modification as well.

So, we can assume that we have total weight of 11m + L from satisfied constraints with the variables ai taking values in {ε / 4,1 + ε / 4}. Hence, [formula] comes as weight from satisfied variable inequalities (with three satisfied inequalities per variable). Then, the remaining weight comes from 2m + L satisfied equation inequalities. The definition of the reduction implies that there exist L equations in the MAX-3LIN-2 instance so that three among the four corresponding inequalities are satisfied. Then, it is easy to inspect that, if three among the four equation inequalities are satisfied when variables take values in {ε / 4,1 + ε / 4}, then the assignment xi: = ai  -  ε / 4 satisfies their corresponding equation as well. This yields an assignment with (at least) L satisfied equations and the proof is complete.

Experiments

We have conducted experiments for two different scenarios; we refer to them as ppl and col. In these two scenarios, we used as alternatives 48 countries and 36 cities, respectively. In both cases, the alternatives were used to define 392 different sets consisting of six alternatives each. The alternatives have been distributed to the different sets almost uniformly; each country appears in at least 47 and at most 52 sets and each city appears in at least 57 and at most 70 sets.

We used both real-world and synthetic data. Real-world data were collected as input from 392 participants in a technology exhibition at our home institution. Each of them was given two distinct sets of six countries and six cities. They were asked to rank the countries in terms of their population and the cities in terms of their cost of living. Synthetic data were obtained by simulating 392 agents who use the Plackett-Luce and Bradley-Terry noise models in order to compute random rankings.

The Bradley-Terry model [\cite=BT52] (BT, in short) is used by an agent in order to decide relations between all pairs of alternatives in her set as follows. Consider a pair of alternatives (x,y) with corresponding utilities (populations or cost of living indices) ux and uy. The agent decides to rank x above y with probability [formula] and y above x with probability [formula]. If the relative ranks of all pairs of alternatives (that have been computed separately) do not define a ranking, the whole process is repeated.

In the Plackett-Luce model [\cite=L59] [\cite=P75] (PL, in short), an agent decides the ranking of the alternatives in her set sequentially. Let B be the set of alternatives the agent has to rank. Starting from the first position, the next undetermined position in the ranking is filled by alternative x∈B with probability [formula]. After a random selection, the chosen alternative is removed from B and the process continues for the next undetermined position and the remaining alternatives until all positions are filled.

The set of constraints were defined using population data for the 48 countries from en.wikipedia.org and cost of living index data for the 36 cities from numbeo.com as retrieved in April 2016. In particular, in the ppl scenario, we have a constraint for each pair of countries x and y so that x is more populous than y. We consider two different weightings for constraints using weight that is either 1 or equal to the population difference between countries x and y. Unit weights are used when we care only about maximizing the number of correctly recovered population comparison between countries. However, there might be pairs that are really important to recover correctly, while some others are not that important. For example, it is important to conclude that China is ranked above Switzerland (their population difference is 1.3 billions) but an error in the comparison between Cuba and Belgium (both with populations around 11 millions) would not be that severe. Analogously, in the col scenario, we have a constraint for every pair of cities x and y so that x has higher cost of living index than y. The weight of the corresponding constraint is either 1 or equal to the cost of living index difference between the two cities.

Since all the profiles we experimented with have d = 6, one would expect that the exact algorithm presented in Section [\ref=sec:constant] would be the obvious choice in order to come up with the optimal scoring rule. Unfortunately, for the size of OptPSR instances we considered (with 1128 constraints for ppl and 630 constraints for col), this algorithm turned out to be really slow, even after implementing several heuristics that yield minor improvements to performance. This rather disappointing outcome together with the fact that d is small, forced us to consider scoring vectors with discretized scores (e.g., which are multiples of 0.05 or 0.02) in order to come up with approximations of the optimal scoring rule. This approach has yielded the vectors (1,0.5,0.35,0.2,0.15,0.05) and (1,0.65,0.65,0.35,0.3,0.25) for the ppl profile with unweighted and weighted constraints and the vectors (1,0.9,0.3,0.3,0.24,0) and (1,0.68,0.68,0.5,0.22,0.22) for the col profile with unweighted and weighted constraints, respectively.

We compare the optimal OptPSR solution (obtained in this way) to several well-known scoring rules such as the Borda count (defined by the scoring vector (d,d - 1,...,1)), the harmonic rule (also known as Dowdall; defined by the scoring vector (1,1 / 2,...,1 / d)), and t-approval rules. Tables [\ref=tab:pairwise] and Table [\ref=tab:weighted] show the performance of these scoring rules in all the OptPSR instances we experimented with.

In Table [\ref=tab:pairwise], which contains data for instances with unweighted constraints, we observe that Borda and Harmonic outperform all approval rules in all cases besides the col scenario with PL agents, where 4-approval is slightly better than Harmonic. Also, there are cases (e.g., ppl profile with BT agents) where Borda performs better than Harmonic and vice versa (e.g., see the results for real-world data). In all scenarios, the values of Borda, Harmonic and the best approval rule have an average difference of 2.3%, 2.36% and 3.1%, respectively, from the optimal values (with maximum difference values of 3.43%, 5.07% and 4.32% that are all observed for the col profile with PL agents). Interestingly, approval rules have amazingly better performance than what their worst-case analysis from Theorem [\ref=thm:approval] indicates.

Clearly, Table [\ref=tab:weighted] shows significantly better results from (almost) all scoring rules on OptPSR instances with weighted constraints. This is to be expected since solutions improve significantly when heavy pairwise relations are correctly recovered. Here, Borda, Harmonic and the best approval rule are all closer to the optimal performance. Now, the average distance is 1.05%, 1.08%, and 1.2%; again, the largest differences are observed for the col profile with PL agents.

Open problems

Our work reveals several open problems. First, we would like to determine the approximability of OptPSR. Is there a polynomial time algorithm with constant approximation ratio? Second, we would like to design an exact algorithm that is practical. Our ambitious goal is to be able to solve OptPSR instances like the ones we used in our experiments. Third, we would like to analyze theoretically scoring rules in random profiles that have been produced by Plackett-Luce or Bradley-Terry agents. Also, considering agents following other noise models that are close to real-world agents definitely deserves investigation.