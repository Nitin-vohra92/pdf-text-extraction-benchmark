Self-testing in parallel with CHSH

Introduction

The most basic self-testing problem is this: given two non-communicating quantum devices, verify through classical interaction alone that they share a maximally entangled pair of qubits. This problem can also be phrased in the language of non-local games. In a non-local game two non-communicating players, Alice and Bob, receive questions from a referee and attempt to win the game by providing answers which, together with the questions, satisfy some predicate. For non-local games, self-testing says that for Alice and Bob to approach the optimal quantum probability of winning, their strategy must approach some particular ideal quantum strategy.

While it is interesting that it is possible to self-test a single pair of maximally entangled qubits, many more applications are possible if many pairs can be tested. This motivates the idea of repeated self-tests, whether in serial or parallel, to test many pairs of maximally entangled qubits. Constructions for parallel repetition are more general, since strategies for serial repetition can be converted to parallel repetition but not the other way around.

The CHSH game [\cite=Clauser:1969:Proposed-Experi] is arguably the most well know non-local game and has seen wide application. It is distinguished by its simplicity, with only single-bit questions and answers for both Alice and Bob. Because of this simplicity, the CHSH game is widely used, both in theory and experiment. Hence it is a natural candidate for use with parallel repetition.

An important distinction to make is between self-tests where the number of players is kept at two, with self-tests where two new players are added for each copy of the self-test. We will be interested in the case of only two players, which places fewer restrictions on strategies and is hence more general.

Previous work

The history of self-testing using CHSH goes back to Popescu and Rohrlich [\cite=Popescu:1992:Which-states-vi] who characterized the optimal quantum strategies for CHSH. Although the terminology and applications of self-testing were later introduced by Mayers and Yao [\cite=Mayers:2004:Self-testing-qu]. Robust proofs of self-testing with CHSH appeared with Bardyn et al. [\cite=Bardyn:2009:Device-independ] and McKague et al. [\cite=McKague:2012:Robust-self-tes].

As a non-local game, parallel repetition of CHSH was considered by Cleve et al. [\cite=Cleve:2008:Perfect-Paralle], although they did not consider self-testing. Reichardt et al. [\cite=Reichardt2013:Classicalcommandofquantumsystems] looked at serial repetition of CHSH for self-testing. The first parallel self-testing result using CHSH is due to Wu et al. [\cite=Wu2015:Deviceindependentself] who used semi-definite programming and numerical methods to give robust error bounds for self-testing with two simultaneous games of CHSH. They also give an analytic proof of self-testing for the ideal case, again for two copies of CHSH.

Self-testing using parallel repetition first appeared in [\cite=McKague:2015:Selftestingin], which used the Mayers-Yao test [\cite=Mayers:2004:Self-testing-qu] and another CHSH-like self-test. However, the robustness bound of the latter test scaled exponentially with the amount of repetition.

Contributions

Our main contribution here is to give a self-testing construction for parallel repetition of the CHSH game. Informally, we prove that if Alice and Bob have a strategy for playing [formula] rounds of CHSH in parallel that achieves an average CHSH value of at least [formula] (i.e. they are ε close to the quantum bound) then their state is within [formula] of [formula] pairs of maximally entangled qubits.

As a step in our construction we also show that it is possible to self-test many maximally entangled pairs of qubits using a modified parallel repetition of CHSH with only a logarithmic number of questions (measurement settings). This is analogous to a similar result built on the Mayers-Yao test in [\cite=McKague:2015:Selftestingin].

In order to achieve our construction we slightly generalize the parallel self-testing framework given in [\cite=McKague:2015:Selftestingin]. Our construction is in some ways a generalization of the analytic proof of self-testing for two copies of CHSH given in [\cite=Wu2015:Deviceindependentself].

A framework for self-testing qubits

Before addressing our particular self-test, we will recall and slightly modify the self-testing framework introduced in [\cite=McKague:2015:Selftestingin].

Technical preliminaries

We define 1k to be the n-bit string which is 1 in the k-th position and 0 everywhere else. For x an n-bit string, let |x| be the number of 1's in x (the Hamming weight). Further, when n is even, define xa to be the n-bit string that agrees with x for the first [formula] bits and is zero elsewhere. The n-bit string xb agrees with x for the last [formula] bits and is zero elsewhere. Later, we will divide x between Alice and Bob so xa represents x on Alice's side, and xb is for Bob's side. Define the matrix R so that it exchanges the first and second halves of a bit string. Since R simply applies a fixed permutation on the entries of a string, it preserves the dot product, so that Rx  ·  Ry  =  x  ·  y. Also, R2  =  I so Rx  ·  y  =  x  ·  Ry.

If we have operators [formula] then for a bit string t∈{0,1}n we define

[formula]

The order of the product is important since we do not know whether the operators all commute. Hence we will make the convention that the index increases from left to right.

Sufficient conditions for self-testing

In [\cite=McKague:2015:Selftestingin] we developed a framework for self-testing states of many qubits, and in particular derived sufficient conditions for self-testing many pairs of maximally entangled qubits. Unfortunately, the framework in [\cite=McKague:2015:Selftestingin] is not general enough for our purposes. In particular, the sufficient conditions require the existence of a large set of commuting operators, but we will be unable to provide them here. In this section we will modify our previous work to provide a set of sufficient conditions which requires a smaller set of commuting operators.

To begin with, we recall Lemma 4 from [\cite=McKague:2015:Selftestingin], which gives a very general set of sufficient conditions for self-testing a many qubit state. Here we present a version which is restricted to many pairs of maximally entangled qubits, rather than the more general version in [\cite=McKague:2015:Selftestingin] which also applies to graph states.

Let [formula] be the n-qubit state

[formula]

Further suppose that [formula] is a normalized state in a Hilbert space HA (register A), and [formula], [formula] are unitary, Hermitian operators on HA such that for any s,t∈{0,1}n

[formula]

and

[formula]

Then there exists an isometry Φ and a state [formula] such that for any p,q∈(0,1)n

[formula]

The ideal state [formula] is the graph state corresponding to [formula] isolated edges and is hence [formula] pairs of maximally entangled states.

The conditions for this lemma involve products of many operators. In general we will not be able to directly deduce properties of such complex products. Hence we will derive a less general set of conditions which are easier to meet from the limited information provided by measurement outcomes. In [\cite=McKague:2015:Selftestingin] this step is provided by Lemma 5. However, the conditions used are too restrictive to be applicable in our case. Hence we will prove a less restrictive version of this lemma.

Suppose that n is even and

[formula] is a state

[formula] are pair-wise commuting operators on HA

[formula] are pair-wise commuting operators on HA

[formula] are operators on HB

[formula] are operators on HB

such that for all [formula]

[formula]

where [formula] is taken modulo n. Then

for any s,t∈{0,1}n

[formula]

for any s∈{0,1}n

[formula]

where ε  =   max {ε1,ε2,ε3}.

The main difference between Lemma 5 in [\cite=McKague:2015:Selftestingin] and our version here is that we have dropped several requirements on the operators. Explicit error bounds are the same as in [\cite=McKague:2015:Selftestingin].

First we address conclusion 1. We will not give the whole proof, but instead refer the reader to the proof of Lemma 5 in [\cite=McKague:2015:Selftestingin] and note the modifications we need to make. We first note that the proof never uses the fact that any operators are Hermitian or unitary. Hence we can drop these requirements. The proof does implicitly use the fact that many operators commute, but it is possible to remove these commutations through a careful choice of ordering of the steps. In particular, for equations (50) to (53) in [\cite=McKague:2015:Selftestingin] the proof starts from small indices and works to larger indices. Using this ordering requires that the leftmost operators commute to the right, but by starting at highest indices and working to lower indices the operators are already in the correct order and no commutation is required.

Here we also need to point out that if we had chosen a different initial ordering for the operators, for example decreasing indices from left to right, then the proof would still apply, provided that the same ordering is used throughout.

Now we turn our attention to conclusion 2. Again we will follow the same proof as in [\cite=McKague:2015:Selftestingin]. We can remove implicit commutations by choosing a different ordering. However, this would result in the [formula] operators coming out it the reverse order in the final bound. To fix this we need to use the fact that all [formula] operators on A's side commute, and also all [formula] operators on A's side commute. First, we reverse the ordering of the [formula]s on A's side. Then when these are converted to [formula]'s on B's side, they are reversed again and come out in the correct order. Meanwhile the [formula]'s on B's side are left alone. They come out in reverse order on A's side, where we commute them around to the correct ordering.

The conclusions of Lemma [\ref=lemma:acandxz] are nearly the conditions of Lemma [\ref=lemma:graphstateselftestconditions], so it is straightforward to join the two together. This will give us our sufficient conditions for self-testing many maximally entangled qubits.

Under the conditions of Lemma [\ref=lemma:acandxz], supposing that {Xk,Zk}nk = 1 are also unitary and Hermitian, there exists a local isometry [formula] and a state [formula] such that for every p,q∈{0,1}n

[formula]

The proof is basically to patch together Lemma [\ref=lemma:graphstateselftestconditions] and [\ref=lemma:acandxz] and work out the bounds. One aspect which requires a bit more attention is the fact that Φ is local. This is a consequence of the construction of Φ in the proof of Lemma [\ref=lemma:graphstateselftestconditions] and is discussed in [\cite=McKague:2015:Selftestingin].

Parallel CHSH is a self-test

Now that we have established a framework for self-testing many pairs of maximally entangled qubits, we are ready to develop our self-test based on parallel repetition of CHSH.

Definition of the non-local game

The non-local game that we will be using for self-testing is a straightforward parallel repetition of the CHSH game:

The referee selects question q∈R{0,1}n and sends qa to Alice and qb to Bob

Alice and Bob respond with bit strings [formula].

The referee chooses [formula] at random.

Alice and Bob win if [formula]

There are many possibly rules for determining when Alice and Bob win. The particular rule we use is quite weak an a sense. We throw away almost all of the information that Alice and Bob provide, and use only one bit from each of them. However, as we shall see, it is still powerful enough for self-testing the entire state. The most important feature is that the expected value of this game measures the average CHSH value over all subtests, which could be measured in other ways.

Customarily the value of a CHSH strategy is calculated by assigning 1 for a win and - 1 for a loss and summing over the expectations of the four possible questions that can be asked. The value falls between - 4 and 4, with quantum strategies between [formula] and [formula] by the Cirel'son inequality [\cite=Cirelson:1980:Quantum-general]. We will take the convention of assigning 4 to a win and - 4 to a loss, and then taking the expected value over all possible questions and subtests (i.e. for various [formula]). This corresponds to averaging the customary CHSH value over all subtests, and is bounded by [formula] for quantum strategies.

Modelling the players' behaviour

In order to use Lemma [\ref=cor:2partysufficientconditions] we will need to define some operators [formula] and [formula]. We will do so by way of Alice and Bob's measurement strategies. But first we need a model. Alice's behaviour can be modelled as a collection of projective measurements:

[formula]

where q is the question, [formula] is a string of answers and [formula]. We can define projectors for individual symbols in the answer by

[formula]

where [formula], ak is the k-th symbol of a, and x∈{0,1}. Note that for all [formula] the operators Γqaj,x and [formula] commute since Πqa and [formula] commute for all [formula]. We can next define observables for each answer symbol by

[formula]

Whenever qa  =  ra, [formula] and [formula] will commute by construction. Now measuring Mq is equivalent to measuring [formula] for each k and returning the resulting eigenvalues as a string (translating 1 to 0 and -1 to 1). Each [formula] is Hermitian and unitary.

We can model Bob's behaviour in a similar way, defining [formula] analogously to [formula]. Then every [formula] will commute with every [formula] since these operators are on different systems.

Let us set

[formula]

We can interpret f as the CHSH value that Alice and Bob would achieve for subtest k if they use the operators corresponding to questions qa, qb, [formula] and [formula]. The value of the non-local game can be expressed as

[formula]

This is the value of Alice and Bob's strategy and is the average CHSH value over all subtests [formula]. It falls between [formula] and [formula] for quantum strategies by the Cirel'son bound [\cite=Cirelson:1980:Quantum-general].

Self-testing from a few questions

In this section we develop a proof of self-testing in a special case. Our non-local game has a very large number of questions and it is difficult to make use of the information contained in the corresponding answers. In particular, each question is asked with an exponentially small probability, so we will know almost nothing about what happens when any particular question is asked. For now we will ignore this problem and assume that for some particular questions we know what the distribution of answers is. This will allow us to draw conclusions about the players' behaviour. In the next section we will return to the full non-local game.

In the previous section we modelled Alice and Bob's measurement strategies. We next need to define [formula] and [formula] so that we can use Corollary [\ref=cor:2partysufficientconditions]. To do this we will make use of a result from [\cite=McKague:2012:Robust-self-tes]:

Let A0,A1 be Hermitian and unitary operators on HA, B0,B1 be Hermitian and unitary operators on HB, and [formula] be a state such that

[formula]

for 0  ≤  δ  ≤  1. Then setting

[formula]

we have

[formula]

where

[formula]

for some operator M. Further, [formula], [formula], [formula] and [formula] are all Hermitian and unitary.

Note that it is possible that zero is an eigenvalue of |M|. For theses cases we must change M on the associated subspace to remove zero eigenvalues and avoid divide-by-zero problems. We can make the new eigenvalue as close to zero as we like, which corresponds to a very small change in Bob's measurements. By making this change small enough, it will be negligible compared to the other errors in the system.

In the next lemma we show how link the above result with Corollary [\ref=cor:2partysufficientconditions] to obtain a self-testing result. Here we assume that we have very good information about a small number of possible questions. This could be accomplished, for example, by having the referee ask only a subset of possible questions.

Suppose that:

For each [formula]

[formula]

For every [formula] with [formula] there exists a question qa with (qa)k  =  0 and [formula] such that

[formula]

for [formula].

Then there exist operators [formula] and [formula] for each [formula] such that the conditions of Corollary [\ref=cor:2partysufficientconditions] are satisfied with [formula] and [formula] .

For each k, the conditions of Lemma [\ref=lemma:buildxz] are satisfied. Hence on Alice's side ([formula]) we set

[formula]

for [formula]. Note that by construction all [formula] pairwise commute on Alice's side, as do all [formula]. For Bob's side ([formula]) we define

[formula]

Here it is possible that two [formula]'s on Bob's side do not commute. With these definitions we can set [formula] for Corollary [\ref=cor:2partysufficientconditions].

Now fix [formula]. We want to know that [formula] approximately commutes with [formula] to fix ε1. If k is on Alice's side and [formula] is on Bob's side (or vice versa) then the operators commute exactly. Hence the two cases to check are where k and [formula] are both at most [formula] or when they are both larger than [formula].

Supposing that k and [formula] are both larger than [formula], we use condition 2 for [formula] and [formula] to find qa and define

[formula]

Applying Lemma [\ref=lemma:buildxz] twice gives

[formula]

Here Bob's operators have not changed from their previous definition. Moreover, since [formula] and [formula] are defined from the same question, they commute with each other. Now it is a straightforward exercise to combine these two estimates and show that for this case we can use [formula]. Roughly, we use the estimates to move [formula] and [formula] over to Alice's side as [formula] and [formula], where we can commute them, and then move them back to Bob's side.

For the other case, where k and [formula] are less than [formula] so that [formula] and [formula] are on Alice's side, we first move [formula] and [formula] over to Bob's side, and then back to Alice side, but as [formula] and [formula], which commute. Then they go back to [formula] and [formula] via Bob's side. Here we end up with a worse estimate, and we finally set

[formula]

Although this is not our main result, we now have a type of parallel CHSH self-test. We simply need to estimate the values (for all k) of [formula] and [formula] for a suitable set of qa. One minimal set of such qa would be the strings indexed by j where the kth bit is 1 exactly when the jth bit of the binary representation of k is 1. The total number of questions is then O( log n). Whenever [formula] their binary representations will differ in some position j. Then the question with index j will bits k and [formula] not equal. This is analogous to the parallel Mayers-Yao test developed in [\cite=McKague:2015:Selftestingin].

The test is in a strict sense not parallel since the question for one subtest is not independent of the questions for other subtests. Nevertheless, it does provide a self-test and the small number of questions could be useful for some applications.

Self-testing from parallel CHSH

In the previous section we showed self-testing, but only looked at a very small number of possible questions. In the full non-local game we would not be able to draw any strong conclusions about specific questions since they would be asked with very small probability. In this section we take a different approach. If the players' value of the non-local game is very high then there must be at least some questions which are driving the value of the non-local game up. These might not be the questions used in Lemma [\ref=lemma:questionstoselftesting], but through various symmetries of the non-local game we can expand the list of questions which work for Lemma [\ref=lemma:questionstoselftesting].

First let us discuss symmetries. Lemma [\ref=lemma:questionstoselftesting] requires that questions [formula] and [formula] for Alice and Bob can be used to achieve a high CHSH value. However, there is obvious symmetry in the non-local game and it is straightforward to relabel the questions and answers so that many different sets of questions can be used. In particular, the mapping

[formula]

allows us to a flip bit k in all questions on Alice's side. An analogous map allows us to flip any bit in all questions on Bob's side. These mappings preserve the value of the non-local game. Applying a suitable set of them allows us to map any qa and qb to [formula], necessarily taking [formula] and [formula] to [formula].

Now we attempt to find some questions which give f(qa,qb,k) a large value. The basic idea is that it is impossible for everyone to be below average. Suppose that the value of the non-local game is at least [formula]. We can view the value of the non-local game given in [\eqref=eq:chshvalue] as an average over possible qb of some value depending on qb. At least one qb is at least average, so there exists some qb such that

[formula]

Let us choose such a qb and then remap the non-local game so that qb maps to [formula]. We can now do the same trick with qa to find that there is at least one qa such that

[formula]

Again we remap the non-local game so that this above average qa gets mapped to [formula].

In order to find a bound for each separate k, we observe that for each fixed k the summand is bounded above by [formula] using the Cirel'son inequality. Supposing that all the error falls on one value of k, we find

[formula]

for all k. Hence we have satisfied the first condition of Lemma [\ref=lemma:questionstoselftesting].

Turning our attention to the second condition of Lemma [\ref=lemma:questionstoselftesting], we first use a similar reasoning to above to find that for each j

[formula]

Now let us fix [formula] and partition the possible qa into two sets. The first set S has either [formula] or [formula]. That is, questions in S have the kth and [formula]th bits equal. The second set T is the remaining qa. Note that sets are of equal size, and qa and [formula] are in the same set. Supposing that all the error falls on T we find

[formula]

for [formula]. Now at least one qa is at least average, so there is some qa which differs in bits k and [formula] which satisfies

[formula]

for [formula]. From the definition of f, we see that the above must also hold for [formula]. At least one of qa and [formula] has kth bit equal to 0 and the [formula]th bit equal to 1. So, we have satisfied the second condition of Lemma [\ref=lemma:questionstoselftesting].

We have shown that if the value of the non-local game is high enough then the conditions of Lemma [\ref=lemma:questionstoselftesting] are satisfied with δ  =  O(nε), proving the following theorem.

If the value of non-local game for [formula] copies of CHSH achieved by a state [formula] is at least [formula] then there exist

Hermitian and unitary [formula] and [formula], defined on HA for [formula] and HB for [formula]

a local isometry [formula]

a state [formula]

such that for any p,q∈{0,1}n

[formula]

where [formula] is [formula] pairs of maximally entangled qubits.

Discussion

We have shown that the CHSH game can be used for testing many pairs of maximally entangled qubits, and that the error bound scales polynomially. This opens the possibility of using CHSH in more applications. The two constructions allow for either a strictly parallel CHSH test, where all subtests are independent, or a construction which requires uses a logarithmic number of questions.

Acknowledgements This work is partially funded by the Dodd-Walls Centre for Photonic and Quantum Technologies.