Finding Blackjack's Optimal Strategy in Real-time and Player's Expected Win

jarek@math.albany.edu

The main rules of blackjack are identical for all casinos, but they differ on details. And it would be too cumbersome to deal with all the variation of those. So this paper provides only the general framework, which, by the way, is easily adaptable to any particular set of blackjack's rules. The reader can see [\cite=BCMM] for explanation of the rules.

We distinguish between hard and soft blackjack's hands; a hand with an ace counted as 11 is soft, otherwise we call it hard. For example, ace and five is a soft sixteen (1 + 5 = 16s); ten and six is a hard sixteen (10 + 6 = 16h); or ace and ace is a soft twelve (1 + 1 = 12s).

Dealer's Probabilities

During the first stage of a game, dealer gets two cards, one face up and one face down. We can assume that his face-down card is still in a deck. Let Dd denote dealer's total given that his face-up card is d (in this paper d always denotes dealer's face-up card), where d = 1 means an ace (it can be counted as 1 or 11), d = 2 means a deuce, [formula], and d = 10 means a ten or any face card (we don't distinguish between a ten and any face card and we refer to them as a ten).

The blackjack's rules force dealer to hit anything below 17, so dealer's total can be 17, 18, 19, 20, 21 (any combination of cards adding to 21 but ten and ace), a natural (ten and ace), and a bust (anything above 21). To simplify the notation we denote a natural by 22 and a bust by 23.

At this point let's assume that we know dealer's probabilities (see the appendix for the algorithm),

[formula]

and [formula]. We assume that there are enough cards in a deck so [formula] for k < 17, and therefore the distribution, [formula], is not degenerate.

Since dealer checks for a natural (if d = 1 or d = 10) before player makes any decision we exclude this possibility by conditioning on the event Dd  ≠  22. This provides us with a new probability measure [formula] such that [formula]. By definition, given [formula],

[formula]

where the trivial case [formula] or [formula] is excluded. Then [formula] and we set [formula]. Note that [formula] for d  ≠  1,10, since [formula] for d  ≠  1,10.

The probability measure [formula] and player's cards determine the optimal strategy. For example, given that player's total equals 19, the player is interested in [formula], since this is the probability that he loses if he stands.

Deck and Cards' Probabilities

Now, we want to know how the fact that dealer doesn't have a natural affects cards' probabilities.

At any time the content of a deck is described by ten numbers [formula], where a1 denotes the number of aces, a2 the number of deuces, a3 the number of three's, [formula], and a10 the number of ten's. We refer to this deck as [formula]. When a card with a face value [formula] is drawn from [formula], then

[formula]

Now suppose that dealer's face-up card is a ten or an ace, but he doesn't have a natural. Despite the fact that we use the same deck, the probabilities are different. If d = 10, then

[formula]

or if d = 1, then

[formula]

And as we noted before [formula] for [formula] if d  ≠  1,10. See the appendix for derivation of these probabilities.

Player's Options

In this section we assume that dealer doesn't have a natural. A player with two cards has three or four options (this depends on casino's rules). We use WdST to denote player's win if he stands and dealer's face-up card is d; WdDD, he double downs; WdH, he hits; WdS, he splits. Given player's hand p, the optimal strategy is determined by looking at expected win for each of the available options: [formula], [formula], [formula], or [formula]. An option with the highest expected win is optimal.

If a player has a natural, then he wins one and a half of his original bet, and the game is over so we exclude this possibility in the computations below.

if Dd < p or Dd = 23, then he wins one dollar;

if Dd > p and Dd  ≠  23, then he loses one dollar;

if Dd = p, we have a tie, nothing happens.

So player's expected win equals

[formula]

where [formula] denotes the expected win under the condition that his total equals p and the cards are coming from [formula]. To simplify the notation we usually skip the conditioning on [formula], moreover when dealing with expressions of the type [formula], it is understood that the expected value is conditioned on   -  {i}.

[formula]

[formula]

It is a finite recursion, since the longest sequence of player's cards has length 20. We can introduce an extra variable that controls the recursion level; 13 is needed to compute [formula], but other hands need lower level of recursion, given desired accuracy, see the implementation.

[formula]

where "play" means all the options available to a player after splitting a hand. This formula is true because after split there are two identical hands (they are not independent but this doesn't concern us since expected value of sum equals sum of expected values).

When splitting aces each hand gets only one additional card (blackjack's rule), so

[formula]

where S1 means only one split. If a casino allows for re-splitting aces then "play" means only one additional card but two aces can be split again, so

[formula]

See the implementation for the general case.

Optimal Strategy and It's Payoff

Given player's two-card hand with total p, the optimal strategy is given by the action with the highest expectation. For example, if

[formula]

then a player should double down. Or for player's hand with at least three cards, we compare [formula] to [formula].

Now, we focus on an arbitrary hand, assuming that player follows the optimal strategy. We want to compute his average win W. Let Wd denote player's win given that dealer's face-up card is d, then [formula]. For d  ≠  1,10, we have

[formula]

and [formula] if i + j < 21.

There are two special cases, [formula] and [formula], where we need to consider the possibility that dealer has a natural. In order to compute [formula] we consider two cases: dealer has a natural and dealer does not have a natural,

[formula]

Note that [formula] means the probability of a natural. Moreover, we compute [formula] using the same method.

The first thing to notice about Table [\ref=ex-win] is that all its numbers are negative. So playing a blackjack is a losing proposition (if you don't vary your bets). But we can do better. In theory, given a [formula], if [formula] we bet one dollar; if [formula] we bet zero dollars. This strategy has a positive expected win, although it has to be modified, since computing [formula] at a blackjack's table would be difficult. The solution: we estimate [formula] by paying attention to cards removed from a deck.

First, we compute the effect of card removal on expected win, namely, we compute the change in expected value if one card is removed,

[formula]

see Table [\ref=ex-removal]. It implies that the cards 1, 8, 9, and 10 (inside the deck) increase player's expected win, since ri < 0 implies [formula]; the cards 2,3,4,5,6, and 7 decrease player's expected win. So by counting cards from these two groups and weighting them according to Table [\ref=ex-removal], we can estimate [formula] and bet accordingly, for more details see Gottlieb [\cite=GG] or Thorp [\cite=T].

Example. Let [formula] be composed of two decks with 111 as our blackjack's rules, see Table [\ref=ex-win]. So we know that [formula]. Now, suppose that the cards R = {1,1,2,2,3,4,4,4,5,5,5,7,7,8,10} are removed from the deck. The direct computation shows that [formula], whereas using Table [\ref=ex-removal] and linear interpolation (an interpolation using an exponential function would be better) when removing more than one card of the same value, we estimate

[formula]

How fast are these procedures when implemented?

The execution times of the program implementing the procedures described in this paper depends on dealer's face-up card. The table below gives times (in seconds) needed to compute [formula] one thousand times for different dealer's face-up cards (player's total is negligible, four decks were used). It was done on a computer with two 1.2 MHz processors (with 256 kB cache each), Although, only one processor was used to run the program.

Moreover, [formula] computes [formula] ten times; computational complexity of [formula] depends on recursion level, for example, it takes 0.51 seconds to compute [formula] with 9 recursion levels and 0.05 seconds with 2 recursion levels (the outputs are identical up to 15 digits after a decimal point). The most complicated case [formula] took 173.76 seconds to compute and 1.10 seconds for [formula]. A faster processor with a bigger cache should compute any split in a matter of seconds. Moreover, it takes about 30 minutes to compute [formula], although some trivial optimization techniques could cut that in half.

Appendix A: conditional probabilities

Given d = 10 and the fact that the dealer doesn't have a natural we want to compute [formula] for [formula]. By definition

[formula]

We compute [formula]; first the probability in the denominator,

[formula]

To compute the probability in the numerator, consider all the permutations of the unknown cards (dealer's face-down card is considered to be in a deck); there are [formula] of them. Next consider all the permutation with an ace as the first and a non-ace as the last card (dealer's face-down card). We count them considering nine choices for the last card,

[formula]

This sum multiplied by [formula] simplifies to [formula], so [formula]. The same method works for [formula].

Appendix B: Implementation

We use the following C++ class to describe a deck of cards,

where [formula] and [formula]. The function cardProb(i) gives probabilities according to measure [formula]; the function cardProb(i,d) gives probabilities according to measure [formula], when dealer's face-up card is d. The other functions are self explanatory. The example below shows how to compute the probability of {1 + 2, 2 + 1} for cards coming from [formula].

Also it is convenient to create a class adding cards according to blackjack's rules. The class has an integer (hand's total) and a boolean variable (soft/hard hand) as members.

The non-member operator operator+(const Hand& h, int i) is used to create temporary objects passed by value to other functions; given a hand, the operator operator+=(int i) is used to add cards to it. For example,

creates a soft sixteen.

With these two classes, the implementation of the expected value functions for stand (no naturals), double down, hit, and split is straightforward. where Q(i,d,deck) denotes [formula].

A variable rec controls the depth of recursion.

When splitting we distinguish between a pair of aces and a non-ace pair. With two aces we use a boolean variable rsa (re-split aces).

Given p > 1, we use two boolean variables, das (double down after split) and rsp (re-split non-ace pairs), and an auxiliary procedure NOSPLIT(Hand p, int d, Deck deck, bool das). With rsp=true, one hand could lead to four hands.

Appendix C: dealer's probabilities

We start with a procedure that computes dealer's probabilities of [formula]. To be more specific let's focus on [formula]; 19, 20, and 21 work the same way, with 17 as an exception.

[formula]

Moreover, we notice that we can move backward, namely

[formula]

The implementation looks as follows.

Now, a procedure dealerProb17(d,e) that computes the probabilities [formula] for e  ≤  17 is needed.

Next, [formula] is computed using a recursive procedure presented below.

And we use a brute force to compute dealerSoft2Hard17(d,e,deck), for example, 16s  →  15h can be decomposed as 16s + 9, 16s + 8 + 1, 16s + 7 + (2), and 16s + 6 + (3).

Finally, two auxiliary procedures are needed. The first one, prob(int a), computes the probability of all possible decompositions of a. For example, if a = 4 then there are eight of them: 4, 1 + 3, 3 + 1, 2 + 2, 1 + 1 + 2, 1 + 2 + 1, 2 + 1 + 1, and 1 + 1 + 1 + 1. Since we need it only for [formula], we can list all the cases and compute them one by one.

The second procedure, prob(int a, int b), where a,b  ≤  5, computes the probability of all possible decompositions of a and b. For example, if a = 2 and b = 3, then 2 + 3, 1 + 1 + 3, 2 + 1 + 2, 2 + 2 + 1, 1 + 1 + 1 + 2, 1 + 1 + 2 + 1, 2 + 1 + 1 + 1, and 1 + 1 + 1 + 1 + 1.