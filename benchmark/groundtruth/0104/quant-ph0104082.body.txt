A Quantum Search Algorithm for a Specified Number of Targets

This work was sponsored by the Department of the Air Force under Contract F19628-00-C-0002. Opinions, interpretations, conclusions, and recommendations are those of the author and are not necessarily endorsed by the United States Air Force.

Introduction

Recently Chen and Diao [\cite=ChenDiao00] presented a quantum algorithm for searching an unsorted database capable of finding, with certainty, a single target item in an N-item database after 2⌈ log 4N⌉ iterations of certain unitary operations. (⌈x⌉ denotes the smallest integer greater than or equal to x.) Grassl [\cite=Grassl01] and Tu and Long [\cite=TuLong01] have given a recursive implementation of these unitary operations, and have pointed out that, with this implementation, the number of oracle calls required for the jth iteration increases exponentially with j.

In this paper I present a modification of the algorithm of [\cite=ChenDiao00] for searching an unsorted database of N items for ν0  ≥  1 target items, provided that the number of targets ν0 is known in advance. In Section 2 below I discuss the case of ν0 equal to a power of four; in this case the algorithm will find one of the target items with unit probability. In Section 3 I discuss the case of ν0 not equal to a power of four; in this case the algorithm will find one of the target items with probability of at least one-half. The number of oracle calls required using the recursive implementation is given in Section 4. The notation and terminology follow, in general, those of [\cite=ChenDiao00] and [\cite=Grassl01].

Number of Targets a Power of Four

Denote the N items in the database D by [formula]. Of these items, a total of ν0 are members of the subset T of target items. An oracle function f(wi) indicates whether a selected item is or is not a target:

[formula]

If N is not already a power of four, we embed the database D in a larger database D containing additional non-target items such that the total number of items in D is the smallest power of four larger than N:

[formula]

where

[formula]

n an integer, i.e.,

[formula]

so

[formula]

The above enlargement of the database is as in [\cite=ChenDiao00]. Here, in addition, we embed D in a database [formula] which is four times larger still:

[formula]

where

[formula]

That is,

[formula]

All of the additional items not in D are by definition non-targets, so equation ([\ref=oracle]) still holds and the cardinality of T is still ν0.

For the database to be searched by a quantum computer [\cite=MerminQCnotes99], the [formula] items in [formula] are set in one-to-one correspondence with the [formula] computational-basis states [formula]:

[formula]

where each of the eigenvalues aj(i) is either 0 or 1. The 2ñ-component vector of aj's associated with wi is termed the symbol of wi:

[formula]

We also define auxiliary symbol functions

[formula]

It should be emphasized that the correspondence ([\ref=correspondence]) is not chosen to make the symbol S(wi) a binary representation of the item index i. On the contrary, it is essential for what follows that none of the N items in the set D be represented by states such that S2(wi) = 00. That is, we require that

[formula]

(We could, for example, establish the correspondence ([\ref=correspondence]) so that wi∈D  ⇒  S2(wi) = 11.) Condition ([\ref=notin00]) implies

[formula]

Extending the technique employed in [\cite=ChenDiao00] to the case of multiple targets, we select ν0 of the items with auxiliary symbols S2(wi) = 00 to be "ground state items." Specifically, the ν0 elements of the set G of ground state items,

[formula]

are those with the symbols

[formula]

The rightmost 2p entries in S(wGν0) are all 1's and constitute a binary representation of ν0 - 1, where

[formula]

We can now define the auxiliary functions

[formula]

and, in terms of these, the auxiliary oracle functions

[formula]

(The symbol "[formula]" denotes logical OR.) Note that

[formula]

The starting state for the iteration is the equally-weighted superposition of computational basis states obtained from the state [formula] by a Walsh-Hadamard transformation,

[formula]

Starting from |s0〉, a total of n0I iterations are performed of the transformation

[formula]

where

[formula]

The unitary operator Ij in ([\ref=iteration]) is defined as

[formula]

where I is the identity operator. In terms of its action on computational-basis states,

[formula]

The unitary operator Isj in ([\ref=iteration]) is defined as

[formula]

The proof that, after n0I iterations, the resulting state |sn0I〉 is an equally-weighted superposition of the ν0 states wi∈T proceeds by induction. Using ([\ref=startingstate]), ([\ref=iteration]), ([\ref=I_j2]) and ([\ref=I_sj]), we find, for j = 0,

[formula]

To evaluate the second sum in ([\ref=s1_intermediate]), divide the set of [formula] states into two groups, those for which S2(wi) = 00 and those for which S2(wi)  ≠  00. The first group contains 22(ñ - 1) states, of which the 22(ñ - 1)  -  ν0 states not in G have F1(wi) = 1, and the remaining ν0 states in G have F1(wi) = 0 (see eqs. ([\ref=auxiliaryfunction]), ([\ref=auxiliaryoracle])). Of the 3  ·  22(ñ - 1) states with S2(wi)  ≠  00, ν0 of these have F1(wi) = 1 by virtue of being target states (f(wi) = 1), and the remaining 3  ·  22(ñ - 1)  -  ν0 have F1(wi) = 0. So,

[formula]

and ([\ref=s1_intermediate]) reduces to

[formula]

We now assume that for some j,

[formula]

and derive the form of |sj + 1〉. From ([\ref=startingstatej]), ([\ref=iteration]), ([\ref=I_j2]) and ([\ref=I_sj]),

[formula]

The second sum in ([\ref=sj_intermediate]) can again be evaluated by counting. The items wi for which Fj(wi) = 1 fall into two disjoint groups, those for which fj(wi) = 1, and the elements of T. Of the former group, 22(ñ - j - 1)  -  ν0 have Fj + 1(wi) = 1 (those with [formula]--recall that the elements of G are not members of {wi|Fk(wi) = 1} for any k), and the remaining 3  ·  22(ñ - j - 1) have Fj + 1(wi) = 0. As for the elements of T, all ν0 have Fj + 1(wi) = 1. Therefore,

[formula]

Using ([\ref=sumj]) in ([\ref=sj_intermediate]), we obtain

[formula]

After applying n0I iterations ([\ref=iteration]) to the starting state ([\ref=startingstate]), we therefore obtain (keeping in mind that Fn0I(wi) = f(wi))

[formula]

A measurement of |sn0I〉 in the computational basis will with certainty yield one of the states corresponding to a target item.

Number of Targets Not a Power of Four

Only a small number of changes are required in the analysis presented above to produce an algorithm which will yield one of the target states with a probability greater than one-quarter when the number of targets is not a power of four, and which reduces to the algorithm of Section 2 when the number of targets is a power of four. All of the definitions through the selection of the ground-state items, eq. ([\ref=Gsymbols]), remain applicable. However, the integer p defined in ([\ref=pdef0]) must be everywhere replaced with p̃

[formula]

where ν is the smallest power of four larger than ν0. I.e.,

[formula]

[formula]

The rightmost 2p̃ entries in S(wGν0) constitute a binary representation of ν0  -  1, but they will are not all 1's. The definitions ([\ref=auxiliaryfunction]) and ([\ref=auxiliaryoracle]) of the auxiliary functions fj(wi) and the auxiliary oracle functions Fj(wi) remain unchanged. However, most significantly, eq. ([\ref=Fn_p]) is replaced with

[formula]

since not all items with [formula] are in G.

So, a derivation parallel to that in Section 2 leads to the conclusion that, by beginning with the initial state ([\ref=startingstate]) and performing ñ  -  p̃ iterations ([\ref=iteration]), we obtain the state

[formula]

If a measurement in the computational basis is made of the state ([\ref=sn_pq0]), the probability that one of the target states will be obtained is

[formula]

where

[formula]

The probability of finding a target state is thus between one, when ν0  =  ν (ρ = 1), and somewhat above one-quarter, when ν0  =  ν / 4  +  1 (ρ = 1 / 4 + 1 / ν).

Now suppose that, rather than making a measurement after ñ  -  p̃ iterations, we perform an "extra" iteration, i.e., compute

[formula]

before measuring. The definitions ([\ref=auxiliaryfunction]), ([\ref=auxiliaryoracle]) of fj(wi) and Fj(wi) work for j  >  ñ  -  p̃ and, with the relations ([\ref=pdef]), ([\ref=nudef]), imply that, regardless of the value of ν0,

[formula]

For j = ñ  -  p̃ the summation formula corresponding to ([\ref=sumj]) is

[formula]

The state resulting after one extra iteration is

[formula]

where

[formula]

The probability of obtaining a target state upon measuring |sñ  -  p̃ + 1〉 is

[formula]

For 1 / 4  <  ρ  <  1 / 2, P1(ρ)  >  P0(ρ), while, for 1 / 2  <  ρ < 1, P1(ρ)  <  P0(ρ). So, the appropriate strategy is to make a measurement after

[formula]

iterations if 1 / 2  ≤  ρ < 1, and to make a measurement after

[formula]

iterations if 1 / 4  <  ρ  <  1 / 2. The probability of obtaining a target state will in this way be at least as large as P0(1 / 2) = P1(1 / 2) = 1 / 2 (see Fig. 1).

Yet another iteration before measurement gives

[formula]

where

[formula]

and a probability of target-finding of

[formula]

Despite the extra iteration, the probability of obtaining a target state when ρ = 1 / 2 is not increased; P2(1 / 2) = 1 / 2. This is true for an arbitrary number of additional iterations. The quantum state obtained after ñ  -  p̃ + q iterations, q  ≥  1, is of the form

[formula]

where Aq and Bq satisfy the recursion relations

[formula]

The probability of finding a target upon measurement is

[formula]

From ([\ref=sn_pq1_result]) and ([\ref=sn_pq_general]) we see that A1 = 1 / 2 and B1 =  - 1 / 2 when ρ = 1 / 2. The relations ([\ref=recursionAq])-([\ref=P_q]) then show that

[formula]

This is not in any sense to claim that iteration algorithms different than those considered here might not improve on the probability of finding a target when ρ = 1 / 2. Nor is it to say that iterations beyond ñ  -  p̃ + 1 necessarily have no use. Probability functions Pq(ρ), q  ≥  2, can, for values of ρ  ≠  1 / 2, be larger than either P0(ρ) or P1(ρ), indeed as large as 1 (see Fig. 1).

Required Number of Oracle Calls

Grassl [\cite=Grassl01] and Tu and Long [\cite=TuLong01] have presented the following implementations of the operators Ij and Isj, and have evaluated the number of oracle calls required each time these operators are applied. From eq. ([\ref=I_j2]) we see that Ij can be written as

[formula]

From the condition ([\ref=notin00]) on the representation of elements of D (and, therefore, on all elements of the target set T), and the definitions ([\ref=auxiliaryfunction]), ([\ref=auxiliaryoracle]) of fj, Fj, it follows that

[formula]

Therefore

[formula]

and we see that each application of Ij requires a single call to the oracle, since the fj's are independent of f.

From the iteration condition ([\ref=iteration]), the definition ([\ref=I_sj]) of Isj, and the unitarity of Ij and Isj, we see that the operators Isj satisfy the relation

[formula]

Let t(j) denote the number of oracle calls required by Isj. Since Ij requires one oracle call, ([\ref=Irecursion]) implies

[formula]

For j = 0,

[formula]

which is independent of f, so

[formula]

and t(j) has the closed form

[formula]

Taking into account the single oracle call required by Ij, the total number of oracle calls required for nI iterations of ([\ref=iteration]) is

[formula]

which, using ([\ref=tclosedform]), has the value

[formula]

It follows from the results of Section 2 that, for ν0 a power of four, the required number of oracle calls to obtain a target with unit probability is

[formula]

If ν0 is not a power of four, the results of Section 3 imply that the number of oracle calls to obtain a target state with probability of at least one half is

[formula]

if ρ  =  ν0  /  ν is between 1/2 and 1, and

[formula]

if ρ is between 1/4 and 1/2.

The original algorithm of Chen and Diao [\cite=ChenDiao00] performs two series of n iterations of ([\ref=iteration]), so the number of oracle calls required to find the unique target item by that method is

[formula]

The exponent log 43 is approximately equal to 0.7925. So, with this particular implementation of the operators Ij and Isj, the computational complexity of the algorithms of [\cite=ChenDiao00] and the present paper scales more slowly than that of the best possible classical algorithm (O(N)), but not as slowly as that of Grover's algorithm [\cite=Grover96-8] ([formula]). Unlike Grover's algorithm, these algorithms will find a target item with certainty if the number of targets is a power of four. It is not known at present whether the implementation employed here is the most efficient possible, or if implementations requiring fewer oracle calls may exist.

Acknowledgments

I would like to thank Markus Grassl for providing a prepublication copy of [\cite=Grassl01], and the anonymous reviewer of the previous version of this paper for also pointing out the relation ([\ref=Irecursion]).

Figure Caption

Figure 1. Probability Pq of finding a target with q "extra" iterations, as a function of ρ. Solid line: q = 0. Dashed line: q = 1. Dotted line: q = 2.