=0pt

Fact Definition Lemma Proposition Convention Example Exercise Thesis Remark

Introduction to clarithmetic III

MSC: primary: 03F50; secondary: 03F30; 03D75; 68Q10; 68T27; 68T30

Keywords: Computability logic; Interactive computation; Game semantics; Peano arithmetic; Constructive theories

Introduction

Being a continuation of [\cite=cla4] and [\cite=cla5], this article relies on the terminology, notation, conventions and technical results of its predecessors, with which the reader is assumed to be well familiar. While the present paper is not self-contained, the entire "Introduction to clarithmetic" series is so, and can be read without prior familiarity with computability logic (CoL), which serves as a logical basis for all theories elaborated in the series.

The previously constructed systems [formula], [formula], [formula] and [formula] form a sequence of incrementally powerful theories, sound and extensionally complete with respect to polynomial time computability, polynomial space computability, elementary recursive time (=space) computability, and primitive recursive time (=space) computability, respectively. Continuing that pattern, the present paper introduces three new, incrementally strong (and stronger than their predecessors) theories [formula], [formula] and [formula].

A natural extreme beyond primitive recursive time is [formula]-provably recursive time (which can be easily seen to be equivalent to [formula]-provably recursive space). That means considering [formula]-provably recursive functions instead of primitive recursive functions as time complexity bounds for computational problems. Our present theory [formula] turns out to be sound and complete with respect to [formula]-provably recursive time computability in the same sense as [formula] is sound and complete with respect to primitive recursive time computability. Remember that, on top of the standard Peano axioms, [formula] had the single extra-Peano axiom xy(yx1), and its only nonlogical rule of inference, termed "[formula]-Induction", was

[formula]

with no restrictions on F(x). [formula] augments [formula] through the following single additional rule

[formula]

where F(x) is elementary. A justification for this rule is that, if we know how to decide the predicate F(x) (the left premise), and we also know that the predicate is true of at least one number (the right premise), then we can apply the decision procedure to F(0), F(1), F(2), until a number n is hit such that the procedure finds F(n) true, after which the conclusion xF(x) can be solved by choosing n for x in it.

The story does not end with provably recursive time computability though. Not all computable problems have recursive (let alone provably so) time complexity bounds. In other words, not all computable problems are recursive time computable. An example is

[formula]

where p(x,y) is a decidable binary predicate such that the unary predicate [formula] is undecidable (for instance, p(x,y) means "Turing machine x halts within y steps"). Problem ([\ref=jul19a]) is solved by the following effective strategy: Wait till Environment chooses a value m for x. After that, for [formula], figure out whether p(m,n) is true. If and when you find an n such that p(m,n) is true, choose n for y in the consequent and retire. On the other hand, if there was a recursive bound τ for the time complexity of a solution M of ([\ref=jul19a]), then the following would be a decision procedure for (the undecidable) [formula]: Given an input m (in the role of y), run M for τ(|m|1) steps in the scenario where Environment chooses m for x at the very beginning of the play of ([\ref=jul19a]), and does not make any further moves. If, during this time, M chooses a number n for y in the consequent of ([\ref=jul19a]) such that p(m,n) is true, accept; otherwise reject.

A next natural step on the road of constructing incrementally strong clarithmetical theories for incrementally weak concepts of computability is to go beyond [formula]-provably recursive time computability and consider the weaker concept of constructively [formula]-provable computability of (the problem represented by) a sentence X. The latter means existence of a machine M such that [formula] proves that M computes X, even if the running time of M is not bounded by any recursive function. System [formula] turns out to be sound and complete with respect to this sort of computability. That is, a sentence X is provable in [formula] if and only if it is constructively [formula]-provably computable. Deductively, [formula] only differs from [formula] in that, instead of ([\ref=jul18a]), it has the following, stronger, rule:

[formula]

where F(x) is elementary. Note that ([\ref=jul18b]) merely "modifies" ([\ref=jul18a]) by changing the status of xF(x) from being a premise of the rule to being an antecedent of the conclusion. A justification for ([\ref=jul18b]) is that, if we know how to decide the predicate F(x), then we can apply the decision procedure to F(0), F(1), F(2), until (if and when) a number n is hit such that the procedure finds F(n) true, after which the conclusion can be solved by choosing n for x in its consequent. Note that, unlike the earlier-outlined strategy for ([\ref=jul18a]), the present strategy may look for n forever, and thus never make a move. This, however, only happens when xF(x) is false, in which case the conclusion is automatically won.

A further weaker concept of (simply) [formula]-provable computability is obtained from that of constructively [formula]-provable computability by dropping the "constructiveness" condition. Namely, [formula]-provable computability of a sentence X means that [formula] proves that a machine M solving X exists, yet without necessarily being able to prove "M solves X" for any particular machine M. An example of a sentence that is [formula]-provably computable yet not constructively so is [formula], where S is an elementary sentence with [formula] and [formula], such as Gödel's sentence. Let L be a machine that chooses the left disjunct of [formula] and retires. Similarly, let R be a machine that chooses the right disjunct and retires. One of these two machines is a solution of [formula], and, of course, [formula] "knows" this. Yet, [formula] does not "know" which one of them is a solution (otherwise either S or S would be provable); nor does it have a similar sort of "knowledge" for any other particular machine.

A system sound and complete with respect to [formula]-provable computability is [formula]. It augments [formula] through the following additional rule:

[formula]

where the premise is an elementary sentence. The admissibility of this rule, simply allowing us to change x to x, is obvious in view of the restriction that xF(x) is a sentence (that is, F(x) contains no free variables other than x). Indeed, if an x satisfying F(x) exists, then it can as well be "computed" (generated), even if we do not know what particular machine "computes" it. As we remember, systems [formula]-[formula] are sound in a strong, constructive sense. Specifically, there is an effective (in fact, efficient) procedure for extracting solutions from proofs. The same strong form of soundness holds for [formula] and [formula] as well. [formula] stands out as the only system whose soundness theorem is not (and cannot be) constructive. Namely, while [formula]-provability of a sentence X implies that X has an algorithmic solution, generally there is no effective (let alone efficient) way to extract a particular solution from a proof of X.

Technical preliminaries

All terminology and notation not redefined in this paper has the same meaning as in [\cite=cla4] [\cite=cla5]. And all of our old conventions from [\cite=cla4] [\cite=cla5] extend to the present context as well. Namely, as in [\cite=cla5], a "sentence" always means a sentence (closed formula) of the language of [formula]. Similarly for " formula", unless otherwise specified or suggested by the context. Also, where n is a natural number, the standard term for n means 0 followed by n "[formula]"s (e.g., 0 is the standard term for 3). We may not always be very careful about terminologically or notationally differentiating between a number and the standard term for it.

As a binary predicate of the variable X over HPMs and the variable X over sentences, " X wins X" is not arithmetical (is not expressible in the language of [formula]), for otherwise so would be the truth predicate for elementary sentences: such a sentence is true iff it is won by an HPM that makes no moves. Remember from Section 14.3 of [\cite=cla4] that, on the other hand, for any particular sentence X, the (now unary) predicate "X wins X" is arithmetical. Throughout this paper, for each sentence X, we assume the presence of a fixed elementary formula [formula] naturally representing such a predicate, and when we say something like "[formula] proves that X wins X", what we precisely mean is that [formula], where [formula] is the standard term for the code of X. Or, if we say "[formula] proves that X is computable", what we precisely mean is that [formula].

The soundness proofs found in this article rely on the following lemma. In it, a clarithmetical sequent means a sequent [formula] where each Ei (0in) is a sentence (of the language of [formula]).

There is an efficient procedure that takes an arbitrary  [formula]-proof of an arbitrary clarithmetical sequent [formula] and constructs an n-ary GHPM M such that [formula] proves that, for any n-ary GHPMs [formula], if each [formula] (1in) is a solution of Ei, then [formula] is a solution of F.

If the phrase "[formula] proves that" is deleted in the present lemma, we get nothing but a weak/simplified version of Theorem 10.1 of [\cite=cla4], which, in turn, is a reproduction of Theorem 10.5 of [\cite=Japlbcs]. An analysis of the proof of the latter, combined with some basic experience in working with [formula], reveals that the latter can be formalized in [formula] in the form required by our present lemma.

[formula], a theory of PA-provably recursive time computability

The language of each of the theories [formula], [formula] and [formula] introduced in this paper is the same as that of any other system of clarithmetic constructed in the present series of articles -- that is, it is an extension of the language of [formula] through the additional binary connectives [formula] and quantifiers ,.

The axiomatization of [formula] is obtained from that of [formula] by adding the single new rule of inference, which we call Finite Search (FS):

[formula]

where F(x) is any elementary formula.

To summarize, the nonlogical axioms of [formula] are those of [formula] (Axioms 1-7 from Section 11 of [\cite=cla4]) plus one single additional axiom xy(yx) (Axiom 8). There are no logical axioms. The only logical rule of inference is Logical Consequence (LC) as defined in Section 10 of [\cite=cla4], and the only nonlogical rules of inference are FS and [formula]-Induction

[formula]

We fix

[formula]

as a standard formula of the language of [formula] saying that Turing machine (encoded by) x, on input y, at computation step z, halts with output t. By an explicit [formula]-provably recursive function we mean a natural number τ such that, where [formula] is the standard term for it, [formula]. Context permitting, we usually identify such a number τ or term [formula] with the (unary) function computed by the Turing machine encoded by τ. When τ is an explicit [formula]-provably recursive function and a given HPM M runs in time τ, we say that τ is an explicit [formula]-provably recursive bound for the time complexity of M; whenever such a τ exists, we say that M is a [formula]-provably recursive time machine.

An arithmetical problem has a [formula]-provably recursive time solution iff it is provable in [formula].

Furthermore, there is an efficient procedure that takes an arbitrary extended [formula]-proof of an arbitrary sentence X and constructs a solution of X (of [formula], that is) together with an explicit [formula]-provably recursive bound for its time complexity.

Proof of the soundness part of Theorem [\ref=ptt1]

Consider any sentence X with a fixed extended [formula]-proof. Our goal is to construct a [formula]-provably recursive time HPM M such that M wins X and, furthermore, [formula] proves that M wins X. We shall not explicitly address the question of the efficiency of our construction, because it is achieved the same way as in all previous soundness proofs. That is, as in the similar proofs of [\cite=cla5], we will limit ourselves to verifying the pre-"furthermore" part of the theorem.

We proceed by induction on the length of the proof of X. In each case of our induction, we show how to construct the above-mentioned HPM M, together with a recursive function τ, and present an informal proof of the fact that M solves X in time τ. A reader sufficiently familiar with [formula] will immediately see that such a proof can be reproduced in [formula].

The case of X being an axiom is simple and is handled in the same way as in the earlier soundness proofs. So is the case of X being derived by LC, only now it relies on Lemma [\ref=j15a] instead of the earlier relied-upon Theorem 10.1 of [\cite=cla4] (= Theorem 10.5 of [\cite=Japlbcs]). The case of X being obtained by [formula]-Induction is essentially handled in the way as in the soundness proof for [formula] found in [\cite=cla5], only with the words "primitive recursive" replaced by "[formula]-provably recursive".

So, the only case worth considering is that of X being derived by FS. Assume X is (the [formula]-closure) of xF(x), and thus its premises are (the [formula]-closures of) [formula] and xF(x). By the induction hypothesis, there is an HPM N that solves [formula]. Similarly for the other premise xF(x) but, since the latter is elementary, its solvability (that is, the solvability of xF(x)) simply means that xF(x) is true.

To describe our purported solution M of xF(x), assume [formula] are exactly the free variables of F(x), so that F(x) can be rewritten as [formula]. For simplicity, we rule out the trivial case of F(x) having no free occurrences of x. At the beginning, M waits for Environment to choose constants for the free variables [formula] of [formula]. Assume [formula] are the constants chosen for [formula]. From now on, we shall write F'(x) for [formula]. Further, where i is a natural number, we shall write Ni for the machine that works just like N does in the scenario where the adversary, at the beginning of the play, has chosen the constant i for the variable x and the constants [formula] for the variables [formula]. So, Ni wins the constant game [formula].

Environment's initial moves bring the original xF(x) down to xF'(x). The goal of M now is to win xF'(x). It achieves this goal by creating a record i, initializing it to 0, and then acting as prescribed by the following procedure:

Procedure LOOP: Simulate Ni until it chooses one of the two [formula]-disjuncts of [formula]. If the right disjunct is chosen, increment i by 1 and repeat LOOP. Otherwise, if the left disjunct is chosen, specify x as i in the (real) play of xF'(x), and retire.

Since xF'(x) is true, sooner or later the above procedure hits an i such that the simulated Ni chooses the left disjunct of [formula], meaning that F'(i) is true. This guarantees that M wins. A bound τ for the time complexity of M is computed by a Turing machine that follows the work of M and counts the steps that it performs before making a move. Such a function τ is [formula]-provably recursive because, as already noted, our entire argument can be reproduced in [formula].

Proof of the completeness part of Theorem [\ref=ptt1]

Consider an arbitrary sentence X, an arbitrary HPM X, and an arbitrary explicit [formula]-provably recursive function χ such that X is a χ time solution of X. Let [formula] be the standard term for the code of χ. We fix some enumeration of pairs of natural numbers and, where a is a natural number, denote the first (resp. second) element of the ath pair by (a)1 (resp. (a)2). We treat (x)1, (x)2 as pseudoterms and assume that the above enumeration is "standard enough", so that the functions (x)1 and (x)2 are primitive recursive and [formula] proves

[formula]

(E  ↔  F abbreviates [formula]). The function χ will also be treated as a pseudoterm. Namely, if we write z = χ(x) within a formal expression, it is to be understood as an abbreviation of [formula].

That χ is an explicit [formula]-provably recursive function, by definition, means that [formula] proves

[formula]

In [formula], from ([\ref=jul19b]) and ([\ref=jul19c]), by LC we get

[formula]

It is obvious that [formula] constructively proves (in the sense of Section 11 of [\cite=cla5]) the primitive recursive time computability of

[formula]

Therefore, by Theorem 11.2 of [\cite=cla5], [formula] proves ([\ref=j13b]), and hence so does [formula] because the latter is an extension of the former.

From ([\ref=j13b]) and ([\ref=j13a]), by FS, we get [formula] which, together with ([\ref=jul19b]), by LC, can be easily seen to imply

[formula]

The rest of our completeness proof for [formula] is literally the same as the completeness proof for [formula] found in Section 7 of [\cite=cla5], with the only difference that now χ is a [formula]-provably recursive (rather than elementary recursive) function; also, where Section 7 of [\cite=cla5] relied on Fact 7.2, now we rely on ([\ref=a2a]) instead.

The intensional strength of [formula]

We say that [formula] constructively proves the [formula]-provably recursive time computability of a sentence X iff, for some particular HPM X and some particular explicit [formula]-provably recursive function χ, [formula] proves that X is a χ-time solution of X.

The following theorem holds for virtually the same reasons as the similar Theorem 16.2 of [\cite=cla4] for [formula] or Theorem 11.2 of [\cite=cla5] for [formula], [formula] and [formula]:

Let X be any sentence such that [formula] constructively proves the [formula]-provably recursive time computability of X. Then [formula] proves X.

From our soundness proof for [formula] it is immediately clear that the above theorem, in fact, holds in the stronger, "if and only if" form. The same can be seen to be the case for Theorem 16.2 of [\cite=cla4] and Theorem 11.2 of [\cite=cla5].

[formula], a theory of constructively [formula]-provable computability

Deductively, [formula] only differs from [formula] in that, instead of the FS rule of the latter, [formula] has the following rule, which we call Infinite Search (IS):

[formula]

where F(x) is any elementary formula.

Let X be a sentence. We say that [formula] constructively proves the computability of X iff, for some HPM X, [formula] proves that X wins X.

Notice that, while our earlier defined concepts of polynomial, elementary recursive, primitive recursive and [formula]-provably recursive time (or space) computabilities are extensional in their nature, the concept of constructively [formula]-provable computability is intensional. To be precise, the former are properties of computational problems while the latter is a property of sentences. An extensional version of this concept could be defined by saying that a computational problem A is constructively [formula]-provably computable in the extensional sense iff there is a sentence X with [formula] (X "represents" A) such that X is constructively [formula]-provably computable in the intensional sense. The forthcoming Theorem [\ref=mainth] can be easily seen to continue to hold after replacing the intensional concept of constructively [formula]-provable computability by its extensional counterpart. Yet, doing so would significantly and unnecessarily weaken the theorem. This is the reason why, in the present context, we have opted for only considering the intensional concept. A similar comment applies to the concept of (not-necessarily-constructively) [formula]-provable computability defined later in Section [\ref=ss12].

For any sentence X, [formula] proves X iff [formula] constructively proves the computability of X.

Furthermore, there is an efficient procedure that takes an arbitrary extended [formula]-proof of an arbitrary sentence X and constructs an HPM X such that [formula] proves that X is a solution of X (of [formula], that is).

Proof of the soundness part of Theorem [\ref=mainth]

As in the earlier soundness proofs, we will limit ourselves to verifying the pre-"furthermore" part. Consider any sentence X with a fixed extended [formula]-proof. We proceed by induction on the length of the proof of X. In each case of the induction, we (show how to) construct an HPM M and present an informal proof of the fact that M solves X. It will be immediately clear that such a proof can be reproduced in [formula].

The case of X being an axiom is simple and is handled as in the soundness proof for [formula]. So is the case of X being derived by LC. So is the case of X being derived by [formula]-Induction -- namely, it is essentially handled in the same way as in the soundness proof for [formula] found in [\cite=cla5], but is, in fact, simpler, because we no longer need to care about complexity.

Finally, assume X is (the [formula]-closure of) [formula], obtained by IS from (the [formula]-closure of) [formula]. By the induction hypothesis, we know how to construct a solution N of [formula]. Here we assume that x occurs free in F(x) (otherwise the case is straightforward), and that [formula] are all the additional free variables of F(x). So, F(x) can be rewritten as [formula]. We let M -- the purported solution of [formula] -- be a machine that, at the beginning of the play, waits till Environment chooses constants [formula] for the variables [formula]. Let F'(x) stand for [formula] and, for each natural number i, let Ni be an HPM that plays [formula] just as N does in the scenario where, at the very beginning of the play, the adversary chose the constant i for the variable x and the constants [formula] for the variables [formula].

After the above event of Environment having chosen constants for all free variables, thus having brought the original game [formula] down to [formula], M creates a record i, initializes it to 0, and then acts as prescribed by the following procedure:

Procedure LOOP: Simulate Ni until it chooses one of the two [formula]-disjuncts of [formula]. If the right disjunct is chosen, increment i by 1 and repeat LOOP. Otherwise, if the left disjunct is chosen, specify x as i in the consequent of [formula], and retire.

If xF'(x) is false, [formula] is (automatically) won by M. And if xF'(x) is true, sooner or later the above procedure hits an i such that the simulated Ni chooses the left disjunct of [formula]; then, again, M wins, because it brings the consequent of [formula] down to the true F'(i).

Proof of the completeness part of Theorem [\ref=mainth]

Consider an arbitrary sentence X and an arbitrary HPM X. Let [formula] be an elementary sentence saying "X does not win X", so that [formula] says "X wins X". Our intermediate -- and main -- goal is to show that [formula] (Lemma [\ref=july]), from which the desired completeness of [formula] follows almost immediately. For the purposes of the subsequent section, it is important to note that, at this point, we are not making any assumptions about X and X. In particular, we are not assuming that X wins X, let alone that [formula] proves so; such an assumption will be made only later, after Lemma [\ref=july] is proven.

By a computation history we shall mean a finite initial segment of some computation branch of X. The way we encode configurations of X is described in Appendix A.1 of [\cite=cla4]. That encoding extends to computation histories as finite sequences of configurations in a standard way. For readability, we will often identify configuration histories with their codes and say something like "a is a computation history" when what is precisely meant is "a is the code of a computation history". We may further identify such an a with the standard term for it.

Remember from Section 14.5 of [\cite=cla4] that, where Φ is a legal position of X, the yield of Φ means the game [formula]. So, the type of the "yield" function in [\cite=cla4] is {}  ×  {}  →  {}. Here, for safety, we need an "intensional" version of this concept/function, whose type is {}  ×  {}  →  {}. Namely, let F be a closed [formula]-formula containing no predicate letters other than [formula], and no function letters other than ,, (F is not necessarily a sentence of the language of [formula] because it may contain constants other than 0). And let Φ be a legal position of F (of [formula], that is). Then, in the context of F, the intensional version of the yield of Φ, denoted by 〈Φ〉!F, is defined inductively as follows:

〈〉!F = F (remember that 〈〉 means the empty run).

For any nonempty legal position 〈λ,Ψ〉 of F (where λ is a labmove and Ψ is a sequence of labmoves):

If λ signifies a choice of a component Gi in an occurrence of a subformula [formula] or [formula] of F, and F' is the result of replacing that occurrence by Gi in F, then [formula].

If λ signifies a choice of a constant c for a variable x in an occurrence of a subformula xG(x) or xG(x) of F, and F' is the result of replacing that occurrence by G(c) in F, then [formula].

Let [formula] be a formula all of whose free variables are among [formula] (but not necessarily vice versa), and let z be a variable not among [formula]. We will write [formula] to denote an elementary formula whose free variables are z and those of [formula], and which is a natural arithmetization of the predicate that, for any constants [formula] in the roles of [formula], holds (that is, [formula] is true) iff a is a computation history and, where Φ is the position spelled on the run tape of the last configuration of that history, Φ is a legal position of X with [formula].

Let y be a variable and E be a formula not containing y. As in Section 14.6 of [\cite=cla4], we say that a formula H is a [formula]-development of E iff H is the result of replacing in E:

either a surface occurrence of a subformula [formula] by Fi (i = 0 or i = 1),

or a surface occurrence of a subformula xF(x) by F(y).

[formula]-development is defined in the same way, only with [formula] instead of [formula].

Assume [formula] is a formula all of whose free variables are among [formula], and y,z are variables not occurring in [formula]. Then:

(a) [formula] proves [formula].

(b) For every [formula]-development [formula] of [formula], [formula] proves [formula]H(y,),,H(y,)areallofthe(,y)- developmentsofE(),CLA9[formula]

For clause (a), observe that the predicate [formula] is primitive recursive and, furthermore, [formula] obviously constructively proves the primitive recursive time computability of [formula]. Hence, by Theorem 11.2 of [\cite=cla5], [formula] proves [formula]. Therefore, of course, so does [formula].

For clause (b), consider any [formula]-development [formula] of [formula] and assume [formula]. For any value of y, [formula] is the game to which [formula] is brought down by a certain labmove [formula]. To solve [formula] -- i.e., to make [formula] true -- we can choose u to be the result of appending such a labmove [formula] to the run-tape content of the last configuration of z. This argument can obviously be reproduced in [formula].

For clause (c), assume [formula], [formula] and [formula]. Consider the scenario where Environment does not move in any configuration starting from the last configuration of z. If X does not move either, it can be seen to lose, because [formula] is the final position reached in the play and its elementarization [formula], by our assumption, is false. But our assumption [formula] means that X cannot lose. So, sooner or later, X will move. We can trace, within [formula], the work of X (compute the continuously lengthening computation history) for as long as it takes, until X makes a move α. This α must be legal. Then it brings [formula] down to one of (the instances of) its [formula]-developments [formula] for a certain value of y. We choose the corresponding [formula]-disjunct [formula] in the consequent of ([\ref=m2e]); in it, we specify u as the computation history that we have traced, and specify y as the above-mentioned "certain value of y", which can be easily found from the last configuration of the history. Again, the entire argument can be reproduced in [formula].

Assume [formula] are pairwise distinct variables, and [formula] is a formula all of whose free variables are among [formula]. Then

[formula]

We prove this lemma by induction on the complexity of [formula]. Pick a fresh variable y. By the induction hypothesis, for any [formula]- or [formula]-development [formula] of [formula] (if there are any), [formula] proves

[formula]

Argue in [formula] to justify [formula]. Consider any values (constants) b and [formula] chosen by Environment for z and [formula], respectively. Throughout the rest of this argument, assume both [formula] and [formula] are true (otherwise we win). We need to see how to win [formula].

To solve [formula], we bring the resource ([\ref=m2e]) down to

[formula]

Since the [formula] and [formula] components of the above are true, in fact, the following resource is at our disposal:

[formula]

We wait till one of the following two events takes place:

Event 1: Environment makes a move α in [formula]. We may assume that this move is legal. Then, for one of the [formula]-developments [formula] of [formula] and some constant c, the labmove [formula] brings [formula] down to [formula]. So, now it remains to see how to win [formula]. In view of clause (b) of Lemma [\ref=m2a] and the truth of [formula], the resource [formula] is at our disposal. Using it, we find a d with [formula]. Now we bring ([\ref=m2d]) down to [formula]. Since the antecedent of this resource is true, it provides a sought way to win [formula].

Event 2: The provider of ([\ref=may18a]) brings it down to

[formula]

for one of [formula] and some constants d,c. Using clause (a) of Lemma [\ref=m2a], we check whether [formula] is true. If not, [formula] is guaranteed to be true (otherwise ([\ref=jul29]) would be lost by its provider), and we continue waiting for Event 1 to occur (never again react to Event 2): if such an event never occurs, the truth of [formula] obviously means that we win. Suppose now [formula] is true. Then, just as in the case of Event 1, ([\ref=m2d]) provides a way to win [formula]. We make the move that brings [formula] down to [formula], and follow the just-mentioned way.

If neither event happens, then [formula] is true (otherwise ([\ref=may18a]) would be lost by its provider) and, again, we win.

[formula].

Let a be the code of the empty computation history, and â be the standard term for a. Of course, [formula] and hence [formula] proves (â). In view of Fact 12.6 of [\cite=cla4], [formula] proves z(zâ). By Lemma [\ref=m2c], [formula] also proves [formula]. These three can be seen to imply [formula] by LC.

Now we are ready to claim the target result of this section. Suppose [formula] constructively proves the computability of X. We may assume that it proves "X solves X" for the earlier-fixed (yet arbitrary) HPM X. In other words, [formula]. Hence [formula]. Then, in view of Lemma [\ref=july], [formula], as desired.

[formula], a theory of PA-provable computability

[formula] only differs from [formula] in that it has the following additional rule of inference, called Constructivization:

[formula]

where F(x) is any elementary formula containing no free variables other than x.

Let X be a sentence. We say that [formula] proves the computability of X iff [formula] proves that there is ([formula]) an HPM that wins X.

For any sentence X, [formula] proves X iff [formula] proves the computability of X.

Proof of the soundness part of Theorem [\ref=mainthten]

As always, this part of the theorem is verified by induction on the length of the proof of X. The cases where X is an axiom, or is derived by LC or IS, are handled in the same way as in the soundness proof for [formula]. Here we shall only look at the case of X being derived by Constructivization. So, assume X is xF(x), where F(x) is an elementary formula not containing any free variables other than x, and xF(x) is derived from xF(x) by Constructivization. By the induction hypothesis, [formula] proves that xF(x) is "computable" which, as F(x) is elementary, simply means that xF(x) is true. So, [formula].

Argue in [formula]. Since xF(x) is true, there is a number a such that F(a) is true. Then the target xF(x) is solved by an HPM M that makes a as its only move in the play and retires. We ([formula], that is) cannot name such an M because we do not know what number a exactly is; yet we know that M exists. In other words, we know that X is computable.

Proof of the completeness part of Theorem [\ref=mainthten]

Consider an arbitrary sentence X. Let [formula] be a natural formalization of the predicate "x is (the code of) an HPM which does not win X". Remember that, in Section [\ref=s19], X was a fixed yet arbitrary HPM. And note that the sentence [formula] of Section [\ref=s19] was nothing but what we can now write as [formula]. So, Lemma [\ref=july] can now be re-stated as

[formula]

Further observe that, while X was fixed in Section [\ref=s19], the proof of Lemma [\ref=july] given there goes through with X as a ([formula]-quantified) variable; more precisely, ([\ref=julya]), in fact, holds in the following, stronger form:

[formula]

By LC, ([\ref=julyb]) implies

[formula]

Assume now [formula] proves that X is computable. In other words, [formula]. Then, by Constructivization, [formula]. But then, in view of ([\ref=julyc]), [formula], as desired.