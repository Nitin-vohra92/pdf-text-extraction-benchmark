= 5pt

Hierarchical Bipartition Routing for delivery guarantee in sparse wireless ad hoc sensor networks with obstacles

Introduction and related work

A wireless ad hoc sensor network is a decentralized network not relying on a preexisting infrastructure in that the nodes operate on limited hardware (memory and energy) and can only interchange packets within a radio range. The number of deployed nodes could be very large. Wireless ad hoc sensor networks are receiving a lot of attention in recent years due to their potential applications in various areas such as monitoring, security and data gathering.

Routing is the process of sending a packet from one or more source nodes to one or more target nodes through intermediate nodes. Each node decides locally to which neighbor the packet is forwarded. The decision is determined by the routing algorithm based on the ID of the destination node, the local topology (and possibly geometry) of the network, extra information stored in each node about the routes (the routing tables) and information contained in the packet itself.

A routing protocol defines the rules for exchanging the information between nodes. In geographic routing protocols the decision to which neighbor the packet is sent is controlled by the position of the nodes and the distances between them. The position information to each node can be obtained either by devices such as GPS or Galileo (geographic coordinates) or by analyzing the network structure (virtual coordinates). Position awareness can often significantly improve the efficiency of routing. In [\cite=MRSS08] it is mentioned that protocols using position information for routing like MFR [\cite=TK84], COP [\cite=Sto06], and GFG [\cite=FS06] are competitive alternatives to the classical routing protocols for wireless ad hoc networks as for example DSR [\cite=JMB01], AODV [\cite=PBD03], and OLSR [\cite=CJLMQV03]).

Most algorithms based on position awareness first try to deliver the packet using greedy techniques. For example, the simplest greedy routing technique [\cite=Fin87] will forward the packet to the neighbor closest to the destination. Most Forward Routing (MFR) [\cite=TK84] and Nearest with Forwarding Progress (NFP) [\cite=HL86] consider the projected distance on the source-destination line. MFR tries to get closer to the destination by sending the packet to the neighbor with maximum projected distance, while NFP suggests to adjust the transmission power by sending the packet to the neighbor with the smallest projected distance.

Greedy routing algorithms can easily be extended by taking into account power consumption. Power aware greedy routing in most cases tries to minimize the ratio of the energy consumed by a transmission to the progress made. The progress is the distance reduction towards the destination. This cost over progress (COP) power-aware framework is first introduced in [\cite=KNS06]. If the cost is equal for all connections, we obtain the simple greedy algorithm as already discussed above [\cite=Fin87]. If the cost of a connection is proportional to the distance between the nodes, the resulting routing is similar to compass routing [\cite=KSU99].

In general, greedy routing algorithms do not guarantee packet delivery. A packet can be trapped in a local minimum where the algorithm will fail to find a next neighbor. The probability of reaching a so-called dead-end increases if the network is less dense or if the network contains obstacles where no nodes can be placed and/or connections are truncated by obstacles.

There are several attempts to obtain delivery guarantee for greedy routing algorithms. The authors of [\cite=BMSU01] propose face routing, which guarantees delivery in two-dimensional unit disk graphs (UDG). Face routing is applied to a planar sub-network obtained by considering the Gabriel Graph [\cite=BMSU01] [\cite=LGSM04], the Relative Neighborhood Graph [\cite=Tou80], or the Morelia Graph [\cite=BCGKOSU04]. In [\cite=SD04] a greedy-face-greedy (GFG) approach is considered, where greedy routing is based on COP as in [\cite=Sto06] and face routing is similar to the one in [\cite=BMSU01]. Energy-aware routing is also proposed in LEARN [\cite=WSWLD06], SPFSP [\cite=SR06], End-to-End (EtE) [\cite=EMS08], and EEGR [\cite=ZS07].

Landmark-based routing algorithms like VCap [\cite=CCDU05], JUMPS [\cite=BPDCFS06], GLIDER [\cite=FGGSZ05], VCost [\cite=EMS07], and BVR [\cite=FRZ05] use virtual coordinates computed from the distances to specific nodes called landmarks, anchors, or beacons. In the first phase, a global and distributed election mechanism elects a set of nodes acting as landmarks. Then the landmarks flood the entire network or only parts of the network such that every node can compute its virtual coordinate depending on the distances to the landmarks. The virtual coordinates can then be used to route a message greedily through the network. Packet delivery is also not guaranteed if different nodes have the same virtual coordinates.

There are also several attempts to obtain delivery guarantee for landmark-based greedy algorithms. Most of them are based on a tree coordinate system like LTP [\cite=CMT07] and ABVCap [\cite=LA08]. An energy efficient approach is introduced in HECTOR [\cite=MRSS08]. This protocol mixes the use of the tree-based coordinate system of [\cite=CMT07] and the landmark-based coordinate system of [\cite=CCDU05] and [\cite=EMS07].

An alternative way for delivery guarantee can be obtained by hierarchical addressing, see for example [\cite=Tsu88]. Tsuchiya solves this problem by allowing nodes to self� configure their addresses. The protocol uses a hierarchical set of landmark nodes that periodically send scoped route discovery messages. A node's address is the concatenation of its closest landmark at each level in the hierarchy. The overhead of route setup can be reduced to O(n log n) and nodes only hold state for their immediate neighbors and their next hop to each landmark. However, this requires a protocol that creates and maintains this hierarchy of landmarks and appropriately tunes the landmark scopes. Recent proposals adopting this approach have been fairly complex [\cite=KAE00] in contrast to our design goal of configuration simplicity, see also [\cite=IS09] for an overview.

A second alternative to obtain delivery guarantee is clustering which is proposed by various researchers as for example in [\cite=CWLG97] and [\cite=KCVP95]. A closely related approach is the construction of connected dominating sets as routing backbones [\cite=W02].

In this paper, we introduce and evaluate a very simple landmark-based network partition technique called Hierarchical Bipartition Routing ([formula]) to support routing with delivery guarantee in wireless ad hoc sensor networks. It is a simple routing protocol that can easily be combined with any other greedy routing algorithm to obtain delivery guarantee. The efficiency of [formula] increases if the network is sparse and contains obstacles. These are exactly the networks where greedy algorithms will fail with high probability. The hierarchical bipartition of the network is performed on a landmark-based data structure setup in a pre-processing phase.

The space necessary to store the additional routing information at a node u is approximately log 2(n)  ·   log 2( deg (u)) bits on average, where n is the total number of sensor nodes in the network and deg (u) is the number of neighbors of u. This is in general not larger than the size necessary to store the IDs of all neighbors of u. The amount of work to setup the complete data structure is on average proportional to flooding the entire network log 2(n) times. The sizes of the virtual addresses are on average only a few bits larger than the sizes of the IDs.

We evaluate the performance of [formula] in combination with two simple energy-aware geographic greedy routing algorithms based on physical coordinates and virtual coordinates, respectively. Our simulations show that the difference between using [formula] and a weighted shortest path to escape a dead-end is only a few percent in typical cases.

This paper is organized as follows. In the next section, we define [formula]. After that in Section 3, we describe two simple greedy routing protocols and how they can escape from a dead-end using [formula] or a weighted shortest path. In section 4, we evaluate the performance of [formula]. Conclusions are given in Section 5.

Hierarchical Bipartition Routing ([formula])

A network is modeled as an undirected graph G = (V,E), where V is the set of nodes ( sensor nodes) and [formula] is the set of undirected edges ( connections) between sensor nodes. A connection e = {u,v} may have a positive weight [formula], also denoted by ω(u,v) or ω(v,u). In general, the weight represents the amount of energy necessary to reach the neighbor node. A path [formula] is a non-empty sequence of nodes ui∈V, 1  ≤  i  ≤  k, such that {ui,ui + 1}∈E, 1  ≤  i  <  k, is a connection between ui and ui + 1. The weight of p is

[formula]

Path p is a shortest path between u and v, if there is no path p' between u and v with ω(p')  <  ω(p).

The ω- distance dω(u,v) between two nodes is the weight of a shortest path between u and v.

The hop distance dh(u,v) between two nodes is the weight of a shortest path between u and v for the case that all connections {u,v} have weight ω(u,v) = 1.

To analyze the performance of [formula], we assume that every node u∈V has a physical geographic position [formula] in the plane defined by a two-dimensional real vector. These positions are only used by the geographic greedy routing protocols, and not by the hierarchical bipartition technique. The euclidean distance between two nodes u and v is

[formula]

Note that the ω-distance dω(u,v) and the hop distance dh(u,v) are defined by the network structure, whereas the euclidean distance is defined by the physical geographic positions of the nodes.

A network G = (V,E) is connected if there is a path between every pair of nodes. Network G' = (V',E') is a sub-network of G if V  ⊆  V and E'  ⊆  E, it is an induced sub-network of G if V'  ⊆  V and E'  =  {{u,v} ~ | ~ {u,v}∈E, ~ u,v∈V'}.

The nodes are assumed to be static. Each node is assumed to have a unique ID which is mainly used to break ties. The unique ID is also necessary to specify the target node of the packet, if we do not want to give every node a unique virtual address.

Initialization

The necessary data structure is built in several phases. In the first phase, an arbitrary node w and two landmark nodes x0, x1 are selected. Landmark node x0 is one of the nodes that has maximum ω-distance to w, and landmark node x1 is one of the nodes that has maximum ω-distance to x0. Every node u with

[formula]

and every node u with

[formula]

Let G0 be the network induced by the nodes with virtual address 0 and let G1 be the network induced by the nodes with virtual address 1.

If network G is connected, then G0 and G1 are connected.

Let v be a neighbor of a node u on a shortest path between u and x0, then

[formula]

If the virtual address of u is 0, then

[formula]

Since

[formula]

we get

[formula]

That is, all nodes v on a shortest path between u and x0 have virtual address 0 and thus G0 is connected. An analogous argumentation shows that G1 is connected. [formula]

In the next phase, we select for every virtual address α∈{0,1} two landmark nodes xα  ·  0, xα  ·  1 from the connected sub-network Gα. Here α  ·  0 and α  ·  1 is the extension of α by symbol 0 or 1, respectively. Landmark node xα  ·  0 is one of the nodes of network Gα that has maximum ω-distance to xα in sub-network Gα, and landmark node xα  ·  1 is one of the nodes of network Gα that has maximum ω-distance to xα  ·  0 in sub-network Gα. A node u of Gα whose ω-distance to xα  ·  0 is less than or equal to the ω-distance between u and xα  ·  1 gets virtual address α  ·  0. It gets virtual address α  ·  1, if the distance between u and xα  ·  0 is greater than the distance between u and xα  ·  1.

The bipartition of every Gα into two further sub-networks Gα  ·  0 and Gα  ·  1 can be continued with the new virtual addresses α until all the created sub-networks consist of only one single node. In this case, the nodes of the network are uniquely identified by the virtual addresses. An inductive application of Lemma [\ref=L1] shows that all the sub-networks Gα are connected.

Distributed address computation

The hierarchical bipartition can easily be computed by a distributed algorithm. Once the network is deployed, an arbitrarily selected node w starts flooding the network. The message carries a weight initialized to zero. The weight is increased by every forwarding node. If node u sends a message to a neighbor vi then u increases the weight by ω(u,vi). If a node receives more than one message, it will store and forward only the one with the smaller weight. If a node does not receive a new message for a while, the current weight represents the ω-distance to w. To be sure that the flooding is finished, the node has to wait for a time longer than the time required to propagate a message through the network. To reduce the overhead during the distance computation, the messages should be sent to the neighbors [formula] in ascending order with respect to the costs at the edges, that is, [formula].

The election of the landmark nodes for the bipartition of the network can be done by the following simple protocol. Assume we want to determine a unique node u with maximum ω-distance to some other node w. Then all nodes with a maximum ω-distance to w in its two-hop neighborhood (in case of parity the nodes with maximum IDs) start sending a message back to w. (The route back to w can be stored during the update process of the ω-distance to w.) Node w receives all these messages and can select the node u with maximum distance to w. It has to wait for a while such that no further messages will arrive. Then it sends a message back to the winner, the node u with maximum distance to w.

Routing protocol

The routing protocol is quite simple and straightforward. Assume a packet should be sent from a source node s to a target node t. If the virtual address of s starts with symbol 0 and the virtual address of t starts with symbol 1, then s is in sub-network G0 and t is in sub-network G1. In this case, the packet is sent step by step to a neighbor whose distance to landmark node x1 is minimum until it reaches a node in G1. Then it is routed within the connected sub-network G1 using the second symbol of the virtual addresses, and so on.

More generally, let α  ·  du  ·  αu be the virtual address of the current node u and α  ·  dt  ·  αt be the virtual address of the destination t such that [formula], du,dt∈{0,1}, and [formula]. That is, the symbols left to du and left to dt are equal in both virtual addresses. If du  =  0 and dt  =  1, the packet is sent greedily towards landmark node xα  ·  1, if du  =  1 and dt  =  0, the packet is sent greedily towards landmark node xα  ·  0. The packet does not leave the connected sub-network Gα. An inductive argumentation proves that [formula] guarantees delivery.

A packet sent with [formula] always reaches its destination.

Address size

The sizes |α| of the virtual addresses α depend on the number of partitions necessary to obtain single node graphs. In this case, the virtual addresses are unique and can be used for the identification of the nodes. If the weights of all edges are equal, then a worst case for the address length is a complete network, that is, a network where every node is connected to all other nodes. Then the number of bipartitions and thus the address length is n - 1. To avoid these worst-case situations, we can stop the bipartition process when all nodes of a sub-network Gα have hop distance ≤  1 to landmark node xα. This will considerably reduce the address size. Since now the nodes do not have unique virtual addresses, it is necessary to include the target ID in the packets.

The routing protocol can be extended as follows: Assume the packet reaches a node u that has virtual target address α but is not the target node. If a neighbor v of u is the target node, the packet can be sent to node v. Otherwise, the packet can be sent to xα and from xα to the target node. This is always possible, because all nodes with virtual address α are neighbors of xα. The decision to stop the bipartition is very easy to implement, because the nodes of Gα that are candidates for flooding only have to check their list of neighbors.

If the weights of the connections are not all equal, but depend on the distances of the connections, then it is in general not necessary to abort the bipartition process. In practical cases, the different lengths of the connections yields to a partition of the network into two almost equally sized sub-networks. In this case, the virtual addresses are unique and it will not be necessary to use the original IDs.

Storage size

A node has to store its ID, its virtual address, a routing table, and temporarily during the initialization phase some ω-distances to landmark nodes and some source IDs. For the partition of sub-network Gα into Gα  ·  0 and Gα  ·  1, we only need the ω-distances to xα  ·  0 and xα  ·  1. When the new virtual addresses α  ·  0 and α  ·  1 are assigned, it is no longer necessary to store these ω-distances, and the IDs of xα  ·  0 and xα  ·  1. For routing a packet it is sufficient to know for every position i, 1  ≤  i  ≤  |α|, the neighbor to which the packet has to be sent if the own address α and the target address of the packet are equal at the first i - 1 positions and differ at position i. If a node u with virtual address α has [formula] neighbors, then the size of the additional routing information is only |α|  ·   log 2 deg (u) bits.

Worst case behavior

From a theoretical point of view, the weight of a path routed by [formula] can be arbitrarily larger than a shortest path between the source and target node. Figure [\ref=fig01] shows a simple example. The virtual addresses of the black and white nodes start with symbol 0 and 1, respectively. A shortest path between the source node s and the target node t has weight 2  ·  a. [formula] routing will send the packet from s to v and then via x1 to t. The weight of this path is m  ·  a, where m can be arbitrary large. However, this is not a typical case for randomly generated networks.

In the worst case, the size of the virtual addresses α can reach the number n of nodes. This is for example the case if the network is complete and all edges have the same weight, or if the network is a path and the connections have exponentially increasing weights [formula]. However, if the number of nodes reachable with increasing distance is for most nodes approximately the same, the size of the virtual addresses is at most log 2n. This is also confirmed by our experimental evaluations of randomly generated networks.

Two greedy routing protocols

We mainly want to use [formula] to guarantee delivery for greedy routing protocols. For this reason, we combine [formula] with geographic greedy routing based on physical and virtual coordinates.

Physical coordinates

As already mentioned in the introduction, the simplest energy-aware geographic greedy routing protocol sends the packet to a neighbor for which the ratio of cost over progress is minimum. This cost over progress (COP) power-aware framework is introduced in [\cite=KNS06]. If we consider physical coordinates, the packet is sent from node u to a neighbor v of u for which

[formula]

and

[formula]

is minimum. If ω(u,v)  =  a, a  >  0, for all connections {u,v}, we obtain the simple geographic greedy routing that selects a neighbor closest to the destination [\cite=Fin87]. For ω(u,v)  =  de(u,v), the routing is similar to compass routing [\cite=KSU99]. If the angle between (u,v) and (u,t) is β and the distance to the target node tends to infinity, the ratio of cost over progress tends to [formula]. If ω(u,v) is defined by the commonly used energy function

[formula]

a,b  >  0, c  ≥  2, then an optimal routing tries to use equidistant steps towards the target node t. The best progress (also called the characteristic distance) is

[formula]

see also [\cite=SL01]. The ratio of cost over progress has its minimum at the position with distance [formula] from u in the direction to the destination.

Virtual coordinates

Our second greedy routing protocol is based on virtual coordinates which we will define by four landmark nodes denoted by A, B, C, and D. These four landmark nodes are selected similarly as in VCap (virtual coordinate assignment protocol) from [\cite=CCDU05]. The first landmark node A is one of the nodes with maximum ω-distance to an arbitrary node w. The second landmark node B is one of the nodes with maximum ω-distance to A. The third landmark node C is one of the nodes for which

[formula]

is maximum. And finally, the fourth landmark node D is one of the nodes for which

[formula]

is maximum. Since will consider energy efficient routing, we use the ω-distances instead of hop distances [\cite=CCDU05] for the computation of the virtual addresses.

In case of parity, the node with larger ID is chosen. The four landmark nodes A,B,C,D define for every node u a 4-tuple

[formula]

Our landmark-based routing protocol sends the packet to a neighbor v for which the ratio cost over progress is minimum. The progress d'(u,t) - d'(v,t) is defined by distance function

[formula]

Dead-end handling

Both greedy routing protocols can reach a so-called dead-end, i.e., a node u that has no neighbor v closer to the destination than u. If a dead-end is reached, the packet is either sent along a shortest path or by [formula] towards the destination node. In both cases the weight function ω is applied. The packet is sent hop by hop until a node is reached whose distance to the destination is less than the distance from the last dead-end node to the destination. Then the original greedy routing is continued.

It is obvious that a shortest-path routing is not possible in practice. We use shortest-path routing only to get a comparison with [formula] under the assumption that following a shortest path is a good idea to get out of a dead-end.

The two geographic routing variants based on physical coordinates are denoted by [formula] and [formula], the two variants based on virtual coordinates are denoted by [formula] or [formula], depending on whether the dead-end problem is cleared with the help of a shortest path or by [formula], respectively.

Analysis

The analysis of [formula] is done by randomly generated networks and randomly selected source and target nodes. The test environment and the obtained evaluation results is explained in the next subsections.

Experimental environment

Our networks have a size of 1000m ×   1000m. The radio range is fixed at 50m, the node density δ varies between 0.5  ·  10- 3 and 9.2  ·  10- 3 nodes per m2, which corresponds to an average node degree between 4 and 72. If one of the randomly created networks is disconnected, we use the largest connected component, if its size is at least [formula] of the size of the complete network.

Networks with holes or obstacles are created with the help of black/white-masks. If the randomly selected position of a node hits a white-entry of the mask, the node is omitted. We do not try to find another position for this node. The masks we use for our evaluations are shown in Figure [\ref=fig03], [\ref=fig05], and [\ref=fig07].

The lakes-mask of Figure [\ref=fig03] (latitude [formula], longitude [formula]) represents wet areas where sensors are lost during the dispersion process. The streets-mask of Figure [\ref=fig05] (latitude [formula], longitude [formula]) represents an area where the sensor nodes are assumed to be dispersed by vehicles driving along streets. The buildings-mask of Figure [\ref=fig07] (latitude [formula], longitude [formula]) represents an example of a metropolitan area. Here we additionally remove all connections between sensors that can not see each other, because there is a building in between.

We use the energy function

[formula]

for every connection {u,v}∈E, such that the characteristic distance is [formula].

Each of the Figures [\ref=fig03], [\ref=fig05], and [\ref=fig07] shows to the right two routing paths. The start node is encircled green, the destination node is encircled blue. The nodes traversed by [formula] are colored black. The nodes traversed by [formula] are colored yellow. The dead-end nodes of [formula] are colored red. The small light green (light red) nodes have a virtual address starting with 0 (with 1, respectively).

For every node density δ between 0.5  ·  10- 3 and 9.2  ·  10- 3 in steps defined by factor 1.2, we randomly create 1000 networks. For every network, we randomly selected 1000 source nodes and 1000 target nodes. Let [formula] and [formula] be the sum of the costs to route from the 1000 source nodes to the corresponding 1000 target nodes in all 1000 networks using [formula] and [formula], respectively. The cost of a route is the sum of the weights of the used connections. The overhead of [formula] is defined by

[formula]

It is defined in the same way for the other routing protocols [formula], [formula], [formula], and [formula].

Evaluations

The tables [\ref=tab01], [\ref=tab02], [\ref=tab03], and [\ref=tab04] show the average overhead in percent as a function of the node density δ. The overhead entries are colored continuously between green (0%) and red (50%). We think that it is more valuable to present the main results in a table than in a graphical illustration, because it is easy to create a graphical view from the values of the table, but not vice versa.

Table [\ref=tab01] considers networks where the sensor nodes are uniformly distributed. If the node density is greater than or equal to 1.0  ·  10- 3, the two greedy routing algorithms [formula] and [formula] on physical coordinates have less overhead than the greedy routing algorithms [formula] and [formula] on virtual coordinates. For less dense networks (δ  <  1.0  ·  10- 3), [formula] has even less overhead than [formula], [formula], [formula], and [formula]. The difference between a shortest path dead-end handling and a [formula] dead-end handling, i.e., the difference between [formula] and [formula] and between [formula] and [formula], is only a few percent. This holds for greedy routing with physical coordinates as well as for greedy routing with virtual coordinates.

The average address lengths and the average number γ of routes that have at least one dead-end are shown in Table [\ref=tab01], [\ref=tab02], [\ref=tab03], and [\ref=tab04] to the right. These tables show that the sizes of the virtual addresses are only a few bits larger that the sizes of the IDs, which are at least ⌈ log 2n⌉.

[formula] seems to be well suited for resolving the dead-end problem. The advantage of [formula] is the very good performance in particular for sparse networks and for networks with obstacles. This show Table [\ref=tab02], [\ref=tab03], and [\ref=tab04].

Coarsening the edge weights

During the initialization phase, the nodes have to store and manage distance values to landmark nodes. The distances are built by sums of edge weights. Our weights of the connections defined in equation [\ref=equ01] can simply be coarsed to only k different values by

[formula]

If we use weight function ωk instead of ω, the overhead of [formula] will increase, depending on the number k of different weights for the connections. In Table [\ref=tab09] it is shown how the overhead increases when the number of different weights decreases. If we have the same weight for all connections, the algorithm considers hop distances. Table [\ref=tab09] to the left shows that 8 different weights for the connections will decrease the overhead of [formula] only by a few percent. The table also shows that the denser the network is, the larger the overhead becomes. However, if the network is dense, the greedy algorithms reach a dead-end less often. If [formula] is used only to guarantee delivery for greedy routing protocols, the overhead will increase only minimal.

Energy to setup the data structure

During the setup of the initial data structure, the network is flooded several times. To determine the distances to the arbitrarily chosen start node w, the complete network is flooded. This is also the case for determining the distances to the landmark nodes x0 and x1. After that the network is flooded only partially, because the distances to landmark nodes x00 and x01 (x10 and x11) are only relevant for the nodes having a virtual address starting with 0 (with 1, respectively). In general, the total amount of energy to determine all distances to the 2  ·  2k landmark nodes with the same address length k is less than the amount of energy to flood the network two times. Our experimental analyses show that the amount of energy necessary for the next bipartition decreases for increasing address lengths.

Table [\ref=tab09] to the right shows the number of transmissions to build the initial data structure. This is not the average over 1000 networks but only one typical example. The network is created with a node density of 2.5  ·  10- 3 nodes per m2 without any masks. It has 2500 nodes and 23462 edges. The first line shows the total number of transmissions for flooding the network from the arbitrarily chosen node w. The second line shows the total number of transmissions for flooding the network from the two landmark nodes x0 and x1. The third line shows the total number of transmissions for flooding two sub-networks from four landmark nodes x00, x01, x10, and x11, and so on.

Conclusions

Greedy algorithms for routing in wireless ad hoc sensor networks are easy to implement. They are very effective but can unfortunately reach an impasse. In this paper, we have introduced and analyzed a very simple hierarchical bipartition technique for wireless ad hoc sensor networks. Every node gets a unique virtual address that can be used to route through the network with delivery guarantee. To keep the advantages of greedy routing, we suggest to use [formula] for finding the way out of a dead-end. This is especially very interesting if the network is sparse or contains obstacles. In these cases, the probability to reach a dead-end is very high. Our experimental evaluations even show the following: If more than 50% of the routes reach at least one dead-end, then the performance of stand-alone [formula] is in general better than the performance of geographic greedy routing with a shortest path dead-end handling.

The main assets and drawbacks of HBR are the following:

packet delivery guaranty

no packet overhead, because the unique virtual addresses are of size log n on average

small routing tables

no geographic coordinates necessary

works only for static network structures and is vulnerable to even small changes of topology

relative time-consuming and energy-consuming set-up phase

unbalanced partitioning process results in large address lengths

unbounded worst-case stretch factor