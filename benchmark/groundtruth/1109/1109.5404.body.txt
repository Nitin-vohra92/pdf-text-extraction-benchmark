Towards Optimal Learning of Chain Graphs

Preliminaries

In this section, we review some concepts from probabilistic graphical models that are used later in this paper. See, for instance, [\citep=Lauritzen1996] and [\citep=Studeny2005] for further information. All the graphs and independence models in this paper are defined over a finite set V. All the graphs in this paper are hybrid graphs, i.e. they have (possibly) both directed and undirected edges. We assume throughout the paper that the union and the intersection of sets precede the set difference when evaluating an expression.

If a graph G has a directed (resp. undirected) edge between two nodes X1 and X2, then we write that X1  →  X2 (resp. X1  -  X2) is in G. When there is a directed or undirected edge between two nodes of G, we say that the two nodes are adjacent in G. The parents of a set of nodes Y of G is the set PaG(Y)  =  {X1|X1  →  X2 is in G and X2∈Y}. The neighbors of a set of nodes Y of G is the set NeG(Y)  =  {X1|X1  -  X2 is in G and X2∈Y}. The boundary of a node X2 of G is the set [formula]. A route between two nodes X1 and Xn of G is a sequence of nodes [formula] st Xi and Xi + 1 are adjacent in G for all 1  ≤  i  <  n. The length of a route is the number of (not necessarily distinct) edges in the route. We treat all singletons as routes of length zero. A route in G is called undirected if Xi  -  Xi + 1 is in G for all 1  ≤  i  <  n. A route in G is called descending from X1 to Xn if Xi  -  Xi + 1 or Xi  →  Xi + 1 is in G for all 1  ≤  i  <  n. If there is a descending route from X1 to Xn in G, then Xn is called a descendant of X1. Note that X1 is a descendant of itself, since we allow routes of length zero. The descendants of a set of nodes Y of G is the union of the descendants of each node of Y in G. Given a route ρ between X1 and Xn in G and a route ρ' between Xn and Xm in G, [formula] denotes the route between X1 and Xm in G resulting from appending ρ' to ρ.

A chain is a partition of V into ordered subsets, which we call the blocks of the chain. We say that an element X∈V is to the left of another element Y∈V in a chain α if the block of α containing X precedes the block of α containing Y in α. Equivalently, we can say that Y is to the right of X in α. We say that a graph G and a chain α are consistent when (i) for every edge X  →  Y in G, X is to the left of Y in α, and (ii) for every edge X  -  Y in G, X and Y are in the same block of α. A chain graph (CG) is a graph that is consistent with a chain. A set of nodes of a CG is connected if there exists an undirected route in the CG between every pair of nodes of the set. A component of a CG is a maximal (wrt set inclusion) connected set of its nodes. A block of a CG is a set of components of the CG st there is no directed edge between their nodes in the CG. Note that a component of a CG is connected, whereas a block of a CG or a block of a chain that is consistent with a CG is not necessarily connected. Given a set K of components of G, a component C∈K is called maximal in G if none of its nodes is a descendant of [formula] in G. A component C of G is called terminal in G if its descendants in G are exactly C. Let a component C of G be partitioned into two non-empty connected subsets [formula] and L. By splitting C into [formula] and L in G, we mean replacing every edge X  -  Y in G st [formula] and Y∈L with an edge X  →  Y. Moreover, we say that the split is feasible if (i) X  -  Y is in G for all [formula], and (ii) X  →  Y is in G for all X∈PaG(L) and [formula]. Let L and R denote two components of G st [formula]. By merging L and R in G, we mean replacing every edge X  →  Y in G st X∈L and Y∈R with an edge X  -  Y. Moreover, we say that the merging is feasible if (i) X  -  Y is in G for all [formula], and (ii) X  →  Y is in G for all [formula] and [formula].

A section of a route ρ in a CG is a maximal undirected subroute of ρ. A section [formula] of ρ is a collider section of ρ if [formula] is a subroute of ρ. Moreover, the edges X1  →  X2 and Xn - 1←Xn are called collider edges. Let X, Y and Z denote three disjoint subsets of V. A route ρ in a CG is said to be Z-active when (i) every collider section of ρ has a node in Z, and (ii) every non-collider section of ρ has no node in Z. When there is no route in a CG G between a node of X and a node of Y that is Z-active, we say that X is separated from Y given Z in G and denote it as [formula]. We denote by [formula] that [formula] does not hold.

Let X, Y, Z and W denote four disjoint subsets of V. An independence model M is a set of statements of the form [formula], meaning that X is independent of Y given Z. Given two independence models M and N, we denote by M  ⊆  N that if [formula] then [formula]. We say that M is a graphoid if it satisfies the following properties: Symmetry [formula], decomposition [formula], weak union [formula], contraction [formula], and intersection [formula]. The independence model induced by a CG G, denoted as I(G), is the set of separation statements [formula]. It is known that I(G) is a graphoid [\citep=StudenyandBouckaert1998]. Let H denote the graph resulting from a feasible split or merging in a CG G. Then, H is a CG and I(H) = I(G) [\citep=Studenyetal.2009].

A CG G is an independence (I) map of an independence model M if I(G)  ⊆  M. Moreover, G is a minimal independence (MI) map of M if removing any edge from G makes it cease to be an I map of M. Given any chain [formula] that is consistent with G, we say that G satisfies the pairwise block-recursive Markov property wrt M if [formula] for all non-adjacent nodes X and Y of G and where k* is the smallest k st [formula]. If M is a graphoid and G satisfies the pairwise block-recursive Markov property wrt M, then G is an I map of M [\citep=Lauritzen1996]. We say that a CG Gα is a MI map of an independence model M relative to a chain α if Gα is a MI map of M and Gα is consistent with α.

Extension of Meek's Conjecture to Chain Graphs

Given two directed and acyclic graphs G and H st I(H)  ⊆  I(G), Meek's conjecture states that we can transform G into H by a sequence of arc additions and covered arc reversals st after each operation in the sequence G is a directed and acyclic graph and I(H)  ⊆  I(G) [\citep=Meek1997]. Meek's conjecture was proven to be true in [\citep=Chickering2002] by developing an algorithm that constructs a valid sequence of operations. In this section, we extend Meek's conjecture from directed and acyclic graphs to CGs, and prove that the extended conjecture is true. Specifically, given two CGs G and H st I(H)  ⊆  I(G), we prove that G can be transformed into H by a sequence of directed and undirected edge additions and feasible splits and mergings st after each operation in the sequence G is a CG and I(H)  ⊆  I(G). The proof is constructive in the sense that we give an algorithm that constructs a valid sequence of operations.

We start by introducing two new operations on CGs. It is worth mentioning that all the algorithms in this paper use a "by reference" calling convention, meaning that the algorithms can modify the arguments passed to them. Let K denote a block of a CG G. Let L  ⊆  K. By feasible block splitting (fbsplitting) K into [formula] and L in G, we mean running the algorithm at the top of Figure [\ref=fig:fb]. The algorithm repeatedly splits a component of G until L becomes a block of G. Before the splits, the algorithm adds to G the smallest set of edges so that the splits are feasible. Let L and R denote two blocks of a CG G. By feasible block merging (fbmerging) L and R in G, we mean running the algorithm at the bottom of Figure [\ref=fig:fb]. The algorithm repeatedly merges two components of G until [formula] becomes a block of G. Before the mergings, the algorithm adds to G the smallest set of edges so that the mergings are feasible. It is worth mentioning that the component Lj in line 6 is guaranteed to be unique by the edges added in lines 3 and 4.

Our proof of the extension of Meek's conjecture to CGs builds upon an algorithm for efficiently deriving the MI map Gα of the independence model induced by a given CG G relative to a given chain α. The pseudocode of the algorithm, called Method B3, can be seen in Figure [\ref=fig:methodb2]. Method B3 works iteratively by fbsplitting and fbmerging some blocks of G until the resulting CG is consistent with α. It is not difficult to see that such a way of working results in a CG that is an I map of I(G). However, in order to arrive at Gα, the blocks of G to modify in each iteration must be carefully chosen. For this purpose, Method B3 starts by calling Construct β to derive a chain β that is consistent with G and as close to α as possible (see lines 5-8). By β being as close to α as possible, we mean that the number of blocks Method B3 will later fbsplit and fbmerge is kept at a minimum, because Method B3 will use β to choose the blocks to modify in each iteration. A line of Construct β that is worth explaining is line 3, because it is crucial for the correctness of Method B3 (see Case 3.2.4 in the proof of Lemma [\ref=lem:correctness]). This line determines the order in which the components of H (initially H = G) are added to β (initially [formula]). In principle, a component of H may have nodes from several blocks of α. Line 3 labels each terminal component of H with its leftmost node in α and, then, chooses any terminal component whose label node is rightmost in α. This is the next component to add to β.

Once β has been constructed, Method B3 proceeds to transform G into Gα. In particular, Method B3 considers the blocks of α one by one in the reverse order in which they appear in α. For each block C of α, Method B3 iterates through the following steps. First, it finds the leftmost block K of β that has some nodes from C. These nodes, denoted as L, are then moved to the right in β by fbsplitting K to create a new block L of G and β. If the nodes of the right neighbor R of L in β are to the right of the nodes of L in α, then Method B3 is done with C. Otherwise, Method B3 moves L further to the right in β by fbmerging L and R in G and β. We prove below that Method B3 is correct. We prove first some auxiliary results.

Let M denote an independence model, and α a chain [formula]. If M is a graphoid, then there exits a unique CG Gα that is a MI map of M relative to α. Specifically, for each node X of each block Ck of α, BdGα(X) is the smallest subset B of [formula] st [formula].

Let X and Y denote any two non-adjacent nodes of Gα. Let k* denote the smallest k st [formula]. Assume without loss of generality that X∈Ck*. Then, [formula] by construction of Gα and, thus, [formula] by weak union. Then, Gα satisfies the pairwise block-recursive Markov property wrt M and, thus, Gα is an I map of M. In fact, Gα is a MI map of M by construction of BdGα(X).

Assume to the contrary that there exists another CG Hα that is a MI map of M relative to α. Let X denote any node st BdGα(X)  ≠  BdHα(X). Let X∈Ck. Then, [formula] and [formula] because Gα and Hα are MI maps of M. Then, [formula] by intersection. However, this contradicts the construction of BdGα(X), because [formula] is smaller than BdGα(X).

Let G and H denote two CGs st I(H)  ⊆  I(G). For any component C of G, there exists a unique component of H that is maximal in H from the set of components of H that contain a descendant of C in G.

By definition of CG, there exists at least one such component of H. Assume to the contrary that there exist two such components of H, say K and K'. Note that [formula] and [formula] by definition of K and K'. Note also that no node of K or PaH(K) is a descendant of K' in H by definition of K. This implies that [formula] and, thus, [formula] by weak union and symmetry.

That K and K' contain some descendants k and k' of C in G implies that there are descending routes from C to k and k' in G st the nodes in the routes are descendant of C in G. Thus, there is a route between k and k' in G st the nodes in the route are descendant of C in G. Note that no node in this route is in PaH(K) or PaH(K') by definition of K and K'. Then, [formula]. However, this contradicts the fact that I(H)  ⊆  I(G) because, as shown, [formula].

Let G and H denote two CGs st I(H)  ⊆  I(G). Let α denote a chain that is consistent with H. If no descendant of a node X in G is to the left of X in α, then the descendants of X in G are descendant of X in H too.

Let D denote the descendants of X in G. Let C denote the component of G that contains X. Note that the descendants of C in G are exactly the set D. Then, there exists a unique component of H that is maximal in H from the set of components of H that contain a node from D, by Lemma [\ref=lem:maximal].

Let K denote the component of H that contains X. Note that K is a component of H that is maximal in H from the set of components of H that contain a node from D, since no node of D is to the left of X in α. It follows from the paragraph above that K is the only such component of H.

We are now ready to prove the correctness of Method B3.

Let Gα denote the MI map of the independence model induced by a CG G relative to a chain α. Then, Method B3(G, α) returns Gα.

We start by proving that Method B3 halts at some point. When Method B3 is done with the rightmost block of α, the rightmost block of β contains all and only the nodes of the rightmost block of α. When Method B3 is done with the second rightmost block of α, the rightmost block of β contains all and only the nodes of the rightmost block of α, whereas the second rightmost block of β contains all and only the nodes of the second rightmost block of α. Continuing with this reasoning, one can see that when Method B3 is done with all the blocks of α, β coincides with α and thus Method B3 halts.

That Method B3 halts at some point implies that it performs a finite sequence of m modifications to G due to the fbsplit and fbmerging in lines 6 and 10. Let Gt denote the CG resulting from the first t modifications to G, and let G0 = G. Specifically, Method B3 constructs Gt + 1 from Gt by either

adding an edge X  -  Y due to line 3 of Fbsplit or Fbmerge,

adding an edge X  →  Y due to line 4 of Fbsplit or Fbmerge,

performing all the component splits due to lines 5-8 of Fbsplit, or

performing all the component mergings due to lines 5-8 of Fbmerge.

Note that none of the modifications above introduces new separation statements. This is trivial to see for the first and second modification. To see it for the third and fourth modification, recall that the splits and the mergings are part of a fbsplit and a fbmerging respectively and, thus, they are feasible. Therefore, I(Gt + 1)  ⊆  I(Gt) for all 0  ≤  t  <  m and, thus, I(Gm)  ⊆  I(G0).

We continue by proving that Gt is consistent with β for all 0  ≤  t  ≤  m. Since this is true for G0 due to line 1, it suffices to prove that if it is true for Gt then it is true for Gt + 1 for all 0  ≤  t  <  m. We consider the following four cases.

Note that Gm is not only consistent with β but also with α because, as shown, β coincides with α when Method B3 halts. In order to prove the lemma, i.e. that Gm = Gα, all that remains to prove is that I(Gα)  ⊆  I(Gm). To see it, note that Gm = Gα follows from I(Gα)  ⊆  I(Gm), I(Gm)  ⊆  I(G0), the fact that Gm is consistent with α, and the fact that Gα is the unique MI map of I(G0) relative to α. Recall that Gα is guaranteed to be unique by Lemma [\ref=lem:unique], because I(G0) is a graphoid.

The rest of the proof is devoted to prove that I(Gα)  ⊆  I(Gm). Specifically, we prove that if I(Gα)  ⊆  I(Gt) then I(Gα)  ⊆  I(Gt + 1) for all 0  ≤  t  <  m. Note that this implies that I(Gα)  ⊆  I(Gm) because I(Gα)  ⊆  I(G0) by definition of MI map. First, we prove it when Method B3 constructs Gt + 1 from Gt by either performing all the component splits due to lines 5-8 of Fbsplit or performing all the component mergings due to lines 5-8 of Fbmerge. Note that the splits and the mergings are feasible, since they are part of a fbsplit and a fbmerging respectively. Therefore, I(Gt + 1) = I(Gt). Thus, I(Gα)  ⊆  I(Gt + 1) because I(Gα)  ⊆  I(Gt).

Now, we prove that if I(Gα)  ⊆  I(Gt) then I(Gα)  ⊆  I(Gt + 1) when Method B3 constructs Gt + 1 from Gt by adding a directed or undirected edge due to lines 3 and 4 of Fbsplit and Fbmerge. Specifically, we prove that if there is an S-active route ρABt + 1 between two nodes A and B in Gt + 1, then there is an S-active route between A and B in Gα. We prove this result by induction on the number of occurrences of the added edge in ρABt + 1. We assume without loss of generality that the added edge occurs in ρABt + 1 as few or fewer times than in any other S-active route between A and B in Gt + 1. We call this the minimality property of ρABt + 1. If the number of occurrences of the added edge in ρABt + 1 is zero, then ρABt + 1 is an S-active route between A and B in Gt too and, thus, there is an S-active route between A and B in Gα since I(Gα)  ⊆  I(Gt). Assume as induction hypothesis that the result holds for up to n occurrences of the added edge in ρABt + 1. We now prove it for n + 1 occurrences. We consider the following four cases.

We continue with the proof of Case 3.2. Let [formula]. Note that X,Y∉S because, otherwise, ρABt + 1 would not be S-active in Gt + 1. For the same reason, ρAXt + 1 and ρYBt + 1 are S-active in Gt + 1. Note that X and Y must be in PaGt(Ri) for line 3 of Fbmerge to add an edge X  -  Y. Then, no descendant of Ri in Gt is in S because, otherwise, there would be an S-active route ρXYt between X and Y in Gt and, thus, [formula] would be an S-active route between A and B in Gt + 1 that would violate the minimality property of ρABt + 1. Then, there is an S-active descending route ρrdt from some r∈Ri to some d∈D in Gt because, as shown, D contains a descendant of Ri in Gt. Then, [formula] is an S-active route between A and d in Gt + 1. Likewise, [formula] is an S-active route between B and d in Gt + 1, where ρBYt + 1 denotes the route resulting from reversing ρYBt + 1. Therefore, there are S-active routes ρAdα and ρBdα between A and d and between B and d in Gα by the induction hypothesis.

Recall that we assumed without loss of generality that Gt has a descending route from Y to a node E st E = B or E∈S. Note that E is a descendant of LY in Gt and, thus, E is a descendant of d in Gα by definition of D and the fact that d∈D. Let ρdEα denote the descending route from d to E in Gα. Assume without loss of generality that Gα has no descending route from d to B or to a node of S that is shorter than ρdEα. We now consider two cases.

Method B3 constructs Gt + 1 from Gt by adding an edge X  →  Y due to line 4 of Fbmerge. Note that X  →  Y occurs in ρABt + 1. We consider two cases.

Assume that X  →  Y occurs as a non-collider edge in ρABt + 1. The proof of this case is the same as that of Case 3.2, with the only exception that X  -  Y should be replaced by X  →  Y.

We are now ready to prove the main result of this paper, namely that the extension of Meek's conjecture to CGs is true. The proof is constructive in the sense that we give an algorithm that constructs a valid sequence of operations. The pseudocode of our algorithm, called Method G2H, can be seen in Figure [\ref=fig:methodg2h]. The following theorem proves that Method G2H is correct.

Given two CGs G and H st I(H)  ⊆  I(G), Method G2H(G, H) transforms G into H by a sequence of directed and undirected edge additions and feasible splits and mergings st after each operation in the sequence G is a CG and I(H)  ⊆  I(G).

Note from line 1 that α denotes a chain that is consistent with H. Let Gα denote the MI map of I(G) relative to α. Recall that Gα is guaranteed to be unique by Lemma [\ref=lem:unique], because I(G) is a graphoid. Note that I(H)  ⊆  I(G) implies that Gα is a subgraph of H. To see it, note that I(H)  ⊆  I(G) implies that we can obtain a MI map of I(G) relative to α by just removing edges from H. However, Gα is the only MI map of I(G) relative to α.

Then, it follows from the proof of Lemma [\ref=lem:correctness] that line 2 transforms G into Gα by a sequence of directed and undirected edge additions and feasible splits and mergings, and that after each operation in the sequence G is a CG and I(Gα)  ⊆  I(G). Thus, after each operation in the sequence I(H)  ⊆  I(G) because I(H)  ⊆  I(Gα) since, as shown, Gα is a subgraph of H. Finally, line 3 transforms G from Gα to H by a sequence of edge additions. Of course, after each edge addition G is a CG and I(H)  ⊆  I(G) because Gα is a subgraph of H.

Acknowledgments

We thank Dr. Jens D. Nielsen and Dag Sonntag for proof-reading this manuscript. This work is funded by the Center for Industrial Information Technology (CENIIT) and a so-called career contract at Linköping University, and by the Swedish Research Council (ref. 2010-4808).