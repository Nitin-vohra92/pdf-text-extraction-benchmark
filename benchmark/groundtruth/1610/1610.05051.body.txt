Lemma Conjecture Proposition Corollary Assumption Remark

| | | |

Asynchronous Discrete Event Schemes for PDEs

Introduction

We develop new schemes for the simulation of porous media flow based on an asynchronous simulation methodology. By asynchronous it is meant different parts of the spatial domain are allowed to exist at different times simultaneously during the course of the simulation. Numerous different categories of numerical, schemes fall under this broad description; here we are interested in schemes based on the Discrete Event Simulation (DES) methodology. This methodology is essentially the idea of evolving a system forward in time by discrete events, which are local in space, with each event having its own local timestep determined by the physical activity in that region, see [\cite=OK_plasma] [\cite=OK_flux] [\cite=async_gas_discharge]. In this way more active regions of the spatial domain receive more events, in principle leading to more efficient distribution of computational effort. A full description and algorithm is presented in Section [\ref=gen_face].

Traditionally DES schemes were developed for naturally discrete systems, not continuous physical systems such as models describing fluid flow or solute transport in porous media. The use of DES concepts applied to continuous physical systems was introduced by [\cite=OK_plasma] for plasma simulation where an event is the motion of an ion particle between two cells. The same authors then presented in [\cite=OK_flux] an asynchronous method for conservation law PDES with sources, in one dimension, based on evolving the PDE model at different rates in different cells. Our methods are all, by contrast, face based, in that an event is always the transfer of mass between cells, not evolution within a cell.

These schemes are self-adaptive in the sense that during each event, the local state of the system is evolved forward in time by an appropriately sized timestep, which is chosen automatically. The size of a timestep can be limited by accuracy requirements, for example, or CFL conditions. In the simulation of the evolution of physical systems, and especially porous media flow applications, the appropriate size for a timestep will often vary significantly in both space and time, see for example Figure [\ref=seb_figure]. Classical explicit and implicit timestepping methods have the disadvantage of using a global timestep size, which must be limited to the smallest appropriate timestep anywhere in domain. We now briefly discuss existing non-global timestepping methods for comparison.

There is some similarity with the modelling philosophy of the reaction diffusion master equation (RDME) [\cite=gardiner1986handbook] and the Gillespie method [\cite=gillespieprime] and its derivatives, see [\cite=erban2007practical] [\cite=gibson2000efficient] for example. However, the methods here are deterministic and approximate the bulk behaviour modelled by a PDE instead of operating on the scale of molecules. The goal of asynchronous schemes may be compared with, for example, adaptive time stepping [\cite=MR2231939] schemes, Space-Time Discontinuous Galerkin methods (see e.g. [\cite=lowrie1998space]) or local timestepping [\cite=MR717689] [\cite=sanders2008integration] [\cite=hudsdorfer_multivariate] schemes (LTS), where the spatial grid is refined in space in order to better capture more active regions, and a corresponding local timestep is used to ensure a local CFL condition. Local timestepping schemes also exist where the grid is not refined spatially and the local timesteps are varied to better capture activity according to local rates. See for example [\cite=otani2000computer], where a binary tree is used to schedule the order in which cells will update, but full asynchronicity is avoided (unlike here) by implementing a standard LTS interpolation procedure between adjacent cells at different times, when approximating spatial derivatives.

While traditional PDE solvers rely on efficient linear algebra solvers, and exponential integrators (eg [\cite=Overview] [\cite=hochbruck-rkei-2005] [\cite=cm] [\cite=tambue2010exponential] [\cite=tambue2013efficient] [\cite=NW]) rely on efficient approximation of the matrix exponential, asynchronous schemes rely on an efficient way of ordering the pending events. The list of pending events is typically stored in a binary tree or custom priority queue, adding some additional complexity to the implementation. A custom type of priority queue is described in [\cite=OK_flux], we use our own implementation of this description. More details on the implementation and comparison to other schemes are discussed in [\cite=myThesis]. Initially we focus on the simulation of linear conservation laws in the absence of reaction terms, describing for example the transport of a non-reactive tracer in porous media,

[formula]

d = 1,2,3, where [formula] is a concentration and f is a given flux function. An initial condition [formula] is provided. For simplicity, we consider 'no flow' boundary conditions, that is, Neumann type boundary conditions with zero flux on external faces. Other types of boundary conditions could easily be added in this framework. We are primarily interested in advection diffusion systems, where the flux is of the form

[formula]

where D is the diffusivity and [formula] is a given velocity. The combination of [\eqref=con_no_source] and [\eqref=flux_ad_diff] is the PDE

[formula]

In Section [\ref=reac_sec] we later describe the incorporation of a reaction term in to [\eqref=ad_dif_full] for our schemes. The spatial domain Ω is discretised into cells, as in a standard finite volume approach (see for example [\cite=FV-intro-paper] [\cite=patankar1980numerical] [\cite=versteeg2007introduction] [\cite=leveque2002finite] and references therein), and equation ([\ref=con_no_source]) is discretised in space over the grid. To describe our new schemes we start by focusing on a simple system; a conservation law [\eqref=con_no_source] without sources with flux given by, for example, [\eqref=flux_ad_diff].

The Basic Face Based Asynchronous Scheme (BAS)

Our schemes make use of the flux on each face of a computational grid arising, for example, from a traditional finite volume (FV) discretisation. The spatial domain Ω is divided to a grid of cells each with a unique index [formula]. Similarly every face also has a unique index [formula]. We define the set of associated faces as the set of all the faces of the two cells which face k is adjacent to. That is, if k is the face in common to two cells j1 and j2, then the set of associated faces is the set of all the faces belonging to either cell j1 or j2. See also Figure [\ref=schematic] for a depiction of some of the notation with respect to the grid. The finite volume discretisation of [\eqref=con_no_source] is based on the approximation of the flux across faces in the grid.

Let fk be the approximation of the flux on a face k, which depends upon the concentration values cj1, cj2 in the two cells with indexes j1,j2 adjacent to face k. The concentration cj of a cell j is assumed constant throughout the cell, and is derived from the mass in the cell mj and its volume Vj as [formula]. The flux fk on a face is assumed constant and defines the flow of mass across the face between its two adjacent cells, i.e., the flow of mass from cell j1 due to face k will be - fkAk; and into cell j2 will be be fkAk, where Ak is area of the face k. The direction of mass flow depends on the sign on fk. To be explicit, the equations for mass flow across a single face k, are

[formula]

For an advection-diffusion system, one of the two cells will be the upwind cell; without loss of generality let this be cell j1. Then the flux across a face k may be approximated by finite differences such as,

[formula]

where k is an approximation of the diffusivity at the face based on the diffusivity in the two cells, typically the harmonic mean of Dj1 and Dj2, Δxk is the distance between the two cell centroids; and v is the scalar product of the velocity at the centre of face k with the unit vector in the direction of the line from the centre of cell j1 to cell j2.

The total rate of change of mass, and thus concentration in a cell j is found from [\eqref=mass_face_flux] for each k∈Fj. This can be expressed as a matrix, L which gives the finite volume semidiscretisation of ([\ref=con_no_source]) as a system of ODEs,

[formula]

where [formula] is the vector of concentrations in cells. In a standard finite volume based implementation [\eqref=fv_disc] is then discretised in time, resulting in the fully discrete approximation.

Face based asynchronous schemes are based on events involving the transfer of mass across a single face but do not form the global system ([\ref=fv_disc]). Instead they can be defined in terms of much smaller local matrices which we call "connection matrices" and introduce in Section [\ref=c_mat_sec]. They proceed in discrete events approximating the effect of [\eqref=mass_face_flux].

The outline of the algorithm is as follows.

Every face has an individual time tk and a projected update time k.

The face with the lowest update time k is chosen for an event.

During an event, the two cells adjacent to face k are updated by having a fixed amount of mass ΔM passed between them.

A timestep Δtk is associated with this event, and after the event the time on face k is updated to tk  +  k.

After the event the update time [formula] is recalculated for every face of the two cells involved in the event.

This repeats until all faces are synchronised at a final time T.

The full algorithm is given in Algorithm [\ref=alg1] and is discussed below. We now consider the details missing from the above outline, specifically how k is calculated and its relation to ΔM and the local flux across a face. Note that choosing an appropriate value of the global mass unit ΔM to balance accuracy and efficiency is of great importance in using this method.

For a face k, the projected update time k is calculated so that in the interval [formula], at most ΔM units of mass pass through the face. The Basic Asynchronous Scheme (BAS) calculates the update time k as,

[formula]

This is derived from a standard Euler-type approximation of the flow of flux through the face, ignoring the effect of the other faces in the cell. That is, we want a face to have passed an amount of mass ΔM in the time interval k  -  tk, and this leads to an approximation of the derivative in [\eqref=mass_face_flux],

[formula]

from which ([\ref=utime]) follows. The absolute value of the flux is used to ensure that the calculated time values are positive. The direction is irrelevant when calculating the always positive k, thus the only magnitude of the flux is important. When ([\ref=utime]) calculates   >  T, the value of T is used instead. In this way the simulation finishes with every face at the desired final time T; it is an Euler-type approximation using the imposed timestep T - tk. The mass transferred during this final synchronisation step is not ΔM. Let δm be the mass transferred in an event for face k. Then, again following from a simple Euler-type approximation,

[formula]

Algorithm [\ref=alg1] describes the BAS method. After initialising the required values on all faces, the update loop is run until every face is synchronised to the desired final time of T. Each iteration of the loop is a single event and proceeds as follows. First the face with the lowest projected update time [formula] is found (line 3) Then the two cells adjacent to this face are located from the grid structure (line 4). The amount of mass to transfer between these cells is calculated (line 5). This equation simply returns the global mass unit ΔM in most cases, except when the face is being forced to use an update time T; see equations [\eqref=utime] and [\eqref=del_m]. Mass is transferred between the cells in the correct direction (lines 6-7). A loop (lines 8-12) updates the faces of cells j1 and j2; recalculating their fluxes and update times based on the new mass values. The loop then continues by finding the next face with the lowest update time (back to line 3). In Figure [\ref=schematic] we show a schematic of two cells undergoing the mass transfer and time update parts of a single event, corresponding to lines 6 - 8 in Algorithm [\ref=alg1]. This is the simplest face based asynchronous scheme we can conceive. We have observed, for every experiment we have attempted with Cartesian grids, that as the mass unit ΔM decreases to zero, the approximation produced by this scheme converges to the exact solution of the linear ODE system produced by applying the corresponding finite volume discretisation to the corresponding PDE [\eqref=con_no_source].

Modifications to BAS

Using A Mass-Passed Tracking Value - the BAST Scheme

When an event occurs in the basic scheme, only one face is updated, while the associated faces are not. Consider adding an extra parameter to each face k, which is intended to track the mass that the face should have passed during an event of an associated face (earlier defined at the start of Section [\ref=gen_face]). Let this parameter be called the mass passed value, ΔMp,k. We describe the implementation of ΔMp,k to illustrate its intended function. First, for every face it is initialised to zero, and reset to zero when the face has an event. In Algorithm [\ref=alg1], during the loop of (lines 9-12) over each face l in the set of associated faces k of the active face k, except k itself, the mass passed value is updated as

[formula]

Compare this to the second equation in [\eqref=del_m]. In [\eqref=mp_inc], the mass-passed tracking value ΔMp,l is incremented by the amount of mass that would have passed through face l during a timestep of length k  -  tl. Also, in the modified scheme every face of the cells j1, j2 has its time updated at this point,

[formula]

as though these faces have also had events, although no transfer has occurred for these faces. The mass passed value effectively tracks the mass the faces would have passed in the time

[formula]

≈ = |f| A,

[formula]

The Cascading or 'Flux Capacitor' Concept of [\cite=OK_flux]

A crucial innovation in [\cite=OK_flux] is allowing cells to trigger their own events if they have been subject to too much activity without an event - each cell has a 'flux capacitor' value assigned, which is incremented each time a neighbouring cell has an event, and reset to zero when the cell itself has an event. Instead of affecting the update time of faces (or cells), the job of the flux capacitor value is, if and when it exceeds a certain threshold, to trigger a new event its cell, independent of its update time and the priority queue. In a situation such as an advancing front or simply a region of high activity, this can lead to cells (or faces) constantly triggering their neighbours, following the path of high activity and ignoring the costly update time and priority queue calculations temporarily. This further emphasises the objective of DES methods to focus attention on the most active parts of the domain. We have also implemented this concept in our face-based Asynchronous schemes. Consider the Mass-Passed Tracking scheme described in Section [\ref=mpsec] with the following modifications. First, the dependence of update time on ΔMp,k is removed (i.e., instead of [\eqref=mass-passed-uptime], we use the basic [\eqref=utime]). Second, when some face j has its ΔMp,j incremented as part of an event on an associated face k, then an event is automatically triggered on j if ΔMp,j  >  ΔM. We note there is potential to use other threshold values than the mass unit ΔM, but it seems to work well, see Section [\ref=frac_sec]. Because these schemes cascade 'cheap' events along fronts or regions of very high activity, we refer to them as cascading schemes, however the underlying concept is of course nothing but the 'flux capacitor' of [\cite=OK_flux]. We have the basic scheme, BAS, augmented with the concept, which we will abbreviate as BAS-casc.

Adding a Reaction Term

It is possible to include a reaction term, so that we may simulate conservation equations of the form

[formula]

i.e., [\eqref=con_no_source] with a reaction term r. It is in principle possible to also apply our method to non-autonomous reaction terms [formula]. We have found that a standard leapfrog implementation of the reaction during events is effective. We describe the additions to the BAS method now. The first modification is that each cell now has its own independent time tj. Now consider lines 5-7 of Algorithm [\ref=alg1], in which mass is transferred, replaced by the following method.

Calculate timestep values for each of the two cells, as Δtj1  =  k  -  tj1 and Δtj2  =  k  -  tj2.

Update the mass in both the cells according to the reaction term, using an Euler type step. For each cell use half the timestep for the cell. That is, perform the update,

[formula]

[formula]

The mass transfer across the face proceeds exactly as in the original scheme; lines 5-7 of Algorithm [\ref=alg1].

Repeat step 2.

Also, at line 8 of Algorithm [\ref=alg1], we set the cell times to be k alongside the face time. That is, tj1←k, tj2←k. We now clarify this process. First consider step 2. The first point to note is that it can be expressed in terms of concentration instead of mass simply as,

[formula]

[formula]

Ignoring for the moment the half timesteps, this is a single step of the Euler method (though with different timesteps for each cell) for the system consisting only of cells j1 and j2, and governed by the reaction-term-only PDE,

[formula]

This is analogous to how in BAS we consider the system consisting only of the two cells j1 and j2 (and the internal face k), governed by the flux PDE [\eqref=mass_face_flux]. Step 4. corresponds to step 2. by 'completing' the halved Euler step. Steps 2. through 4. are thus simply an operator splitting method, applied to the tiny two cell subsystem considered by each event. Specifically it a leapfrog method, the simplest form of operator splitting.

This is an extension of the concept of our face based schemes to systems with reaction or source terms; the only technicality is the introduction of time values assigned to cells as well as faces, which is required to define timesteps for the reaction steps in a sensible way. This method retains the interesting property of not needing to be explicitly based on a PDE. Indeed, the scheme can be implemented based on [\eqref=mass_face_flux] for the faces and [\eqref=mass_cell_reac] for the cells, without any use or reference to [\eqref=con_with_source]. The modifications described here can also be applied to BAST. We can imagine this method having difficulty with situations or parts of a domain where there is no flux between cells but still reactions within the cells changing the concentration values there - in this case the reaction activity could be 'missed' by the lack of events. It is likely possible to find other modifications which allow the schemes to handle reaction terms.

Numerical Results

Before we outline some some steps towards convergence in Section [\ref=sec:Convergence] we present some numerical experiments with the new schemes which demonstrate convergence and the relationship between scheme parameters such as N the total number of events, ΔM the mass unit and the average time step Δt. Our first test systems are linear PDEs, which produce ODE systems of the form [formula] after a finite volume discretisation. In Section [\ref=reac_sec] we add in a reaction term. Reference solutions for comparison are computed below using a first order exponential integrator, see [\cite=Overview] [\cite=hochbruck-rkei-2005] [\cite=cm] [\cite=tambue2010exponential] [\cite=tambue2013efficient] [\cite=NW]. The error is measured in the discrete L2(Ω) norm. Specifically, we use the standard Euclidean norm, scaled by [formula], where J is the number of cells in the discretisation. The scaling by [formula] is to remove dependence of the error on the size of the system as without the scaling the error estimate would always increase with [formula], due to the definition of the Euclidean norm.

The Matlab Reservoir Simulation Toolkit (MRST [\cite=mrst_prime]) was used to generate the grids for the experiments but the discretisation and solver routines were implemented by us.

Fracture System with Varying Diffusivity

In this example a single layer of cells is used, making the problem effectively two dimensional. The domain is 10  ×  10  ×  10 metres, divided into 100  ×  100 cells of equal size. We specify the velocity field to be uniformly one in the x-direction and zero in the other directions in the domain, i.e., [formula] (a constant velocity field may not be realistic however this example still provides an interesting test case). The initial condition was [formula] everywhere except at [formula] where [formula]. A fracture in the domain is represented by having a line of cells which we will give certain properties. These cells were chosen by a weighted random walk through the grid (weighted to favour moving in the positive y-direction so that the fracture would bisect the domain). This process started on an initial cell which was marked as being in the fracture, then randomly chose a neighbour of the cell and repeated the process. This was done once to prepare the grid before the main tests. We set the diffusivity to be D  =  100 on the fracture and D = 0.1 elsewhere. Figure [\ref=fraccomp] a) shows the diffusivity of the system.

In Figure [\ref=fraccomp] we show in b) the reference solution of [\eqref=ad_dif_full] at T = 2.4 which, since this is a linear system, is an extremely accurate approximation to the true solution. In Figure [\ref=fracshow] a) we plot the solution at T = 2.4 using BAS with ΔM = 10- 6 and in c) with ΔM = 10- 9. Visually the ΔM = 10- 9 solve agrees well with the comparison solve Figure [\ref=fraccomp] b). In Figure [\ref=fracshow] b) and d) we have plotted maps of the number of events on each cell on a log scale for each of the respective solves. We observe that the updates and hence computational work, is concentrated in the regions of most physical activity - i.e. in the high diffusivity region and to right of it (due to the advection). It seems that with the smaller value of ΔM BAS is better able to concentrate computational activity where it is needed - note the greater spread in events over the system in Figure [\ref=fracshow] b) compared to d).

In Figure [\ref=frac_plotsMain] a) we show the convergence of the schemes with ΔM. the estimated error is plotted against the mass unit ΔM, and we clearly observe that the error for all our schemes is O(ΔM) for sufficiently small ΔM. In Figure [\ref=frac_plotsMain] b) the estimated error is plotted against average timestep, Δt. Interestingly the error of the asynchronous schemes seems to be first order with respect to the average timestep. Plot c) shows the total number of events N against ΔM. For Figure [\ref=frac_plotsMain] c), it is interesting how for both schemes the relationship between N and ΔM is the same for sufficiently small ΔM, as we see clearly N  =  O(ΔM- 1). For larger mass unit values we observe that N is not changing with respect to ΔM for BAS, although from plot Figure [\ref=frac_plotsMain] a) we can see that the error is still decreasing for that range of mass unit values.

Note that a relation Δt  =  O(ΔM) logically follows from the relations implied in plots c) and d) (results for this can also be seen in [\cite=myThesis]). This relation may be naively inferred from [\eqref=utime], from which it follows that [formula]. However, we cannot take this for granted since after any number of events the mass vector [formula], and thus the flux across any given face fk, can be expected to be different if a different value of ΔM is used for the solve. Thus we cannot rule out a priori that the denominator |fkAk| in [\eqref=utime] has some dependence on ΔM.

Plot c) indicates that for sufficiently small ΔM, the total number of events over the solve, for a given ΔM, is the same or almost the same, for both BAS and BAS-Casc. This could possibly indicate is the existence of some 'preferred path' of events, that is, an ordering of faces on which events occur, which in the limit ΔM  →  0 all our schemes follow.

Uniform constant diffusivity example

In this example the domain is Ω  =  10  ×  10  ×  10 metres again, discretised into 40  ×  40  ×  32 cells, for a total of 51200 cells in the system. We solve [\eqref=ad_dif_full] with a diffusivity field that is uniformly [formula] and a constant velocity field [formula]. The initial condition is sinusoidal, varying between 0 and 1, on the line of cells where y = z = 0, and zero elsewhere. The final time was T = 2.4. We show the state of the system at the final time T in Figure [\ref=3d_disp] a), as produced by BAST with ΔM  =  1.9532  ×  10- 10. This solution is very accurate, compared to the reference solution in Figure [\ref=3DPlotsMain] a). Plot b) in Figure [\ref=3d_disp] shows the logarithm of the number of events experienced by each cell during the same BAST solve. We see again how the scheme automatically focuses more computational effort, in the form of transfer events, at different areas of the domain according to local rate of activity. There is about a difference of five orders of magnitude in number of events between the least and most active cells in Figure [\ref=3d_disp] b). In Figure [\ref=3DPlotsMain] we present comparisons of various parameters for the schemes; the format is the same as Figure [\ref=frac_plotsMain], and many of the conclusions are similar. Plots b) through d) in Figure [\ref=3DPlotsMain] indicate relationships between the parameters ΔM, N (total number of events), average Δt, and error, of the schemes.

Reaction-Diffusion Example

This experiment is a reaction-diffusion system in two dimensions with a Cartesian grid, intended to test the leapfrog type reaction term implementation described above. The velocity field was uniformly zero. The reaction term used is

[formula]

which is a Langumiur-type reaction term, that can be used to model, for example, mass in the system adsorbing to the walls of the porous medium and thus being lost (see for example, [\cite=masel1996principles]). In our example a region of high concentration in the centre of the domain diffuses outwards (the diffusivity field is uniform) while reacting according to the above Langmuir adsorption term. The final time is T = 1. The domain is again Ω  =  10  ×  10  ×  10 metres and discretised into [formula] cells. For this test the concentration was [formula] for all [formula] except at [formula] where [formula]. The boundary conditions were no-flow on all boundaries.

Figure [\ref=Fig:ReacSol] a) shows the reference solution, (b) is produced by BAS with ΔM = 10- 6 and (c) with ΔM = 10- 9. We see that with ΔM = 10- 6 the accuracy is noticeably worse than for ΔM = 10- 9. In (c) we plot the logarithm of number of events in each cell for ΔM = 10- 9. We see that the computational effort largely follows the diffusion process of the solution.

In Figure [\ref=reac1plotsmain] we show the convergence and parameter relations of the schemes. Interestingly, the parameter relations revealed in Figure [\ref=reac1plotsmain] plots b) through d) are the same as those from the experiments in previous sections. Again, Figure [\ref=reac1plotsmain] plot a) shows that error of the schemes converge to zero as ΔM decreases to zero. The schemes are still roughly first order with the addition of a reaction term.

Towards a General Convergence Result for BAS

Connection Matrices

One event in the scheme of Algorithm [\ref=alg1] is the transfer of mass across the active face k, between the two cells j1 and j2 adjacent to k. In effect, during the event, the face k and the two cells are being considered as an independent system from the rest of the domain. The only free variables are the masses mj1 and mj2 in the two cells. Thus, with the finite volume discretisation of the flux in place, the local flow of mass across the face may be considered as a 2  ×  2 ODE system. Consider [\eqref=fv_disc] for only two cells, after multiplying out each cell equation by the volume Vj, we have

[formula]

The non-negative scalars ak,bk are functions of the diffusivity Dj and velocity vj of the two cells, the distance between their centres, and the area of the face k. Recalling equations [\eqref=mass_face_flux] and [\eqref=fd_ad_flux], we can see that, if j1 is the upwind cell, then a and b are,

[formula]

or, if j2 is the upwind cell,

[formula]

where v is the scalar product of the velocity at the centre of the face, with the unit vector in the direction of the line connecting the centres of the two cells, pointing from the upwind into the downwind cell. Thus we see that ak and bk are indeed non-negative, since k and v are both non-negative. The matrix in ([\ref=con_mat_first]) is an example of what we henceforth refer to as a local connection matrix k. The corresponding global connection matrix Lk is the sparse matrix with nonzero elements only at (j1,j1), (j1,j2), (j2,j1) and (j2,j2);

[formula]

The structure of the connection matrix reflects the conservation of mass between the two adjacent cells (since the column sum is zero). The connection matrix Lk associated with face k describes the relationship between the two cells j1 and j2 adjacent to face k in the discretisation [\eqref=fv_disc], and thus has nonzero entries only in columns and rows j1 and j2. Let [formula] be the vector of all mass values in the system and [formula] the vector of all concentration values in the system, related by [formula], where [formula] is the diagonal matrix with entries [formula], i.e., the inverse of the volume in each cell. The global ODE system for [formula] can be accumulated from the connection global matrices on each face, that is,

[formula]

Right multiplying by [formula] gives

[formula]

and we see that the system discretisation matrix L in ([\ref=fv_disc]) is accumulated from the connection global matrices on every face, that is,

[formula]

Connection matrices are useful for re-expressing our schemes. Consider the local description of an event across face k with adjacent cells j1, j2. Lines 5 - 7 in Algorithm [\ref=alg1] describe an update that is equivalent to an Euler type step for solving ([\ref=con_mat_first]), i.e.,

[formula]

where I is the identity matrix. Alternatively, using the J  ×  J connection matrix Lk, then we can express event updates in terms of the entire system. The full system version of ([\ref=eu_mt_1]) is

[formula]

Due to the sparsity of Lk, clearly only the cells j1, j2 are affected by [\eqref=eu_mt_2] even though the equation describes the entire system. We now describe properties of global connection matrices. A connection matrix acting on any vector produces a vector pointing in only one direction in the solution space. That is, the action of a connection matrix Lk on any vector [formula] is a scalar multiple of a vector k, determined by Lk. Consider a connection matrix Lk with non-empty columns and rows j1, j2, then

[formula]

where [formula], where the non-zero entries elements are at j1 and j2. It follows that k is an eigenvector of Lk and the corresponding eigenvalue can be found,

[formula]

thus the eigenvalue λk is negative.

Framework for analysis

Here we present a framework for the analysis of BAS based on the connection matrix formulation. In particular we use the fact that the action of a connection matrix Li on any vector [formula] produces a scalar, determined by [formula], multiplying a direction vector ẑi. For two connection matrices Li and Lj, with corresponding direction vectors ẑi, ẑj, define ci,j to be such that

[formula]

and vice versa for cj,i. The eigenvalue of Li from [\eqref=evalue_con_mat] is then λi  =  ci,i. Define the matrix C as having the entries (C)i,j  =  ci,j. Let L be the sum of some connection matrices, [formula]. Consider the action of L on some vector [formula],

[formula]

where we have defined fk by [formula], using [\eqref=con_fix_dir]. Let Ẑ be the matrix whose kth column is ẑk, and let [formula] be the vector whose kth entry is fk, then

[formula]

Now consider,

[formula]

Then

[formula]

where the sum is over the action of each Li on the [formula]. Indeed, for any arbitrary [formula],

[formula]

From this we have [formula] which we can use to re-express [formula]

[formula]

If we use the standard definition of [formula], we can rewrite this as

[formula]

For the scheme BAS, after some total number of events n, let nk be the number of events experienced by face k. Let [formula] be the vector whose kth entry is nk. Then the state of BAS can be expressed as,

[formula]

Note that we are assuming that the direction of mass transfer is consistent across each face across the whole solve (i.e. so that the direction of transfer is never reversed from a previous step), which may not be completely justified in all cases. Comparing [\eqref=true] and [\eqref=BASapprox], we have a sufficient condition for convergence.

Assuming the direction of mass transfer is consistent across each face across the whole solve, BAS will converge if

[formula]

as ΔM  →  0, when [formula] evolves according to the rules of the scheme in Algorithm [\ref=alg1].

A sketch proof of [\eqref=n_is_phi] is as follows. First we approximate [formula] by a continuous variable, [formula]. We assume that in the limit ΔM  →  0 this is justifiable, as ΔM becomes so small that integer multiples of ΔM become effectively continuous. We wish to argue that

[formula]

Given that [formula], the solution to this is

[formula]

from which [\eqref=n_is_phi] would follow. Note that the right hand side of [\eqref=ode_heuristic] is the flux. To see this consider the action of a Lk on [formula], using [\eqref=BASapprox]

[formula]

(For this we used [formula].) The vector on the right hand side of [\eqref=lkonmn] has only two nonzero entries, the positive and negative of the flux across face k. Since ẑk has only nonzero entries - 1 and 1, the flux across face k is the coefficient of the right hand side. Accumulating over every face k, we have,

[formula]

We must interpret the t in the derivative in [\eqref=ode_heuristic] as the system time, i.e. the time of the face which has most recently updated. Since [formula], [formula] is the vector of displacements along each direction vector ẑ, from the starting point of [formula]. Thus [\eqref=ode_heuristic], if true, implies that the rate of change of the solution in the direction of a ẑ associated with a face k, with respect to the system time, is equal to the flux across face k. We can ask if anything in the construction of the scheme indicates the potential for this behaviour. Interestingly, we can examine [\eqref=utime], the equation for determining update time for a face. We restate it here for convenience,

[formula]

where fk is the flux across the face k, k is the update time of the face, and tk is the time of the face. If the face is chosen for an event (by having a lowest update time), then it updates with timestep Δtk  =  k  -  tk. We may re-arrange to [formula]. Heuristically, in the limit ΔM  →  0 we may replace the fraction with [formula], and write

[formula]

A vector of these values would give [\eqref=ode_heuristic]. There is however the need to bridge the gap between the asynchronous nature of the algorithm and the synchronous nature of the ODE [\eqref=ode_heuristic]. For this we would have to assume or demonstrate that in the limit ΔM  →  0, the individual face times tk tend towards being equal or arbitrarily close to the entire system time t. This is a potential subject of further work.

Concluding Remarks

New simulation methods based on discrete asynchronous events have been developed and tested. The schemes were BAS, the simplest implementation of the methodology, and BAST, which adds a mass-tracking feature which reduces error due to asynchronicity. From these tests we see that the new asynchronous schemes converge in error, for fixed grids, as ΔM  →  0. The order of convergence is appears to be approximately O(ΔM) according to the numerical results. There also seems to be a regime of sufficiently low ΔM in which parameter relationships emerge. These relationships are,   =  O(Δt), N  =  O(ΔM- 1), Δt  =  O(ΔM), and Δt  =  O(N- 1). The convergence results also indicate the basic viability of the face based asynchronous schemes, and the fact that the same conclusions can be drawn for BAS and three different modified schemes, implies the existence of a large space of possible viable schemes of this class. We note that the relation Δt  =  O(N- 1) can be explained a priori, following from the fact that every face will have timesteps summing to T, and that N is the sum of the number of events on each face. The way that Δt is calculated for the non-tracking schemes BAS is then equivalent to [formula], where K is the number of faces. This must be modified for the mass-tracking scheme BAST but a similar a priori relation can certainly be found. We note further that then the relationship Δt  =  O(ΔM) is equivalent to O(N- 1)  =  O(ΔM), so that these two observed relations are equivalent. Also, the relations Δt  =  O(ΔM) and   =  O(ΔM) together imply   =  O(Δt). This leaves the observations   =  O(ΔM) and N  =  O(ΔM- 1) as independent and requiring theoretical explanation. The relation N  =  O(ΔM- 1) may seem to follow naturally from the construction of the schemes, but showing this rigorously while taking account of the asynchronous nature of the schemes is nontrivial. While care was taken in optimizing our codes, they remain essentially demonstration pieces and so we do not compare the efficiency against well established methods. For obvious reasons the implementation of DES based schemes for continuous systems such as these is not as well understood as for classical schemes. The new schemes demonstrate convergence and can be applied to large scale problems in three dimensions and offer complete adaptivity.

Acknowledgments

The work of Dr D. Stone was funded by the SFC/EPSRC(EP/G036136/1).

References