Lemma Corollary

Finite connected components of the aliquot graph

Introduction

For [formula], let [formula] denote the sum of the proper divisors of n. Ancient Greek mathematicians studied the forward orbits n, s(n), s(s(n)), , now called aliquot sequences, and noted that they sometimes enter cycles, such as 6, 6, and 220, 284, 220, . In the modern computer era, more than a billion examples of such aliquot cycles have been found [\cite=chernykh] [\cite=moews]; most of these, like {220,284}, have order 2, and are termed amicable pairs. A long-standing conjecture posits that there are infinitely many aliquot cycles.

One can also ask about the inverse orbits [formula]. Although questions concerning the inverse image s- 1({n}) of a given n go back at least 1000 years [\cite=sesiano], the idea of iterating the inverse map appears to have been considered only recently (see [\cite=egps] and [\cite=delahaye], for instance). In relation to this, Garambois [\cite=garambois] has conducted many numerical studies, focusing in particular on isolated cycles, i.e. cycles that are their own inverse orbits. For instance, s- 1({28}) = {28}, so {28} is an isolated cycle of order 1.

In this paper, we seek to generalize this concept. To do so, following Delahaye [\cite=delahaye], we introduce the aliquot graph, which packages all of the aliquot sequences together into a single directed graph. Precisely, every natural number is a node of the graph, and for any [formula], there is a directed edge from m to n if and only if n = s(m). As the examples noted above demonstrate, the aliquot graph is not connected; in fact any two distinct aliquot cycles lie in distinct connected components, so presumably the graph has infinitely many components. In these terms, we see that Garambois' isolated cycles are examples of finite connected components.

Our objectives are (1) to find examples of finite connected components beyond simple cycles, and (2) to determine a comprehensive list of all finite connected components with at least one small node. Toward the first objective, in Section [\ref=sec:alg] we present an algorithm for computing the inverse image s- 1({n}) of a given even number n in time O(n1 / 2 + ε); as a corollary, we obtain the estimate #  s- 1({n})  ≪  n1 / 2 + ε, which improves on a recent result of Pomerance [\cite=pomerance]. In Section [\ref=sec:examples] we apply the algorithm to all even amicable pairs with smaller element below 1014, and to all known aliquot cycles of order [formula] with smallest element below 1017. In this way we identify many interesting examples of finite connected components.

Concerning the second objective, note first that if p and q are distinct primes then s(pq) = p + q + 1. As a slight strengthening of the Goldbach conjecture, we have the following:

Hypothesis G. Every even number at least 8 is the sum of two distinct primes.

There is ample evidence in favor of Hypothesis G: Lu [\cite=lu] showed that it holds for all but at most O(x0.879) even numbers ≤  x, and e Silva et al. [\cite=esilva] ran a large distributed computation to verify it for all even n∈[null].

Assuming Hypothesis G, for any odd number [formula], we have n = p + q + 1 = s(pq) for distinct odd primes p, q. Since pq > n and is again odd, we can repeat this construction to see that the inverse orbit [formula] is infinite; in particular, n has infinite connected component. Note also that 1 = s(11), 3 = s(s(9)) and 7 = s(s(49)). Thus, under Hypothesis G, every odd number except 5 has infinite inverse orbit and, since s(5) = 1, every odd number has infinite connected component. Unconditionally, Erds et al. [\cite=egps] showed that infinite inverse orbits exist; in fact all but a density zero subset of the odd numbers have infinite inverse orbit, although the method of proof does not allow one to exhibit a specific such number.

We say that a connected component of the aliquot graph is potentially infinite if it contains an odd number. Absent a proof of Hypothesis G (including the Goldbach conjecture), we cannot prove that a given potentially infinite connected component is actually infinite, unless it is shown to contain 1. However, we will take Hypothesis G for granted in what follows, so our numerical results will be conditional upon it. With this caveat, in Section [\ref=sec:1e9] we describe a computation determining the complete list of finite connected components of the aliquot graph that contain a number below 109.

Finally, in Section [\ref=sec:conclusion] we conclude with some related questions and speculations suggested by the numerics.

Acknowledgements

This paper was inspired by the work of Jean-Luc Garambois [\cite=garambois], as well as posts by David Stevens and another user, who wishes to remain anonymous, on . I thank them for raising interesting questions. I also thank Carl Pomerance for helpful comments and for pointing out the related results in [\cite=egps] and [\cite=pomerance].

An algorithm for s- 1

Suppose that [formula] is given, and we wish to find [formula] satisfying s(m) = n. If [formula] is odd, then searching through small primes p, we expect to find one quickly (polynomial time in log n) such that q = n - 1 - p is prime, so that n = s(pq); although a proof of this seems far off, that does not prevent it from working well in practice to find an element of s- 1({n}), even for very large odd n. On the other hand, it is conjectured that all large odd n have ≫  n /  log 2n representations as p + q + 1 (and this certainly holds for at least some arbitrarily large n, by the prime number theorem and pigeonhole principle), and it follows that no algorithm can compute all of s- 1({n}) in fewer than O(n /  log n) bit operations. In light of this, and since our application requires only even values, we assume henceforth that n is even.

Let us first consider the possibility of odd m. If [formula] and [formula], then it is easy to see that m must be a square. Let p be the largest prime factor of m, and write m = a2p2k. Then we have

[formula]

so that [formula] and [formula]. For a = 1 and each odd a∈[null], we run through all [formula], where [formula] is the smallest odd number exceeding every prime factor of a, perform a binary search for integral p  ≥  q satisfying [\eqref=eq:sa2], and apply a primality test.

Next we consider [formula], and write it in the form ab, where we think of [formula] as the "smooth" part of m, with only small prime factors, and b as the rest. Then we have

[formula]

For a fixed choice of a, we view [\eqref=eq:ab] as a linear equation constraining the pair (s(b),b). First note that if g =  gcd (σ(a),s(a)) =  gcd (a,s(a)), then [\eqref=eq:ab] has no solutions unless g|n. When g|n, we put u = σ(a) / g and v = s(a) / g, so that (x,y) = (s(b),b) is a solution to ux + vy = n / g. Using the Euclidean algorithm, we can determine a particular solution [formula], and the general solution in positive integers is then (x,y) = (x0 + rv,y0 - ru) for [formula]. Our algorithm proceeds by working recursively through all possible prime factorizations of a. For the base case of the recursion, once the number of possibilities for b is small enough, we test all of them to see if the equality n = s(ab) is satisfied.

As described, this method is only a little more efficient than directly considering every possible even m  ≤  2n, but fortunately there are a few ways in which we can reduce the search space. First, we can detect the cases b = p or b = p2 for a prime p by solving [\eqref=eq:ab], which gives a linear or quadratic equation for p, and applying a primality test. Second, in the typical case when b has no small prime factors, we can narrow the range for s(b) using the following estimate:

Let b > 1 be an integer with smallest prime factor p. Then s(b)∈[b  /  p,bΩ(b)  /  p].

Since b / p is a proper divisor of b, we have s(b)  ≥  b / p, directly from the definition. For the upper bound, let [formula] be the prime factorization of b, consider the set

[formula]

and write [formula], with [formula] in increasing order. Next set b0 = 1 and [formula] for [formula]. Then

[formula]

Consider [formula], and suppose that qj = pki. Then bj = pibj - 1 and

[formula]

Since q1 = p and the qj are strictly increasing, we thus have

[formula]

Hence

[formula]

Although we do not know p in advance, we will know a lower bound for it in the course of the recursion. Supposing that p  ≥  p1 and that we have already checked the cases b = 1, b = p and b = p2, we have

[formula]

where p1' denotes the smallest prime exceeding p1. Thus, defining

[formula]

we have

[formula]

so that b∈[b1,b2] and s(b)∈[s1,s2]. We stop the recursion and test every value of b once the number of (x,y)∈[s1,s2]  ×  [b1,b2] satisfying ux + vy = n / g falls below p1.

Third, the solutions with b = pq for distinct primes p and q can also be determined without searching, since in this case we have

[formula]

Thus, factoring (au + nv) / g and testing all of its divisors [formula] will reveal p and q. Since (au + nv) / g is potentially quite large, this test is more expensive than that for b = p or p2, so we use it only when p1 is large enough to guarantee that b is a product of two primes.

Our procedure is described in more detailed pseudocode in Algorithm [\ref=alg]. We turn now to the running time analysis. First, by either using a sieve to amortize the factorization of a or working recursively through the possibile factorizations, we see that it takes at most Oε(n1 / 2 + ε) bit operations to find all odd m with s(m) = n.

For even m, consider a simplified version of the algorithm in which we omit the checks for b = p, b = p2 and b = pq, and stop the recursion once [formula]. (These simplifications make the algorithm slightly less efficient, but one can see that they do not significantly affect the asymptotic running time.) Suppose that the recursive procedure is called with input a, and let p denote the largest prime factor of a, with [formula]. Then either p = 2 or the criterion for stopping the recursion was not satisfied when considering a / pk, so that [formula]. We may assume that [formula], so in either case, writing f(a) = a / pk - 1, we have [formula]. The number of [formula] satisfying [formula] is no more than [formula], and this gives an upper bound for the number of times that the recursive procedure is called.

Next, let p1 denote the smallest prime exceeding both [formula] and every prime factor of a. Then by [\eqref=eq:b2s2], the values of b that we consider in the base case of the recursion for a satisfy

[formula]

Moreover, s(b) is determined modulo v = s(a) / g, so the number of possibilities to consider is at most

[formula]

Summing over all g|n and a satisfying gcd (s(a),σ(a)) = g, we see that the total number of candidate values for b is bounded by

[formula]

The largest prime factor of a and the value of s(a) can be carried along as extra state information during the recursion, so no work is required to factor a. On the other hand, we can expect the b values that arise to occur sparsely throughout (0,n), and we need to factor them in order to compute s(b). In practice, one can use a generic factoring algorithm with good average-case performance. To get a provable estimate for the running time, it suffices to record all of the candidate pairs (a,b) in a list and apply Bernstein's batch factorization algorithm [\cite=bernstein] to the b values. Since there are Oε(n1 / 2 + ε) pairs and each b is bounded by n, the total time to factor all of them is still Oε(n1 / 2 + ε).

Thus, we have shown the following.

The algorithm described in this section computes s- 1({n}) for a given [formula] in time at most Oε(n1 / 2 + ε).

For [formula], #  s- 1({n})  ≪  εn1 / 2 + ε.

Numerical results

Examples of finite connected components

For any given [formula], the forward orbit of n under s either terminates with 1, grows without bound, or enters a cycle. In the first two cases, n must have infinite connected component. Hence, to find finite connected components, it suffices to consider only those n contained in a cycle, and compute their inverse orbits. For each even amicable pair with smaller element below 1014, as well as the known perfect or sociable cycles with smallest element below 1017, we started with the smallest n in the cycle and iteratively computed s- 1({n}), s- 1(s- 1({n})), until reaching either the empty set or a set containing an odd number. In the former case, n has finite connected component, and our computation determines it entirely; in the latter case, assuming Hypothesis G, the connected component is infinite.

It is also conceivable that there are n for which neither case occurs, and the procedure does not terminate. However, for any n, the elements of [formula] are bounded by 2n, so chains of even numbers in the inverse orbit of n grow at most exponentially in the iteration count. Moreover, for any m of the form p + 1 for prime p, we have m = s(p2). We see no reason why numbers of this form should not occur among the elements of the inverse orbit of n with the same frequency as for random numbers of the same size. Thus, provided that the kth iterate of s- 1 applied to {n} is non-empty, we expect it to contain an odd number with probability ≫  1 / k. Since the harmonic series diverges, we therefore expect to reach an odd number eventually, as long as the inverse orbit is infinite. This was borne out by our numerics, as every connected component that we considered was found to be either finite or potentially infinite.

Of the 24003 even amicable pairs that we considered, 7438 pairs were found to belong to a finite connected component, and of those, 2394 were isolated cycles. The average size of the components was 37968 / 7438  ≈  5.1, and the largest was of size 58, corresponding to the amicable pair {29215166389256,31021462090744}; it is shown in Figure [\ref=fig:amicable].

For even aliquot cycles of size other than 2, only 75 are known with smallest element below 1017. We found 12 belonging to a finite connected component, of which three are isolated cycles (including the perfect numbers 28 and 137438691328); they are shown in Figure [\ref=fig:sociable].

Finite connected components containing a small node

Towards our second objective, we found, conditional on Hypothesis G, the complete list of finite connected components of the aliquot graph containing a number [formula]. As it turns out, there are 101 such components, out of 435 known cycles of even numbers in that range. They are comprised of 462 nodes, 88 of which exceed 109. The 14 examples containing a number below 107 are shown in Figure [\ref=fig:1e7].

Our computation proceeded as follows. First, beginning with each even number [formula], we used PARI/GP [\cite=pari] to compute the forward orbit n, s(n), , until arriving at a number m = sk(n) satisfying one of the following conditions:

m is odd;

m - 1 is prime;

m = sj(n) for some j < k;

m  ≥  1050.

In the first two cases, n is connected to an odd number (m in case (1), (m - 1)2 in case (2)), so its connected component is potentially infinite. In the third case, the forward orbit enters a cycle. We determined the minimum number in each cycle and collated the cycles discovered for all [formula]. It turned out that they were all among the cycles considered in Section [\ref=sec:examples], so we could readily classify each connected component as either finite or potentially infinite. That left 1053 numbers in the indeterminate case (4), to which we applied the algorithm from Section 2 to search for odd numbers in the inverse orbit of n, then of s(n), s(s(n)), , until reaching a value of sk(n) in excess of 248. With this method we succeeded in finding an odd number for all but nine values of n, whose forward orbits merged into just four distinct aliquot sequences. Finally, we resolved these by continuing the forward orbits with a larger cutoff of 1070.

For each n with potentially infinite connected component, we recorded, as a certificate, an odd number [formula] and indices [formula] such sk(n) = sj(m). The interested reader may find these at [\cite=data], along with the data pertaining to the finite connected components.

Related questions

Recall that a number [formula] is called non-aliquot (or untouchable) if [formula]. Pollack and Pomerance [\cite=pp] have conjectured that the non-aliquot numbers have asymptotic density

[formula]

in the natural numbers, and this is supported by the available numerical evidence. Their analysis relies heavily on some heuristics for the typical behavior of s over the natural numbers. The heuristics do not apply to amicable numbers, which are atypical in this respect (e.g., for any amicable number a, the sequence a, s(a), s(s(a)) is not monotonic, which is a rare event among all natural numbers). Nevertheless, one can ask whether the amicable pairs that form isolated cycles have a density within the set of all amicable pairs (ordered by smaller element, say). Empirically almost all aliquot cycles have order 2, so this density, if it exists, should agree with that of the isolated cycles among all cycles. Table [\ref=tab:density] shows the frequency of isolated cycles among all known cycles in various ranges up to 1014. Based on this limited evidence, we speculate that the limiting density does exist and is approximately 6%.

Similarly, one might ask whether there are infinitely many finite connected components, and whether the cycles with finite connected component have a density among all cycles. Table [\ref=tab:density] also shows data relevant to these questions. Again we speculate that the answer to both is yes, with the limiting density approximately 19%.

Finally, we found finite connected components of every size [formula]. Table [\ref=tab:large] shows the ones of record size when ordered by smallest element. It seems plausible that every positive integer is the cardinality of a finite connected component; in particular, we conjecture that there are arbitrarily large finite components.