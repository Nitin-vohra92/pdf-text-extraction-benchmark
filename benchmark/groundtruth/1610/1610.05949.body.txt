Visual-Inertial Monocular SLAM with Map Reuse

INTRODUCTION

Motion estimation from onboard sensors is currently a hot topic in Robotics and Computer Vision communities, as it can enable emerging technologies such as autonomous cars, augmented and virtual reality, service robots and drone navigation. Among different sensor modalities, visual-inertial setups provide a cheap solution with great potential. On the one hand cameras provide rich information of the environment, which allows to build 3D models, localize the camera and recognize already visited places. On the other hand IMU sensors provide self-motion information, allowing to recover metric scale for monocular vision, and to estimate gravity direction, rendering absolute pitch and roll of the sensor.

Visual-inertial fusion has been a very active research topic in the last years. The recent research is focus on tightly-coupled (i.e. joint optimization of all sensor states) visual-inertial odometry, using keyframe-based non-linear optimization [\cite=LeuteneggerIJRR14] [\cite=EngelIMU] [\cite=ForsterRSS15] [\cite=AlejoICRA16] or filtering [\cite=MourikisICRA07] [\cite=JonesIJRR11] [\cite=WuRSS15] [\cite=BloeschIROS15]. Nevertheless these approaches are only able to compute incremental motion and lack the capability to close loops and reuse a map of an already mapped environment. This implies that estimated trajectory accumulates drift without bound, even if the sensor is always localizing in the same environment. This is due to the use of the marginalization of past states to maintain a constant computational cost [\cite=MourikisICRA07] [\cite=JonesIJRR11] [\cite=LeuteneggerIJRR14] [\cite=WuRSS15] [\cite=BloeschIROS15] [\cite=EngelIMU], or the use of full smoothing [\cite=ForsterRSS15], with an almost constant complexity in exploration but that can be as expensive as a batch method in the presence of loop closures [\cite=iSAM2].

In this paper we present Visual-Inertial ORB-SLAM, to the best of our knowledge the first keyframe-based Visual-Inertial SLAM that is able to close loops and reuse its map. Inspired by [\cite=ptam] our tracking optimizes current frame assuming a fixed map, and our backend performs local Bundle Adjustment (BA), optimizing a local window of keyframes, including an outer window of fixed keyframes that ensures global consistency. This approach allows for a constant time local BA, in contrast to full smoothing, and as not marginalizing past states we are able to reuse them. We detect large loops using place recognition and a lightweight pose-graph optimization, followed by full BA in a separate thread not to interfere with real-time operation. Fig. [\ref=fig:view] shows the reconstruction of our system in a sequence with continuous revisiting.

Both tracking and local BA work fixing states, which could potentially bias the solution, therefore we need a very good visual-inertial initialization that provides accurate state values before we start fixing states. To this end we propose in Section [\ref=sec:ini] a novel IMU initialization method that estimates scale, gravity direction, velocity, and gyroscope and accelerometer biases, by processing the keyframes created by ORB-SLAM [\cite=MurTRO15] from a few seconds of video. In contrast to [\cite=MartinelliIJCV14] [\cite=yangTASE16] [\cite=KaiserRAL17] where vision and IMU are jointly estimated, we only need to estimate the IMU variables, as the vision part is already solved by ORB-SLAM. We divide the initialization into simpler subproblems. We first propose a method to estimate gyroscope biases which are ignored in [\cite=MartinelliIJCV14] [\cite=yangTASE16]. We then solve scale and gravity without considering accelerometer bias, in a similar way to [\cite=LuptonTRO12] (which ignored gyroscope biases and did not solve scale as it uses stereo vision). We then introduce the knowledge of gravity magnitude and solve for accelerometer bias, ignored in [\cite=yangTASE16] [\cite=KaiserRAL17], also refining scale and gravity direction. In a final step we compute the velocity of all keyframes. We validate the method in real sequences, concluding that it is an efficient, reliable and accurate method that solves IMU biases, gravity, velocity and scale. Moreover our method is general and could be applied to any monocular SLAM system.

VISUAL-INERTIAL PRELIMINARIES

The input for our Visual-Inertial ORB-SLAM is a stream of IMU measurements and monocular camera frames. We consider a conventional pinhole-camera model [\cite=Hartley] with a projection function [formula], which transforms 3D points [formula] in camera reference [formula], into 2D points on the image plane [formula]:

[formula]

where [formula] is the focal length and [formula] the principal point. This projection function does not consider the distortion produced by the camera lens. When we extract keypoints on the image, we undistort their coordinates so that they can be matched to projected points using [\eqref=eq:proj].

The IMU, whose reference we denote with [formula], measures the acceleration [formula] and angular velocity [formula] of the sensor at regular intervals Δt, typically at hundreds of Herzs. Both measurements are affected, in addition to sensor noise, by slowly varying biases [formula] and [formula] of the accelerometer and gyroscope respectively. Moreover the accelerometer is subject to gravity [formula] and one needs to subtract its effect to compute the motion. The discrete evolution of the IMU orientation [formula], position [formula] and velocity [formula], in the world reference [formula], can be computed as follows [\cite=ForsterRSS15]:

[formula]

The motion between two consecutive keyframes can be defined in terms of the preintegration [formula], [formula] and [formula] from all measurements in-between [\cite=LuptonTRO12]. We use the recent IMU preintegration described in [\cite=ForsterRSS15]:

[formula]

where the Jacobians [formula] and [formula] account for a first-order approximation of the effect of changing the biases without explicitly recomputing the preintegrations. Both preintegrations and Jacobians can be efficiently computed iteratively as IMU measurements arrive [\cite=ForsterRSS15].

Camera and IMU are considered rigidly attached and the transformation [formula] between their reference systems known from calibration [\cite=kalibr].

VISUAL-INERTIAL ORB-SLAM

The base of our visual-inertial system is ORB-SLAM [\cite=MurTRO15]. This system has three parallel threads for Tracking, Local Mapping and Loop Closing. The system is designed to work on large scale environments, by building a covisibility graph that allows to recover local maps for tracking and mapping, and by performing lightweight pose-graph optimizations at loop closure. In addition ORB-SLAM allows to build a map of an environment and switch to a less CPU-intensive localization-only mode (i.e. mapping and loop closing are disabled), thanks to the relocalization capability of the system. ORB-SLAM is open-source and has been extensively evaluated on public datasets achieving top performing results. In this section we detail the main changes in Visual-Inertial ORB-SLAM with respect to the original system.

Initialization

Our system initializes first using only monocular vision, as in the original ORB-SLAM. After few seconds it performs a specific initialization of the scale, gravity direction, velocity, and accelerometer and gyroscope biases. The reason for this delayed initialization is twofold. Firstly the sensor has to perform a motion that makes all variables observable. Secondly our tracking and local BA works fixing old keyframes in the optimization. We need these values to have converged, before we can actually fix a keyframe. This IMU initialization is detailed in Section [\ref=sec:ini].

Tracking

Our visual-inertial tracking is in charge of tracking sensor pose, velocity and IMU biases, at frame-rate. This allows us to predict the camera pose very reliably, instead of using an ad-hoc motion model as in the original monocular system. Once the camera pose is predicted, the map points in the local map are projected and matched with keypoints on the frame. We then optimize current frame j by minimizing the feature reprojection error of all matched points and an IMU error term. This optimization is different depending on the map being updated or not by the Local Mapping or the Loop Closing thread, as illustrated in Fig. [\ref=fig:tr].

When tracking is performed just after a map update, the IMU error term links current frame j with last keyframe i:

[formula]

where the feature reprojection error [formula] for a given match, is defined as follows:

[formula]

where [formula] is the keypoint location in the image, [formula] the map point in world coordinates, and [formula] the information matrix associated to keypoint scale. The IMU error term [formula] is:

[formula]

where [formula] is the information matrix of the preintegration and [formula] of the bias random walk [\cite=ForsterRSS15], and ρ is the Huber robust cost function. We solve this optimization problem with Gauss-Newton algorithm implemented in g2o [\cite=g2o]. After the optimization, the resulting estimation and Hessian matrix serves as prior for next optimization.

Assuming no map update, the next frame j + 1 will be optimized with a link to frame j and using the prior computed in the previous optimization:

[formula]

where [formula] is a prior term:

[formula]

where () are the estimated states from previous optimization and [formula] the prior information matrix (i.e. the resulting Hessian matrix from previous optimization). After this optimization, frame j is marginalized out [\cite=LeuteneggerIJRR14]. This optimization linking two consecutive frames and using a prior is performed until a map change, when the prior will be no longer valid. Note that this is the optimization that is always performed in localization-only mode, as the map is not updated.

Local Mapping

The Local Mapping performs local BA after a new keyframe insertion. It optimizes the last N keyframes (local window) and all points seen by those N keyframes. All other keyframes that share observations of local points (i.e. are connected in the covisibility graph to any local keyframe), but are not in the local window, contribute to the total cost but are fixed during optimization (fixed window). The keyframe N + 1 is always included in the fixed window as it constraints the IMU states. Fig. [\ref=fig:ba] illustrates the differences between local BA in original ORB-SLAM and Visual-Inertial ORB-SLAM. The cost function is a combination of IMU error terms [\eqref=eq:Eimu] and reprojection error terms [\eqref=eq:Ereproj]. Note that the visual-inertial version, compared to the vision only, is more complex as there are 9 additional states (velocity and biases) to optimize per keyframe. A suitable local window size has to be chosen for real-time performance.

The Local Mapping is also in charge of keyframe management. The original ORB-SLAM policy discards redundant keyframes, so that map size does not grow if localizing in a well mapped area. This policy is problematic for using IMU information, which constraints the motion of consecutive keyframes. The longer the temporal difference between consecutive keyframes, the weaker information IMU provides. Therefore we allow the mapping to discard redundant keyframes, if that does not make two consecutive keyframes in the local window of local BA to differ more than [formula]. To be able to perform full BA, after a loop closure or at any time to refine a map, we do not allow any two consecutive keyframes to differ more than 3s. If we switched-off full BA with IMU constraints, we would only need to restrict the temporal offset between keyframes in the local window.

Loop Closing

The loop closing thread aims to reduce the drift accumulated during exploration, when returning to an already mapped area. The place recognition module matches a recent keyframe with a past keyframe. This match is validated computing a rigid body transformation that aligns matched points between keyframes [\cite=Horn]. Finally an optimization is carried out to reduce the error accumulated in the trajectory. This optimization might be very costly in large maps, therefore the strategy is to perform a pose-graph optimization, which reduces the complexity, as structure is ignored, and exhibits good convergence as shown in [\cite=MurTRO15]. In contrast to the original ORB-SLAM, we perform the pose-graph on 6 Degrees of Freedom( DoF) instead of 7 DoF [\cite=HaukeScale], as scale is observable. This pose-graph ignores IMU information, not optimizing velocity or IMU biases. Therefore we correct velocities by rotating them according to the corrected orientation of the associated keyframe. While this is not optimal, biases and velocities should be locally accurate to continue using IMU information right after pose-graph optimization. We perform afterwards a full BA in a parallel thread that optimizes all states, including velocities and biases.

IMU INITIALIZATION

We propose in this section a method for scale, gravity direction, velocity and IMU biases estimation, given a set of keyframes processed by a monocular SLAM algorithm. The idea is to run the monocular SLAM for a few seconds, assuming the sensor performs a motion that make all variables observable. While we build on ORB-SLAM [\cite=MurTRO15], any other SLAM could be used. The only requirement is that any two consecutive keyframes are close in time (see Section [\ref=sec:mapping]), to reduce IMU noise integration.

The initialization is divided in simpler subproblems: (1) gyroscopes biases estimation, (2) scale and gravity approximation, considering no accelerometer bias, (3) accelerometer biases estimation, and scale and gravity direction refinement, and (4) velocity estimation.

Gyroscope Bias Estimation

Gyroscope bias can be estimated just from the known orientation of two consecutive keyframes. Assuming a negligible bias change, we optimize a constant bias [formula], which minimizes the difference between gyroscope integration and relative orientation computed from ORB-SLAM, for all two consecutive keyframes:

[formula]

where N is the number of keyframes. [formula] is computed from the orientation [formula] computed by ORB-SLAM and calibration [formula]. [formula] is the gyroscope integration between two consecutive keyframes. We solve [\eqref=eq:gyro] with Gauss-Newton with a zero bias seed. Analytic jacobians for a similar expression can be found in [\cite=ForsterRSS15].

Scale and Gravity Approximation (no accelerometer bias)

Once we have estimated the gyroscope bias, we can preintegrate velocities and positions, rotating correctly the acceleration measurements compensating the gyroscope bias.

The scale of the camera trajectory computed by ORB-SLAM is arbitrary. Therefore we need to include a scale factor s when transforming between camera [formula] and IMU [formula] coordinate systems:

[formula]

Substituting [\eqref=eq:s] into the equation relating position of two consecutive keyframes [\eqref=eq:preint], and neglecting at this point accelerometer bias, it follows:

[formula]

The goal is to estimate s and [formula] by solving a linear system of equations on those variables. To avoid solving for N velocities, and reduce complexity, we consider two relations [\eqref=eq:pnobias] between three consecutive keyframes and use velocity relation in [\eqref=eq:preint], which results in the following expression:

[formula]

where, writing keyframes i,i + 1,i + 2 as 1,2,3 for clarity notation, we have:

[formula]

We stack then all relations of three consecutive keyframes [\eqref=eq:sys1] into a system [formula] which can be solved via Singular Value Decomposition (SVD) to get the scale factor s* and gravity vector [formula]. Note that we have 3(N - 2) equations and 4 unknowns, therefore we need at least 4 keyframes.

Accelerometer Bias Estimation, and Scale and Gravity Direction Refinement

So far we have not considered accelerometer bias when computing scale and gravity. Just incorporating accelerometer biases in [\eqref=eq:sys1] will heavily increase the chance of having an ill-conditioned system, because gravity and accelerometer biases are hard to distinguish [\cite=MartinelliIJCV14]. To increase observability we introduce new information we did not considered so far, which is the gravity magnitude G. Consider an inertial reference I with the gravity direction [formula], and the already computed gravity direction [formula]. We can compute rotation [formula] as follows:

[formula]

and express now gravity vector as:

[formula]

where [formula] can be parametrized with just two angles around x and y axes in [formula], because a rotation around z axis, which is aligned with gravity, has no effect in [formula]. This rotation can be optimized using a perturbation [formula]:

[formula]

with a first-order approximation:

[formula]

Substituting [\eqref=eq:gr3] in [\eqref=eq:pnobias] and including now the effect of accelerometer bias, we obtain:

[formula]

Considering three consecutive keyframes as in [\eqref=eq:sys1] we can get rid of velocities and get the following relation:

[formula]

where [formula] remains the same as in [\eqref=eq:sys1-2], and [formula], [formula], and [formula] are computed as follows:

[formula]

where (:,1:2) means the first two columns of the matrix. Stacking all relations between three consecutive keyframes [\eqref=eq:sys2] we form a linear system of equations [formula] which can be solved via SVD to get the scale factor s*, gravity direction correction [formula] and accelerometer bias [formula]. In this case we have 3(N - 2) equations and 6 unknowns and we need again at least 4 keyframes to solve the system. We can compute the condition number (i.e. the ratio between the maximum and minimum singular value) to check if the problem is well-conditioned (i.e. the sensor has performed a motion that makes all variables observable). We could relinearize [\eqref=eq:gr3] and iterate the solution, but in practice we saw that a second iteration does not produce a noticeable improvement.

Velocity Estimation

We considered relations of three consecutive keyframes in equations [\eqref=eq:sys1] and [\eqref=eq:sys2], so that the resulting linear systems do not have the 3N additional unknowns corresponding to velocities. The velocities for all keyframes can now be computed using equation [\eqref=eq:pbias], as scale, gravity and bias are known. To compute the velocity of the most recent keyframe, we use the velocity relation [\eqref=eq:preint].

Bias Reinitialization after Relocalization

When the system relocalizes after a long period of time, using place recognition, we reinitialize gyroscope biases by solving [\eqref=eq:gyro]. The accelerometer bias is estimated by solving a simplified [\eqref=eq:sys2], where the only unknown is the bias, as scale and gravity are already known. We use 20 consecutive frames localized with only vision to estimate both biases.

EXPERIMENTS

We evaluate the proposed IMU initialization method, detailed in Section [\ref=sec:ini] and our Visual-Inertial ORB-SLAM in the EuRoC dataset [\cite=EUROC]. It contains 11 sequences recorded from a micro aerial vehicle (MAV), flying around two different rooms and an industrial environment. Sequences are classified as easy, medium and difficult, depending on illumination, texture, fast/slow motions or motion blur. The dataset provides synchronized global shutter WVGA stereo images at [formula] with IMU measurements at [formula] and trajectory ground-truth. These characteristics make it a really useful dataset to test Visual-Inertial SLAM systems. The experiments were performed processing left images only, in an Intel Core i7-4700MQ computer with 8Gb RAM.

IMU Initialization

We evaluate the IMU initialization in sequences V1_01_easy and V2_01_easy. We run the IMU initialization from scratch every time a new keyframe is inserted by ORB-SLAM. We run the sequences at a lower frame-rate so that the repetitive initialization does not interfere with the normal behavior of the system. The goal is to analyze the convergence of the variables as more keyframes, i.e. longer trajectories, are processed by the initialization algorithm. Fig. [\ref=fig:ini] shows the estimated scale and IMU biases. It can be seen that between 10 and 15 seconds all variables have already converged to stable values and that the estimated scale factor is really close to the optimal. This optimal scale factor is computed aligning the estimated trajectory with the ground-truth by a similarity transformation [\cite=Horn]. Fig. [\ref=fig:ini] also shows the evolution in the condition number, indicating that some time is required to get a well-conditioned problem. This confirms that the sensor has to perform a motion that makes all variables observable, especially the accelerometer bias. The last row in Fig. [\ref=fig:ini] shows the total time spent by the initialization algorithm, which exhibits a linear growth. This complexity is the result of not including velocities in [\eqref=eq:sys1] and [\eqref=eq:sys2], which would have resulted in a quadratic complexity when using SVD to solve these systems. Subdividing the initialization in simpler subproblems, in contrast to [\cite=MartinelliIJCV14] [\cite=KaiserRAL17], results in a very efficient method.

The proposed initialization allows to start fusing IMU information, as gravity, biases, scale and velocity are reliably estimated. For the EuRoC dataset, we observed that 15 seconds of MAV exploration gives always an accurate initialization. As a future work we would like to investigate an automatic criterion to decide when we can consider an initialization successful, as we observed that an absolute threshold on the condition number is not reliable enough.

SLAM Evaluation and Comparison to State-of-the-Art

We evaluate the accuracy of our Visual-Inertial ORB-SLAM in the 11 sequences of the EuRoC dataset. We start processing sequences when the MAV starts exploring. The local window size for the local BA is set to 10 keyframes and the IMU initialization is performed after 15 seconds from monocular ORB-SLAM initialization. The system performs a full BA just after IMU initialization. Table [\ref=t:acc] shows the translation Root Mean Square Error (RMSE) of the keyframe trajectory for each sequence, as proposed in [\cite=tumrgbd]. We use the raw Vicon and Leica ground-truth as the post-processed one already used IMU. We observed a time offset between sensor and ground-truth of - 0.2s in the Vicon Room 2 sequences and 0.2s in the Machine Hall, that we corrected when aligning both trajectories. We also measure the scale factor that would align best the estimated trajectory and ground-truth. This scale factor can be regarded as the residual scale error of the trajectory and reconstruction. Our system is able to process all these sequences in real-time, except sequence V1_03_difficult, where the movement is too extreme for the monocular system to initialize. The results show that our system is able to recover motion with metric scale, with a scale error typically below 1%. The system achieves a typical precision of [formula] for [formula] room environments and of [formula] for [formula] industrial environments. Note that our system is able to close loops and localize using the existing map when revisiting, which avoids drift accumulation. These results can be improved by applying a full BA afterwards, as seen in Table [\ref=t:acc]. The reconstruction for sequence V1_02_medium can be seen in Fig. [\ref=fig:view], and in the accompanying video.

In order to test the capability of our system to reuse a previous map of an environment, we run in a row all sequences of the same scene. We first process the first sequence and perform a full BA. Then we run the rest of the sequences, where our system performs relocalization and continue doing SLAM. We then compare the accumulated keyframe trajectory with the ground-truth. Bottom rows of Table [\ref=t:acc] show accuracy results. As there exists a previous map, our system is now able to localize the camera in sequence V1_03_difficult. These results show that there is no drift accumulation when revisiting the same scene, as the RMSE for all sequences is not larger than for individual sequences.

We have compared our system with the state-of-the-art direct visual-inertial odometry for stereo cameras [\cite=EngelIMU], which also showed results in Vicon Room 1 sequences, allowing for a direct comparison. Fig. [\ref=fig:comp] shows the Relative Pose Error (RPE) [\cite=Geiger2012CVPR]. To compute the RPE for our method, we need to recover the frame trajectory, as only keyframes are optimized by our backend. To this end, when tracking a frame we store a relative transformation to a reference keyframe, so that we can retrieve frame pose from the estimated keyframe pose at the end of the execution. We have not run a full BA at the end of the experiment. We can see the error for the visual-inertial odometry method grows with the traveled distance, while our visual-inertial SLAM system does not accumulate error due to map reuse. The stereo method [\cite=EngelIMU] is able to work in V1_03_difficult, while our monocular method fails. Our monocular SLAM successfully recovers metric scale, and achieves comparable accuracy in short paths, where the advantage of SLAM is negligible compared to odometry. This is a remarkable result of our feature-based monocular method, compared to [\cite=EngelIMU] which is direct and stereo.

CONCLUSIONS

We have presented in this paper a novel tightly coupled Visual-Inertial SLAM system, that is able to close loops in real-time and localize the sensor reusing the map in already mapped areas. This allows to achieve a zero-drift localization, in contrast to visual odometry approaches where drift grows unbounded. The experiments show that our monocular SLAM recovers metric scale with high precision, and achieves better accuracy than the state-of-the-art in stereo visual-inertial odometry when continually localizing in the same environment. We consider this zero-drift localization of particular interest for virtual/augmented reality systems, where the predicted user viewpoint must not drift when the user operates in the same workspace. Moreover we expect to achieve better accuracy and robustness by using stereo or RGB-D cameras, which would also simplify IMU initialization as scale is not longer unknown.

ACKNOWLEDGMENT

We thanks the authors of [\cite=EUROC] for releasing the EuRoC dataset and the authors of [\cite=EngelIMU] for providing their data to compare our results in Fig. [\ref=fig:comp].