Quantum Computational Representation of the Bosonic Oscillator

Introduction

The harmonic oscillator is one of the most important dynamical systems in mathematical physics, providing a basis for the description of many fundamental physical concepts. These range from normal mode analysis in classical many-body theory, the coulombic interaction in quantum mechanics [\cite=CORNISH-84], the algebra of angular momentum operators [\cite=SCHWINGER-65], supersymmetric quantum mechanics [\cite=MEJIA+PLEITEZ-02], coherent states in quantum optics, free particle states and perturbation theory expansions in relativistic quantum field theory, excitations of relativistic strings and many other examples. The oscillator also provides a framework for the description of bosons, which is part of the focus of this work. It is a completely solvable system and has been described from numerous points of view in both the classical and quantum formalisms.

In this article our aim is to show how the quantized one-dimensional harmonic oscillator can be described in quantum computational terms. This requires the introduction of a suitable Hilbert space, a quantum register, over which the computational processes are carried out. It turns out that, because bosons have no upper limit to their excitation levels, this involves a tremendous amount of mathematical redundancy. The Hilbert space dimension of the quantum register introduced is far bigger than that actually needed to describe a quantized boson, most of the states in the register being what we call transbosonic. It is in fact non-separable, i.e., has no denumerable basis, whereas the conventional Hilbert space used to describe the quantum harmonic oscillator is denumerable. We will show exactly how bosonic states are restricted to a tiny subspace of the register and remain there during the quantum computational processes involved in the quantum register approach.

The motivation for taking this approach arises from a combination of circumstances. In the nineteen fifties, Ulam and von Neumann began to discuss computational models known as cellular automata, in which simple rules of computation applied to systems with many degrees of freedom could produce complex patterns of behaviour. By the nineteen eighties, Fredkin, Feynman [\cite=FEYNMAN-82], Minsky [\cite=MINSKY-82] and others were speculating on the possibility of describing the laws of physics and the universe in terms of cellular automata and computation. Underlying their ideas was a dissatisfaction with the conventional description of physics based on continuous space and time. In their work, the number of computational degrees of freedom was generally considered very large but countable. This has found resonance recently in a number of directions, such as the spin network approach to quantum gravity and the holographic principle, which asserts that the information content within a region of spacetime is limited by how much information can be packed over its defining surface, which can hold no more than about 1069 bits per square metre.

Feynman's approach is notable because of his interest in applying quantum principles to computation. In due course, the field of quantum computation emerged as a major theoretical and experimental field of research, and Feynman's influence on this has been well-documented [\cite=HEY-99]. At present, the practical difficulties involved in the construction of an actual quantum computer have focused most attention on systems consisting of a relatively small number of quantum bits. This is in contrast to the thinking behind the work of Fredkin, Minsky, Wolfram and others, who envisaged the universe as consisting of a vast number of degrees of freedom.

Our long-term interest is in seeing how far the principles of quantum computation can be extended to cover much larger systems, such as the universe, in line with the ideas of the pioneers. However, it is important to show that these ideas can also apply to real physical systems, such as those encountered in the laboratory. A particularly good area for discussion in this direction is quantum optics, for two reasons. First, experiments in quantum optics are particularly clean both theoretically and experimentally. Secondly, devices such as beam-splitters, mirrors, Wollaston prisms, lenses and phase-shifters can be linked together in a modular way to build up more complex apparatus, such as Mach-Zender interferometers. It should also be possible to couple many beam-splitters [\cite=ELITZUR-01] and Mach-Zender interferometers together to form much larger systems. This is very similar to the idea of linking many single serial processors to form a parallel processing computer. We imagine the process of linking more and more pieces of apparatus being continued to such an extent and over such distance scales that the result begins to look as if the universe itself is one gigantic quantum experiment. Quantum optics provides one scenario in which Feynman's vision of a universe, or at least a substantial part of it, and its associated laws, as being described in quantum computational terms looks reasonable and useful. The link with these ideas and the harmonic oscillator arises quite naturally because photons are bosons and have many of the characteristics of oscillators.

The plan of this paper is as follows. First we discuss some basic concepts involved in our formalism. We start with the notion of a logic function, which is a function from any given domain into the discrete set {0,1}, relating it to classical bits and classical register states. This puts us in a position where we can discuss classical computation and the CNOT gate. This is followed by a discussion of quantization and quantum computation, where we introduce a quantum variant of the CNOT discussed in the classical case. This quantum version of the CNOT is required for our discussion of the quantized bosonic oscillator which then follows. We show how the standard oscillator can be seen as a form of quantum computation in an infinite rank quantum register, i.e., an infinite collection of quantum bits. We conclude with a review of the quantum register description of coherent states, which are important in many realistic situations.

On the matter of notation, we distinguish states and operators involved in the standard quantum theory and their analogues in the quantum register description using the following conventions. States described by standard Hilbert space vectors will always be represented using angular Dirac bra-ket notation, such as |Ψ〉, 〈φ|, etc., whereas states represented by elements of a quantum register will be described by a modified form of this notation, replacing the angular bracket with a round bracket, i.e., |ψ), (f|, etc. The quantum register analogue of an operator Ô in the standard theory will be denoted by [formula], with one or two exceptions.

Logic functions, bits and states

To explain our approach fully, it will be helpful to review some basic concepts associated with classical logic and computation.

Let X be a discrete indexing set for another set Y, the latter set consisting of objects having certain properties in which we are interested. Each element x of X will be called a site and serves as a label for a corresponding unique element y(x) of Y. The number N of elements in X will be assumed finite for now, but taken to infinity when we apply our ideas to the bosonic oscillator. For convenience, we shall label the elements of X by an integer running from zero to N - 1, i.e., [formula].

Suppose we have asked a particular question f of the object y(x) at site x, this question having only one of two possible answers, either yes ([formula] true) or no ([formula] false). If the answer is yes we will associate the number f(x) = 1 with x; otherwise we will associate the number f(x) = 0.

Assuming we can ask the same question of all elements in Y, we now define the logic function f(X) to be a real valued function from X into the discrete set [formula], with its value f(x) at each site x in X defined by the answer to the question f asked of the corresponding y(x) in Y.

If we had asked some other question g of y(x), we would have obtained an answer g(x) at site x which could in principle differ to the answer f(x) to question f. Each question therefore defines a particular logic function over X. We shall denote the set of all distinct logic functions over X by [formula]. If two questions have the same logic function then we shall regard these questions as synonymous, i.e. equivalent. Otherwise, we shall regard these questions as distinct. For finite N, it is easy to see that there are exactly 2N distinct logic functions in [formula]. Two important logic functions which occur in every set of logic functions are the yes function Yes, which satisfies the property [formula] for every site x in X, and the no function No, which satisfies the property [formula] for every site x in X.

In classical computation, we are generally interested in various sorts of maps involving logic functions. We define a type [formula] gate to be a map from the Cartesian product [formula] copies of [formula]) into the Cartesian product [formula]. A binary gate is a type [formula] gate and a rank-n gate is a type (n,n) gate.

Binary gates can be defined via truth tables, in which "yes" = 1 = T = ``true" and ``no" = 0 = F = ``false". Three important binary gates are:

the AND binary gate [formula], defined by

[formula]

where [formula] denotes the logical and applied to the truth value associated with [formula] and [formula]

the "OR" binary gate [formula], defined by

[formula]

where [formula] is the logical "inclusive or";

the XOR binary gate, defined by

[formula]

where [formula] denotes addition modulo two. This is also known as exclusive or .

Separately, each of these three binary gates are commutative and, when generalized to type (3,1) gates, associative, but this is not true of other binary gates in general.

Associated with every logic function f in [formula] is another logic function [formula], known as its negation, or logical dual, defined by the statement

[formula]

which can be solved to give

[formula]

Classical bits

We will find it very useful to encode logic functions in terms of two-component objects called bits, analogous to classical (Pauli) spinors. It should be kept firmly in mind, however, that despite appearances, these objects are neither spinors, fermions, nor Grassmannian variables, and have nothing to do with spin-half angular momentum. They are simply a way of encoding elementary pieces of information, i.e., truth values, in computational terms.

Given a logic function [formula], define the classical bit state (henceforth abbreviated to bit state) [formula]  at x∈X as the two component object

[formula]

Here the subscript on the column vector reminds us that this particular bit state refers to element x and not to any other element of X. The set of all possible distinct bit states at x defines a classical bit subregister, denoted by Rx. The basis vectors

[formula]

provide a basis for Rx, in that any classical bit state [formula] at x can be written as the linear combination

[formula]

using the standard rules for matrix multiplication and addition. However, because the components [formula] and [formula] can take values one or zero only, Rx is not a vector space over the reals.

The adjoint bit state [formula] at x is defined by

[formula]

where

[formula]

Using the rulewhere δij is the Kronecker delta, we find

[formula]

i.e.,

[formula]

The anti-bit state ψ̃f is defined by

[formula]

where

[formula]

is one of the Pauli matrices. This matrix plays the role of the negation operation and is called a flip. We have the relations

[formula]

The usefulness of this encoding is that we can readily express a number of natural questions in bit terms. For a finite set, the cardinality #  X of the set X is given by

[formula]

where σ0x is the 2  ×  2 identity operator at x. The number [formula] of yes values over X relative to the logic function f is given by

[formula]

where

[formula]

Likewise, the number [formula] of no values over X relative to the logic function f  is given by

[formula]

where

[formula]

The difference [formula] is given by

[formula]

where σ3x is the third Pauli matrix

[formula]

We will expand the algebraic structure of these operators in anticipation of subsequent extension to quantum bits. At each site x, define the transition operators

[formula]

Then at any given site, the operators P0,P1, A, A+ and the zero operator 0 can be multiplied together to give the closed algebra of operators shown in Table 1, where for example the product P1A = 0 is read off from the intersection of the row labelled P1 and the column labelled A:

Table 1. The product rule for projection, transition, and Pauli operators.

Classical logic registers

In the above, the set X is treated as if it were a physical space over which we have defined a local bit state [formula] at each site x. This is analogous to the description of a system of N point particles in Newtonian mechanics where at each instant of time each particle is regarded as having a well-defined position in three-dimensional (physical) space with some instantaneous velocity. A more sophisticated but entirely analogous approach is to consider such an N-particle system as a single point in a 6 - N dimensional phase space. Likewise, an equivalent description of our qubit system is to adopt a tensorial approach, where we define the classical register state |f) as the tensor product

[formula]

the symbol [formula] denoting the equivalent of the Kronecker product. Here, the product contains one factor for every element of X. The ordering of factors in this product is not significant at the formal level and what really matters are the labels. Of course, once a matrix representation has been chosen for such a state, the relative ordering of labels does become important and must be kept fixed.

The number of distinct classical register states is the same as the cardinality of [formula], i.e., 2N. The set of distinct classical register states of the form [formula] defines what we call the classical register RX over X and this is the analogue of classical phase space. It is important to keep in mind that, just as in the case of classical phase space, the vector addition of different elements of the classical register has no classical interpretation, but there will be a quantum interpretation of such addition. The cardinality N of the indexing set X will be referred to as the rank of the associated register RX, in both classical and quantum versions. We shall henceforth use the notation RN to mean the rank-N register RX. An infinite-rank register will be denoted by R∞  .

Each logic function f can be mapped into a unique integer nf in the interval [formula] by the rule

[formula]

and we may use the notation |f) or |nf) to denote the corresponding register state when there is no ambiguity. We shall call this rule the computational map.

Two of the states in the register RN are particularly important; the void state |0) is the state associated with the No logic function over X, i.e.,

[formula]

and the fully excited state, associated with the Yes logic function:

[formula]

The void state should not be thought of as either a vacuum" state or as a ground state". The reason for this will become evident when we show how to describe the harmonic oscillator in quantum register terms. The ground state of the harmonic oscillator actually corresponds to the first excited state of the void state. The void state is an example of a transbosonic state, defined below, and its interpretation will be discussed in our next paper, when we describe actual physics experiments via quantum registers.

Dual register states (f| are defined by

[formula]

and then the inner product (f|g) is defined in the obvious way:

[formula]

This inner product has the property that

[formula]

where δf,g is the logic function equivalent of the Kronecker delta, i.e., takes value unity for f = g and zero otherwise. The 2N orthonormal classical register states in RN form a convenient basis, known as the computational basis, for the Hilbert space HN associated with the classical register RN when we have quantized the system.

Classical computation and CNOT

Before we can discuss quantum computation, we need to review some notions of classical computation. Consider a classical system composed of two sites denoted by a and b, i.e., [formula] and consider a logic function f over X. This is equivalent to the classical register state [formula], an element of a rank-two classical register. A basis for this register is given by the set [formula] where

[formula]

and so on. Relative to this basis, the register state |f) has the expansion

[formula]

where [formula], [formula], and so on.

So far, no issues of entanglement can arise because classical registers do not support general superposition. This is reflected by the fact that the coefficients fij in the expansion ([\ref=abc]) of the state |f) relative to the basis [formula] are not only either ones or zeros, but satisfy the condition

[formula]

which is a necessary and sufficient condition for a bipartite quantum state to be separable, i.e., not entangled [\cite=JAROSZKIEWICZ-03A].

A local operator is any operator on register states which acts on each individual site with no reference to any of the other sites. Examples are the identity operator

[formula]

and the negation operator,

[formula]

Products of local operators are also local operators.

Both classical and quantum computation requires the use of non-local operators, the most important being the CNOT, or controlled-not, gate, which involves two sites. It is related to the XOR or measurement gate given in equation [formula], the difference being that the CNOT gate has two output bits. For the rank two register system X given above, consider the non-local operator

[formula]

Its effect is to flip the state at site b if the state at site a answers yes, otherwise the state at b is unaltered. The first site a is known as the (information) donor and the second site b is the acceptor (of information). Its action on state |f) returns the state:

[formula]

Now a bona fide rank-two classical register state is necessarily separable, i.e., satisfies condition [formula]. By considering all four possible values of the coefficients [formula] [formula] etc., it can be readily proved that ([\ref=156]) satisfies this condition, so that it is a legitimate classical register state. However, it is not possible to rearrange ([\ref=156]) as it stands to look like a separable state without running the risk of a formal division by zero. Explicit separability at this point therefore requires a knowledge of the specific logical outcomes (i.e., truth values) [formula] and [formula]. Hence the result of the CNOT operation has a degree of contextuality; although we can be sure in advance that the result of a CNOT operation is in general a classical register state over a rank-two system, and therefore is separable, we cannot explicitly write it out as such until we know the details of the initial state it acts on.

There are two other properties of the CNOT operation which will be important in any extension of our work to quantum field theory. First, the CNOT operation implies a temporal ordering, in that it asks a question of the state of the donor site a and only then gives a response in terms of doing something to the acceptor site b. This is underlined by the above mentioned contextuality. Any question Q and answer A involves a natural ordering, [formula], which defines what can be called a logical or computational arrow of time. With the CNOT gate, it is not possible to actually change the answer at site b before we have asked the question of site a and received an answer.

The other important property of the CNOT gate Cab is its involvement of two distinct bits in a non-trivial way which distinguishes it from local operations. This non-locality is the analogue of the spatial derivative operator in conventional quantum field theory, which is the continuum version of a nearest neighbour interaction and without which there would be no spacetime dynamics as such. In computational terms, the CNOT gate allows the transmission of information over the register.

The CNOT gate is reversible, Cab being its own inverse. The transpose CNOT gate CTab is defined by

[formula]

which merely reverses the roles of acceptor and donor, but still operates forwards in time.

In our discussion of the bosonic oscillator, below, it turns out that the CNOT gate does not occur on its own in general but is used to build up more complex computational gates. A particularly important case is the transpose gate Tab, defined by

[formula]

The transpose gate has the effect of switching the logic values between two sites:

[formula]

It may be represented in the form

[formula]

Hence we may write

[formula]

which we shall use in our study of the quantized bosonic oscillator.

Quantization

Up to this point all quantities have involved only real numbers, which is a requirement in classical logic and classical physics in general. When we quantize, however, we normally introduce complex numbers into the formalism, such as in the expression [formula] for the commutator of the particle observables of momentum and position. Quantization of the classical register means regarding the classical bit states |1) and |0) as the basis vectors of a complex Hilbert space known as a quantum bit, or qubit. Arbitrary linear complex combinations of these basis vectors are now permitted. The price paid for this is that we immediately lose the interpretation of the components of qubits in terms of classical truth-values. On the other hand, we gain a contextual probabilistic interpretation. Unlike a classical state, a quantum state has physical meaning only within the context of the experiment chosen to test it.

Once we have quantized the theory, we can consider variants of result ([\ref=adg]), arising from the fact that now we can make arbitrary unitary transformations of the basis vectors. In particular, at a given site, consider a non-classical change in the standard qubit basis of the form

[formula]

where α and β are real phases. This change may be represented by the action of the unitary operator

[formula]

acting on the qubit. Under this transformation, any operator O acting on the qubit transforms according to the rule

[formula]

We find

[formula]

the other elementary qubit operators remaining unchanged. This transformation preserves the rules given in Table 1.

For a two qubit system, consider the combined transformation

[formula]

where the phases are changed independently. Then the CNOT gate Cab transforms according to the rule

[formula]

The transpose gate Tab transforms according to the rule

[formula]

where [formula]. This result will be used in our discussion of coherent states. We find

[formula]

which switches the information between the two sites in a non-classical way whenever θ not a multiple of 2π. For example, choosing θ  =  π / 2 we find the useful result

[formula]

which will be used in our discussion of the momentum operator for the quantized bosonic oscillator.

Quantum computation

In 1982, Feynman discussed the possibility of simulating physics in terms of quantum computation [\cite=FEYNMAN-82]. In 1995 [\cite=BARENCO-95], it was shown that any quantum computation could be built up from local unitary operations and CNOT gates alone. This suggests that it should be possible to realize Feynman's vision and reinterpret all quantum theories in terms of local unitary operations and CNOT gates.

We now show how we can rewrite the quantized bosonic oscillator in quantum computational terms, i.e., via local operations and CNOT gates. The first step is to discuss the bosonic quantum register, which forms the matrix in which we set the quantized oscillator.

The bosonic quantum register

Let R∞   be an infinite-rank classical bit register, i.e., R∞   is a collection of an infinite number of classical bits, each labelled by a distinct non-negative integer n∈[0,  ∞  ). We shall call this register a bosonic quantum register to indicate that it has infinite rank. Each bit has two possible states and therefore R∞   contains an infinite number of classical states, each of which is of the form

[formula]

For example,

[formula]

Clearly, each classical register state [formula] corresponds to a unique binary sequence [formula] consisting of an infinite string of ones and zeros. The connection with logic functions is as follows. Given a classical state in R∞  , we ask a classical logic question at each bit. If the answer for the nth bit is yes" then the corresponding sequence element sn∈S is one, otherwise it is a zero. For every state in this register, we have to ask an infinite number of questions to establish its corresponding sequence. A given sequence corresponds to a unique logic function over the register.

As a set, R∞   is non-denumerable, i.e., it is not possible to assign a unique integer to each of its states. This creates a potential problem when we come to quantization, because the Hilbert space H∞ corresponding to R∞   is an infinite tensor product and such Hilbert spaces are always non-separable [\cite=STREATER+WIGHTMAN:64] (i.e., have no countable basis). This is at odds with the fact that the quantized bosonic oscillator has a complete set of eigenstates of the Hamiltonian which is countable. Fortunately, for the harmonic oscillator, we can restrict our attention to a set of very special operators (called bosonic operators) over the quantum register, so that in physical applications, non-separability can be avoided [\cite=STREATER+WIGHTMAN:64] [\cite=KLAUDER+SUDARSHAN:68].

To understand how this comes about, we first classify each state in R∞   as one of three possible types. Two of these types form countable sets whilst the third type is non-denumerable. These types correspond, roughly speaking, to the integers, rationals, and irrationals respectively, which can be seen by the following heuristic arguments.

The first type, the set of all finite countable states in R∞  , consists of states associated with binary sequences which consist of zeros after some given finite element J, which depends on the sequence. For example, the state [formula] is finite countable (J = 4) whereas the state corresponding to the infinitely recurring sequence [formula] is not. For a finite countable state [formula] the computational map [formula] maps this state to the integer

[formula]

The second type, the recurring sequence states in R∞  , consists of those sequences which would be finite countable sequences but for the fact that the infinite string of zeros after J is replaced by some non-trivial recurring binary sequence. Recurring sequence states cannot be classified by finite integers using the computational map [formula]. However, we can use another map, defined by

[formula]

to map such states into the interval [formula]. We shall call this the continuum map. It is easy to see that in fact, all states in R∞   can be mapped into the interval [formula] via the continuum map. The void state [formula] maps into zero whilst the fully occupied state [formula] maps into 2. All other states necessarily map into the open interval [formula].

It is not hard to see that finite countable states and recurring sequence states map into the rationals via the continuum map, but not into a one-to one way. For example, the finite countable state [formula] maps into the number 1 by the continuum map, which is also the value mapped from the recurring sequence state [formula].

The problem with non-denumerability arises because of the existence of the third type of infinite binary sequence. This consists of all those binary sequences which are not recurring, such as [formula], an example based on the successive digits in the decimal representation of π. There are infinitely many such sequences and they cannot be counted, as they correspond to the irrationals, which is easy to prove.

Our conclusion is, therefore, that states in R∞   cannot be classified by the integers. Instead, we may use the sequence corresponding to each state as an index, viz, if S is the binary sequence [formula] then the corresponding state |S) is given uniquely by the expression

[formula]

Given two such register state |S), |T), their inner product (S|T) is defined in the obvious way, viz

[formula]

This takes value unity if and only if the sequences S and T are identical, otherwise it is zero.

Quantization amounts to taking the set of all such states as a basis [formula] for a non-separable Hilbert space H∞  . States in H∞   will be called quantum register states and are of the form

[formula]

where the summation is over all possible infinite binary sequences and the coefficients [formula] are complex. The Hilbert space inner product is defined in the obvious way, viz

[formula]

As discussed above, finite countable sequences can be mapped into the integers via the computational map [formula]. For a sequence S which maps into integer n, we can use the notation |n) rather than |S) to denote the corresponding quantum register state.

The quantized bosonic oscillator

The quantum register states we need to represent the quantized bosonic oscillator form a subset of the finite countable states. To identify this subset, we need to filter out of the set of all finite countable states those states which are redundant.

To do this, we first define the bosonic projection operators:

[formula]

where the superscripts label the different qubit operators discussed in Table 1 and the subscripts denote sites in the register. Each bosonic projection operator [formula] defines a one-dimensional Hilbert space with basis |2n). Eigenstates of these operators with eigenvalue + 1 will be called bosonic eigenstates.

Next, we define the bosonic identity operator

[formula]

This operator satisfies the idempotency condition required of any projection operator, viz,

[formula]

and plays the role of a bosonic filter", passing only those states and operators associated with the quantum register which have the desired properties associated with the harmonic oscillator.

Definition:  A quantum register operator [formula] is bosonic if and only if it commutes with the bosonic identity, i.e.,

[formula]

Definition: A bosonic state is defined to be any vector in the infinite rank quantum register H∞   which is an eigenstate of [formula] with eigenvalue + 1. All other states in H∞   will be referred to as transbosonic.

Examples of transbosonic states are the void state |0) and all those finite countable elements |n) of the basis [formula] where n is not some power of two. In fact, almost all elements in the quantum register are transbosonic. It can be readily verified that linear superpositions of bosonic states are always bosonic states, whilst linear superpositions of any transbosonic state with any other state in the register is always transbosonic.

The importance of the bosonic operators is that when they are applied to bosonic states, the result is always a bosonic state, which can be easily proved.

We now in a position to discuss how we map the standard quantum oscillator onto the quantum register.

For the quantum oscillator, the most important operators are the ladder operators a and a+. We can use them to discuss coherent (Glauber) states and the more traditional one-particle states. We shall focus on the latter now and deal with the former towards the end of this paper.

Given the generic form for the classical one-dimensional oscillator Hamiltonian

[formula]

where α,β are positive constants, we define the ladder operators in the usual way:

[formula]

where x̂,p̂ are the usual bosonic position and momentum operators satisfying the standard Weyl-Heisenberg algebra

[formula]

Then we find

[formula]

where [formula] [formula] has the physical dimensions of an energy and Î is the identity operator in the standard oscillator Hilbert space H.

Using standard arguments, it is easy to show that the ladder operators have the representations

[formula]

where the states [formula] are the usual orthonormal excited states of the ground state |0〉. These states are identified one-to-one with the bosonic states |2n) discussed above, viz

[formula]

To find a quantum register representation of the ladder operators, we first introduce some auxiliary notation. We define

[formula]

None of these operators is bosonic as can be readily proved. In fact, the operators [formula] can be used to generate bosonic states from the void state (which is transbosonic). Specifically, we have

[formula]

With these definitions we construct the operators

[formula]

Remarkably, these operators are bosonic, as can be readily proved from the fact that

[formula]

To simplify the notation, we shall henceforth leave out the implied tensor product symbols [formula]. Then we find

[formula]

where the symbols and superscripts on the right hand side refer to Table 1 and the subscripts label different qubits. These operators satisfy the relations

[formula]

Then the ladder operators take the quantum register representation

[formula]

These operators are bosonic and have the commutation relation

[formula]

Because these register ladder operators commute with the bosonic identity [formula] any states that they create from bosonic states are also bosonic. We find for example

[formula]

Note that aB annihilates the bosonic ground state |1), giving the zero vector 0 in the quantum register H∞  , not the void state |0).

The quantized bosonic Hamiltonian ([\ref=111]) has the quantum register representation

[formula]

It commutes with the bosonic identity [formula] and therefore, any states in the quantum register which start off bosonic at initial time remain bosonic, if they evolve under this Hamiltonian.

Quantum computation

It is not immediately apparent from the quantum register representation of the Hamiltonian in which way computational operations are involved in bosonic oscillator dynamics, particularly given that the number states |n〉 ↔  |2n) are eigenstates of the Hamiltonian and therefore have trivial time dependence. To see how bosonic dynamics involves quantum register computation, recall that the position and momentum operators in the standard theory are given by

[formula]

We represent them in the quantum register description by the operators

[formula]

These operators are bosonic, by virtue of the fact that the operators aB,a+B are bosonic. Then we find

[formula]

In the quantum register representation, these operators take the forms

[formula]

and

[formula]

where [formula] and [formula] are specific cases of the operator [formula].

We note now that the operators x̂B and p̂B are bosonic operators, i.e., they commute with the bosonic identity, [formula]. Moreover, these operators act only on bosonic states, i.e., eigenstates of [formula] with eigenvalue [formula]. Suppose we have such a bosonic state |Ψ). Then

[formula]

because the operators

[formula]

annihilate the bosonic identity. This can be seen from the properties of Table 1, which hold for every qubit in the quantum register. The same argument applies to the momentum operator and we find

[formula]

if |Ψ) is a bosonic state.  Because all physically relevant operators representing observables, such as the Hamiltonian [formula], can be constructed out the x̂B and p̂B, this establishes the basic result, which is that the bosonic oscillator can indeed be discussed in terms of quantum computation. The P0i operators are local unitary operators and the transpose operators [formula] are essentially CNOT gates. This agrees with the results of Barenco et al [\cite=BARENCO-95], where it was shown that any quantum computation could be built up from local unitary operations and CNOT gates alone.

Coherent states

In quantum optics, photon states occur frequently in certain types, depending on the preparation procedures. Three important types are single photon states, coherent states and thermalized states. Each of these have their individual experimentally observable properties which allow the experimentalist to determine their nature from observations of ensembles of such states. Coherent states are important in quantum optics because they are essentially the sort of states created by lasers. They are also important in particle physics.

A coherent state |z〉, [formula] is a linear superposition of single particle states with the property that

[formula]

With our conventions, we find

[formula]

Such states can also be represented by the action of the shift operator

[formula]

acting on the ground state |0〉 [\cite=KLAUDER+SUDARSHAN:68].

The quantum register version [formula] of this operator is given by

[formula]

acting on the bosonic state |20). If we writethen we find

[formula]

using [formula] Since this operator acts on |20), which is an eigenstate of the bosonic identity [formula], we may replace it by the expression

[formula]

which displays the quantum computational structure of coherent states.

Concluding remarks

The view explored by Feynman, Fredkin and others during the early nineteen eighties that the universe might be describable in computational terms is an attractive idea which gave rise to the current intense interest in quantum computers. What we have shown in this paper is that this idea certainly works for a system as useful as the bosonic oscillator, which finds many applications throughout physics. We expect that a similar, though inevitably more detailed, analysis should hold for all free particle quantum field theories, as these can be regarded as systems of coupled oscillators.

Our result immediately raises interesting questions about more complicated coupled systems, such as the anharmonic oscillator, and by implication, interacting quantum field theories. The quantum register approach rests on the properties of very particular operators, as given in Table 1, and these cannot be altered. Therefore, any new interactions can come about only because of novel non-local" interactions between register sites. Essentially, a quantum register imposes its own rules on the formalism. Work is in hand to understand how to use this approach for more complex systems.

Acknowledgements

J.Ridgway-Taylor thanks the EPSRC for a grant.