Proposition Lemma Definition Remark

Decorated proofs for computational effects: Exceptions

, Dominique Duval

, Laurent Fousse

, Jean-Claude Reynaud

.

Introduction

In this paper, as in the apparented papers [\cite=DD10-dialog] [\cite=DDR11-seqprod] [\cite=DDFR12b-state], we consider that a computational effect in a language corresponds to an apparent lack of soundness: the intended denotational semantics is not a model of the syntax, but it becomes so when the syntax is endowed with relevant decorations; more precisely, a proof system can be designed for dealing with these decorations, which is sound with respect to the intended denotational semantics. In [\cite=DDFR12b-state] this point of view has been applied to the side-effects due to the evolution of the states of the memory in an imperative or object-oriented language. In this paper, it is applied to the effects caused by exceptions. It happens that there is a duality between the denotational semantics of states and the core part of the semantics of exceptions [\cite=DDFR12a-short]. The encapsulation of the core part inside the mechanism of exceptions is a succession of case distinctions; the proof system is extended for dealing with it. Properties of exceptions can be proved using this inference system and the proofs can be simplified by re-using proofs on states, thanks to the duality.

To our knowledge, the first categorical treatment of computational effects is due to Moggi [\cite=Mo91]; this approach relies on monads, it is implemented in the programming language Haskell [\cite=Wa92] [\cite=haskell]. Although monads are not used in this paper, the basic ideas underlying our approach rely on Moggi's remarks about notions of computations and monads. The examples proposed by Moggi include the exceptions monad TA  =  A  +  E where E is the set of exceptions. Later on, using the correspondence between monads and algebraic theories, Plotkin and Power proposed to use Lawvere theories for dealing with the operations and equations related to computational effects [\cite=PP02] [\cite=HP07]; an operation is called algebraic when it satisfies some relevant genericity properties. The operation for raising exceptions is algebraic, while the operation for handling exceptions is not [\cite=PP03]. It follows that the handling of exceptions is quite difficult to formalize in this framework; several solutions are proposed in [\cite=SM04] [\cite=Le06] [\cite=PP09]. In this paper we rather use the categorical approach of diagrammatic logics, as introduced in [\cite=D03-diaspec] and developed in [\cite=DD10-dialog].

In Section [\ref=sec:exc] a denotational semantics for exceptions is defined, where we dissociate the core operations from their encapsulation. Then a decorated proof system and a decorated specification for exceptions are defined in Section [\ref=sec:deco] and it is checked that the denotational semantics for exceptions can be seen as a model of this specification. In Section [\ref=sec:proof] we use this framework for proving some properties of exceptions.

Denotational semantics for exceptions

In this Section we define a denotational semantics of exceptions which relies on the semantics of exceptions in various languages, for instance in Java [\cite=java] and ML [\cite=sml]. Syntax is introduced in Section [\ref=subsec:exc-syntax] and the distinction between ordinary and exceptional values is discussed in Section [\ref=subsec:exc-sem]. Denotational semantics of raising and handling exceptions are considered in Sections [\ref=subsec:exc-tag] and [\ref=subsec:exc-untag], respectively.

Signature for exceptions

The syntax for exceptions in computer languages depends on the language: the keywords for raising exceptions may be either raise or throw, and for handling exceptions they may be either handle or try-catch, for instance. In this paper we rather use throw and try-catch, but this choice does not matter. More precisely, the syntax of our language may be described in two parts: a pure part and an exceptional part. The pure part is a signature [formula], made of types and operations; the [formula]-expressions are called the pure expressions. The interpretation of the pure expressions should neither raise nor handle exceptions. We assume that the pure operations are either constants or unary. General n-ary operations would require the use of sequential products, as in [\cite=DDR11-seqprod]; in order to focus on the fundamental properties of exceptions they are not considered in this paper. The exceptional part is made of a symbol Ei for each index i in some set of indices I, which is declared as: [formula], where Pi is a pure type called the type of parameters for the exceptional type Ei (the Pi's need not be distinct). The exceptional types Ei provide familiar notations for the raising and handling operations and in Section [\ref=subsec:exc-tag] they are interpreted as sets, however we will not define any expression of type Ei.

Let us assume that the signature [formula] is fixed. The expressions of our language are defined recursively from the pure operations and from the raising and handling operations, as follows.

Given a set of indices I and a symbol Ei for each i∈I, the signature for exceptions [formula] is made of [formula] together with a raising operation for each i in I and each type Y in [formula]:

[formula]

and a handling operation for each [formula]-expression f:X  →  Y, each non-empty list of indices [formula] and each [formula]-expressions g1:Pi1  →  Y, , gn:Pin  →  Y:

[formula]

Ordinary values and exceptional values

The syntax for exceptions defined in Section [\ref=subsec:exc-syntax] is now interpreted in the category of sets. In order to express the denotational semantics of exceptions, a major point is that there are two kinds of values: the ordinary (or non-exceptional) values and the exceptions. It follows that the operations may be classified according to the way they may, or may not, interchange these two kinds of values: an ordinary value may be tagged for constructing an exception, and later on the tag may be cleared in order to recover the value. Then we say that the exception gets untagged. Let us introduce a set [formula] called the set of exceptions. For each set X we consider the disjoint union [formula] with the inclusions [formula] and [formula].

For each set X, an element of [formula] is an ordinary value if it is in [formula] and an exceptional value if it is in [formula]. A function [formula] is said to raise an exception if there is an element x∈X such that [formula]; propagate exceptions if [formula] for every [formula]; recover from an exception if there is some [formula] such that f(e)∈Y.

We will use the same notations for the syntax and for its interpretation. Each type X is interpreted as a set X. Each pure expression f0:X  →  Y is interpreted as a function f0:X  →  Y, which can be extended as [formula]. When f:X  →  Y is a [formula]-expression, which may involve some raising or handling operation, its interpretation is a function [formula] which is defined in the next Sections [\ref=subsec:exc-tag] and [\ref=subsec:exc-untag]. In addition, every function [formula] can be extended as [formula], which is defined by the equalities [formula] and [formula]. This is the unique extension of f to [formula] which propagates exceptions.

The interpretation of a [formula]-expression f:X  →  Y is a function which propagates exceptions; this function may raise exceptions but it cannot recover from an exception. In Section [\ref=subsec:exc-untag], in order to catch exceptions, we will introduce functions which recover from exceptions. However such a function cannot be the interpretation of any [formula]-expression. Indeed, a try-catch expression may recover from exceptions which are raised inside the try block, but if an exception is raised before the try-catch expression is evaluated, this exception is propagated. Recovering from an exception can only be done by functions which are not expressible in the language generated by [formula]: such functions are called the untagging functions, they are defined in Section [\ref=subsec:exc-untag]. Together with the tagging functions defined in Section [\ref=subsec:exc-tag] they are called the core functions for exceptions.

Tagging and raising exceptions: throw

Raising an exception is based on a tagging process, modelled as follows.

For each index i∈I there is an injective function [formula], called the exception constructor or the tagging function of index i, and the tagging functions for distinct indices have disjoint images. The image of ti in [formula] is denoted Ei.

Thus, the tagging function [formula] maps a non-exceptional value (or parameter) a∈Pi to an exception [formula]. This means that the non-exceptional value a in Pi gets tagged as an exception ti(a) in [formula]. The disjoint union of the Ei's is a subset of [formula]; for simplicity we assume that [formula]

For each index i∈I and each set Y, the throwing or raising function [formula] is the tagging function ti followed by the inclusion of [formula] in [formula]: [formula]

Untagging and handling exceptions: try-catch

Handling an exception is based on an untagging process for clearing the exception tags, which is modelled as follows.

For each index i∈I there is a function [formula], called the exception recovery or the untagging function of index i, which satisfies: [formula]

Thus, for each [formula] the untagging function ci(e) tests whether the given exception e is in Ei; if this is the case, then it returns the parameter a∈Pi such that e = ti(a), otherwise it propagates the exception e. Since it has been assumed that [formula], the untagging function ci(e) is uniquely determined by the above equalities.

For handling exceptions of type Ei raised by some function [formula], for i in a non-empty list [formula] of indices, one provides for each k in [formula] a function [formula] (which thus may itself raise exceptions). Then the handling process builds a function which encapsulates some untagging functions and which propagates exceptions. The indices [formula] form a list: they are given in this order and they need not be pairwise distinct. It is assumed that this list is non-empty, because it is the usual choice in programming languages, however it would be easy to drop this assumption.

For each function [formula], each non-empty list [formula] of indices in I and each family of functions [formula] (for [formula]), the handling function

[formula]

is defined as follows. Let [formula], for short. For each x∈X, [formula] is defined in the following way.

First f(x) is computed: let [formula].

If y is not an exception, then it is the required result: if y∈Y then [formula].

If y is an exception, then:

If the type of y is Ei for some index i in [formula], then y has to be caught according to the first occurrence of the index i in the list: for each [formula],

Check whether the exception y has type Eik: let [formula].

If the exception y has type Eik then it is caught: if z∈Pik then [formula].

If the type of y is Ei for some [formula], then y is propagated: otherwise [formula].

Equivalently, the definition of [formula] can be expressed as follows.

Let [formula], then [formula].

When n = 1 we get [formula]

The handling process involves several nested case distinctions. Since it propagates exceptions, there is a first case distinction for checking whether the argument x is an exception (which is simply propagated) or not. If x is not an exception, then there is a case distinction (1-2) for checking whether f(x) is an exception or not. If f(x) is an exception then each step (a-b) checks whether the result of the untagging function is an exception. All these case distinctions check whether some value is an exception or not, they rely on disjoint unions of the form [formula]. In contrast, for each step (a-b) there is another case distinction encapsulated in the computation of the untagging function, which checks whether the exception has the required exception type and relies on the disjoint union [formula].

Decorated logic for exceptions

In Section [\ref=sec:exc] we have introduced a signature [formula] and a denotational semantics for exceptions. However the soundness property is not satisfied: the denotational semantics is not a model of the signature, in the usual sense, since an expression f:X  →  Y is interpreted as a function [formula] instead of f:X  →  Y. Therefore, in this Section we build a decorated specification for exceptions, including a "decorated" signature and "decorated" equations, which is sound with respect to the denotational semantics of Section [\ref=sec:exc]. For this purpose, first we form an equational specification by extending the signature [formula] with operations ti and ci and equations involving them, in order to formalize the tagging and untagging functions of Sections [\ref=subsec:exc-tag] and [\ref=subsec:exc-untag]. Then we add decorations to this specification, and we define the interpretation of the expressions and equations according to their decorations. This means that we have to extend the equational logic with a notion of decoration; the decorations and the decorated inference rules are given in Section [\ref=subsec:deco-deco]. In Section [\ref=subsec:deco-exc] we define the decorated specification for exceptions and in Section [\ref=subsec:deco-model] we check that this decorated specification is sound with respect to the denotational semantics of Section [\ref=sec:exc]. In the decorated specification for exceptions, there are on one side private operations for tagging and untagging exceptions, which do not appear in the signature for exceptions [formula], and on the other side public operations for raising and handling exceptions, which are defined using the private operations. According to remark [\ref=rem:ppg], an important feature of exceptions is that all public operations propagate exceptions, such operations will be called propagators; operations for recovering from exceptions may appear only as private operations, which will be called catchers.

Decorations

In order to deal with exceptions we define three decorations for expressions. They are denoted by (0), (1) and (2) used as superscripts, and their meaning is described in an informal way as follows.

The interpretation of a pure expression [formula] may neither raise exceptions nor recover form exceptions.

The interpretation of a propagator [formula] may raise exceptions but it is not allowed to recover from exceptions; thus, it must propagate all exceptions.

The interpretation of a catcher [formula] may raise exceptions and recover form exceptions.

Every pure expression can be seen as a propagator and every propagator as a catcher. It follows that every expression can be seen as a catcher, so that the decoration (2) could be avoided; however we often use it for clarity.

In addition, we define two decorations for equations. They are denoted by two distinct relational symbols [formula] for strong equations and by ~   for weak equations. Using the fact that every expression can be seen as a catcher, their meaning can be described as follows.

A strong equation [formula] is interpreted as an equality of the functions f and g both on ordinary and on exceptional values.

A weak equation [formula] is interpreted as an equality of the functions f and g on ordinary values, but f and g may differ on exceptional values.

Clearly every strong equation [formula] gives rise to the weak equation f  ~  g. On the other hand, since propagators cannot modifiy the exceptional values, every weak equation between propagators can be seen as a strong equation, and a similar remark holds for pure expressions.

It follows from these descriptions that every catcher k gives rise to a propagator [formula] with a weak equation [formula]: this propagator [formula] has the same interpretation as k on the non-exceptional values and it is interpreted as the identity on the exceptional values.

In the short note [\cite=DDFR12a-short] it is checked that, from a denotational point of view, the functions for tagging and untagging exceptions are respectively dual, in the categorical sense, to the functions for looking up and updating states. It happens that this duality also holds from the decorated point of view. Thus, most of the decorated rules for exceptions are dual to the decorated rules for states [\cite=DDFR12b-state]. The decorated rules for exceptions are given here in three parts (Figures [\ref=fig:proof-rules-one], [\ref=fig:proof-rules-two] and [\ref=fig:proof-rules-three]). For readability, the decoration properties are often grouped with other properties: for instance, "[formula]" means "[formula] and [formula] and f  ~  g".

The rules in Figure [\ref=fig:proof-rules-one] may be called the rules for the decorated monadic equational logic for exceptions. The unique difference between these rules and the dual rules for states lies in the congruence rules for the weak equations: for states the replacement rule is restricted to pure g's, while for exceptions it is the substitution rule which is restricted to pure f's.

Several kinds of decorated coproducts are used for dealing with exceptions. The rules in Figure [\ref=fig:proof-rules-two] are the rules for a decorated initial type [formula], also called an empty type, and for a constitutive coproduct, as defined below. These rules are dual to the rules for the decorated final type and for the observational product for states in [\cite=DDFR12b-state].

A decorated initial type for exceptions is a type [formula] such that for every type X there is a pure expression [formula] such that every function from [formula] to X is weakly equivalent to [formula].

It follows that every pure expression and every propagator from [formula] to X is strongly equivalent to [formula].

A constitutive coproduct for exceptions is a family of propagators (qi:Xi  →  X)i such that for every family of propagators (fi:Xi  →  Y)i there is a catcher [formula], unique up to strong equations, such that [formula] for each i.

This definition means that a constitutive coproduct can be used for building a catcher from several propagators; this corresponds to the fact that the set [formula] is the disjoint union of the Ei's.

The next property corresponds to remark [\ref=rem:toppg].

For each catcher [formula] there is a propagator [formula], unique up to strong equations, such that [formula]

According to the previous rules, for each type X there are two pure expressions [formula] and [formula]. It is straightforward to check that they form a coproduct with respect to pure expressions and strong equations: for each [formula] and [formula] there is a pure expression [formula], unique up to strong equations, such that [formula] and [formula], indeed such a situation implies that [formula] and [formula]. This pure coproduct, with coprojections [formula] and [formula], is called the coproduct [formula]. In addition, we assume that it satisfies the following decorated coproduct property.

For each propagator [formula] and each catcher [formula] there is a catcher [formula], unique up to strong equations, such that [formula] and [formula]

The rules in Figure [\ref=fig:proof-rules-three] are the rules for the construction of [formula] and for the decorated coproduct [formula]. They will be used for building the handling operations from the untagging operations.

A decorated specification for exceptions

Let L denote the inference system provided by the decorated rules for exceptions (Figures [\ref=fig:proof-rules-one], [\ref=fig:proof-rules-two] and [\ref=fig:proof-rules-three]). As for other inference systems, we may define theories and specifications (or presentations of theories) with respect to L. They are called decorated specifications and decorated theories, respectively. This approach is based on the general framework for diagrammatic theories and specifications [\cite=D03-diaspec] [\cite=DD10-dialog], but no knowledge of this framework is assumed in this paper. A decorated theory is made of types, expressions, equations and coproducts which satisfy the decorated rules for exceptions. In this Section we define a decorated specification [formula], which may be used for generating a decorated theory by applying the decorated inference rules for exceptions.

Let [formula] be some fixed equational specification (as in Section [\ref=subsec:exc-syntax] for simplicity it is assumed that [formula] has no n-ary operation with n > 1). The decorated specification for exceptions [formula] is made of the equational specification [formula] where each operation is decorated as pure and each equation as strong (or weak, since both coincide here), a type [formula] called the empty type and for each i in some set I a type Pi (of parameters) in [formula], a propagator [formula], a catcher [formula] and the weak equations: [formula] and [formula].

For each i in I and each type Y in [formula] the raising propagator

[formula]

is defined as

[formula]

According to remark [\ref=rem:ppg], the handling operation [formula] is a propagator, not a catcher: indeed, it may recover from exceptions which are raised by f, but it must propagate exceptions which are raised before [formula] is called.

For each propagator [formula], each non-empty list of indices [formula] and each propagators [formula], the handling propagator

[formula]

is defined as follows.

It will be proved in Lemma [\ref=lem:coprod-cotu] that since [formula] we have [formula]. It follows that when n = 1 and 2 we get respectively:

Decorated models

Let Exc be a set and Pi (for i∈I) a family of sets with injections [formula], such that [formula] is the disjoint union of the images Ei = ti(Pi). Then we may define a decorated theory [formula] as follows. A type is a set, a pure expression [formula] is a function f:X  →  Y, a propagator [formula] is a function [formula] and a catcher [formula] is a function [formula]. For instance, each injection [formula] is a propagator [formula]. The conversion from pure expressions to propagators is the construction of [formula] from f0:X  →  Y and the conversion from propagators to catchers is the construction of [formula] from [formula]. Composition of two expressions can be defined by converting them to catchers and using the composition of functions [formula] and [formula] as [formula]. When restricted to propagators this is compatible with the Kleisli composition with respect to the monad [formula]. When restricted to pure expressions this is compatible with the composition of functions f0:X  →  Y and g0:Y  →  Z as [formula]. A strong equation [formula] is an equality ([formula]), and a weak equation f  ~  g:X  →  Y is an equality ([formula]); when restricted to propagators both notions coincide. The empty set [formula] is a decorated initial type and the family of propagators [formula] is a constitutive coproduct, because the family of functions [formula] is a coproduct in the category of sets.

The models of a decorated specification Σ with values in a decorated theory Θ are defined as kinds of morphisms from Σ to Θ in [\cite=DD10-dialog]: a model maps each feature (type, pure expression, propagator, catcher, decorated initial type, constitutive coproduct, ) of Σ to a feature of the same kind in Θ. When Θ is the theory [formula] we recover the meaning of decorations as given informally in Section [\ref=subsec:deco-deco]. When in addition Σ is the specification [formula] we get the following result.

The decorated specification for exceptions [formula] is sound with respect to the denotational semantics of Section [\ref=sec:exc], in the sense that by mapping every feature in [formula] to the feature with the same name in the decorated theory [formula] we get a model of [formula] with values in [formula].

For the tagging and untagging operations this is clear from the notations. Then for the raising operations the result is obvious. For the handling operations the result comes from a comparison of the steps (1-2) and (a-b) in Definitions [\ref=defi:deco-handle] and [\ref=defi:exc-handle], while step (A-B) in Definition [\ref=defi:deco-handle] corresponds to the propagation of exceptions by the handling functions, as in remark [\ref=rem:cases].

Proofs involving exceptions

As for proofs on states in [\cite=DDFR12b-state], we may consider two kinds of proofs on exceptions: the explicit proofs involve a type of exceptions, while the decorated proofs do not mention any type of exceptions but require the specification to be decorated, in the sense of Section [\ref=sec:deco]. In addition, there is a simple procedure for deriving an explicit proof from a decorated one. In this Section we give some decorated proofs for exceptions, using the inference rules of Section [\ref=subsec:deco-deco]. Since the properties of the core tagging and untagging operations are dual to the properties of the looking up and updating operations we may reuse the decorated proofs involving states from [\cite=DDFR12b-state]. Starting from any one of the seven equations for states in [\cite=PP02] we can dualize this equation and derive a property about raising and handling exceptions. This is done in this Section for two of these equations.

On states, the annihilation lookup-update property means that updating any location with the content of this location does not modify the state. A decorated proof of this property is given in [\cite=DDFR12b-state]. By duality we get the following annihilation untag-tag property, which means that tagging just after untagging, both with respect to the same exceptional type, returns the given exception.

For each i∈I: [formula]

Lemma [\ref=lem:ci-ti] is used in Proposition [\ref=prop:hi-ri] for proving the annihilation catch-raise property: catching an exception by re-raising it is like doing nothing. First, let us prove Lemma [\ref=lem:coprod-cotu], which has been used for getting Equation ([\ref=eq:handle-deco-one]).

For each propagator [formula] we have [formula].

Since [formula] is characterized up to strong equations by [formula] and [formula], we have to prove that g  ~  g and [formula]. The weak equation is due to the reflexivity of ~  . The unicity of [formula] up to weak equations implies that [formula], and since both members are propagators we get [formula].

For each propagator [formula] and each i∈I: [formula]

By Equation ([\ref=eq:handle-deco-one]) and Definition [\ref=defi:deco-raise] we have [formula]. By Lemma [\ref=lem:ci-ti] [formula], and the unicity property of [formula] implies that [formula]. Thus [formula]. Finally, since [formula] and f is a propagator we get [formula].

On states, the commutation update-update property means that updating two different locations can be done in any order. By duality we get the following commutation untag-untag property, which means that untagging with respect to two distinct exceptional types can be done in any order. A detailed decorated proof of the commutation update-update property is given in [\cite=DDFR12b-state]. The statement of this property and its proof use semi-pure products, which were introduced in [\cite=DDR11-seqprod] in order to provide a decorated alternative to the strength of a monad. Dually, the commutation untag-untag property use semi-pure coproducts, which generalize the decorated coproducts [formula] from Definition [\ref=defi:deco-exc-coprod-ctc]. The coproduct of two types A and B is defined as a type A + B with two pure coprojections [formula] and [formula], which satisfy the usual categorical coproduct property with respect to the pure morphisms. Then the semi-pure coproduct of a propagator [formula] and a catcher [formula] is a catcher [formula] which is characterized, up to strong equations, by the following decorated version of the coproduct property: [formula] and [formula]. Then as usual, the coproduct f' + k':A + B  →  C + D of a propagator f':A  →  C and a catcher k':B  →  D is the catcher [formula]. Whenever g is a propagator it can be proved that [formula]; thus, up to strong equation, we can assume that in this case [formula] is a propagator; it is characterized, up to strong equations, by [formula] and [formula].

For each i,j∈I with i  ≠  j:

[formula]

For each i,j ∈ I with i   ≠   j:

[formula]

According to Equation ([\ref=eq:handle-deco-two]): [formula] Thus, the result will follow from [formula]. It is easy to check that [formula], so that [formula] Similarly [formula] hence [formula] Then the result follows from Lemma [\ref=lem:cj-ci].