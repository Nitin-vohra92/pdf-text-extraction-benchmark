C-.13em o-.07em C-.13em o-.15em A

Quadratic Interval Refinement for Real Roots

Originally presented as a "Poster" at ISSAC 2006

Introduction

Typically the process of approximating the real roots of a univariate polynomial comprises two phases: root isolation where the distinct roots are separated into disjoint intervals, followed by root refinement where the approximations of the roots are improved until they are within specified limits. This paper is concerned with refinement, and assumes that isolation has already taken place (see for instance [\cite=RouillierZimmerman]).

There are many methods for root refinement. Newton's Iteration is a well-known example, and dates back over three hundred years. Bisection is another refinement method, slower than Newton's Iteration but more robust. This article presents a variant of Regula Falsi which combines the robustness of Bisection with the rapid convergence of Newton's Iteration. The algorithm is implemented as an integral part of (from version 4.3 onwards). We call the new algorithm Quadratic Interval Refinement, or simply QIR.

Prerequisites for using QIR are knowledge of an initial interval I for which the function has opposite signs at the two end points (both must be rational), and a procedure which evaluates f at a given rational point with arbitrary precision. Naturally, the function f must be continuous on I. It is best if the interval I contains a single simple root of f; furthermore, if f has a valid Taylor expansion about that single simple root then convergence of QIR will ultimately be quadratic. If I contains several roots then QIR will eventually discard all but one of them as refinement proceeds.

Notation

For a real number x we write [formula] to mean the integer closest to x; either candidate may be chosen in the case of a tie. We use the notation I(a,b) to denote the open interval [formula].

We abuse terminology harmlessly by taking isolating interval to mean an interval I(a,b) for which f(a) and f(b) have opposite sign -- we do not require that the interval contain just a single root of f.

By Newton's Iteration we refer to the root approximation method starting from some given x0 and generating successive iterates using the formula xn  =  xn - 1  -  f(xn - 1) / f'(xn - 1). This method is sometimes called Newton-Raphson Iteration.

By Bisection we refer to the interval refinement method where the interval I(a,b) is refined to either I(a,(a + b) / 2) or I((a + b) / 2,b), the choice depending on the sign of f((a + b) / 2). This method is also called Binary Chop.

By Regula Falsi we refer to the interval refinement method where linear interpolation is used to predict the position of the root, and then one end of the interval is moved to this predicted value so that the new interval still contains a sign change.

Motivation

Why invent a new method when Newton's Iteration works so well? QIR offers a simple unified approach which can refine any isolating interval with a rate of convergence and a computational cost comparable to that of Newton's Iteration. Thus QIR has several advantages over Newton's Iteration:

A significant difficulty with Newton's Iteration is obtaining a suitable starting value given an isolating interval: this is the essence of point (a). It may be necessary to use some other interval refinement method prior to using Newton's Iteration. Point (b) poses no problem when approximating roots of explicit polynomials since the derivative can readily be evaluated, but in other cases it may not be easy to obtain values of the derivative. Point (c) is relevant only when using arbitrary precision rational arithmetic. Point (d) is important when a guarantee of the accuracy obtained is desired. With some cunning one can alleviate weaknesses (c) and (d) of Newton's Iteration: e.g. replacing approximants by similar values having a simpler denominator of about the right size, and using the derivative to estimate the width of an interval containing the root.

Note that one should avoid naive use of Newton's Iteration with exact rational arithmetic because the sizes of the numerators and denominators of successive approximants can increase rapidly: typically the k-th approximant will have numerator (or denominator) containing O(dk) digits where d is the degree of the polynomial whose root is being sought.

Description of the Method

QIR works by repeatedly narrowing the isolating interval until the width is smaller than the prescribed limit. Each individual narrowing step receives an initial interval and a refinement factor [formula] by which it must reduce the interval width; it uses discretized linear interpolation to guess a narrower interval containing the root. If the guess was good, the interval is updated; if not, the interval is unchanged, and the narrowing step returns an indication of failure. The refinement factor is increased after every successful narrowing step.

A narrowing step conceptually divides its initial interval into N consecutive equal width sub-intervals. It then uses linear interpolation to locate the sub-interval in which it guesses the root to lie. The guess is tested by evaluation at the end points of the chosen sub-interval. If the guess was lucky then the initial interval is replaced by the chosen sub-interval; otherwise an indication of failure is returned. The case N = 4 is handled specially: the initial interval is always replaced by the correct sub-interval, but failure is indicated if linear interpolation led to a bad guess.

The refinement factor is varied according to the following rule:

after a successful narrowing step, N←N2

after a failed narrowing step, if N  >  4 then [formula]

This strategy is inspired by the knowledge that linear interpolation produces approximations whose errors decrease roughly quadratically when sufficiently close to a root of a well-behaved function.

Obviously, if one of the evaluation points happens to be the exact root ξ then this value is returned as an exact root. This is possible only if ξ is rational and with "suitable" denominator.

An Illustrative Example

We present here an example where QIR appears to achieve quadratic convergence immediately (but only due to "good fortune"), then later it is forced to reduce the refinement factor back to 4 for a few iterations before true quadratic convergence can begin. Note how few evaluations are needed to attain quite high accuracy.

The Algorithm

Here we present explicitly the algorithm using a pseudo-language. The actual source code is contained in the package RealRoots.cpkg and is publicly available as part of the standard distribution of (from version 4.3 onwards) -- see the web site [\cite=cocoaweb].

Main routine: RefineInterval

(3) Return the interval I.

Auxiliary procedure: RefineIntervalByFactor when N  >  4

(6) Otherwise f(x̂) has the same sign as f(xhi), so check the interval to the left:

Auxiliary procedure: RefineIntervalByFactor when N = 4

We give a verbal description rather than pseudo-code for RefineIntervalByFactor with N = 4. Use linear interpolation to predict which of the 5 sub-interval end points is closest to the root. Refine the input interval using Bisection twice. If one of the end points of the refined interval agrees with our prediction, return success, otherwise return failure. Note that the initial interval is always narrowed by a factor of 4.

Termination of the Algorithm

We show that the algorithm always terminates. In RefineInterval if N = 4 then the interval is always narrowed; if N > 4 then either the interval is narrowed (by more than a factor of 4), or N is reduced. Since RefineInterval terminates when the interval has width less than ε, and since each narrowing reduces the width by at least a factor of 4, there can be only a finite number of narrowings. If no narrowing occurs (i.e. N > 4 and failure was reported) then N is reduced, but N is never smaller than 4, so there can be only finitely many iterations in which the interval is not narrowed.

Quadratic Convergence

The mathematical justification underlying the convergence rate of QIR is very similar to that underlying Newton's Iteration. We assume that the isolating interval I contains a single simple root ξ and that the function f admits a Taylor expansion centred on ξ valid in an open neighbourhood: i.e. for sufficiently small δ we have

[formula]

for some exponent k  ≥  2 and suitable constants C1 and C2; moreover C1  ≠  0 since ξ is a simple root.

Let xlo and xhi be the two end points of the interval I and ε be its width. When ε is small enough we have:

[formula]

Estimating ξ by linear interpolation gives   =  xlo  +  λ  ·  (xhi  -  xlo) where λ  =  f(xlo) / (f(xlo) - f(xhi)). Observe that f(xlo) - f(xhi)  =  C1ε  +  C2η + O(εk + 1) where |η|  =  |(xlo  -  ξ)k  -  (xhi  -  ξ)k|  ≤  εk. Substituting and simplifying gives [formula]. Regarding cubic and higher order terms in ε as negligible, this tells us that |  -  ξ|  <  ε2  ·  2C2 / C1.

Now we show that convergence of QIR is eventually quadratic. We say that the isolating interval I of width ε is narrow enough for f whenever ε  ·  C2 / C1  <  1 / 8. Observe that, starting from any isolating interval, this condition will be satisfied after only finitely many iterations. Henceforth we shall assume I is narrow enough.

When applying the algorithm RefineIntervalByFactor to the parameters (f,I,N) we shall say that N is small enough for I if N  ·  ε  ·  C2 / C1  <  1 / 2. Note that N = 4 is always small enough because we have assumed that I is narrow enough.

Suppose that algorithm RefineIntervalByFactor is called on (f,I,N) where N is small enough for I. The condition ε  ·  C2 / C1  <  1 / 8 implies that linear interpolation produces an estimate [formula] whose distance from ξ does not exceed ε2  ·  2C2 / C1  <  ε / N. Hence step (2) of RefineIntervalByFactor makes a good prediction, and so success will be returned. Denote the narrowed interval by I'. Now, the next iteration of RefineInterval will call RefineIntervalByFactor on the parameters (f,I',N2). Since I' is narrower than I it is surely narrow enough for f. Moreover, one may easily verify that N2 is small enough for I'. Hence, by induction, all subsequent calls to RefineIntervalByFactor will return success, and convergence is therefore quadratic.

In contrast, while still assuming that I is narrow enough for f, if RefineIntervalByFactor is called when N is not small enough for I then failure may occur. Since N is not small enough, we must have N > 4. So when failure occurs the refinement factor N is reduced. Hence, there can be only finitely many failures before N becomes small enough for I, and then guaranteed quadratic convergence ensues.

Weaknesses

A weakness of QIR as described here is the cost of evaluating f exactly at various rational points. For instance, if f is a high degree polynomial and the evaluation point x is a rational with large denominator then f(x) is likely to have an enormous denominator: more or less the n-th power of the denominator of x where n is the degree of f.

An interesting solution would be to use high precision floating point arithmetic. If variable precision floating point numbers are available then it would be sufficient to evaluate f approximately to obtain values with at least m + 2 bits of precision where m =  log 2(N) the logarithm of the refinement factor. If the relative errors in f(xlo) and f(xhi) are at most 2- m - 2 then step (2) in RefineIntervalByFactor will compute the index κ differing by at most 1 from the value one would have obtained using exact rational arithmetic.

As presented here QIR may calculate an interval much narrower than the specified limit. This is a (minor) defect because it means the last two evaluations of f will be at rational numbers with needlessly large denominators (with up to twice as many digits as truly required), and thus costing more than is strictly necessary. In practice one can simply reduce the value of the refinement factor N in the final iteration of |RefineInterval| to avoid the overshoot.

Experimental Results

We present here a small selection of experimental results. The computer used was a Macintosh G5 (running MacOS X 10.4) with 2GHz processors, and 3.5G bytes of RAM. The software used was  4.6 which relies upon the excellent library GMP (version 4.2, see [\cite=GMPweb]) for arbitrary precision arithmetic. All timings are measured in seconds.

The real root isolation code in is a simplistic implementation of the method described in [\cite=RouillierZimmerman], which is based on Descartes's Rule of Signs. Their implementation appears to be faster than ours in .

We describe briefly the polynomials used for the timing tests. The first two polynomials are adapted from the FRISCO test suite (see [\cite=friscoweb1] and [\cite=friscoweb2]) since cannot represent complex numbers. Both polynomials are designed to be challenging for a root isolator, and indeed the real root isolator implemented in fails with "Recursion too deep". However I(0,1) is a valid isolating interval for both polynomials, and it was used as input to QIR. The first polynomial is f1  =  ((c2x2 - 3)4 + c4x18)(c2x2 - 3) for c = 10100; there are four complex roots quite close to the real positive root, and this delays the onset of quadratic convergence. The second polynomial is f2  =  x50 + (1050x - 1)3 and has two complex roots very close to the real positive root again delaying the onset of quadratic convergence: note how quickly 10000 digits are obtained compared to the time needed for 1000 digits.

The third and fourth polynomials have a similar structure; all their roots are real by construction. f3 has degree 32 and is the minimal polynomial of [formula], while f4 has degree 128 and is the minimal polynomial of [formula]. These polynomials are interesting because they both have a root which is "almost integer": f3 has a root close to 45, and f4 has a root close to 10.

In the table below, the column headed "#roots" indicates how many intervals were refined, the column headed "isolate" is the time taken by the root isolator, and the other columns give the times taken to refine all the intervals found by the isolator to a width not greater than ε.

The GMP library offers functions for computing the integer part of roots of big integers (viz. |mpzqrt| and |mpzoot|); these functions use Newton's Iteration specialized to the computation of k-th roots. We compared QIR with these functions in the following way. To compute d digits of [formula] using |mpzqrt| we passed as argument the value 5  ×  102d. Similarly to compute d digits of [formula] and [formula] we called |mpzoot| with arguments 3  ×  103d and 2  ×  105d respectively. The timings for QIR are for refining the root interval to a width not exceeding 10- d -- the initial isolating interval was

[formula]

Conclusions

QIR is a simple algorithm combining the speed of Newton's Iteration with the robustness of Bisection. It is easy to implement, and the implementation supplied with demonstrates its genuine competitiveness with Newton's Iteration (except perhaps for computing square roots).