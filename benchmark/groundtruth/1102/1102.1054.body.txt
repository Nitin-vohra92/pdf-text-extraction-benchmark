=0pt

Corollary Definition Lemma Proposition Convention Example Remark Fact Exercise

A new face of the branching recurrence of computability logic

MSC: primary: 03B47; secondary: 03B70; 68Q10.

Keywords: Computability logic; Interactive computation; Game semantics; Resource semantics.

Introduction

Computability logic (CoL) is a long-term project for redeveloping logic on the basis of a constructive game semantics. The approach induces a rich collection of logical operators, standing for various natural operations on games. Among the most important of those is the branching recurrence operator [formula], in its logical behavior reminiscent of Girard's [\cite=Gir87] storage operator ! and (especially) Blass's [\cite=Bla92] repetition operator R, yet different from either: for instance, the principle P  →  P  ([formula] means [formula]) is valid in CoL while linear of affine logics do not prove it with , understood as !,?, and →   as linear implication; and the principle [formula] is not valid in CoL (nor provable in affine logic) while its counterpart is validated by Blass's semantics.

Recent years ([\cite=Japtocl1]-[\cite=Japseq], [\cite=Japtowards]-[\cite=Ver] and more) have seen rapid and sustained progress in constructing sound and complete axiomatizations for various, often quite expressive, fragments of CoL, at both the propositional and the first-order levels. Those fragments, however, have typically been recurrence-free, and finding syntactic descriptions (such as axiomatizations) of the logic induced by [formula] remains among the greatest challenges in the CoL enterprise. Among the reasons why the progress towards overcoming this challenge has been so slow is the degree of technical involvement of the existing, "canonical" definition of [formula] as given in [\cite=Jap03] [\cite=Japfin]. It has become increasingly evident that replacing that definition by a substantially less intricate counterpart would be necessary in order to make a breakthrough in syntactically taming [formula]. This is exactly what the present paper is devoted to. It introduces a technically new, very simple and compact, definition of [formula] and proves that the new version of [formula] is logically equivalent to the old one. This means that, from now on, studies of the fragments of CoL involving [formula] can safely focus on the new version of this operator without losing any already known results concerning [formula] and without any need to reintroduce or revisit the philosophical, mathematical or computational motivations and intuitions associated with [formula] and elaborated in detail in the earlier literature on CoL.

We call the old version of [formula] and its dual [formula] tight, and call the new versions of these operations loose. Due to equivalence, the purely technical difference between the two versions does nor warrant introducing new symbols for the new operations. However, since this paper has to simultaneously deal with both versions, in order to avoid confusion, we shall use the symbols [formula] for the tight versions of ,, and the symbols [formula] for the loose versions.

The intended audience for this relatively short (by the standards of CoL) and technical paper is expected to be familiar with the main concepts of CoL, such as those of static games, easy-play machines (EPM), the basic game operations, validity, and the related notions. If not, it would be both necessary and sufficient to read the first ten sections of [\cite=Japfin] for a self-contained, tutorial-style introduction. Having [\cite=Japfin] at hand would probably be necessary in any case, because we rely on the notation and terminology of [\cite=Japfin] without reintroducing them, so any unfamiliar symbols or terms should be looked up in [\cite=Japfin], which has a convenient glossary for that. The definition of [formula] given in [\cite=Japfin] is longer than necessary for our purposes and, for that reason, the present paper reintroduces [formula] through a shorter definition. No other old operations or concepts will be reintroduced and, again, they are to be understood as defined or explained in [\cite=Japfin].

The two versions of branching recurrence

Remember that, in semiformal terms, a play of [formula] starts as an ordinary play of game A. At any time, however, player [formula] (the environment) is allowed to make a "replicative move", which creates two copies of the current position Φ of A. From that point on, the game turns into two games played in parallel, each continuing from position Φ. We use the bits 0 and 1 to denote those two threads, which have a common past (position Φ) but possibly diverging futures. Again, at any time, [formula] can further branch either thread, creating two copies of the current position of that thread. If thread 0 was branched, the resulting two threads will be denoted by 00 and 01; and if the branched thread was 1, then the resulting threads will be denoted by 10 and 11. And so on: at any time, [formula] may split any of the existing threads w into two threads w0 and w1. Each thread in the eventual run of the game will be thus denoted by a (possibly infinite) bitstring. The game is considered won by [formula] (the machine) if it wins A in each of the threads; otherwise the winner is [formula].

In formal terms, consider a constant game A. There are two types of legal moves in (legal) positions of [formula]: replicative and non-replicative. To define these, we agree that, where Φ is a position, by an node of the underlying BT-structure of [formula] we mean a bitstring w such that w is either empty, or else is u0 or u1 for some bitstring u such that Φ contains the move [formula]. Such a node is said to be a leaf iff it is not a proper prefix of any other node of the underlying BT-structure of [formula]. A replicative move can only be made by (is only legal for) [formula], and such a move in a given position Φ should be [formula], where w is a leaf of the underlying BT-structure of [formula]. As for non-replicative moves, they can be made by either player. Such a move by a player [formula] in a given position Φ should be w.α, where w is a node of the underlying BT-structure of [formula] and α is a move such that, for any infinite extension v of w, α is a legal move by [formula] in the position [formula] of A. Here and later, for a run Θ and a bitstring x, [formula] means the result of deleting from Θ all moves except those that look like u.β for some initial segment u of x, and then further deleting the prefix "u." from such moves. A legal run Γ of [formula] is considered won by [formula] iff, for every infinite bitstring v, [formula] is a [formula]-won run of A. This completes our definition of [formula]. The dual operation [formula] is defined in a symmetric way, by interchanging [formula] with [formula]. That is, [formula].

This was a brutally quick review, of course. See [\cite=Japfin] for more explanations and illustrations.

Anyway, now it is time to define [formula]. A run Γ is stipulated to be a legal run of [formula] iff every move of Γ has the prefix "w." for some finite bitstring w and, for any infinite bitstring v, [formula] is a legal run of A (here [formula] means the same as before). Next, such a Γ is considered to be a [formula]-won run of [formula] iff, for every infinite bitstring v, [formula] is a [formula]-won run of A. As always, the dual operation [formula] is defined in a symmetric way by interchanging [formula] with [formula], or by stipulating that [formula].

Intuitively, [formula] can be seen as parallel play of a continuum of threads/copies of A. Each thread is denoted by an infinite bitstring and vice versa: every infinite bitstring denotes a thread. The meaning of a move w.α, where w is a finite bitstring, is making the move α simultaneously in all threads of the form wy. Correspondingly, when Γ is a legal run of [formula] and x is an infinite bitstring, [formula] represents the run of A that took place in thread x. And, in order to win the overall game [formula], [formula] needs to win A in all threads. As we saw earlier, a similar characterization applies to [formula] as well. However, the difference -- again at the intuitive level -- is that, while in the tight version of the game the threads are generated/built/grown step-by-step through replicative moves (and ordinary moves of A are only allowed to be made in existing threads), in the loose version all of the uncountably many threads are "already there" from the very beginning (which explains the absence of replicative moves), so that moves of A can be made in any of them at any time.

The preservation of the static property

Whenever a new game operation is introduced in CoL, one needs to make sure that it preserves the static property of games, for otherwise many things can go wrong.

The class of static games is closed under [formula] and [formula].

The rest of this section is devoted to a proof of the above theorem. Considering only [formula] is sufficient, because [formula] is expressible in terms of [formula] and [formula], with [formula] already known (Theorem 14.1 of [\cite=Jap03]) to preserve the static property of games.

Assume A is a constant static game, Ω is a [formula]-delay of Γ, and Ω is a [formula]-illegal run of [formula]. Then Γ is also a [formula]-illegal run of [formula].

We will prove this lemma by induction on the length of the shortest illegal initial segment of Ω. Assume the conditions of the lemma. We want to show that Γ is a [formula]-illegal run of [formula]. Let [formula] be the shortest ([formula]-) illegal initial segment of Ω. Let [formula] be the shortest initial segment of Γ containing all [formula]-labeled moves of [formula]. If Φ is a [formula]-illegal position of [formula] then so is Γ and we are done. Therefore, for the rest of the proof, assume that

[formula]

Let Θ be the sequence of those [formula]-labeled moves of Ψ that are not in Φ. Obviously

[formula]

We also claim that

[formula]

Indeed, suppose this was not the case. Then, by ([\ref=654]), Φ should be [formula]-illegal. This would make Γ a [formula]-illegal run of [formula] with Φ as an illegal initial segment which is shorter than [formula]. Then, by the induction hypothesis, any run for which Γ is a [formula]-delay, would be [formula]-illegal. But, as observed in Lemma 4.6 of [\cite=Jap03], the fact that Ω is a [formula]-delay of Γ implies that Γ is a [formula]-delay of Ω. So, Ω would be [formula]-illegal, which is a contradiction because, according to our assumptions, Ω is [formula]-illegal.

We are continuing our proof. There are two possible reasons to why [formula] is an illegal (while Ψ being legal) position of [formula]:

Reason 1: α does not have the form w.β for some bitstring w and move β. Then, in view of ([\ref=e142]), [formula] is a [formula]-illegal position of [formula]. As [formula] happens to be an initial segment of Γ, the latter then is a [formula]-illegal run of [formula], as desired.

Reason 2: α = w.β for some bitstring w and move β but, for some infinite extension v of w, [formula] is an illegal -- and hence [formula]-illegal -- position of A. Clearly ([\ref=e141]) implies that [formula] is a [formula]-delay of [formula]. Therefore, since A is static, by Lemma 4.7 of [\cite=Jap03], [formula] is a [formula]-illegal position of A. But [formula]. A [formula]-illegal position will remain illegal after removing a block of [formula]-labeled moves (in particular, [formula]) at the end of it. Hence [formula], which is the same as [formula], is an illegal position of A. Consequently, [formula] is an illegal position of [formula]. This, in view of ([\ref=e142]), implies that [formula] is in fact a [formula]-illegal run of [formula]. But then, as desired, so is Γ, because [formula] is an initial segment of it.

Assume A is a static constant game, Γ is a [formula]-won run of [formula], and Ω is a [formula]-delay of Γ. Our goal is to show that Ω is also a [formula]-won run of [formula] (this is exactly what [formula]'s being static means).

If Ω is a [formula]-illegal run of [formula], then it is won by [formula] and we are done. So, assume that Ω is not [formula]-illegal. According to the earlier mentioned Lemma 4.6 of [\cite=Jap03], if Ω is a [formula]-delay of Γ, then Γ is a [formula]-delay of Ω. So, by Lemma [\ref=l14], our Γ cannot be [formula]-illegal, for otherwise so would be Ω. Γ also cannot be [formula]-illegal, because otherwise it would not be won by [formula]. Consequently, Ω cannot be [formula]-illegal either, for otherwise, by Lemma [\ref=l14], Γ would be [formula]-illegal. Thus, we have narrowed down our considerations to the case when both Γ and Ω are legal runs of [formula].

The fact that Γ is a legal, [formula]-won run of [formula] implies that, for every (if [formula]) or some (if [formula]) infinite bitstring v, [formula] is a [formula]-won run of A, and therefore (as A is static and [formula] is obviously a [formula]-delay of [formula]) [formula] is a [formula]-won run of A. Since Ω is a legal run of [formula], the above, in turn, means nothing but that Ω is a [formula]-won run of [formula]. This completes our proof of Theorem [\ref=jan31].

The equivalence between the two versions

The formulas  [formula]   and  [formula]  are uniformly valid.

Uniform validity of [formula] means nothing but existence of an EPM E1 such that, for any static game A, E1 wins [formula], i.e. [formula]. We define such an EPM/strategy/algorithm E1 as one that repeats the following routine over and over again (infinitely many times unless one of the iterations never terminates). At any step of the work of the algorithm, Ψ stands for Φ1., where Φ is the then-current position of the play. That is, Ψ is the then-current position within the [formula] component.

ROUTINE: Keep granting permission until the adversary makes a move β that satisfies the conditions of one of the following two cases, and then act according to the corresponding prescription.

Case 1: β is a move w.α in [formula]. Make the same move w.α in [formula].

Case 2: β is a move w.α in [formula]. Make a series of replicative moves (if necessary) in [formula] so that w becomes a node of the underlying BT-structure of [formula]. Then make the move w.α in [formula].

Consider any run Ω that could be generated when E1 (in the role of [formula]) plays as described. It is obvious that E1 does not make illegal moves unless its adversary does so first. So, if Ω is an illegal run of [formula], it is [formula]-illegal and hence [formula]-won. Now assume Ω is a legal run of [formula]. Let Σ  =  Ω1. and Π  =  Ω2.. That is, Σ is the run that took place in [formula], and Π is the run that took place in [formula]. If, for every infinite bitstring v, [formula] is a [formula]-won run of A, then [formula] is the winner in the overall game because it is the winner in its [formula] component. Suppose now v is an infinite bitstring such that [formula] is a [formula]-won run of A. With a moment's thought, one can see that [formula]. So, [formula] is a [formula]-won run of [formula]. This makes Σ a [formula]-won run of [formula], and hence Ω a [formula]-won run of [formula], as desired.

To prove the uniform validity of [formula], we construct an EPM E2 that wins [formula] for any static game A. The work of E2 consists in repeating the following routine over and over again. At any step of the work of the algorithm, Ψ stands for Φ2., where Φ is the then-current position of the play. That is, Ψ is the then-current position within the [formula] component. Also, E2 maintains a record f for a mapping from the leaves v of the underlying BT-structure of [formula] to finite bitstrings f(v), such that (as can be easily seen from an analysis of the work of E2)

[formula]

At the beginning, the only leaf is ε (the empty bitstring), and the value of f(ε) is set to ε.

ROUTINE: Keep granting permission until the adversary makes a move β that satisfies the conditions of one of the following three cases, and then act according to the corresponding prescription.

Case 1: β is a replicative move [formula] in [formula]. Let v = f(w). Then update f by setting f(w0) = v0, f(w1) = v1 and without changing the value of f on any other (old) leaves of the underlying BT-structure of [formula]; do not make any moves.

Case 2: β is a non-replicative move w.α in [formula]. Let [formula] be all leaves u of the underlying BT-structure of [formula] such that w is a prefix of u. And let [formula]. Then make the moves [formula] in [formula]; leave the value of f unchanged.

Case 3: β is a move w.α in [formula]. First assume there is a (unique due to ([\ref=feb4])) leaf x in the underlying BT-structure of [formula] such that w is a proper extension of f(x). Then update f by letting f(x) = w and without changing the value of f on any other leaves; make the move x.α in [formula]. Now suppose there is no leaf x in the underlying BT-structure of [formula] such that w is a proper extension of f(x). Let [formula] be all leaves y of the underlying BT-structure of [formula] such that w is a prefix of f(y) (note: the set of such leaves well may be empty, i.e., n may be 0). Then make the moves [formula] in [formula]; leave the value of f unchanged.

Consider any run Ω that could be generated when E2 plays as described. As in the previous case, we may assume that Ω is legal, for otherwise it can be easily seen to be [formula]-illegal and hence [formula]-won. Let Σ  =  Ω1. and Π  =  Ω2.. That is, Σ is the run that took place in [formula], and Π is the run that took place in [formula]. Further, for a number i such that ROUTINE (in the scenario that generated Ω) is iterated at least i times, we let fi denote the value of the record f at the beginning of the i'th iteration, and Ψi denote the position reached by that time in the [formula] component.

Consider any infinite bitstring v and assume that [formula] is a [formula]-won run of A (if there is no such v, then obviously [formula] is the winner in the overall game). Let z be an infinite bitstring satisfying the following condition:

For any i such that ROUTINE is iterated at least i times, where vi is the (unique) prefix of v such that vi is a leaf of the underlying BT-structure of [formula], we have that fi(vi) is a prefix of z.

With some analysis, details of which are left to the reader, one can see that such a z exists, and that [formula]. So, [formula] is a [formula]-won run of [formula]. This makes Σ a [formula]-won run of [formula], and hence Ω a [formula]-won run of [formula], as desired.

The present theorem can be applied to various particular ,-containing fragments of the (otherwise open-ended) language of CoL to show that the two -- tight and loose -- understandings of , yield the the same classes of valid or uniformly valid formulas. This would be done through a rather straightforward induction relying on the fact that the operators of the language respect equivalence in the sense of Theorem [\ref=main], and that modus ponens preserves validity and uniform validity. But, of course, Theorem [\ref=main] establishes equivalence between the two versions of , in a much stronger sense than just in the sense of validating the same principles.