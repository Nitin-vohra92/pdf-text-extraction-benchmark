Proposition Corollary Theorem Definition FactRemark Example Claim Proposition Corollary Observation

cm cm cm cm in

Parallel addition in non-standard numeration systems

Introduction

A positional numeration system is given by a base and by a set of digits. The base β is a real or complex number such that |β| > 1, and the digit set A is a finite alphabet of real or complex digits. The most studied numeration systems are of course the usual ones, where the base is a positive integer. But there have been also numerous studies where the base is an irrational real number (the so-called β-expansions), a complex number, or a non-integer rational number, etc. Some surveys can be found in [\cite=Lothaire] and [\cite=cant].

In this work, the base β is an algebraic number, that is to say, the root of a polynomial with integer coefficients, and the digits of A are consecutive integers. We consider only finite β-representations, see Section [\ref=prem] for definitions. Let us denote

[formula]

In general, the set FinA(β) is not closed under addition. In this paper, we will prove that when β is a root of a polynomial with a dominant coefficient, the alphabet A can be chosen in such a way that FinA(β) is a ring, and, moreover, addition can be performed by a parallel algorithm with time complexity O(1).

Addition of two numbers in the classical b-ary numeration system, where b is an integer [formula], has linear time complexity. In order to save time, several solutions have been proposed. A popular one is the Avizienis signed-digit representation [\cite=Avizienis], which consists of changing the digit set. Instead of taking digits from the canonical alphabet [formula], they are taken from a symmetric alphabet of the form [formula], a being an integer such that [formula] (b has to be [formula]). Such a numeration system is redundant, that is to say, some numbers may have several representations. This property allows one to perform addition in constant time in parallel, because there is a limited carry propagation. A similar algorithm for base 2 has been devised by Chow and Robertson [\cite=ChowRobertson], using alphabet { - 1,0,1}. Here addition is realized in parallel with a window of size 3. Notice that Cauchy [\cite=Cauchy] already considered the redundant representation in base 10 and alphabet [formula].

In symbolic dynamics, such functions computable in parallel are called local, more precisely p-local, which means that to determine the image of a word by a p-local function, it is enough to consider a sliding window of length p of the input. It is a general result that a p-local function is computable by an on-line finite automaton with delay p - 1, see [\cite=Frougny2] for instance.

Amongst the non-standard bases, special attention has been paid to the complex ones, which allow to represent any complex number by a single sequence (finite or infinite) of natural digits, without separating the real and the imaginary part. For instance, it is known that every complex number can be expressed with base - 1 + i and digit set {0,1}, [\cite=Penney].

Parallel algorithms for addition in bases - 2, [formula], 2i and - 1 + i have been given in [\cite=NM]. Results on addition in bases - b, [formula] and - 1 + i in connection with automata theory have been presented in [\cite=Frougny2]. In particular, if b is an integer, [formula], and [formula] with [formula], addition in base [formula] is computable in parallel and is a (q + 1)-local function. If [formula] is even, set a = |b| / 2; then addition in base [formula] on A is a (2q + 1)-local function.

The paper is organized as follows: First we suppose that the base β is a root of a polynomial with integer coefficients such that one of them is greater than twice the sum of the moduli of the other ones. We then say that β satisfies the strong representation of zero property (or, for short, that β is SRZ). We give a parallel algorithm, Algorithm I, for addition in that case, Theorem [\ref=AI]. When β is an integer [formula], it is the same algorithm as the one of Avizienis.

Section [\ref=reduc] is devoted to reduction of the working alphabet. We now suppose that β is a root of a polynomial such that one coefficient is greater than the sum of the moduli of the other ones. We then say that β satisfies the weak representation of zero property (or, for short, that β is WRZ). We give a parallel algorithm, Algorithm II, where the alphabet is reduced compared to Algorithm I, but there is a fixed number of iterations depending (only) on the weak polynomial satisfied by β, to be compared with Algorithm I which always has just one iteration.

We then show that in fact all algebraic numbers with no conjugate of modulus 1 are SRZ (or WRZ), and we give a constructive method to obtain the suitable polynomial (strong or weak representation of zero) from the minimal polynomial of β, Proposition [\ref=dominant].

In the end, we concentrate on the case where β is the Golden Mean. Algorithm II works with alphabet [formula], which is big compared to the minimally redundant alphabet. Using ideas similar to the Chow and Robertson algorithm, we obtain a parallel algorithm on { - 1,0,1}, Algorithm III. This algorithm can be applied to the Fibonacci numeration system as well.

Preliminaries

A finite word on the alphabet A is a concatenation of a finite number of letters of A. The set of words on A is the free monoid A*. The set of bi-infinite words on A is denoted [formula].

A finite β- representation of x with digits in A is a finite sequence [formula], with xi in A, such that [formula]. It is denoted by the word

[formula]

with the most significant digit at the left hand-side, as in the decimal numeration system.

The notion of a function computable in parallel comes from computer arithmetic (see [\cite=Kornerup]), where it is defined on finite words, but we give here a definition on bi-infinite words. A function [formula] is said to be computable in parallel if there exist two non-negative integers r and t, a positive integer k, and a function Φ from Ap to Bk, with p = r + t + k, such that if [formula] and [formula], then v = φ(u) if, and only if, for every i in [formula], [formula]. This means that the image of u by φ is obtained through a sliding window of length p. Such functions are computable in constant time in parallel.

The notion of a local function comes from symbolic dynamics (see [\cite=LM]) and is often called a sliding block code. It is a function computable in parallel with k = 1. The parameter r is called the memory and the parameter t is called the anticipation of the function φ. The function φ is then said to be p-local.

To be self-contained, we recall the classical algorithms for parallel addition of Avizienis [\cite=Avizienis], and of Chow and Robertson [\cite=ChowRobertson]. In what follows, "for each i in parallel" means that "each numbered step is executed in parallel, and the results of the parallel computations are shared between the steps".

Algorithm of Avizienis: Base β = b, [formula] integer, parallel addition on alphabet [formula], [formula].

Input: two words [formula] and [formula] of A*, with [formula], [formula] and [formula]. Output: a word [formula] of A* such that

[formula]

for each i in parallel do 0. zi: = xi + yi 1. if [formula] then qi: = 1, ri: = zi - b if [formula] then qi: =  - 1, ri: = zi + b if [formula] then qi: = 0, ri: = zi 2. zi: = qi - 1  +  ri

Addition realized by the Avizienis algorithm is a 2-local function, with memory 1 and anticipation 0. Notice that the minimally redundant symmetric alphabet is obtained with the value [formula].

The Chow and Robertson algorithm works for base 2 and alphabet { - 1,0,1}. We give here a generalization to an even base β = b = 2a, [formula].

Algorithm of Chow and Robertson: Base β  =  b = 2a, [formula] integer, parallel addition on alphabet [formula].

Input: two words [formula] and [formula] of A*, with [formula], [formula] and [formula]. Output: a word [formula] of A* such that

[formula]

for each i in parallel do 0. zi: = xi + yi 1. if [formula] then qi: = 1, ri: = zi - b if [formula] then qi: =  - 1, ri: = zi + b if [formula] then qi: = 0, ri: = zi if zi  =  a and zi - 1 > 0 then qi: = 1, ri: =  - a if zi  =  a and [formula] then qi: = 0, ri: = a if zi  =   - a and zi - 1 < 0 then qi: =  - 1, ri: = a if zi  =   - a and [formula] then qi: = 0, ri: =  - a 2. zi: = qi - 1  +  ri

Addition realized by the Chow and Robertson algorithm is a 3-local function, with memory 2 and anticipation 0.

The main difference between the two algorithms is that the Avizienis algorithm is neighbour-free, while the Chow and Robertson algorithm is neighbour-sensitive, since the decision taken at position i in Step 1 depends also on the digit at position i - 1.

Parallel algorithm

Now we move to bases β that are algebraic numbers. Let us formalize the assumption we want β to satisfy.

Let β be such that |β| > 1. We say that β satisfies the strong representation of zero property (or, for short, that β is SRZ) if there exist integers [formula], for some non-negative integers h and k, such that β is a root of the polynomial

[formula]

and

[formula]

The polynomial S is a said to be a strong polynomial for β.

If β satisfies ([\ref=treba1]), then the word [formula] is a β-representation of zero. From this we can derive a set of rewriting rules, generated by the rule [formula].

To simplify the notation, we set B = b0 and [formula] The inequality from Definition [\ref=DefSRZ] now reads

[formula]

Suppose that β is SRZ. We choose the symmetric alphabet

[formula]

For this fixed alphabet A, we describe a parallel algorithm for addition in base β. Let us denote

[formula]

Then a = a' + cM. The alphabet [formula] will be referred to as the inner alphabet.

Algorithm I: Parallel addition for base β with the strong representation of zero property (β is SRZ).

Input: two words [formula] and [formula] of A*, with [formula], [formula] and [formula]. Output: a word [formula] of A* such that

[formula]

for each i in parallel do 0. zi: = xi + yi 1. find [formula] such that zi - qiB∈A' 2. [formula]

Before proving the correctness of the algorithm, let us stress that the numbers c, a, and a' have been defined in such a way that they satisfy

[formula]

The first two inequalities are clear. To verify the last one, we will use the fact that, for any positive real numbers γ,δ, one has [formula]. Putting [formula] and δ = B - 2M, we obtain

[formula]

This inequality, together with our choice a  =  a' + cM, already proves the third inequality of [\eqref=nerovnosti].

Suppose that β is SRZ. Then Algorithm I realizes addition in constant time in parallel in FinA(β) with [formula], where [formula].

The proof is structured in two parts:

The digits of the output belong to A:

After Line 0 of Algorithm I, zi belongs to [formula]. Since the inner alphabet A' is formed by 2a' + 1 consecutive integers and [formula], there exists qi such that zi - qiB∈A'. Since [formula] and [formula], the integer qi can be found in range [formula]. Finally, in Line 2, the new digit zi (denoted for the moment by znewi) is

[formula]

As [formula] and [formula], the resulting znewi satisfies [formula].

The output represents the number x + y:

In order to avoid a tedious description of ranges of summation indices, we will consider all coefficients which do not play any role in our consideration to be equal to zero. With this convention, bi = 0 for all [formula], and therefore we may express the rewriting rule [\eqref=treba1] as [formula]. Similarly, xi and yi are set to 0 for all [formula], and thus [formula]. Also the auxiliary coefficients qi are set to 0 for all [formula].

After Line 2 of Algorithm I, we obtain

[formula]

Since for the last sum we have

[formula]

the output is correct.

The correctness of the algorithm stems from the inequalities [\eqref=nerovnosti], which are satisfied by many triplets a, a', c. Our specific choice of a, a', and c displayed in [\eqref=treba3] and [\eqref=treba4] gives the smallest possible value a, and thus the smallest cardinality of the alphabet A in our algorithm. Of course, this does not exclude existence of other parallel algorithms with smaller alphabets. Let us demonstrate the optimality of our choice of a, a', and c. According to (ii) of [\eqref=nerovnosti], in order to minimize a, we have to minimize integers a' and c. The choice of a' in [\eqref=treba4] is minimal with respect to the requirement [formula]. By (ii) and (iii) of [\eqref=nerovnosti], we obtain

[formula]

Combining the last inequality with (i) of [\eqref=nerovnosti], and insisting on positivity of c, we have

[formula]

which already shows that our choice of c in [\eqref=treba4] was minimal as well. Let us point out that we also used the inequality B > 2M.

Consider the base β  =  10. It is SRZ for the polynomial - X + 10 = 0, where B = 10 and M = 1. In this case

[formula]

Therefore, our algorithm provides parallel addition in the decimal numeration system on alphabet [formula], and in fact it is precisely the algorithm that Avizienis gave in 1961, see [\cite=Avizienis].

More generally, for any integer [formula], the base β  =  b is SRZ for the polynomial - X + b = 0, and therefore we can apply the same algorithm for addition, namely on the alphabet [formula] with [formula].

Consider the base β  =  2. For such a base, - X + 2 = 0 is not a strong polynomial. Nevertheless, this base satisfies also the polynomial - X2  +  4 = 0, which already is strong, with B = 4 and M = 1. Now we have

[formula]

So Algorithm I works for base 2 with the alphabet [formula], and is 3-local. Remind that the Chow and Robertson algorithm is 3-local as well, but it works with smaller alphabet { - 1,0,1}.

Let us consider the base [formula], the Golden Mean. This base β is one root of the quadratic equation X2 = X + 1, the second root is [formula]. Since β4 + (β')4  =  7, β is a root of the strong polynomial

[formula]

with B = 7 and M = 2. This implies c = 1, a' = 3, and a = 5. The alphabet we work with is [formula]. The inner alphabet is [formula].

In the following, we denote the signed-digit - b by [formula] (this notation is already present in the work of Cauchy [\cite=Cauchy]). Below is shown the performance of Algorithm I for addition of two numbers from FinA(β), namely

[formula]

We have [formula] and [formula].

[formula]

All positions i of z for which zi does not belong to the inner alphabet [formula] must be modified by adding or subtracting the rewriting rule [formula], with the digit 7 on position i, as follows:

[formula]

Hence x + y = z = β12  +  β10  -  β9  -  β8 + 2β7 + 3β5 + 5β4 - 2β3  +  β2  -  β + 2 - β- 1  +  β- 4.

Consider the complex base β  =   - 1 + i. Since β4  =   - 4, we can use the strong polynomial X4 + 4 with B = 4 and M = 1, i.e., we can perform parallel addition on the alphabet [formula], and this addition is a 5-local function. This result appeared in [\cite=Frougny2]. There is also a parallel algorithm on alphabet [formula] (à la Chow and Robertson), which gives a 9-local function, [\cite=Frougny2]. On the minimally redundant alphabet { - 1,0,1}, there is a parallel addition algorithm provided by Nielsen and Muller [\cite=NM].

Take for base β the rational [formula]. This is an algebraic number, which is not an algebraic integer. It is known that any non-negative integer has a finite expansion in this base on the alphabet [formula], see [\cite=FrougnyKlouda]. There is a strong polynomial S(X) =  - 2X + 7 with B = 7 and M = 2. Thus a' = 3, c = 1, and a = 5. It is not difficult to see that any integer has a finite representation on the redundant alphabet [formula], and, by Algorithm I, addition is realizable in parallel.

Reduction of the alphabet

It is very difficult to prove that an alphabet used by some algorithm for parallel addition is minimal. It is a lot easier to prove that the alphabet is not minimal; which is the case for the alphabet we worked with in Algorithm I. Let us start this section with an example.

Take for β the Golden Mean. This base satisfies the equation

[formula]

We say that rewriting rule [formula] is positively applied at position i if the number 3 is added to the actual digit occurring at position i and the number 1 is subtracted from the actual digits at positions i - 2 and i + 2. Analogously, we define the negatively applied at position i. We shall present a parallel algorithm for addition on the alphabet

[formula]

Let us explain the algorithm less formally.

Input: two finite sequences of digits (xi) and (yi) of [formula], with [formula] and [formula]. Output: a finite sequence of digits (zi) of [formula] such that

[formula]

for each i in parallel do [formula]

During the course of the algorithm, we change only the actual values of the coefficients zi, but we do not change the sum [formula]. Therefore, for correctness of the algorithm, we just have to realize that

after Step 0, each zi belongs to [formula],

after Step 1, each zi belongs to [formula],

after Step 2, each zi belongs to [formula], and, finally,

after Step 3, each zi belongs already to the original alphabet [formula].

Let us illustrate the algorithm on the following example:

[formula]

When β is the Golden Mean, we have seen how using a weaker representation of zero [formula] enables to exploit the reduced alphabet [formula] instead of the alphabet [formula], which was necessary for applying the strong representation of zero [formula]. The idea of this reduction can be generalized to other bases β as well.

Let β be such that |β| > 1. We say that β satisfies the weak representation of zero property (or, for short, that β is WRZ) if there exist integers [formula], for some non-negative integers h and k, such that β is a root of the polynomial

[formula]

and

[formula]

The polynomial W is said to be a weak polynomial for β.

When β is WRZ, we can describe a parallel algorithm for addition. Let us put as above [formula], and let

[formula]

Similarly to Algorithm I, the inner alphabet is [formula] with [formula]. The algorithm works in

[formula]

The steps will be indexed by [formula]. After the [formula]-step, the digits zi will belong to the alphabet

[formula]

and to the alphabet A for [formula]. Clearly [formula].

Algorithm II: Parallel addition for base β with the weak representation of zero property (β is WRZ).

Input: two words [formula] and [formula] of A*, with [formula], [formula] and [formula]. Output: a word [formula] of A* such that

[formula]

for each i in parallel do 0. zi: = xi + yi 1. for [formula] to s do 2. if zi∈A' then qi: = 0 else qi: =  sgn  zi 3. [formula]

Suppose that β is WRZ. Then Algorithm II realizes addition in constant time in parallel in FinA(β) with alphabet [formula], where [formula].

During the course of the algorithm, we do not change the value [formula] (thanks to the fact that we are only applying the weak representation of zero, either positively, or negatively). For correctness of the algorithm, we just have to check the magnitude of digits at the time when the algorithm stops.

After the 0th-step, any digit zi belongs to the alphabet A(0). We will prove

This already will confirm the correctness of Algorithm II.

Let us discuss the value of digits zi after the [formula]-step according to the value qi computed in this step. During the discussion we shall use the inequalities

[formula]

which follow from the choice of s by [\eqref=trebaII3]. Let zi be in [formula]. There are three possible cases:

qi = 0: In this case, [formula] and [formula]. Therefore,

[formula]

i.e., [formula] for [formula] and znewi∈A for [formula].

qi = 1: In this case, [formula] and

[formula]

Therefore, for the upper bound we have

[formula]

On the other hand, we obtain for the lower bound

[formula]

i.e., [formula] for [formula] and znewi∈A for [formula].

qi =  - 1: Analogous to the previous case.

In the previous discussion we have also used the inequality [formula] which is a consequence of the definition of a, see [\eqref=trebaII2].

If β is a root of a strong polynomial, we may use both Algorithms I and II with this strong representation of zero. They work with the alphabet [formula], whereby in the first algorithm [formula], while in the second one [formula]. Thus the alphabet of Algorithm II is never bigger than the alphabet of Algorithm I using the same SRZ.

It is easy to see that both the alphabets coincide (aI  =  aII) if, and only if, [formula]. If B and M satisfy this inequality, then the parameter s from Algorithm II is equal to 1, and the algorithms are the same.

If 4M - 1  >  B  >  2M, then Algorithm II uses a strictly smaller alphabet. The price we have to pay is the number of steps. Unlike Algorithm I, the number of steps in Algorithm II depends on values M and B in the weak polynomial. Another disadvantage of Algorithm II is the increasing number of positions needed to store the result. Comparing the length of outputs in both algorithms, if d = k + h is the degree of the strong or weak polynomial, Algorithm I can enlarge the number of used positions by d, while Algorithm II enlarges the number of used positions by ds.

A given base β can satisfy more than one strong polynomial, and, consequently, we have several versions of Algorithm I. Similarly, one base β can satisfy several different weak polynomials, and thus several versions of Algorithm II.

Let us consider an integer base β  =  b in [formula].

If [formula], then - X  +  b  =  0 is a strong polynomial for b, with B = b and M = 1, thus [formula]. According to the previous remark, the two algorithms (I and II) coincide and require the same alphabet [formula] with [formula]. In this sense, both algorithms are generalizations of the Avizienis algorithm to non-integer bases.

For b = 2, the equation - X  +  2  =  0 is a weak polynomial and we may use it in Algorithm II, which works now with the alphabet A  =  { - 2, - 1,0,1,2}. This alphabet is bigger than the alphabet in the parallel algorithm given by Chow and Robertson, but, on the other hand, it is smaller than the alphabet in the algorithm that we have described in Example [\ref=binar].

In both our algorithms (I and II), the decision about application of the rewriting rule at position i depends only on the actual value of the digit at this position. This is the crucial difference from the algorithm described by Chow and Robertson for base 2, where the decision depends also on the digit at the right neighboring position i - 1. A natural question is whether this kind of strategy may be applied to other bases as well. In the last section, we can answer this question positively, at least for the Golden Mean.

Polynomials with a dominant coefficient

Algorithms I and II are applicable only to bases β being a root of a strong or a weak polynomial, that is to say, a polynomial with integer coefficients, where one of these coefficients is dominant, i.e., is greater than twice or once the sum of the moduli of the other coefficients. We shall show that for most of the algebraic numbers β with |β| > 1 such a strong or weak polynomial exists.

Let α be an algebraic number of degree d with algebraic conjugates [formula] (including α itself). Let us assume that |αi|  ≠  1 for all [formula] and |α| > 1. Then, for any [formula] there exist a polynomial

[formula]

and an index [formula] such that

[formula]

Let G(X) be the minimal polynomial of α, i.e.,

[formula]

Let M be the companion matrix of the polynomial G(X):

[formula]

It is a well-known fact, which can be easily verified, that the characteristic polynomial of M satisfies

[formula]

where I is the unit matrix of corresponding size d  ×  d. In particular, the numbers αj are eigenvalues of M. For any n in [formula], [formula], define

[formula]

Since the matrix Mn has eigenvalues [formula], we have

[formula]

As M is a rational matrix, its power Mn is rational as well, and thus det (Mn - XI) is a polynomial with rational coefficients. It implies that, for all n in [formula], the polynomial Gn(X) has rational coefficients. Clearly, for all n in [formula] and j in [formula], we have

[formula]

where [formula] is the set of all subsets of [formula] with cardinality j. Without loss of generality, let us assume [formula], and denote j0  =   max {i:1 < |αi|}. Our choice of j0 guarantees that

[formula]

for any subset [formula] and [formula]. Therefore, for all such choices of [formula], we have

[formula]

Since the coefficients gj(n) of the polynomial Gn satisfy [\eqref=koef], we can deduce

[formula]

We may already claim that there exists n0 = n0(t) in [formula] such that

[formula]

or, equivalently,

[formula]

The existence of a suitable n0 is obvious, as the right hand side tends to 0 and the left hand side has the limit 1.

Let us fix one such n0, and denote by K the least common multiple of the denominators of ratios [formula]. Then the polynomial Q(X) = KGn0(Xn0) and the index i0  =  n0j0 have the desired properties.

Let [formula], and let [formula] be a polynomial with integer coefficients ti in [formula]. T is called a t-polynomial if there exists [formula] such that

[formula]

The polynomial Q constructed in the proof of Proposition [\ref=dominant] clearly is a t-polynomial, and, for t = 1 we obtain a weak polynomial, while for t = 2 we get a strong polynomial.

Lemma 8 in [\cite=Akiyama] gives a little bit weaker statement in the case of an expanding algebraic integer α, i.e., |αi| > 1 for all conjugates of α. Our proof of the previous Proposition [\ref=dominant] was strongly inspired by the proof given by S. Akiyama, P. Drungilas, and J. Jankauskas in [\cite=Akiyama].

The proof of Proposition [\ref=dominant] is constructive. The strong representations of zero we have used in Examples [\ref=binar], [\ref=fibonacci], and [\ref=Gaussian] can be obtained by the construction given in the proof with t = 2, namely as follows:

For β  =  2, the minimal polynomial is G(X)  =  X - 2, then G2(X)  =  X - 22, and the desired Q(X)  =  G2(X2)  =  X2  -  4.

For the Golden Mean, the minimal polynomial is G(X)  =  X2 - X - 1 = (X - β)(X  -  β') with [formula] and [formula]. The minimal n satisfying [\eqref=chceme1] is n = 4. Therefore, [formula], and the final [formula].

For the base β  =   - 1 + i, the minimal polynomial is G(X)  =  (X + 1 - i)(X + 1 + i)  =  X2 + 2X + 2. Already for n = 2 we have [formula], and our strong representation of zero uses the polynomial Q(X)  =  G2(X2)  =  X4 + 4.

Let β be an algebraic number with a conjugate γ such that |γ| = 1. Then β cannot satisfy a t-polynomial for any [formula].

Suppose that β is a root of a polynomial [formula] with integer coefficients [formula]. Then also the conjugate γ is a root of W(X):

[formula]

Since |γ| = 1, we obtain

[formula]

By Proposition [\ref=dominant] and Proposition [\ref=mod1] we obtain the following result:

Let β with |β| > 1 be an algebraic number. Then β is SRZ (or WRZ) if and only if it has no conjugate of modulus 1.

It is fairly easy to recognize whether an algebraic number does, or does not have a conjugate of modulus 1, by looking at its minimal polynomial. First, if the number is quadratic, it cannot have any conjugate of modulus 1. Suppose now that α is an algebraic number of degree d > 2, with a conjugate α' with modulus |α'|  =  1. Let [formula] be its minimal polynomial, G(X) in [formula]. Since G(X) is minimal, α'  ≠    ±  1; i.e., α' is not real. As the minimal polynomial has all its coefficients real, the complex conjugate [formula] is a root of G as well. In general, if the minimal polynomial has two different roots η and [formula], then the minimal polynomial satisfies

[formula]

thus it is reciprocal and its degree is even. This is summarized in the following remark.

Let β with |β| > 1 be an algebraic number of degree d.

If d is odd, or

if d = 2, or

if [formula] is even and the minimal polynomial of β is not reciprocal,

then β has no conjugate of modulus 1.

The Golden Mean - all good things come in threes

In [\cite=Berstel], Berstel described an algorithm for parallel addition in base [formula] on an alphabet with cardinality 13. In this section, we give Algorithm III for parallel addition in this numeration system on the alphabet { - 1,0,1}. This alphabet cannot be further reduced, as proved in [\cite=Frougny2]. In our algorithm, we use a method similar to the method of Chow and Robertson.

We begin by describing two auxiliary algorithms for elimination of digits. Both of them use the weak representation of zero [formula].

The first auxiliary algorithm removes digits - 2:

Algorithm A: Base [formula], reduction from alphabet [formula] to [formula].

Input: a finite sequence of digits (zi) of { - 2,1,0,1,2}, with [formula]. Output: a finite sequence of digits (zi) of { - 1,0,1,2}, with [formula].

for each i in parallel do 1. case [formula] then qi: =  - 1 else qi: = 0 2. zi: = zi - 3qi + qi + 2 + qi - 2

For the correctness of Algorithm A we have to show that the value znewi  =  zi - 3qi + qi + 2 + qi - 2 belongs to the alphabet { - 1,0,1,2} for each i. We will use the fact that our prescription for qi satisfies

[formula]

Let us discuss the value of znewi according to the values qi:

zi∈{1,2}: Then, znewi  =  zi  +  qi + 2  +  qi - 2∈{ - 1,0,1,2}.

zi = 0: Then our algorithm for the value qi supposes that [formula] or [formula]. According to [\eqref=removing2], we have qi + 2 = 0 or qi - 2 = 0. Therefore, znewi = qi + 2  +  qi - 2∈{ - 1,0}.

zi∈{ - 2, - 1}: Then, znewi  =  zi  +  3  +  qi + 2  +  qi - 2∈{ - 1,0,1,2}.

zi = 0: The rule for the value qi supposes that [formula] and [formula]. Therefore, qi + 2  =  qi - 2  =   - 1, which implies znewi  =  3  +  qi + 2  +  qi - 2  =  1.

Other combinations, namely (qi  =  0 and zi∈{ - 2, - 1}) or (qi  =   - 1 and zi∈{1,2}), are impossible. Thereby, we have shown that the digits of the result belong to the desired alphabet { - 1,0,1,2}.

The second auxiliary algorithm removes digits 2:

Algorithm B: Base [formula], reduction from alphabet { - 1,0,1,2} to { - 1,0,1}.

Input: a finite sequence of digits (zi) of { - 1,0,1,2}, with [formula]. Output: a finite sequence of digits (zi) of { - 1,0,1}, with [formula].

for each i in parallel do 1. case [formula] then qi: = 1 else qi: = 0 2. zi: = zi - 3qi + qi + 2 + qi - 2

Before explanation of the correctness of Algorithm B, we point out several simple facts about the values qi determined in Algorithm B:

Fact 1.   [formula]

Fact 2.   [formula]

Fact 3.   [formula]

Fact 4.   [formula]

Unlike the previous four facts, the following three ones deserve short proofs:

Fact 5.   [formula] Proof of Fact 5. The assumption zi  =  1 and qi = 0 implies [formula]. If zi + 2 =  - 1, then we have directly qi + 2 = 0. Now suppose that zi + 2  =  0. If qi + 2 were equal to 1, then, according to Fact 4, the value qi is equal to 1, a contradiction. The discussion for qi - 2 is analogous.

Fact 6.   [formula] Proof of Fact 6. When zi  =  0, then the value qi is zero in these two situations: a) One of numbers zi + 2, zi - 2 is not positive. Then, according to Fact 2, one of the values qi + 2, qi - 2 is zero. b) Both [formula] and [formula]. The assumption qi = 0 forces, without loss of generality, that zi - 2 = 1 and [formula]. So we can use Fact 3 to deduce qi - 2 = 0.

Fact 7.   [formula] Proof of Fact 7. The assumption zi  =  1 and qi = 1 implies [formula] or [formula]. According to Fact 1, at least one of numbers qi + 2 or qi - 2 is 1.

Now we demonstrate the correctness of Algorithm B, by showing that znewi  =  zi - 3qi + qi + 2 + qi - 2 belongs to the alphabet { - 1,0,1} for each i.

Let us again discuss the value znewi according to the values qi:

zi =  - 1: Then, znewi =  - 1  +  qi + 2  +  qi - 2∈{ - 1,0,1}.

zi = 0: Due to Fact 6, we have znewi  =  qi + 2 + qi - 2∈{0,1}.

zi = 1: According to Fact 5, we have znewi  =  1 + qi + 2 + qi - 2 = 1.

zi = 2: Then, znewi =  - 1  +  qi + 2  +  qi - 2∈{ - 1,0,1}.

zi = 1: Due to Fact 7, we have znewi  =   - 2 + qi + 2 + qi - 2∈{ - 1,0}.

zi = 0: According to Fact 4, we have znewi  =   - 3 + qi + 2 + qi - 2 =  - 1.

Other combinations, namely (qi  =  0 and zi = 2) or (qi  =  1 and zi  =   - 1), are impossible. Thereby, we have shown that the digits of the result belong to the desired alphabet { - 1,0,1}.

Lastly, we can proceed by summarizing the Algorithm III for parallel addition in base [formula] and alphabet { - 1,0,1}:

Algorithm III: Base [formula], parallel addition on alphabet A  =  { - 1,0,1}.

Input: two finite sequences of digits (xi) and (yi) of { - 1,0,1}, with [formula] and [formula]. Output: a finite sequence of digits (zi) of { - 1,0,1} such that

[formula]

for each i in parallel do 0. vi: = xi + yi 1. use Algorithm A with input (vi) and denote its output (wi) 2. use Algorithm B with input (wi) and denote its output (zi)

It is easily seen that Algorithm A is local with memory 4 and anticipation 4. Algorithm B is local with memory 6 and anticipation 6. Therefore, Algorithm III is 21-local with memory 10 and anticipation 10.

All of our algorithms described above are working with symmetric alphabets of signed-digits. Such a choice of alphabet is practical, because the algorithm for addition can be used for subtraction at the same time. However, the symmetry of the alphabet is not necessary for parallelism as such. The parallel algorithm for addition in base being the Golden Mean given by Berstel [\cite=Berstel] uses an alphabet of 13 non-negative digits, namely [formula]. In fact, our auxiliary Algorithms A and B demonstrate that, if we do not insist on the symmetry, we may be able to further reduce the alphabet.

In Algorithm III, input values x2i and y2i at even positions do not influence the output values z2i + 1 at odd positions, and similarly for the input in odd positions. Therefore, the data at even and odd positions can be stored separately, and addition can be performed in parallel on the input (x2i) and (y2i) on one hand, and on the input (x2i + 1) and (y2i + 1) on the other hand, by an 11-local function independently.

The structure of Algorithm III depends heavily on the coefficients of the weak polynomial satisfied by the Golden Mean. It is not clear how to generalize it to a broader class of bases. However, the case where β is a quadratic unit integer seems feasible similarly to the Golden Mean.

The Fibonacci numbers are defined as follows:

[formula]

It is well known that any non-negative integer N can be expressed as a sum of different Fibonacci numbers,

[formula]

If, moreover, we require [formula] for any index j, then such an expression is unique, see [\cite=Zeckendorf]. For example, the number 29 can be represented in the Fibonacci numeration system by (29)F  =  1010000, as 29  =  F6 + F4. If we abandon the requirement of uniqueness, and allow coefficients - 1,0,1, then the numeration system is redundant, and addition can be performed by a parallel algorithm in constant time as well. Let us explain it. We want to add two integers written in the form

[formula]

We can use Algorithm III with a small modification. Algorithm III is based on the weak representation of zero -  βi + 2 + 3βi  -  βi - 2 = 0. The Fibonacci numbers satisfy analogous relations:

- Fi + 2 + 3Fi - Fi - 2  =  0 for all [formula]

- F3 + 3F1 - F0  =  0

- F2 + 3F0  =  0

Therefore, the Algorithm III needs only slight changes, namely at the positions with indices i = 0,1 in Part 1 (Algorithm A) and i = 0,1,2,3 in Part 2 (Algorithm B).

However, a function computable in parallel is defined by a sliding window of length p, which means that the function Φ cannot depend on any particular index i, but only on the p-tuples of the input alphabet. To get rid of this problem, we use the classical trick of extending the alphabet { - 1,0,1} by an artificial symbol, say $, to indicate the exceptional positions to the function Φ. Thus we will represent the above mentioned number 29 as [formula]. The domain of the 21-local function Φ announced in Corollary [\ref=21] has to be enlarged to the set { - 1,0,1,$}21, and the definition of Φ must be correspondingly extended as well.

Note that, due to the relation - F3 + 3F1 - F0  =  0, the alternative option of processing the odd positions separately from the even positions (as described in Remark [\ref=2machines]. for base [formula]) cannot be used for the Fibonacci numeration system.

Acknowledgements

We are grateful to Shigeki Akiyama for showing us the connection between polynomials with a dominant coefficient and the height reducing problem with expanding base α, and for providing us the reference [\cite=Akiyama]. We also want to thank Wolfgang Steiner for pointing out that the results contained in [\cite=FrougnySteiner] imply Proposition [\ref=dominant] in case β is a Pisot number. Finally, we thank Péter Burcsi for Proposition [\ref=mod1].

We acknowledge financial support by the Czech Science Foundation grant GAR 201/09/0584, and by the grants MSM6840770039 and LC06002 of the Ministry of Education, Youth, and Sports of the Czech Republic.