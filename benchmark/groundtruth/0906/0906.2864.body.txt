Discussion of Twenty Questions Problem

Introduction

Unit computation of mordern computer is still binary, while "Yes or No" question is a good illustration of such computing, asking one question is equivalent to spending one bit of computation resource. This discussion is intended to give an intution behind symbol source coding through discussing the different ways for solving a concrete twenty question problem. The rest of this paper is organized as follows. Section [\ref=sec:2] introduces the way of one-by-one asking. Section [\ref=sec:3] is about top-down division. In Section [\ref=sec:4] we discuss the way of down-top merging. The work is concluded in Section [\ref=sec:5].

One-bye-One Asking

We depict the TQP(Twenty Question Problem) with 20 boxes in which only one box contains a ball, shown as figure [\ref=fig:1]. With method one, we choose arbitraily one box and say it contain the ball, if opening the box and find there is none, equivalently answered by "No", we get information content [formula]. Continuously we draw another box but miss the ball again, we get information content [formula]. Step forward repeatedly, and assume the ball is found at step N(1  ≤  N  ≤  20), up to now the total information content we got is [formula]. Without loss of generality, the guessing process is illustrated as choosing the boxes in order from left to right, shown as figure [\ref=fig:2]. For every guessing, we have "Yes" or "No" results, Imagine that 1 bit is spent for every guessing. Then the expected bits need solving the TQP with the One-by-One method equals to [formula].

Top-Down Division

Before every asking we divede equally the boxes into two groups, then ask if the ball is in one of the two groups. According to the answer continue this strategy repeatly until the ball is found. This division process is shown as figure [\ref=fig:3]. In this way the expected bits to spend is [formula]. The information content gotten from this ways is [formula].

Down-Top Merging

The smartest way presented here is to merge the options in Down-Top direction, which follows Huffman Coding method[\cite=ref:1]. Every box has the same probability [formula] to contain the ball, combine two of the boxes and imagine they become a bigger one, then the probability of the ball in this bigger box is [formula]. For every merging we make sure that the two boxes (real or imagined box) have the smallest probability of including the ball. For example, after first merging we have one bigger box which has probability [formula] and there are 18 boxes with probability [formula], so 9 bigger boxes should be formed from the 18 boxes respectively. Repeat merging bigger boxes until we have a box which include the ball with probability 1. This merging process is shown as figure [\ref=fig:4]. From this process we have the spent bits is [formula]. The information content gotten in this way is [formula].

Conclusion

From above discussion, we can definitely conclude that to find the ball the three tricks get the same information content, but the first method consume in average much more extra effort than the later two methods. For TQP, the Top-Down Divsion method and Down-Top Merging method consume the same expected bits for achieving the goal. But they are not of the same efficiency. Actually the Down-Top Merging is optimal while Top-Down Divsion is sub-optimal, just like nuclear fusion has much more energy than nuclear fission.

Take an example as figure [\ref=fig:5]. A symbol set with [formula], with Huffman merging we get expected code length [formula], while greedy division has expected code length (1 + 1  =  2bits).