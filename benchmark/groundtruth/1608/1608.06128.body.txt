Joint Subcarrier and CPU Time Allocation for Mobile Edge Computing

Introduction

Limited battery life continuously shows up as the top concern of smartphone users [\cite=kumar2010cloud]. The problem is becoming even more severe in the predictable future, given the ever-growing demands for compute-intensive apps and the stalling battery capacity of smartphones. Mobile edge computing recently comes up as a promising solution [\cite=barbarossa2014communicating] [\cite=satyanarayanan2014cloudlets] [\cite=mao2016dynamic]. By deploying small-scale datacenters at wireless access points - known as cloudlets - the system allows smartphone users to offload compute-intensive tasks to a nearby cloudlet, so as to extend their battery life by trading off heavy CPU cycles for lightweight communication.

The performance of offloading critically depends on the allocation of both radio and compute resources: the former determines the data transmission speed and the communication energy consumption; the latter determines the compute time of tasks offloaded to a cloudlet. In general, the more resources are allocated, the better an offloading request is served. However, both radio and compute resources are highly constrained in a cloudlet. In particular, cloudlets are deployed at wireless access points where only a limited number of radio channels are available. Meanwhile, an economic, scalable deployment forces cloudlets to be no more than small-scale datacenters with limited compute capabilities. Therefore, to develop effective computation offloading strategies, it is critical to take both radio and compute resources into account.

However, a large body of existing works simply assumed an infinite amount of compute resources available in a cloudlet, where the offloaded tasks were computed with negligible processing time. The problem of offloading scheduling was then reduced to radio resource allocation. For example, Chen et al. [\cite=chen2015decentralized] modeled the competition for radio resources as a congestion game of selfish mobile users. Kaewpuang et al. [\cite=kaewpuang2013framework] studied the cooperation game of offloading service providers, where the radio and compute resources were assumed to be managed by different entities separately. As we shall show in this paper, coordinately managing both resources improves the overall utilization significantly. Sardellitti et al. [\cite=sardellitti2015joint], on the other hand, simply ignored the congestion of compute resources in a cloudlet by throttling the CPU cycles allocated to each offloaded task. Juan et al. [\cite=liu2016delay] also assumed an infinitely powerful cloudlet such that the execution time for each offloaded task was guaranteed to be a constant value.

Recently, a few researchers started to jointly consider the limitations in radio and compute resources. Nonetheless, some of their assumptions either are inefficient in regards to energy reduction or will weaken the applicability of the result. In [\cite=barbarossa2013joint], CPU resources were allocated as percentages of the total CPU frequency, meaning that jobs are running in parallel. Such parallel execution maintains fairness but prolongs the average execution time. Radio resource was allocated in non-preemptive time slots in [\cite=yue2014cloud]. However, all the slots are of a fixed length, and an unnecessarily long slot-length results in waste of radio resource. Furthermore, the efficiency of the proposed scheduling policy is sensitive to some parameters that need to be searched empirically under different system settings.

Motivated by the above limitations in existing works, in this paper, we propose algorithms that fully utilize the limited radio and compute resources to reduce the energy consumption of mobile devices. Given the small coverage of the cloudlet, we consider an OFDMA system so that interference among users could be ignored, with subcarriers as the radio resource. In terms of compute resource, we allocate CPU time slots of the cloudlet non-preemptively with varied slot-length. We first propose near-optimal algorithms that separately schedule subcarriers and CPU time slots. We show that naive combination of per-resource allocations greatly degrades the system performance. The reason is that congestion of one resource will cause significant waste of the other. To address this problem, we propose a joint scheduling algorithm to coordinately manage subcarriers and CPU of the cloudlet. Simulation results show that a noteworthy amount of energy is saved through joint scheduling compared to separate allocation. Moreover, the coordinate management of different resources is of greater advantage when more prominent performance gains could be achieved through computation offloading.

System Model

We consider centralized resource allocation for mobile edge computing with OFDMA as the multiple access scheme. A cloudlet with certain computation capability is deployed at the wireless access point to provide job-execution services. Our objective is to minimize the total energy consumption of mobile users. In this section, we will model both the remote resources in the cloudlet and the local resources of mobile devices. We will then analyze the required energy and time for offloading, and formulate the energy-minimization problem.

Model of the Cloudlet and Mobile Users

As shown in Fig. [\ref=model], we consider a snapshot when the CPU of the cloudlet is idle, and there are N available subcarriers to serve M mobile users. The CPU frequency of the cloudlet is fc. Let C  =  {1,2,...,N} denote the available subcarriers to be allocated. The bandwidth of each subcarrier is BN. Further denote G as the channel-gain-to-noise ratio matrix. We assume G remains constant during the scheduling process.

Let U  =  {1,2,...,M} denote the M users, each with a job to execute either locally or remotely. In the following, we may call user and job interchangeably. Each job Ji is described by its input data size [formula] and deadline [formula]. For user Ui, the maximal frequency of local CPU is [formula]. Maximal transmission power and static circuit power are denoted by [formula] and [formula].

Energy Consumption

Local execution

According to [\cite=zhang2013energy], at frequency fi, the energy consumption of each CPU cycle is κf2i, and the required CPU cycles for completing a job is given by [formula], where [formula] is the input data size, while κ and X are known constants. In order to minimize the local execution energy consumption, the CPU frequency of Ui should be set to [formula] such that its deadline is exactly met since the energy consumption of each CPU cycle increases with its frequency. Thus, the local energy cost for Ui is given by

[formula]

We assume that [formula] is always larger than fi, so that local execution is always feasible for all users.

Remote execution

In the case of offloading, it consumes energy to send the input data [formula] to the cloudlet. The energy consumption for receiving the computation results is ignored as the amount of output data is much less the input data [\cite=barbarossa2013joint] [\cite=yue2014cloud] [\cite=zhang2013energy]. Therefore, the energy cost for offloading is:

[formula]

where [formula] and Tit are the transmission power and transmission time, respectively.

We now show that the optimal value of [formula] could be derived through bisection search. Denote W  =  {W(i,j)|W(i,j)∈{0,1},i∈U,j∈C} as the subcarrier allocation matrix. For user Ui who has been allocated a group of subcarriers W(i), transmit energy efficiency (in bits per joule) is convex with the transmit power [\cite=xiong2012energy]. Therefore, via bisection search we can find the optimal [formula] that minimizes the transmission energy for the input data. In addition, as the transmit power has to be larger than a threshold [formula] to meet the job deadline [formula], we have

[formula]

Time for Offloading

Transmission

Let P  =  {P(i,j)|P(i,j)∈[null],i∈U,j∈C} be the power allocation matrix. The optimal power allocation matrix P is obtained by the water-filling algorithm [\cite=wong1999multiuser]. We then have the aggregated data rate as

[formula]

and transmission time as

[formula]

Queuing and remote execution

We assume non-preemptive CPU allocation, which assigns a time slot to one user each time until its job completes. The remote execution time in the cloudlet is then given by

[formula]

Denote [formula] as the execution sequence in the cloudlet, and jobs are executed in the ascending order of [formula]. The queuing time in the cloudlet is then

[formula]

where [formula] is the indicator of whether job Jj is offloaded. Thus, the total time for remote execution is given by

[formula]

Problem Formulation

We now formulate the total energy consumption minimization problem as follows:

[formula]

Constraint ([formula]a) ensures that each subcarrier is assigned exclusively to one user. ([formula]b) enforces non-preemptive execution in the cloudlet. ([formula]c) and (d) are the results of bisection search and water-filling with a given the subcarrier allocation matrix W. ([formula]c) places an upper bound for the total transmission power. Finally, ([formula]e) and ([formula]f) respectively calculate the local-execution and offloading energy and ([formula]g) enforces the corresponding hard deadline on each of the offloaded task.

This resource allocation problem is a mixed-integer nonlinear programming (MINLP) problem, which in general is NP-hard. The optimal solution to such a problem is difficult to find, due to the combinatorial optimization variables ([formula]). Also, handling the non-convex functions in both the objective and constraints brings an additional challenge. In the following, we will propose efficient algorithms to solve this problem with near-optimal performance.

Cloudlet with Unlimited Computation Capability

In this section, we address problem ([\ref=eq1]) under a common assumption adopted in existing literatures, i.e., a powerful cloudlet whose computation capability is far beyond the offloading demands of users. For this special case, we develop an efficient algorithm to allocate the radio resources, which could serve as a performance upper bound for the case that the cloudlet possesses limited compute resources as will be pursued in the next section. From the previous discussions, the optimal transmit power and power allocation are respectively obtained through bisection search and the water-filling algorithm. The problem now is to allocate the subcarriers properly.

The subcarrier allocation problem in mobile edge computing system poses several new challenges. Firstly, it is difficult to derive closed-form expressions for the outcome of bisection search and water-filling algorithm, which makes it impossible to explicitly compare different subcarrier allocation results. Besides, for the users who execute their tasks locally, the allocated subcarriers will be wasted.

To avoid such waste of radio resources, subcarriers should be allocated in groups that will ensure beneficial offloading. Intuitively, users with heavy computation workload and meanwhile in good channel conditions should have high priorities to offload, as relatively few subcarriers are required by such users to meet the deadline requirement while energy savings will be large. Thus, to find these users, we propose an algorithm that allocates subcarriers in the "minimum" group of each user, which is defined as the minimum set of subcarriers required to guarantee beneficial offloading. In each iteration, we find the minimum subcarrier group [formula] for each user Ui and obtain the corresponding energy consumption. The tasks of the users achieving the most energy savings with their minimum subcarrier groups should be offloaded to the cloudlet. Details of the proposed subcarrier allocation policy are summarized in Algorithm 1.

Cloudlet with Limited Computation Capability

Though the assumption of unlimited compute resource at the cloudlet simplifies the offloading and subcarrier allocation policy design, it is necessary to consider the limited computation capability of the cloudlets as they are small-scale in practice. In this case, the queuing delay Qic and execution time Tic in the cloudlet are non-negligible, and the congestion in the cloudlet may lead to the violation of the deadline requirements. Therefore, the compute resources should be properly scheduled to maximize the offloading gain. In this section, we will first develop a per-resource allocation algorithm that combines the subcarrier allocation policy developed in Section III with an optimal CPU time scheduling strategy, which serves as a baseline. We will then propose a joint scheduling scheme to coordinately allocate subcarriers and CPU time slots.

Per-Resource Allocation

As a baseline, we first consider a per-resource allocation algorithm. In this algorithm, subcarriers are assigned first, and the CPU time slots are scheduled in the second stage. The cloudlet allocates subcarriers following Algorithm 1, with the only difference on checking deadline constraint, where the execution time in the cloudlet Tic is also considered. Non-preemptive CPU scheduling of the cloudlet in the second stage essentially determines the job execution order. The resulted queuing time of each job dictates whether the deadline requirements are satisfied and finally whether offloading requests are accepted. In the following, we will develop the optimal CPU scheduling policy.

Since non-preemptive CPU scheduling problem is NP-hard [\cite=jeffay1991non], we propose an optimal algorithm based on dynamic programming with pseudo polynomial complexity. In the dynamic programming algorithm, the non-preemptive CPU scheduling problem is decomposed into M states. In state I, we solve the subproblem of maximizing total energy saving with I out of the M users, and store the maximum amount of saved energy as well as the corresponding execution time as intermediate results.

To avoid duplicated iterations, each subproblem adopts previously computed results as input, as elaborated in Algorithm 2. Assume [formula] is one of the subsets considered in state I. Let [formula] and [formula] be the results of this subproblem. To solve it, we divide all possible execution sequences of these I jobs in [formula] into I categories by the last executed job.

Now consider the category where user i is executed at last. For the first I - 1 users, the largest energy reduction is [formula], and their execution time is [formula]. Note that [formula] and [formula] are collected from the results of state I - 1. It is unnecessary for all of the first I - 1 users to offload successfully. For user i, the ready time before its job could be executed in the cloudlet is the longer one of queuing time [formula] and its transmission time Tit. When the deadline [formula] could be satisfied after the execution in the cloudlet, its offloading request is accepted. The corresponding results of this category will be updated as and Likewise, we calculate the results of all the I categories, and choose the one with the largest energy saving as the final output [formula]. The results of the final state, where M users are considered, are the optimal solution to the original CPU scheduling problem.

Joint Allocation

Separate allocation leads to inefficient use of the radio and compute resource because users may still have to execute their tasks locally even if they are assigned with subcarriers. The reason is that in the subcarrier allocation stage, the queuing time for each user remains unknown. The congestion in the CPU of the cloudlet may cause execution deadline violations, leading to the waste of subcarriers. For instance, there might be two users both with stringent deadlines and could not wait for the completion of the other's task. Thus, only the user with a larger energy saving gets the chance of offloading. In this case, subcarriers originally allocated to the user that has to execute its task locally could be re-allocated to other users.

To address the uncertainty of successful offloading and to optimize the utility of limited resources, joint allocation is necessary, i.e., we should find the least amount of both radio and compute resources that ensures successful offloading, and allocate them to the users who save energy most efficiently.

The proposed algorithm is summarized in Algorithm 3, where for each user, we find the minimum subcarrier group that supports beneficial offloading and also calculate the amount of CPU time needed for remote processing. The users who save the most energy with each CPU cycle are allocated with the corresponding subcarriers and CPU time slot.

By identifying the minimum subcarrier group and energy saving per CPU cycle, the utilization of both the radio and compute resources is optimized. Another advantage of joint allocation is that the queuing time is already known before scheduling. Such a prior knowledge of congestion will help to avoid the waste of resources.

Performance Evaluations

In this section, we evaluate the performance of proposed algorithms. We focus on four questions: 1) How much energy could offloading save (compared with local execution)? 2) Is joint allocation in advantage of per-resource allocation? 3) How well does the proposed algorithms perform (compared with optimal allocation)? 4) How does the limited computation capability of the cloudlet influence system performance?

System Setting

Users are randomly located in a circle centered at the cloudlet. Large scale fading of the channels is modeled as: The Rayleigh fading model is adopted for small scale fading. The frequency band of the subcarriers is from 1850 to 1960 kHz, with the bandwidth of each subcarrier as 18.75 kHz. The mobile users' circuit power and maximum transmission power are set to be 50 mW and 1 W, respectively. Input data size is uniformly distributed in the range of 900 - 1100 bits, the job deadlines are uniformly distributed in the range of 50 - 150 ms, and κ is set as [formula][\cite=kumar2010cloud] [\cite=zhang2013energy]. The parameter X is set to be 18000 cycles per bit.

Simulations

In the following simulations, optimal energy savings are obtained by exhaustively searching the subcarrier allocation matrix. In the case when CPU capability is limited, we combine exhaustive search of subcarrier allocation and optimal CPU scheduling to find the optimal results.

Number of users

Energy consumption achieved by the proposed algorithms as the number of users increases are shown in Fig. [\ref=energy_M]. From the curves, both Algorithm 1 (minimum group allocation) and Algorithm 3 (joint allocation) achieve near-optimal performance, for cases without and with computational constraints, respectively. Per-resource allocation only achieves half of the energy saving compared to joint allocation, although the subcarrier allocation (minimum group allocation) is close to optimal and CPU time allocation (dynamic programming) is optimal. The numbers of offloaded users are compared in Fig. [\ref=number_M], where we find that the constraint of the CPU capabilities (red curves) leads to a reduction of the offloading number by nearly 50%.

Coverage of the cloudlet

We further investigate the impacts of coverage radius of the cloudlet in Fig. [\ref=saving_radius]. As the radius r increases, the offloading gain shrinks. The reason is that the users are distributed at a longer distance from the cloudlet on average. Therefore, fewer users could be supported for offloading. This further demonstrates that to provide satisfactory offloading services and achieve seamless connection, the cloudlets need to be close to the users and densely deployed. Considering the high deployment cost of computationally powerful datacenters, cloudlets with limited compute resource are preferred in practice.

CPU frequency of the cloudlet

Fig. [\ref=saving_cpu] shows how the total energy saving varies as computation capability of the cloudlet, i.e., the CPU frequency fc , increases. It can be seen that there is a saturation point at around 800 MHz for a 3-user system (green curves). However, when there are 7 users (red curves), the energy saving keeps increasing due to richer user-diversity (comparing Δ2 with Δ3). Another observation is that joint allocation is of greater advantage over per-resource allocation as the CPU frequency fc increases (comparing Δ1 with Δ2). When fc is larger than a threshold, the performance of joint allocation algorithm approaches the optimal scheduling policy without CPU constraint. These results demonstrate that coordinate management better utilizes the resources when a larger offloading gain can be achieved, either by a richer user-diversity or enhanced processing power.

Conclusions

In this paper, we proposed joint scheduling algorithms of both radio and compute resources for mobile edge computing systems using OFDMA, which are efficient and near-optimal in terms of energy saving for mobile devices. Through extensive simulations, we showed that the per-resource allocation greatly degrades the system performance, even though the allocation policy for each type of resource is near-optimal. Therefore, rather than simply combining separate allocation policies, the congestion information of both types of resources should be considered simultaneously. Furthermore, such joint scheduling is more critical when computation offloading can provide a more prominent energy saving. For future investigations, we will explore the cooperations among cloudlets to further improve the offloading gain.