Lemma

Deep Hashing: A Joint Approach for Image Signature Learning

Introduction

Recent years have witnessed spectacular progress on similarity-based hash code learning in a variety of computer vision tasks, such as image search [\cite=Chum08a], object recognition [\cite=TorralbaFW08] and local descriptor compression [\cite=Strecha12] etc. The hash codes are highly compact (, several bytes for each image) in most cases, which significantly reduces the overhead of storing visual big data and also expedites similarity-based image search. The theoretic ground of similarity-oriented hashing is rooted from Johnson-Lindenstrause theorem [\cite=dasguptaG03], which elucidates that for arbitrary n samples, some O( log (n))-dimensional subspace exists and can be found in polynomial time complexity. When embedded into this subspace, pairwise affinities among these n samples are preserved with tight approximation error bounds. This seminal theoretic discovery sheds light on trading similarity preservation for high compression of large data set. The classic locality-sensitive hashing (LSH) [\cite=Indyk98] is a good demonstration for above tradeoff, instantiated in various similarity metrics such as Hamming distance [\cite=Indyk98], cosine similarity [\cite=charikar02], [formula] distance with p∈(0,2] [\cite=datar04], Jaccard index [\cite=Broder98] and Euclidean distance [\cite=AndoniINR13].

Images are often accompanied with supervised information in various forms, such as semantically similar / dissimilar data pairs. Supervised hash code learning [\cite=mu10] [\cite=WangKC12] harnesses such supervisory information during parameter optimization and has demonstrated superior image search accuracy compared with unsupervised hashing algorithms [\cite=andoniI08] [\cite=WeissTF08] [\cite=GongLGP13]. Exemplar supervised hashing schemes include LDAHash [\cite=Strecha12], two-step hashing [\cite=LinSSHS14], and kernel-based supervised hashing [\cite=liuw12] etc.

Importantly, two factors are known to be crucial for hashing-based image search accuracy: the discriminative power of the features and the choice of hashing functions. In a typical pipeline of existing hashing methods, these two factors are separately treated. Each image is often represented by a vector of hand-crafted visual features (such as SIFT-based bag-of-words feature or sparse codes). Regarding hash functions, a large body of existing works have adopted linear functions owing to the simplicity. More recently, researchers have also explored a number of non-linear hashing functions, such as anchor-based kernalized hashing function [\cite=liuw12] and decision tree based function [\cite=LinSSHS14].

This paper attacks the problem of supervised hashing by concurrently conducting visual feature engineering and hash function learning. Most of existing image features are designated for general computer vision tasks. Intuitively, by unifying these two sub-tasks in the same formulation, one can expect the extracted image features to be more amenable for the hashing purpose. Our work is inspired by recent prevalence and success of deep learning techniques [\cite=Lecun98gradient-basedlearning] [\cite=Bengio09] [\cite=KrizhevskySH12]. Though the unreasonable effectiveness of deep learning has been successfully demonstrated in tasks like image classification [\cite=KrizhevskySH12] and face analysis [\cite=SunWT14], deep learning for supervised hashing still remains inadequately explored in the literature.

Salakhutdinov et al. proposed semantic hashing in [\cite=SalakhutdinovH09], where stacked Restricted Boltzmann Machines (RBMs) are employed for hash code generation. Nonetheless, the algorithm is primarily devised for indexing textual data and its extension to visual data is unclear. Xia et al. [\cite=XiaPLLY14] adopted a two-step hashing strategy similar to [\cite=LinSSHS14]. It firstly factorizes the data similarity matrix to obtain the target binary code for each image. In the next stage, the target codes and the image labels are jointly utilized to guide the network parameter optimization. Since the target codes are not updated once approximately learned in the first stage, the final model is only sub-optimal. Lai et al. [\cite=LaiPLY15] developed a convolutional deep network for hashing, comprised of shared sub-networks and a divide-and-encode module. However, the parameters of these two components are still separately learned. After the shared sub-networks are initialized, their parameters (including all convolutional/pooling layers) are frozen during optimizing the divide-and-encode module. Intrinsically, the method in [\cite=LaiPLY15] shall be categorized to two-step hashing, rather than simultaneous feature / hashing learning. Liong et al. [\cite=LiongLWMZ15] presented a binary encoding network built with purely fully-connected layers. The method essentially assumes that the visual features (, GIST as used in the experiments therein) have been learned elsewhere and fed into its first layer as the input.

As revealed by above literature overview, a deep hashing method which simultaneously learns the features and hash codes remains missing in this research field, which inspires our work. The key contributions of this work include:

We propose the first deep hashing algorithm of its kind, which performs concurrent feature and hash function learning over a unified network.

We investigate the key pitfalls in designing such deep networks. Particularly, there are two major obstacles: the gradient calculation from non-differentiable binary hash codes, and network pre-training in order to eventually stay at a "good" local optimum. To address the first issue, we propose an exponentiated hashing loss function and devise its bilinear smooth approximation. Effective gradient calculation and propagation are thereby enabled. Moreover, an efficient pre-training scheme is also proposed. We verify its effectiveness through comprehensive evaluations on real-world visual data.

The proposed deep hashing method establishes new performance records on four image benchmarks which are widely used in this research area. For instance, on the CIFAR10 dataset, our method achieves a mean average precision of 0.73 for Hamming ranking based image search, which represents some drastic improvement compared with the state-of-the-art methods (0.58 for [\cite=LaiPLY15] and 0.36 for  [\cite=liuw12]).

The Proposed Method

Throughout this paper we will use bold symbols to denote vectors or matrices, and italic ones for scalars unless otherwise instructed. Suppose a data set [formula] with supervision information is provided as the input. Prior works on supervised hashing have considered various forms of supervision, including triplet of items [formula] where the pair [formula] is more alike than the pair [formula] [\cite=mu10] [\cite=norouzi12] [\cite=LaiPLY15], pairwise similar/dissimilar relations [\cite=liuw12] or specifying the label of each sample. Observing that triplet-type supervision incurs tremendous complexity during hashing function learning and semantic-level sample labels can be effortlessly converted into pairwise relations, hereafter the discussion focuses on supervision in pairwise fashion. Let S, D collect all similar / dissimilar pairs respectively. For notational convenience, we further introduce a supervision matrix [formula] as

[formula]

Figure [\ref=fig:network] illustrates our proposed pipeline of learning a deep convolutional network for supervised hashing. The network is comprised of two components: a topmost layer meticulously-customized for the hashing task and other conventional layers. The network takes a p  ×  q-sized images with c channels as the inputs. The K neurons on the top layer output either -1 or 1 as the hash code. Formally, each top neuron represents a hashing function [formula], where [formula] denotes the 3-D raw image. For notational clarity, let us denote the response vector on the second topmost layer as [formula], where φ(  ·  ) implicitly defines the highly non-linear mapping from the raw data to a specified intermediate layer.

For the topmost layer, we adopt a simple linear transformation, followed by a signum operation, which is formally presented as

[formula]

The reminder of this section firstly introduces the hashing loss function and the calculation of its smoothed surrogate in Section [\ref=subsec:loss]. More algorithmic details of our proposed pretraining-finetuning procedure are delivered in Section [\ref=subsection:pretrain].

Exponentiated Code Product Optimization

The key purpose of supervised hashing is to elevate the image search accuracy. The goal can be intuitively achieved by generating discriminative hash codes, such that similar data pairs can be perfectly distinguished from dissimilar pairs according to the Hamming distances calculated over the hash codes. A number of hashing loss functions have been devised by using above design principal. In particular, Norouzi et al. [\cite=NorouziF11] propose a hinge-like loss function. Critically, hinge loss is known to be non-smooth and thus complicates gradient-based optimization. Two other works [\cite=liuw12] [\cite=LinSSHS14] adopt smooth L2 loss defined on the inner product between hash codes.

It largely remains unclear for designing optimal hashing loss functions in perceptron-like learning. The major complication stems from the discrete nature of hash codes, which prohibits direct gradient computation and propagation as in typical deep networks. As such, prior works have investigated several tricks to mitigate this issue. Examples include optimizing a variational upper bound of the original non-smooth loss [\cite=NorouziF11], or simply computing some heuristic-oriented sub-gradients [\cite=LaiPLY15]. In this work we advocate an exponential discrete loss function which directly optimizes the hash code product and enjoys a bilinear smoothed approximation. Compared with other alternative hashing losses, here we first show the proposed exponential loss arguably more amenable for mini-batch based iterative update and later exhibit its empirical superiority in the experiments.

Let [formula] denote K hash bits in vector format for data object [formula]. We also use the notations [formula], [formula] to stand for bit k of [formula] and the hash code with bit k absent respectively. As a widely-known fact in the hashing literature [\cite=liuw12], code product admits a one-to-one correspondence to Hamming distance and comparably easier to manipulate. A normalized version of code product ranging over

[formula]

Two-Stage Supervised Pre-Training

Deep hashing algorithms (including ours) mostly strive to optimize pairwise (or even triplet as in [\cite=LaiPLY15]) similarity in Hamming space. This raises an intrinsic distinction compared with conventional applications of deep networks (such as image classification via AlexNet [\cite=KrizhevskySH12]). The total count of data pairs quadratically increases with regard to the training sample number, and in conventional applications the number of atomic losses in the objective only linearly grows. This entails a much larger mini-batch size in order to combat numerical instability caused by under-sampling, which unfortunately often exceeds the maximal memory space on modern CPU/GPUs.

We adopt a simple two-stage supervised pre-training approach as an effective network pre-conditioner, initializing the parameter values in the appropriate range for further supervised fine-tuning. In the first stage, the network (excluding the hashing loss layer) is concatenated to a regular softmax layer. The network parameters are learned through optimizing the objective of a relevant semantics learning task (, image classification). After stage one is complete, we extract the neuron outputs of all training samples from the second topmost layer (, the variable [formula]'s in Section [\ref=subsec:loss]), feed them into another two-layer shallow network as shown in Figure [\ref=fig:network] and initialize the hashing parameters [formula], [formula]. Finally, all layers are jointly optimized in a fine-tuning process, minimizing the hashing loss objective Q. The entire procedure is illustrated in Figure [\ref=fig:network] and detailed in Algorithm [\ref=alg:deephash].

Experiments

This section reports the quantitative evaluations between our proposed deep hashing algorithm and other competitors.

Description of Datasets: We conduct quantitative comparisons over four image benchmarks which represent different visual classification tasks. They include MNIST for handwritten digits recognition, CIFAR10 which is a subset of 80 million Tiny Images dataset and consists of images from ten animal or object categories, Kaggle-Face, which is a Kaggle-hosted facial expression classification dataset to stimulate the research on facial feature representation learning, and SUN397 [\cite=xiaoj10] which is a large scale scene image dataset of 397 categories. Figure [\ref=fig:example] shows exemplar images. For all selected datasets, different classes are completely mutually exclusive such that the similarity/dissimilarity sets as in Eqn ([\ref=eqn:y]) can be calculated purely based on label consensus. Table [\ref=table:data] summarizes the critical information of these experimental data, wherein the column of feature dimension refers to the neuron numbers on the second topmost layers (, dimensions of feature vector [formula]).

Implementation and Model Specification: We have implemented a substantially-customized version of the open-source Caffe [\cite=Jia13caffe]. The proposed hashing loss layer is patched to the original package and we also largely enrich Caffe's model specification grammar. Moreover, To ensure that mini-batches more faithfully represent the real distribution of pairwise affinities, we re-shuffle the training set at each iteration. This is approximately accomplished by using the trick of random skipping, namely skipping the next few samples in the image database after adding one into the mini-batch.

We designate the network layers for each dataset by referring to Caffe's model zoo [\cite=Jia13caffe]. Table [\ref=table:net] presents the deep network structure used for Kaggle-Face. The non-linear transform layers (, RELU and local normalization layers) are ignored due to space limit. Specifically, the softmax layer is used only for pre-training the first 7 layers and not included during fine-tuning. We provide the network configuration information in the format of Caffe's grammar in the supplemental material.

Baselines and Evaluation Protocol: All the evaluations are conducted on a large-scale private cluster, equipped with 12 NVIDIA Tesla K20 GPUs and 8 K40 GPUs. We denote the proposed algorithm as DeepHash. On the chosen benchmarks, DeepHash is compared against classic or state-of-the-art competing hashing schemes, including unsupervised methods such as random projection-based LSH [\cite=charikar02], PCAH, SH [\cite=WeissTF08], ITQ [\cite=GongLGP13], and supervised methods like LDAH [\cite=Strecha12], MLH [\cite=NorouziF11], BRE [\cite=BRE], and KSH [\cite=liuw12]. LSH and PCAH are evaluated using our own implementations. For the rest aforementioned baselines, we thank the authors for publicly sharing their code and adopt the parameters as suggested in the original software packages. Moreover, to make the comparisons comprehensive, four previous deep hashing algorithms are also contrasted, denoted as DH-1 and DH[formula]-1 from [\cite=XiaPLLY14], DH-2 [\cite=LiongLWMZ15], and DH-3 [\cite=LaiPLY15]. Since the authors do not share the source code or model specifications, we instead cite their reported accuracies under identical (or similar) experimental settings.

Importantly, the performance of a hashing algorithm critically hinges on the semantic discriminatory power of its input features. Previous deep hashing works [\cite=XiaPLLY14] [\cite=LaiPLY15] use traditional hand-crafted features (, GIST and SIFT bag-of-words) for all baselines, which is not an optimal setting for fair comparison with deep hashing. To rule out the effect of less discriminative features, we strictly feed all baselines (except for four deep hashing algorithms from [\cite=XiaPLLY14] [\cite=LiongLWMZ15] [\cite=LaiPLY15]) with features extracted from some intermediate layer of the corresponding networks used in deep hashing. Specifically, after the first supervised pre-training stage in Algorithm [\ref=alg:deephash] is completed, we re-arrange the neuron responses on the layer right below the hashing loss layer (, layer #7 in Table [\ref=table:net]) into vector formats (namely the variable [formula]'s) and feed them into baselines.

All methods share identical training and query sets. After the hashing functions are learned on the training set, all methods produce binary hash codes for the querying data respectively. There exist multiple search strategies using hash codes for image search, such as hash table lookup [\cite=andoniI08] and sparse coding style criterion [\cite=LinSSHS14]. Following recent hashing works, we only carry out Hamming ranking once the hashing functions are learned, which refers to the process of ranking the retrieved samples based on their Hamming distances to the query. Under Hamming ranking protocol, we measure each algorithm using both mean-average-precision (mAP) scores and precision-recall curves.

Investigation of Hamming Ranking Results: Table [\ref=table:map1] and Figure [\ref=fig:ap] show the mAP scores for our proposed DeepHash algorithms (with supervised pre-training and fine-tuning) and all baselines. To clearly depict the evolving accuracies with respect to the search radius, Figure [\ref=fig:pr] displays the precision-recall curves for all algorithms with 32 hash bits. There are three key observations from these experimental results that we would highlight:

1) On all four datasets, our proposed DeepHash algorithm significantly perform better than all baselines in terms of mAP. For all non-deep-network based algorithm, KSH achieves the best accuracies on MNIST, CIFAR10 and Kaggle-Face, and ITQ shows top performances on SUN397. Using 48 hash bits, the best mAP scores obtained by KSH or ITQ are 0.9817, 0.5482, 0.4132, and 0.0471 on MNIST / CIFAR10 / Kaggle-Face / SUN397 respectively. In comparison, our proposed DeepHash performs nearly perfect on MNIST (0.9938), and defeat KSH and ITQ by very large margins, scoring 0.7410, 0.5615, and 0.1293 on other three datasets respectively.

2) We also include four deep hashing algorithms by referring to the accuracies reported in the original publications. Recall that the evaluations in [\cite=XiaPLLY14] [\cite=LaiPLY15] feed baseline algorithms with non-CNN features (, GIST). Interestingly, our experiments reveal that, when conventional hashing algorithms take CNN features as the input, the relative performance gain of prior deep hashing algorithms becomes marginal. For example, under 48 hash bits, KSH's mAP score 0.5482 is comparable with regard to DH-3's 0.581. We attribute the striking superiority of our proposed deep hashing algorithm to the importance of jointly conducting feature engineering and hash function learning (, the fine-tuning process in Algorithm [\ref=alg:deephash]).

3) Elevating inter-bit mutual complementarity is overly crucial for the final performance. For those methods that generate hash bits independently (such as LSH) or by enforcing performance-irrelevant inter-bit constraints (such as LDAH), the mAP scores only show slight gains or even drop when increasing hash code length. Among all algorithms, two code-product oriented algorithm, KSH and our proposed DeepHash, show steady improvement by using more hash bits. Moreover, our results also validate some known insights exposed by previous works, such as the advantage of supervised hashing methods over the unsupervised alternatives.

Effect of Supervised Pre-Training: We now further highlight the effectiveness of the two-stage supervised pre-training process. To this end, in Table [\ref=table:finetune] we show the mAP scores achieved by three different strategies of learning the network parameters. The scheme "DeepHash (random init.)" refers to initializing all parameters with random numbers without any pre-training. A typical supervised gradient back-propagation procedure as in AlexNet [\cite=KrizhevskySH12] is then used. The second scheme "DeepHash (pre-training)" refers to initializing the network using two-stage pre-training in Algorithm [\ref=alg:deephash], without any subsequent fine-tuning. It serves as an appropriate baseline for assessing the benefit of the fine-tuning process as in the third scheme "DeepHash (fine-tuning)". In all cases, the learning rate in gradient descent drops at a constant factor (0.1 in all of our experiments) until the training converges.

There are two major observations from the results in Table [\ref=table:finetune]. First, simultaneous tuning all the layers (including the hashing loss layer) often significantly boosts the performance. As a key evidence, "DeepHash (random init.)" demonstrates prominent superiority on MNIST and CIFAR10 compared with "DeepHash (pre-training)". The joint parameter tuning of "DeepHash (random init.)" is supposed to compensate the low-quality random parameter initialization. Secondly, positioning the initial solution near a "good" local optimum is crucial for learning on challenging data. For example, the dataset of SUN397 has as many as 397 unique scene categories. However, due to the limitation of GPU memory, even a K40 GPU with 12GB memory only support a mini-batch of 600 samples at maximum. State differently, each mini-batch only comprises 1.5 samples per category on average, which results in a heavily biased sampling towards the pairwise affinities. We attribute the relatively low accuracies of "DeepHash (random init.)" to this issue. In contrast, training deep networks with both supervised pre-training and fine-tuning (, the third scheme in Table [\ref=table:finetune]) exhibit robust performances over all datasets.

Comparison with Hand-Crafted Features: To complement a missing comparison in other deep hashing works [\cite=XiaPLLY14] [\cite=LiongLWMZ15] [\cite=LaiPLY15]), we also compare the hashing performance with conventional hand-crafted features and CNN features extracted from our second topmost layers. Following the choices in relevant literature, we extract 800-D GIST feature from CIFAR10 images, and 5000-D DenseSIFT Bag-of-Words feature from SUN397 images. The comparisons under 16 and 32 hash bits are found in Table [\ref=table:nondeepfeature], exhibiting huge performance gaps between these two kinds of features. It clearly reveals how the feature quality impacts the final performance of a hashing algorithm, and a fair setting shall be established when comparing conventional and deep hashing algorithms.

Concluding Remarks

In this paper a novel image hashing technique is presented. We accredit the success of the proposed deep hashing to the following aspects: 1) it jointly does the feature engineering and hash function learning, rather than feeding hand-crafted visual features to hashing algorithms, 2) the proposed exponential loss function excellently fits the paradigm of mini-batch based training and the treatment in Eqn. ([\ref=eqn:alossapprox]) naturally encourages inter-bit complementarity, and 3) to combat the under-sampling issue in the training phase, we introduce the idea of two-stage supervised pre-training and validate its effectiveness by comparisons.

Our comprehensive quantitative evaluations consistently demonstrate the power of deep hashing for the data hashing task. The proposed algorithm enjoys both scalability to large training data and millisecond-level testing time for processing a new image. We thus believe that deep hashing is promising for efficiently analyzing visual big data.

Appendix: Network Configurations

Tables [\ref=table:net_mnist]-[\ref=table:net_sun397] present the configurations of the deep networks used for selected benchmarks. The non-linear transform layers are majorly ReLU (rectified linear unit) and LRN (local response normalization). Specifically, the softmax layers are used only for pre-training the convolutional/innerProduct layers and not included during fine-tuning, which are thus not enumerated in these tables.