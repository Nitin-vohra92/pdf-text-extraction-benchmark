Near Memory Similarity Search on Automata Processors

Introduction

The growth of media content combined with advances in NLP, vision, and robotics has catalyzed the growth and demand for applications such as document retrieval [\cite=document_distances] [\cite=tandon13], content-based search, and deduplication [\cite=dedup]. In 2010, Internet users had shared more than 260 billion images on Facebook [\cite=facebook-photos], and by 2014, uploaded upwards of 300 hours of YouTube per minute [\cite=youtube-statistics]. Furthermore, the rate of multimedia content creation and consumption is projected to grow exponentially [\cite=rebooting-the-it-revolution].

To make these volumes of data searchable, applications rely on similarity search which is embodied as the k-nearest neighbors algorithm [\cite=google-images] [\cite=facebook-search]. The kNN algorithm consists of many parallelizable distance calculations and a single global top-k sort. While computationally very simple, scaling kNN beyond a single node is challenging as the algorithm is memory bound in both CPUs and GPUs. While distance calculations are cheap and highly parallelizable across the dataset, moving feature vector data from memory to the compute device is a huge bottleneck. Moreover, this data is used only once per kNN query and discarded, and the result of a kNN query is only a handful of identifiers. In order to amortize data movement cost, queries are typically batch processed which has intrinsic limitations when constrained to meet tight latency targets.

Because of its significance, generality, parallelism, simplicity, and small result set, kNN is an ideal candidate for near data processing. The key insight is that by exploiting higher bandwidths and applying large data reductions near memory, we can substantially reduce data movement requirements over interconnects such as PCIe. There have been many proposals for processing in memory (PIM) in the past [\cite=McKee95] [\cite=iram] [\cite=flexram] [\cite=DIVA] [\cite=impulse] [\cite=activepages]. In this paper, we evaluate kNN on the Micron Automata Processor (AP), a recent PIM architecture for high speed automata evaluation. Most prior work on the AP has focused on the domain of high speed pattern mining such as biological motif search [\cite=ap-motif-search], frequent itemset mining [\cite=ap-apriori], and Brill tagging [\cite=ap-brill-tagging]. Other work has also highlighted how to use the AP for solving graph problems [\cite=ap-graph].

In contrast, our work is the first to explore and evaluate similarity search on the AP which presents unique design and implementation challenges. We propose a novel nondeterministic finite automata design for kNN using temporal encodings and show current generation hardware can achieve 52.6×   performance over current multicore processors. We also evaluate AP performance and energy efficiency against competing FPGA and GPU solutions (NVIDIA Tegra Jetson K1 GPU, NVIDIA Titan X GPU, and Xilinx Kintex-7 FPGA). We then propose mutually orthogonal optimization techniques and architectural extensions which can yield an additional 73.6×   performance improvement making the AP a competitive alternative to existing heterogeneous computing substrates.

Our work makes the following contributions:

A novel automata design for kNN codesigned with the AP architecture which solves kNN in linear time with dimensionality as opposed to linear time with both dimensionality and cardinality by exploiting a temporally encoded sort.

A comprehensive energy efficiency and performance comparison of the AP against contemporary heterogeneous computing platforms such as FPGAs and GPUs.

Hardware/software codesign to leverage the AP to implement approximate variants of kNN.

Optimization techniques to reduce the resource footprint and improve the throughput of kNN on future generation APs.

Simple architectural extension recommendations to augment the capabilities and efficiency of the AP architecture.

The rest of the paper is organized as follows. In Section [\ref=sec:background], we provide background on the AP and outline the kNN algorithm. Section [\ref=sec:automata-design] presents the kNN automata design for the AP and Section [\ref=sec:methodology] outlines our evaluation methodology. Section [\ref=sec:evaluation] highlights performance and energy efficiency results. Section [\ref=sec:optimizations] presents design optimization techniques, and Section [\ref=sec:analysis] proposes simple architectural extensions. Finally, Section [\ref=sec:related-work] highlights related work and we conclude in Section [\ref=sec:conclusion].

Background

k-nearest neighbors

Similarity search: Performing similarity search between a query and a dataset of candidate vectors is done through k-nearest neighbors (kNN), and consists of distance calculations and global top-k sorting (Algorithm [\ref=knn_algorithm]). Intuitively, the goal of kNN is to find the closest neighbors for a query vector against a set of candidate vectors in a database.

A query/candidate vector pair is considered more similar if the metric space distance between them is smaller. For instance, two images in content-based search [\cite=content_based_search] are considered more similar if the distance between their feature vectors is smaller. Image feature vectors are generated using descriptors like SIFT [\cite=Lowe2004SIFT], SURF [\cite=Bay2008SURF], or using convolutional neural networks (CNNs) [\cite=AlexNet2012]. The exact kNN algorithm scans through the dataset for each query/candidate pair resulting in a total complexity of O(qnd) where q is the number of query vectors, n is the number of dataset vectors, and d is the vector dimensionality. The algorithm presents two opportunities to exploit parallelism: query level parallelism where multiple queries are batch processed, and data level parallelism where multiple dataset vectors are processed in parallel for a single query.

Approximate variants of kNN employ spatial indexing structures to trade off accuracy for run time by using heuristics to prune the search space. We consider three approximate kNN algorithms: randomized kd-trees, hierarchical k-means, and locality sensitive hashing [\cite=flann] [\cite=lsh]. In randomized kd-trees, the dataset is indexed across multiple parallel trees which each partition the dataset based on dimensions with highest variance. The index structure size scales exponentially with depth so the height of the tree is often constrained. Each leaf in the tree is associated with a bucket of candidate points where a linear kNN scan of the bucket is applied to compute the result. Similarly, hierarchical k-means generates an index by hierarchically partitioning the dataset into clusters. Unlike randomized kd-trees, traversing the k-means index requires a distance calculation at each node to determine the next traversal. Again each leaf in the index represents a bucket of candidate points which is scanned linearly after the traversal. Finally, locality sensitive hashing (LSH) uses a set of hash functions to put similar query vectors into the same bucket (buckets are again linearly scanned) [\cite=lsh].

Binary quantization: Automata processors do not have hardened arithmetic units so implementing Euclidean distance is inefficient. Instead, we subset our design space by evaluating Hamming distances which maps well to the AP. Real valued vectors can be converted to Hamming space by applying techniques like iterative quantization (ITQ) [\cite=gong2011ITQ]. Some information embedded in the features is lost as quantization narrows the possible dynamic range of feature values; however, in practice Hamming codes have been shown to be a viable alternative to Euclidean space representations [\cite=Gionis:1999:SSH:645925.671516] [\cite=LSH_Lazebnik] [\cite=LDAHash] [\cite=Torralba08smallcodes] [\cite=Wang:2012:SHL:2412384.2412893] [\cite=Spectral_Hashing] [\cite=facebook-search]. For our analysis, we assume dataset vectors are already quantized offline using ITQ removing this process from the critical path of the kNN kernel.

Micron Automata Processor

Hardware architecture: The AP is a non-von Neumann architecture which uses a non-deterministic finite automata (NFA) driven execution model [\cite=MAP]; the system architecture is shown in Figure [\ref=system-architecture]. A typical AP device is composed of four ranks which each consist of eight automata processors which are each further subdivided into two half cores (AP core). Each half core is composed of 96 AP blocks and each block contains 256 state transition elements (STEs); this results in a maximum of 24576 STEs per half AP core or 1572864 STEs per board. In the context of an NFA, one STE is responsible for implementing one state in the NFA. Since NFAs cannot span AP cores, the maximum sized automata that can be implemented is limited to 24576 states.

A central reconfigurable routing matrix (not shown) is responsible for connecting STEs to implement different NFAs. In addition to STEs, each AP block contains four counters, 12 boolean elements, and a maximum of 32 reporting STEs. Counters have an increment-by-one and reset port which resets the counter whenever an upstream state connected to the reset port is active. Counters are always programmed to user specified threshold values and activate down stream states if the internal count exceeds this static threshold; counters cannot be incremented by more than one and do not expose internal count values. Finally, each AP block contains boolean elements which can each be programmed to function as any standard two input logic gate.

Programming model: To program the AP, applications must be converted to equivalent NFAs expressed in terms of NFAs, counters, and boolean elements. Applications can either be compiled to NFAs by supplying a Perl Compatible Regular Expression (PCRE), or an XML based Automata Network Markup Language (ANML) file containing the NFA specification. For applications that cannot be easily expressed as PCREs, the programmer must specify an ANML file. The primary strength of the AP architecture is its capacity for high internal bandwidth and parallel computing; to fully harness this compute and bandwidth, it is ideal to instantiate many NFAs in parallel.

Each state in the NFA is associated with an 8-bit symbol or set of 8-bit symbols which is defined by a PCRE. A state is activated when the input symbol matches the symbol set associated with it and any previous state connected to it is active on the previous time step. The sequence of symbols is driven by a symbol stream from the host processor; NFA state activations themselves cannot be combined to form a new symbol stream from inside the AP. Each NFA also has specially designated start states and reporting states which are used to initiate state activations and return results from the AP respectively. Start states do not need an upstream state to be active when matching the input symbol, and activate whenever the input symbol matches its symbol set. Reporting states generate a signal which returns a unique identification number associated with it, and the offset (i.e. cycle count) within the symbol stream at which the state was activated. This information is then used by a host processor application to resolve the result of the calculation.

System integration: An AP device interfaces to a host processor over a PCIe x8 Gen 3 interface much like a GPU or FPGA. The host processor is responsible for configuring the device, driving the symbol streams, and processing the signals generated by the reporting states. Typically a host processing application will use provided APIs to operate the AP.

AP Design Constraints

Arithmetic operations are inefficient: The AP fabric does not contain hardened arithmetic units precluding Euclidean distance [\cite=ap-technode]. While STEs can be treated as lookup tables, implementing arithmetic units with lookup tables is inefficient and difficult to program. On the other hand, Hamming distance and Jaccard similarity on the AP is well documented and can be efficiently implemented [\cite=ap-hamming-distance].

No nested finite automata: The programming model for the AP assumes that the symbol stream that drives NFAs is provided exclusively by an external host processor. This means, state activations or output values from an NFA cannot be combined to dynamically form a symbol stream to drive another nested NFA.

Symbol streams cannot be dynamically modified: The external symbol streams that drive the NFAs in the AP cannot be modified so symbol streams must be defined statically before being streamed into the AP. This eliminates the possibility of feedback interactions between the NFAs and the symbol stream, making constructs such as dynamically inserting a reset symbol into the symbol stream impossible.

Automata Design

We now present our automata design for Hamming distance kNN guided by the insights and constraints outlined in Section [\ref=sec:background]. Our design is subdivided into two components: Hamming macros for distance calculations and sorting macros to sort distance scores.

Hamming Macros

The distance calculations in kNN exhibit abundant data parallelism and is an excellent match for the AP. In von-Neumann architectures, typically the dataset vectors are streamed from memory and the number of calculations performed is limited by the rate at which vectors can be streamed from memory; for n vectors each with d dimensions this takes O(nd) time to complete the distance calculations. For the AP we instead stream the queries to the dataset vectors encoded in NFAs on the AP and perform comparisons against all candidate vectors in parallel much like a ternary content addressable memory (TCAM). This allows the AP to exploit the theoretical maximal degree of data parallelism in the context of kNN and reduces the run time to O(d) per distance calculation; the only limitation is the number of spatial resources required to implement the large number of parallel automata.

We instantiate one Hamming macro per vector in the dataset as shown in boxed portion of Figure [\ref=full-hamming-macro]a; each Hamming macro computes the "inverted Hamming distance" or the number of dimensions minus the Hamming distance. In effect, it measures the similarity between the feature vector and the query. Each Hamming macro encodes a unique feature vector from the dataset and operates in parallel with all other Hamming macros. Since Hamming macros can be replicated arbitrarily, the factor of parallelism we can achieve is only limited by the capacity of the AP.

The Hamming macro is composed of a guard state, compute states, and collector states. The guard state is a designated start state which is responsible for detecting the start of file (SOF) symbol demarcating the start of an input query vector and protects the rest of the NFA from unintentional state activations. The compute states are composed of a sequence of ternary states and matching states; each matching state activates when the input query vector value matches for the dimension in the encoded dataset vector.

In order to compute the inverted Hamming distance, states which correspond to matches are first fed into one or more collector states which effectively function as a large OR reduction. The collector states then drive a counter which we will refer to as a inverted Hamming distance counter in the sorting macro which keeps track of how many matches occurred. For larger dimensional vectors we implement the collector states as a reduction tree using ternary states to limit the maximum state fan in and improve routability.

Sorting Macros

The second phase of kNN consists of distilling the distance scores across every element in the dataset to the top k neighbors. Typically on von-Neumann architectures this is achieved using priority queue insertions or alternative sorting algorithms like k-selection, and takes O(n log n) time per query. For the AP, this must be conveyed using the activation signals from reporting states which consist of the unique state ID that can be mapped back to the feature vector, and the cycle offset into the symbol stream on which the state activated. Furthermore, the sorting latency must be comparable to that of the Hamming macros otherwise it will dominate execution time.

We use a temporally encoded sort by combining the concepts of temporal encodings [\cite=race-logic] and spaghetti sort [\cite=spaghetti-sort] as shown in Figure [\ref=race-sort] yielding an O(d) time sort. The key insight is that vectors with lower Hamming distances have a higher inverted Hamming distance score. To sort the vectors across the dataset in parallel, we uniformly increment the inverted Hamming distance counters until they reach a static threshold equal to the vector dimensionality + 1; we use the pulse mode on the counter so that when the threshold is reached, a single cycle pulse is emitted from the counter. Hamming macros which are most similar to the query vector or have a higher inverted Hamming distance will trigger reporting state activations first; this means the temporal order of state activations amounts to the order of vector IDs sorted by increasing Hamming distance. Note that the total number of cycles required to perform this temporally encoded sort is equal to the number of vector dimensions making the latency of the sort the same as the latency of the Hamming macro.

In order to support the temporal sort, a sorting macro shown in Figure [\ref=full-hamming-macro]b must be appended to the Hamming macro. To provide time for the sort to execute we pad the symbol stream with filler symbols (EOF) for d cycles (Figure [\ref=full-hamming-macro]c). A sort state is responsible for waiting until an end of file (EOF) symbol is detected before triggering the EOF state which resets the counter. The sort state also doubles as an unconditional increment signal for the inverted Hamming distance counter to perform the temporally encoded sort. A reporting state after the counter is responsible for reporting at which offset the inverted Hamming distance counter exceeded the threshold and the unique state ID assigned to that reporting state. The unique state ID is used to reverse lookup which dataset vector it corresponds to before returning the result.

Partial Reconfiguration

The STE resources required by our design scales both with the number of dataset vectors and dimensions. This means the capacity of the AP limits the total number of vectors that can be processed per configuration. To scale to arbitrarily large datasets, we exploit the reconfiguration capability of the AP which allows the fabric to be reconfigured much like dynamic reconfiguration on an FPGA. We assume these additional configurations are precompiled into a set of board images. Once the queries are streamed through the first portion of the dataset, a reconfiguration prepares the AP with the next portion of the dataset until all of the data is processed. This requires the host processor to also keep track of intermediary results per query across board reconfigurations as sort results are computed. Current generation APs (Gen 1) require 45 ms [\cite=ap-apriori] per reconfiguration but next generation APs (Gen 2) are projected to have at least two orders of magnitude improvement (≈  100x) [\cite=ap-personal].

Implementing Spatial Indexing Structures

So far our automata design has been constrained to implementing linear kNN search. While some index traversals are possible to offload to the board by prepending an indexing macro to each Hamming macro, it is more efficient to factor the index traversal out to the host processor in software. This is because the AP is a spatial architecture so every Hamming macro would have to evaluate whether it is part of the search space making a vast majority of the traversals unnecessary and no better than linear search. Instead, the host processor can traverse the index and pick which set of vector macros to load and query. This modification is synergistic with our design so far since the number of dataset vectors supported by each AP board configuration naturally provides a bucket size limit for each indexing technique. Finally, by offloading index traversal to the host processor, we can also support any arbitrary spatial indexing structure.

Evaluation Methodology

To evaluate the performance and energy efficiency gains of the AP, we compare against an Intel Xeon E5-2620, ARM Cortex A15, NVIDIA Tegra Jetson K1, NVIDIA Titan X, and Xilinx Kintex 7 (Table [\ref=evaluated-platforms]). The next few sections outline our methodology used to compare run time, and energy efficiency for each platform.

Workload Parameters

The run time of our NFA design scales with dimensionality so we select several different feature vector lengths. Practical vector dimensionality for feature descriptors like Speeded Up Robust Features (SURF) [\cite=surf], word embeddings [\cite=document-distances], Scale Invariant Feature Transform (SIFT) [\cite=sift], and semantic embeddings [\cite=tagspace] are shown to range from 64 to 256; higher dimensional feature descriptors like those produced by AlexNet [\cite=alexnet] can be reduced using techniques like principle component analysis [\cite=pca]. Past literature also shows the number of nearest neighbors k range anywhere between 1 (exclusively nearest neighbor) and 20 [\cite=lowe-ratio-test] [\cite=document-distances] [\cite=motion-planning] [\cite=how-many-results]. The parameter sets we choose to evaluate are shown in Table [\ref=knn-parameters] for 4096 queries.

Micron Automata Processor

To estimate the performance of the AP, we simulate the design using the AP SDK 1.7.26 since full AP driver stacks at the time of writing are not available. We implemented our designs in ANML, validated our design using the AP Workbench, and ran placement and route for each design to obtain resource utilization and frequency estimates. We assume that the host processing program can operate concurrently (non-blocking API calls) with the AP much like how a CUDA program offloads to GPUs. Since datasets in kNN applications are typically static, we do not include compile times since compilation can be done offline. To estimate power, we connect a power meter to single rank AP, and measure real static and load power consumption; the dynamic power is computed as the average load minus average static power and scaled up to reflect a four rank device. To estimate energy consumption for the AP we take the simulated run time and multiply by the measured dynamic power. We then apply linear scaling factors to normalize the 50 nm AP process technology [\cite=ap-technode] to match the 28 nm lithographies of the CPU, GPU, and FPGA devices.

CPU, GPU, and FPGA

For our CPU baseline, we use the Fast Library for Approximate Nearest Neighbors (FLANN) [\cite=flann] to run time and energy efficiency for our baselines. For our GPU baseline, we use a modified off-the-shelf CUDA implementation [\cite=gpu-knn]. Run time is recorded as wall clock time and dynamic power is measured using a power meter by taking the difference between the load and idle power. Energy consumption is estimated by multiplying dynamic power by run time. To benchmark indexing times for spatial data structures, we use custom implementations and the ITQ LSH implementation provided by LSHBOX [\cite=lshbox]. For simplicity, we use four hash tables for LSH and four randomized kd-trees; for kd-trees and k-means each tree traversal checks one bucket.

To compare against FPGAs, we implement a configurable AXI4-Stream compliant core in Verilog for a Xilinx Kintex-7-325T. The core consists of a scratchpad for queries and parameters, distance unit, and priority queue, and processes multiple queries in parallel; data vectors are streamed to through the core, once per batch of queries. We use Vivado 2014.4 to synthesize, place, and route the design, and report the estimated post-placement and route power using worst case activity factors. To estimate run time, we simulate the design using the Vivado simulator.

Results

Resource Utilization

We first evaluate resource utilization since the number of vectors that can be processed per board configuration will affect AP performance. We report the total rectangular block area based on the post-placement and route utilization reports generated by the apadmin tool. For each of our parameter sets kNN-WordEmbed, kNN-SIFT, and kNN-TagSpace, we observe resource utilizations of 41.7%, 90.9%, and 78.6% of the total resource capacity respectively. This equates to 128 Kb of encoded data before exceeding board capacities of current generation APs (1024 x 128 dimensions or 512 x 256 dimensions). Finally we note that resource utilization does not depend on the number of neighbors k since sorting does not require additional scratch space.

Run Time Performance

We now compare the run time performance of the AP relative to other competing platforms is shown in Figure [\ref=small-perf-results] and Figure [\ref=large-perf-results] for a small dataset (512-1024 points) and large dataset (220  ≈  1 million points) respectively. We evaluate using a small dataset to illustrate the performance of the AP without the need for reconfiguration, and contrast it to the performance when the dataset size exceeds the capacity of a single AP board. For the small dataset, the AP can achieve an order of magnitude performance improvement over competing CPU solutions for datasets that fit on one board configuration (512-1024 points). This performance improvement can be attributed to a combination of the parallel processing capacity of the AP, and the temporally encoded sort which dramatically lowers the run time of the sorting step from O(n log n) to O(d). We observe poor GPU performance likely due to poor blocking of the binarized data; since vectors are quantized to be 32 times smaller, the finer grained memory accesses become less optimal for our off-the-shelf baseline. For the larger dataset, the performance of the current generation AP (Gen 1) degrades dramatically due to dynamic reconfiguration overheads which account for upwards of 98% of the execution time. To quantify the impact of this bottleneck, we provide a second estimate with second generation AP reconfiguration latencies (AP Gen 2) which are projected to be ≈  100×   better. We also show the projected performance of the AP with the optimization techniques and architectural extensions presented in Section [\ref=sec:optimizations] and  [\ref=sec:analysis] (AP Opt + Ext). Our analytical model shows that the two orders of magnitude improvement in reconfiguration time will yield more than an order of magnitude performance improvement (19.4×  ) between Gen 1 and Gen 2, and shifts the bottleneck back to the computation.

We now evaluate and compare the efficacy of spatial indexing techniques relative to equivalent CPU baselines. Since AP driver stacks are unavailable, we use an analytical model to estimate AP run time by benchmarking the index traversals on the CPU, and adding it to estimated AP reconfiguration and simulated run time. In our model, we batch searches to the same bucket where possible and report the average run time over several iterations; each bucket size is set to the capacity of one AP board configuration (512-1024 points). Decreasing bucket sizes further would not yield run time improvements, underutilize the AP, and unnecessarily lower search accuracy since less data is scanned. Each searched bucket incurs a dynamic reconfiguration penalty so we again evaluate using Gen 1 and Gen 2 reconfiguration times. Figure [\ref=spatial-indexing] shows the relative performance of the AP for indexing techniques compared to single threaded CPU baselines. We generally see similar run time improvements as the linear baseline for the AP; this is because for large buckets, the linear scan dominates execution time over index traversals. We do not expect the AP to provide as substantial improvements with finer grained bucket sizes since a small number of distance calculations would be faster on the CPU.

Energy Efficiency

The estimated energy efficiency of the AP for the small and large datasets are shown in Figure [\ref=small-energy-results] and Figure [\ref=large-energy-results] respectively. Unsurprisingly the Gen 1 AP can provide up to 43×   energy efficiency improvement over general purpose cores and is largely in line with the run time improvements we observe. When compared to production FPGA and GPU platforms, our results show that the Gen 1 AP is severely outperformed due to high reconfiguration overheads. However with Gen 2 reconfiguration times the AP achieves competitive energy efficiency and generally is within one order of magnitude of competing production platforms. With architectural extensions and design optimizations on next generation devices, we expect the AP to surpass even FPGA fabrics in energy efficiency.

Automata Optimization Techniques

We now introduce three mutually orthogonal automata design optimizations: vector packing, symbol stream multiplexing, and statistical activation reduction which can provide substantial improvements in resource utilization efficiency, application throughput, and external bandwidth demands respectively.

Vector Packing

To more efficiently utilized the STE resources, we propose vector packing. The key insight is that Hamming macros share common portions which can be combined by overlaying them over the same base NFA to reduce resource utilization. Figure [\ref=vector-packing] shows how to pack Hamming macros encoding the vectors {1,1,0,1} (Figure [\ref=vector-packing]a) and {1,0,0,0} (Figure [\ref=vector-packing]b) into a single NFA (Figure [\ref=vector-packing]c). We refer to the boxed portion in Figure [\ref=vector-packing]c as a vector ladder that is the base NFA used to pack vectors on to. For each additional vector packed, we instantiate additional collector states, and sorting macros to the appropriate states in the vector ladder. In theory, all dataset vectors can be packed into a single NFA but in practice we are limited by the maximum state in-degree, and maximum NFA size. So instead, vectors are packed until we reach one of these limitations; we then start a new NFA and repeat until all vectors are processed.

We evaluate vector packing by running a microbenchmark which places and routes eight vectors across 32, 64, and 128 dimensions, and compare their resource utilizations shown in Figure [\ref=vector-packing-plot]. The "No Vector Packing" line shows the number of AP blocks used without vector packing. Based on this usage, we use an analytical model to estimate the projected savings with vector packing ("Vector Packed - Theoretical") and compare it to the actual post-place and route results ("Vector Packed - Actual"). Surprisingly, we find that vector packing is ineffective in practice at reducing the resource footprint. We believe this is due to the increased routing pressure and reduced compilation feasibility. For high dimensional and cardinality designs, we find that the compiler has difficulty routing the design since compilations resulted in placed but not routed results. The high routing pressure is most likely due to the vector ladder in designs which introduces many states with high fan outs. However, we expect that in future generation APs and with tool chain maturity, that vector packing will eventually provide viable improvements.

Symbol Stream Multiplexing

Another inefficiency in our automata design is that each state in the vector ladder only responds to effectively one bit (1 or 0) in the symbol stream. However symbol streams are 8 bits wide so processing a single query vector at a time is wasteful. To improve the throughput of the design, the unused bits in the symbol stream can encode additional parallel query vectors which can provide up to an 7×   throughput improvement by exploiting query level parallelism. To support parallel queries, up to seven parallel NFAs for each dataset vector can be instantiated where each NFA PCRE is programmed to process a different bit slice of the symbol stream. We cannot achieve an 8×   improvement because of special symbols like the SOF and EOF.

To discriminate among the bits in the symbol, the STEs can be programmed to effectively perform a ternary match. For instance, an NFA which matches the first bit in the symbol as 1 would require a PCRE corresponding with the ternary match 0b*******1 (with * denoting wildcard bits). This can be achieved by exhaustively encoding all extended ASCII characters which satisfy the ternary match. Similarly, the PCRE for a STE which would match a 0 would express the ternary match for 0b*******0. A similar set of ternary matches can be constructed to discriminate among other bit slices in the stream. Finally, symbol stream multiplexing is an orthogonal modification to vector packing since it only requires duplicating existing NFA structures and replacing STE symbols.

For the current generation of AP, we find that there is neither sufficient resources, nor sufficient external bandwidth to implement stream multiplexing. Replicating the base design 7×   is infeasible since our design already uses 41-91% of the board capacity. Similarly, replicating the number of reporting states 7×   requires in excess of 200 Gbps of external PCIe bandwidth to convey all the activations. However, with future technology scaling, higher board capacities, better PCIe interconnects, and statistical reduction (discussed next), stream multiplexing should become viable.

Statistical Activation Reduction

As the sorting step completes, the AP reports state activation to the host processing unit. We assume the AP communicates state activations by using a bit mask and reporting an offset; the offset indicates which cycle in the symbol stream the activations correspond to. Since activations are often sparse, the bit mask can be compressed by reporting (32 bit) offsets into the mask that are non-zero. For a kNN design that encodes n vectors on the AP, we expect 32  ×  n bits to convey the activations plus 32  ×  d bits to convey the activation time step. A single query (which has a latency of 2d cycles), requires the AP to convey 32  ×  (n  +  d) bits every 2d  *  7.5ns (133 MHz design). This amounts to 36.2, 18.1, and 9.0 Gbps of sustained external bandwidth for kNN-WordEmbed, kNN-SIFT, and kNN-TagSpace respectively which are significant fractions of the PCIe Gen 3 x8 bandwidth (63 Gbps).

Ideally we want to suppress state activations after the top k results from the temporal sort have been communicated. However, dynamically inserting an EOF symbol to reset the automata is not possible (Section [\ref=sec:ap-description]), and building an NFA to generate a global reset signal would couple all NFAs and exceed the maximum NFA size. So instead, we propose a combination of local reductions and statistical guarantees to suppress additional state activations while still providing mostly correct results.

This can be done by first grouping m Hamming and sorting macro pairs together into some set S; for a dataset D this yields R  =  |D| / |S| sets of m macro pairs each. For each set S, we use a counter to track how many state activations have occurred locally. If the global number of desired neighbors is k, for each group of Hamming macros we only report the top k' results where k'  <  k k'  *  R  >  k. This is can be done by resetting all of the inverted Hamming distance counters after k' reporting states have activated within a set of macros shown in Figure [\ref=reduction-macro]. Each of the k' local result sets can then be sorted globally on the host processing unit. The key is that instead of reporting all m state activations per set, we only need to report k' states which provides a bandwidth reduction by a factor of m / k'. For appropriately set values of k', k, and m, the probability that the global result set does not contain the global top k neighbors can be made small. Even for failing cases, the result sets returned by this statistical approximation will be mostly correct.

To determine how much data reduction is achieved without compromising accuracy, we build a statistical model to measure accuracy. For each configuration, we randomly generate dataset and query vectors shown in Figure [\ref=statistical-model] for different values of k', k, and m used in our evaluation. We then perform the vector grouping, local kNN, and global top-k sort to determine whether the result is correct. We repeat this process 100 times to determine statistically how often an incorrect result is returned. Our results show that for reasonable parameters we can achieve good bandwidth reductions and still achieve acceptable result accuracy. Finally, we note that this optimization is synergistic with vector packing since vector packing provides a natural grouping of vectors.

Architecture Extension Recommendations

In this section we present several microarchitectural extension recommendations, discuss their application impact, and briefly evaluate their effect on resource utilization and/or performance on future AP hardware.

Counter Increment Extension

One limitation of the AP is the lack of arithmetic units which limits the space of computation that can be efficiently implemented. In particular, the AP counters limit arithmetic calculations to those that increment by one such as Hamming distance or Jaccard distance. In the context of kNN, allowing the counters to take multiple increment signals would enable processing of multiple vector dimensions in parallel per time step (encodes up to 7 dimensions per symbol). Applying this optimization would preclude stream multiplexing since it uses the higher symbol bits to encode dimensions of the same query instead of the same dimension across queries. This optimization would reduce query latency by roughly 43% since the temporal sort still requires the same number of cycles.

More generally, this modification is useful to reduce the need for collector states when performing reductions or counting multiple activations in parallel. For example, this modification can also enhance the throughput and latency of the apriori frequent item set mining automata presented in [\cite=ap-apriori] to increase the number of dataset vectors processed in parallel for a given itemset. Modifying the 8-bit counters to increment by up to 8 can be done efficiently with a carry save adder but requires 2.8x more two-input gates. However, since the AP fabric contains roughly two orders of magnitude fewer counters than STEs this modification should incur minimal overall area overhead.

Counter Dynamic Threshold Extension

A second counter extension is allowing dynamic counter thresholds; currently counter thresholds are fixed at design compile time which eliminates any way of implementing data dependent dynamic comparisons and control structures. A simple extension is to expose a reconfigurable counter threshold port which can be driven by the internal count of another counter. This can enable computations that require dynamic information as opposed to the static counter threshold currently available in the AP counters. Most notably this modification can be used to build automata constructs that expose arithmetic comparisons between two dynamic values as shown in Figure [\ref=comparison-automata]. This automata can be used to build a more powerful "if (A > B) ... else ..." construct which is more useful than the currently available "if (A > threshold) ... else ...". This extension requires no additional hardware resources and only requires a few additional wires in the routing fabric to accommodate newly exposed internal counts.

STE Decomposition Extension

Another key challenge of the AP fabric is fully utilizing the symbol address space of the STEs. For instance, in the context of kNN, only one bit of information is used by each STE per symbol to determine the state output. This means our kNN automata design is underutilizing an 8-input STE or lookup table effectively as a 1-input lookup table (LUT) since the remaining 7-bits of the symbol do not affect the output. From a resource utilization standpoint this is wasteful; a simple extension is to allow decomposition of STEs in the fabric into multiple smaller STEs.

The key insight is that an 8-input LUT can easily be composed from two smaller 7-input LUTs which can each be further decomposed if necessary (Figure [\ref=ste-decomposition]). We refer to the degree to which an 8-input STE is decomposed as the decomposition factor; for instance, if we use an 8-input LUT as 4 ×   6-input LUTs, the decomposition factor is 4×  . By performing this decomposition, multiple smaller STE units which are underutilized can be packed together allowing significant resources savings. To evaluate this extension, we build an analytical model to estimate savings in the context of kNN (Figure [\ref=knn-ste-savings]). In our analytical model we assume each state in the original automata has a resource cost of one 8-input STE before packing states together. We then estimate how many 8-input STEs would be required if different degrees of STE decomposition are available. For instance, if an 8-input STE can be decomposed into 2 ×   7-input STEs, three states which each only need to see 6 bits of the symbol can be packed in to two 8-input STEs incurring a cost of two. Similarly, these three states can be packed into a single 8-input STE if it can be broken down into 4 ×   6 input STEs incurring a cost of 1. Since the Hamming macro portion of the kNN automata dominates the STE cost, our model shows STE decomposition can provide strong linear reductions in STE resources.

A more general use case for STE decomposition applies to generalized regular expressions; it is not unreasonable to assume that the extended ASCII characters (ASCII values 128-255) frequently remain unused in many PCREs. Since the original ASCII character set consists of only 128 symbols, two 7-bit STEs can be encoded in a decomposed 8-bit STE immediately yielding 2x resource utilization improvement. Practically there is an optimal granularity to which STEs should be decomposed (ex. FPGAs use 6-LUTs) since decomposing STEs indefinitely incurs increased configuration overheads.

Summary

Resource savings on the AP translates directly to performance improvements since more parallel NFAs can be instantiated in parallel. By compounding the mutually orthogonal architectural extensions in this section with automata design optimizations in Section [\ref=sec:optimizations] we estimate that on next generation APs (AP Opt + Ext), we can achieve up to an additional 73.6×   performance throughput for kNN over Gen 2 improvements (Figure [\ref=large-perf-results]). The additional compute density from technology scaling incurs power overheads so we expect the energy efficiency to only improve by up to 23.1×   (Figure [\ref=large-energy-results]). Figure [\ref=summary-plot] shows how much of the improvements come from each optimization and architectural extension: natural technology scaling (50 nm to 28 nm), STE decomposition (with 4×   decomposition factor), vector packing (packed into groups of 4), and 8-input counter increment extensions. With these additional improvements, the AP will be comparable to or even better than FPGAs and GPUs.

Related Work

We are not the first to propose accelerating kNN using alternative computing substrates or near data processing techniques. Unsurprisingly, near data processing has a well established history [\cite=activepages] [\cite=swanson14] [\cite=activedisk] [\cite=rap2] [\cite=cassm] [\cite=intelligent-disk]; however what is surprising is near data kNN search has a similarly well established history.

TCAM Based kNN: Content addressable memories (CAMs) and TCAMs are arguably among the first commercial substrates that featured limited near data processing capabilities compared to traditional memories. Prior work has shown it is possible to implement approximate variants of kNN using TCAMs. Most notably, Shinde et al [\cite=shinde10] propose ternary locality sensitive hashing (TLSH) and Bremler-Barr et al [\cite=bremler-barr15] propose using binary-reflected Gray code to implement approximate nearest neighbors using TCAMs. Unfortunately the accessibility of TCAMs has traditionally been limited to niche hardware applications (ex. routers) making them difficult to program, access, and evaluate.

Near Data Accelerators for kNN: Similarly, we are not the first to propose near data processing as a solution for kNN calculations. As far back the late 1980s, Kanerva et al. [\cite=sparse-distributed-memory] propose Sparse Distributed Memory (SDM) for nearest neighbor search. Roberts et al [\cite=pcam] proposed proximity content-addressable memory (PCAM) which employed the ideas behind SDM. Lipman et al [\cite=smart-access-memory] proposed Smart Access Memory which integrated distance calculation units coupled with a systolic array sort to perform kNN. More recently, Tandon et al [\cite=tandon13] proposed a all pairs similarity search accelerator extension for the L2-cache to accelerate NLP applications.

AP Pattern Mining and Similarity Search: Pattern mining is a well explored application space on the AP; prior work has shown the AP can provide significant performance improvement for applications like biological motif search [\cite=ap-motif-search], frequent itemset mining [\cite=ap-apriori], and Brill tagging [\cite=ap-brill-tagging]. Outside of pattern mining prior work has also demonstrated techniques for solving graph problems such as finding cliques and Hamiltonian paths [\cite=ap-graph]. In comparison, we are the first to explore accelerating similarity search using kNN on the AP and provide comprehensive performance and energy efficiency comparison across competing heterogeneous computing platforms.

Conclusion

We presented an implementation of and several optimization techniques for Hamming distance kNN for the Micron Automata Processor using a temporally encoded sort. Our results show that our design can achieve significant performance gains at comparable energy efficiency as competing FPGA, and GPU solutions. While the workload sizes we explore in this paper are limited, we expect that with better technology scaling, and improved reconfiguration latency that the AP will be able to support significantly larger workloads. We also expect that as the platform matures the architecture, resource capacity, and power will improve dramatically making the AP a promising platform for many other near data processing applications.

Acknowledgements

We would like to thank Micron Technologies for providing support for this project. In particular, we thank Matt Grimm, Matt Tanner, and Indranil Roy at Micron Technologies for taking the time to help guide our work, and provide power measurements for our evaluation.