D..

VConv-DAE: Deep Volumetric Shape Learning Without Object Labels

Introduction

Despite the recent advances in 3D scanning technology, acquiring 3D geometry or shape of an object is a challenging task. Scanning devices such as Kinect are very useful but suffer from problems such as sensor noise, occlusion, complete failure modes (e.g. dark surfaces and gracing angles). Incomplete geometry poses severe challenges for a range of application such as interaction with the environment in Virtual Reality or Augmented Reality scenarios, planning for robotic interaction or 3D print and manufacturing.

To overcome some of these difficulties, there is a large body of work on fusing multiple scans into a single 3D model [\cite=kin_fusion]. While the surface reconstruction is impressive in many scenarios, acquiring geometry from multiple viewpoint can be infeasible in some situations. For example, failure modes of the sensor will not be resolved and some viewing angles might simply be not easily accessible e.g. for a bed or cupboard placed against a wall or chairs occluded by tables.

There also has been significant research on analyzing 3D CAD model collections of everyday objects. Most of this work  [\cite=ckgk-prabm-11] [\cite=KCKK12] use an assembly-based approach to build part based models of shapes. Thus, these methods rely on part annotations and can not model variations of large scale shape collections across classes. Contrary to this approach, Wu et al. (Shapenet [\cite=Shape_net]) propose a first attempt to apply deep learning to this task and learn the complex shape distributions in a data driven way from raw 3D data. It achieves generative capability by formulating a probabilistic model over the voxel grid and labels. Despite the impressive and promising results of such Deep belief nets [\cite=hinton2006fast] [\cite=lee2011unsupervised], these models can be challenging to train. While they show encouraging results on challenging task of shape completion, there is no quantitative evaluation. Furthermore, it requires sampling for test time inference which severely limits the range of future 3D Deep Learning applications.

While deep learning has made remarkable progress in computer vision problems with powerful hierarchical feature learning, unsupervised feature learning remains a future challenge that is only slowly getting more traction. Labels are even more expensive to obtain for 3d data such as point cloud. Recently, Lai et al. [\cite=lai_icra14] propose a sparse coding method for learning hierarchical feature representations over 3D point clouds. However, their approach is based on dictionary learning which is generally slower than convolution based models and less scalable. Our work also falls in this line of work and aims at bringing the success of deep and unsupervised feature learning to 3D representations.

To this end, we make the following contributions:

We formulate two related problems of learning shape representation and completion in a simple unsupervised framework which is trained in a discriminative manner end-to-end on a binary voxel encoding.

Our method outperforms previous supervised approach shapenet  [\cite=Shape_net] on denoising and shape completion task by a large margin while it obtains competitive results on shape classification. Our method is trained from scratch and end to end thus circumventing the training issues of previous work (shapenet) [\cite=Shape_net] such as layer wise pre-training.

We provide an extensive quantitative evaluation protocol for task of denoising and shape completion based on large scale collection of CAD models. This is essential to compare and evaluate the generative capabilities of deep Learning on volumetric representations when obtaining ground truth of real world data is challenging.

At test time, our method is at least two orders of magnitude faster than shapenet, making it more favourable for real-time applications and larger scenes.

Related Work

Part and Symmetry based Shape Synthesis

There exist some work [\cite=ckgk-prabm-11] [\cite=KCKK12] based on CAD models that use an assembly-based approach to build deformable part-based models. There is also some work that detect the symmetry in point cloud data and use it to complete the partial or noisy reconstruction. A comprehensive survey of such techniques is covered in Mitra et al.[\cite=mpwc_symmSurvey_12]. However, part and symmetry based methods are typically class specific and require part annotations which are expensive. Moreover, this line of work has not shown results on large scale dataset that comes with various classes and poses.

Deep learning for 3D data

ShapeNet [\cite=Shape_net] is the first work that applied deep learning to learn the 3d representation on large scale CAD model database. Apart from recognition, it also desires capability of shape completion. It builds a generative model with convolutional RBM [\cite=hinton2006fast] [\cite=lee2011unsupervised] by learning a probability distribution over class labels and voxel grid. The learned model is then fine tuned for the task of shape completion. Following the success of Shapenet, there have been recent work [\cite=Maturana_2015_7900]that further improves the recognition results on 3D data. However, there is no work that has tried to tackle both problems. Thus, our work is inspired by Shapenet in the functionality but different in methodology. In particular, deep learning research argues  [\cite=Vincent08] that learning representation with over-complete model or huge parameters are more prone to overfitting compared to the approach that learns from noisy data. Our work learns feature representation directly from noisy data and we show that it greatly improves the network ability for task such as shape completion.

Denoising Auto-Encoders

Our network architecture is inspired by DAE [\cite=Vincent08] [\cite=vincent2010stacked] main principle that predicting any subset of variables from the rest is a sufficient condition for completely capturing the joint distribution between a set of variables. In order to share weights for stationary distributions such as they occur in images, convolutional auto-encoders have been proposed [\cite=masci2011stacked]. Our model differs with such architecture as it is not stacked and learned end to end without any layer fine-tuning or pre-taining. Furthermore, we use learnable upsampling unit (deconvolutional layers) to reconstruct back the encoded input. Recent work of Geras and Sutton [\cite=SDASutton] experiment with different noise levels used in DAE, starting with high levels and then reducing to low noise levels. However, they show that the approach is not very useful in their case and also depends on other hyperparameters such as the number of hidden nodes and learning rate.

Learnable Upsampling Layer

The concept of upsampling layer was first introduced by Zeiler and Fergus  [\cite=zeiler14] to visualize the filters of internal layer in a 2D ConvNet. However, they simply transpose the weights and do not learn the filter for upsampling. Instead, Long et al.  [\cite=Long2015] first introduced the idea of deconvolution as a trainable layer for semantic image segmentation. However, they use pretrained models to upsample the coarse image segmentation map whereas in our case, deconvolutional layer reconstructs the 3D input from scratch. Note that a concurrent work  [\cite=3DRNN-Savarese] also proposes a decoder based on volumetric deconvolution that outputs 3D reconstruction given an multi view encoding of images. In contrast, we propose a denoising volumetric auto encoder for shape classification and completion that encodes volumes and also decodes to volumes.

Rest of the paper is organised as follows: In the next section, we first formulate the problem and describe our deep network and training details. We then move on to the experiment section where we first show the experiments for classification on ModelNet database. We then formulate the protocol for evaluating current techniques for the task of shape completion and show our quantitative results. We conclude with qualitative results for shape completion and denoising.

Learning Discriminative Volumetric Reconstruction and Representation

Given a collection of shapes of various objects and their different poses, our aim is to learn the shape distributions of various classes. At test time, we want to leverage the learnt representation for shape recognition tasks as well as use the generative capabilities of the auto encoder architectures for predicting enhanced version of corrupted representations. These corruptions can range from noise like missing voxels to more severe structured noise patterns.

VConv-DAE: Convolutional Denoising Auto Encoder for Volumetric Representations

Voxel Grid Representation.

Following Shapenet[\cite=Shape_net], we adopt the same input representation of geometric shape: a voxel cube of resolution 24. Thereafter, each mesh is first converted to a voxel representation with 3 extra cells of padding in both directions to reduce the convolution border artifacts and stored as binary tensor where 1 indicates the voxel is inside the mesh surface and 0 indicates the voxel is outside the mesh. This results in the overall dimensions of voxel cube of size 30×  30×  30.

Architecture.

To this end, we learn an end to end, voxel to voxel mapping by phrasing it as two class (1-0) auto encoder formulation from a whole voxel grid to a whole voxel grid. An overview of our VConv-DAE architecture is shown in Figure [\ref=fig:dae]. Labels in our training corresponds to the voxel occupancy and not class label. Our architecture consists of dropout layer directly connected to the input layer which we call DataDrop. The first part of our network can be seen as an encoder stage that results in a condensed representation (bottom of figure). In the second stage, the network reconstruct back the input from this intermediate representation by deconvolutional layers which acts as a learnable local upsampling unit. We will now explain the key components of the architecture in more detail.

DataDrop: Dropout as Data Augmentation.

While data augmentation has been used a lot to build deep invariant features for images  [\cite=krizhevsky2012imagenet], it is relatively little explored on volumetric data. We propose a DataDrop layer that directly puts a dropout [\cite=JMLR:v15:srivastava14a] layer on the input. This serves the purpose of input data augmentation while also injecting random noise to the input for learning robust representation. This also results in an implicit training on a virtually infinite amount of data and has shown in our experiments to greatly avoid over-fitting.

Encoding Layers: 3D Convolutions

The first convolutional layer has 64 filters of size 9 and stride 3. The second convolutional layer has 256 filters of size 4 and stride 2 meaning each filter has 64×  4×  4×  4 parameters. This results into 256 channels of size 3×  3×  3. These featue maps are later flattened into one dimensional vector of size 6912 (= 256×  3×  3×  3) dimensions, which acts as a shape descriptor for classification experiments later. This encoded input is now reconstructed back with two deconv layers. First Deconv layer contains 64 filters of size 5 and stride 2 while the last deconv layer finally merges all 64 feature cubes back to the original voxel grid. It contains a filter of size 6 and stride 3.

Decoding Layers: 3D Deconvolutions

While CNN architecture based on convolution operator have been very powerful and effective in a range of vision problems, Deconvolutional (also called convolutional transpose) based architecture are gaining traction recently. Deconvolution (Deconv) is basically convolution transpose which takes one value from the input, multiplies the value by the weights in the filter, and place the result in the output channel. Thus, if the 2D filter has size f×   f, it generates a f×  f output matrix for each pixel input. The output is generally stored with a overlap (stride ) in the output channel. Thus, for input x, filter size f, and stride d, the output is of dims (x - i) * d + f. Upsampling is performed until the original size of the input has been regained.

We did not extensively experiment with different network configurations. However, small variations in network depth and width did not seem to have significant effect on performance. Some of the design choice also take into account the input voxel resolution. We chose two convolutional layers for encoder to extract robust feature at multiple scales. Learning a robust shape representation essentially means capturing the correlation between different voxels. Thus, receptive field of convolutional filter plays a major role and we observe the best performance with large conv filters in the first layer and large deconv filter in the last layer. We experimented with two types of loss functions: mean square loss and cross entropy loss. Since we have only two classes, there is not much variation in performance with cross entropy being slightly better.

Dataset and Training

Dataset.

Wu et al. [\cite=Shape_net] use Modelnet, a large scale 3D CAD model dataset for their experiments. It contains 151,128 3D CAD models belonging to 660 unique object categories. They provide two subset of this large scale dataset for the experiments. The first subset contains 10 classes that overlaps with the NYU dataset [\cite=Silberman] and contains indoor scene classes such as sofa, table, chair, bed etc. The second subset of the dataset contains 40 classes where each class has at least 100 unique CAD models. Following the protocol of  [\cite=Shape_net], we use both 10 and 40 subset for classification while completion is restricted to subset of 10 that mostly corresponds to indoor scene objects.

Training Details.

We train our network end-to-end from scratch. We experiment with different levels of dropout noise and observe that training with more noisy data helps in generalising well for the task of denoising and shape completion. Thus, we set a noise level of p = 0.5 for our DataDrop layer which eliminates half of the input at random and therefore the network is trained for reconstruction by only observing 50% of the input voxels. We train our network with pure stochastic gradient decent and a learning rate of 0.1 for 500 epochs. We use momentum with a value of 0.9. We use the open source library Torch for implementing our network.

Experiments

We conduct a series of experiments in particular to establish a comparison to the related work of Shapenet [\cite=Shape_net]. First, we evaluate the representation that our approach acquires in an unsupervised way on a classification task and thereby directly comparing to Shapenet. Then, we propose two settings to evaluate quantitatively the generative performance of 3D deep learning approach on a denoising and shape completion task - on which we also benchmark against Shapenet and baselines related to our own setup. We conclude the experiments with qualitative results as well as runtime comparison.

Classification

Features learned from deep networks are state-of-the-art in various computer vision problems. Shapenet is also considered state-of-the-art for volumetric shape representations. However, unsupervised feature learning using deep network is less explored area. Therefore, we evaluate how the features learned in unsupervised manner compare with other state-of-the-art 3D mesh features that makes use of class label information during training. We conduct 3D classification experiments to evaluate our features. Following shapenet, we use the same train/test split by taking the first 80 models for training and first 20 examples for test. Each CAD model is rotated along gravity direction every 30 degree which results in total 38,400 CAD models for training and 9,600 for testing.

Setup.

We propose following three methods to evaluate our network for the task of classification:

Ours-SVM : We feed forward the test set to the network and simply take the fixed length bottleneck layer of dimensions 6912 and use this as a feature vector for a linear SVM. Note that the representation is trained completely unsupervised.

Fine-Tuning-1(Ours-FT1): We follow the set up of Shapenet [\cite=Shape_net] which puts a layer with class labels on top most feature layer and fine tunes the network. In our network, we take the bottleneck layer which is of 6912 dimensions and put a softmax layer on top and fine tune it for classifcation.

Fine-Tuning-2(Ours-FT2): Here, we put another layer in between bottleneck and softmax layer. So, the resulting classifier has an intermediate fully connected layer 6912-512-40.

For comparison, we also report performance for Light Field descriptor (LFD [\cite=chen2003visual], 4,700 dimensions) and Spherical Harmonic descriptor (SPH [\cite=kazhdan2003rotation], 544 dimensions). We also report the overall best performance achieved so far on this dataset [\cite=su15mvcnn] [\cite=Maturana_2015_7900].

Discussion

Our network achieves comparable performance when compared to shapenet. MvCnn  [\cite=su15mvcnn] outperforms other methods by a large margin. However, unlike the rest of the methods, it works in the image domain - while we are interested in pushing deep learning method for volumetric domain. For each model, MvCnn  [\cite=su15mvcnn] first renders it in different views and then aggregate the scores of all rendered images obtained by CNN. Our representation compares favorably against shapenet taking into account that our method is trained without any knowledge of class labels.

Denoising and Shape Completion

In this section, we show experiments that evaluate our network on the task of denoising and shape completion. This is very relevant in the scenario where geometry is captured with depth sensors that often comes with holes and noise due to sensor and surface properties. Ideally, this task should be evaluated on real world depth or volumetric data but obtaining ground truth for real world data is very challenging and to the best of our knowledge, there exists no dataset that contains the ground truth for missing parts and holes of Kinect data. Kinect fusion type approach still suffer from sensor failure modes and large objects like furnitures often cannot be scanned from all sides in their typical location.

We thus rely on CAD model dataset where complete geometry of various objects is available and we simulate different noise characteristics to test our network. We use the 10-class subset of ModelNet database for experiments. In order to remain comparable to Shapenet, we use their pretrained generative model for comparison and train our model on the first 80 (before rotation) CAD models for each class accordingly. This results in 9600 training models for the following experiments.

Denoising Experiments

We first evaluate our network on the same random noise characteristics with which we train the network. This is still challenging since the test set contains different instance than train set. We also vary the amount of random noise injected during test time for evaluation. Training is same as that for classification and we use the same model trained on the first 80 CAD models. At test time, we use all the test models available for these 10 classes for evaluation.

Baseline and Metric

To better understand the network performance for reconstruction at test time, we study following methods:

Convolutional Auto Encoder (CAE): We train the same network without any noise meaning without any dropout layer. This baseline tells us the importance of data augmentation or injecting noise during training.

Shapenet(SN): We use pretrained generative model for 10 class subset made public by Shapenet and their code for completion. We use the same hyper-parameters as given in the their source code for completion. Therefore, we set number of epochs to 50, number of gibbs iteration to 1 and threshold parameter to 0.1. Their method assumes that an object mask is available for the task of completion at test time. Our model does not make such assumption since this is difficult to obtain at test time. Thus, we evaluate shapenet with two different scenario for such a mask: first, SN-1, by setting the whole voxel grid as mask and second, SN-2, by setting the occupied voxels in test input as mask. Given the range of hyper-parameters, we report performance for the best hyperparameters.

Metric

: We count the number of voxels which differs from the actual input. So, we take the absolute difference between the reconstructed version of noisy input and original (no-noise) version. We then normalise reconstruction error by total number of voxels in the grid (13824=24×  24×  24)). Note that the voxel resolution of 30×  30×  30 is obtained by padding 3 voxels on each side thus network never sees a input with voxel in those padding. This gives us the resulting reconstruction or denoising error in %.

Discussion

Our network is significantly better than the CAE as well as Shapenet. This is also depicted in Figure [\ref=fig:noise_plot] where we plot performance over different noise levels as well as in Table [\ref=fig:denoising]

Our network superior performance over no noise network (CAE) justifies learning representations from noisy data. The result also implies that our network is significantly more robust for denoising when compared to shapenet. Performance of shapenet and CAE degrades a lot (almost linearly) with the increase in noise.

Slicing Noise and Shape completion

In this section, we evaluate our network for a structured version of noise that is motivated by occlusions in real world scenario failure modes of the sensor which generates "holes" in the data. To simulate such scenarios, we inject slicing noise in the test set as follows: For each instance, we first randomly choose n slices of volumetric cube and remove them. We then evaluate our network on three amount of slicing noise depending upon how many slices are removed.

Injected slicing noise is challenging on two counts: first, our network is not trained for this noise. Secondly, as shown in Figure [\ref=fig:qualitative] , injecting 30 % of slicing noise leads to significant removal of object with large portion of object missing. Thus, evaluating on this noise relates to the task of shape completion. For comparison, we again use Shapenet with the same parameters as described in the previous section. In the Table below, 10, 20, 30 indicates the % of slicing noise. So, 30 % means that we randomly remove all voxels lying on 9 (30 % ) faces of the cube. We use the same metric as described in the previous section to arrive at the following numbers in %

Discussion

Our network consistently improves over shapenet by roughly 8 percent points. Note that 1% error in above table is equal to getting 138 voxels wrong. We show qualitatively in the next section that this makes a significant difference in the quality of reconstructed version. As shown in the figure [\ref=fig:noise_plot], while shapenet degrades heavily with the amount of noise, our network is significantly more robust and better for completion. Comparing the noise (left) and slicing (right) case also suggest that our network finds completing slicing noise (shape completion) more challenging than denoising random noise. As we will see in next section, 30 % of slicing noise removes significant chunk of the object.

Qualitative Comparison

In Table [\ref=fig:denoising] and [\ref=fig:qualitative], each row contains 4 images where the first one corresponds to the ground truth, second one is obtained by injecting noise (random and slicing) and acts as a input to our network. Third image is the reconstruction obtained by our network while fourth image is the outcome of shapenet. Shapenet reconstructions in these two tables are obtained by setting the mask to whole voxel grid (SN-1). As shown in the qualitative results, our network can fill in significant missing portion of objects when compared to shapenet. All images shown in Table [\ref=fig:qualitative] are for 30 % slicing noise scenario whereas the Table [\ref=fig:denoising] corresponds to inputs with 50% random noise. Judging by our quantitative evaluation. our model finds slicing noise to be the most challenging scenario. This is also evident in the qualitative results and partially explained by the fact that network is not trained for slicing noise. Edges and boundaries are smoothed out to some extent in some cases. In Table [\ref=fig:qual-mask2], we also compare with the shapenet reconstruction obtained with different mask(SN-2).

Limitation and Failure Cases

Although our model can recover significant missing portions of the object, it is still not trained for the scenario where most of the object is missing. In figure [\ref=fig:failure], the second image in the row is generated by slicing noise as explained before. However, it removes the majority of the object in three slice removal which our network can not recover during test time. Intuitively, while network captures the correlations between a certain size of neighbourhood, it's ability is still bounded by a certain limit. For such scenario, we believe the network should be trained with even more structured noise.

Runtime comparison with Shapenet

We compare our runtime during train and test with Shapenet. All runtime reported here are obtained by running the code on Nvidia K40 GPU. Training time for Shapenet is quoted from their paper where it is mentioned that pre-training as well as fine tuning each takes 2 days and test time of 600ms is calculated by estimating the time it takes for one test completion. In contrast, our model trains in only 1 day. We observe strongest improvements in runtime at test time, where our model only takes 3ms which is 200x faster than Shapenet - an improvement of two orders of magnitude. This is in part due to our network not requiring sampling at test time. We believe the presented speed-up is key to scale up 3D deep learning techniques to scene level inference.

Conclusion and Future Work

We have presented a simple and novel approach that is at least two order of magnitude faster than prior work, delivers comparable results on recognition and significantly stronger results on denoising and shape completion while being trained without object labels. We believe that the obtained fast processing speed is key to move in the future from object towards scene level inference in 3D deep learning.