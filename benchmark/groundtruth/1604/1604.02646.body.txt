[formula]

Visualization Regularizers for Neural Network based Image Recognition

Introduction

Regularization is an important aspect of deep neural network training. It prevents over-fitting in the absence of sufficient data. Usually regularizers restrict the norms of the weight parameters. A commonly used regularizer the L2 norm regularizer, penalizes the sum of squares of the weight parameters. Other regularizers include soft-weight sharing, introduced by Nowlan and Hinton [\cite=nowlan1992simplifying]. Erhan et. al. showed that layer-wise unsupervised pre-training acts as a regularizer for deep neural networks [\cite=erhan2010does]. Dropout [\cite=srivastava2014dropout] is a more recent regularizer proposed for deep neural networks. There has also been recent works on adaptive dropout [\cite=ba2013adaptive], which is an improvement over the original dropout. In this paper, we propose a novel regularizer which we call as the visualization regularizer (VR), based on the visual quality of features learned by the internal nodes.

Vision tasks benefit from features consisting of primitives recognized by mid-level vision systems. Deep neural networks have been known to learn hierarchical layers of feature representation [\cite=lecun2015deep] [\cite=bengio2009learning]. On observing the features learned by deep neural networks trained using back propagation, it is seen that in contrast to well defined mid-level features, the node features are often noisy. More meaningful features (smoother features for example) can be favorable to training the network. Our proposed regularizer imposes a constraint on the hidden nodes of a neural network to learn smoother features. Since, the definition of the regularizer depends on the visual property of smoothness, it is only pertinent to domains with a notion of spatial locality, such as images.

We show that the VR regularizer is a special case of Tikhonov regularization [\cite=tikhonov1977solutions]. The Tikhonov matrix of the conventional L2 norm regularizer corresponds to an identity matrix multiplied by the regularization weight. Whereas, the Tikhonov matrix for the VR regularizer is more generalised but sparse.

Using our regularizer, we achieve better performance in terms of accuracy than the baselines when compared on benchmark datasets such as MNIST [\cite=lecun1998mnist] and CIFAR-10 [\cite=Krizhevsky2009]. Moreover the computational complexity of the training algorithm is same as that of the unregularized training algorithm. Our experimental results show that the features features learned by the nodes are smoother than the features learned without the VR regularizer.

This paper is organized in five sections. Section II gives a brief introduction to the architecture of deep neural networks and the notation used. The notion of visualization of a node is formally defined in section III. The proposed VR regularizer and the training algorithm along with the complexity analysis are described in section IV. Section V establishes the relationship to Tikhonov regularization. Section VI presents all the experimental results and observations. Finally Section VII concludes with a summary of the achievements and scopes for future work.

Deep neural network architecture

The investigations presented in this paper are based on a muti-class classification setting. The notation followed in this paper is as follows: [formula] denotes the input, Wi and [formula] respectively denote the weights and biases corresponding of the layers, [formula] denotes the pre-activation of the layers, [formula] denotes the activation of layers and [formula] denotes the output of the neural network. The subscripts i in the notation denotes the ith hidden layer. The following equations describe a deep neural network with l hidden layers.

[formula]

where g, is the activation function, a monotonically increasing non-linear function such as sigmoid, tanh or the rectified linear unit.

The loss function used for training is the sum of the classification loss and the regularization term. For a neural network M and a dataset D, the loss function can be written as,

[formula]

where Lc(M,D) denotes the classification loss between the output of the neural network and the true class labels, Reg(M) denotes the regularization term and λ denotes the regularizer weight. However, dropout cannot be included in the loss function. It is incorporated into the training algorithm.

The notion of visualization of a node

Visualization of a node refers to the visualization of the features learned by the node. Visualization of the nodes of a neural network have been studied by Erhan et. al. [\cite=erhan2009visualizing]. They proposed the activation maximization algorithm for visualizing features learned by a node. Following the notion in [\cite=erhan2009visualizing] we define the visualization of a node as follows.

Visualization of a node is defined to be the input pattern(s) which activate(s) the node maximally under the restriction of the L2 norm of the input to be equal to unity. The L2 norm of the input is restricted to unity to prevent the input from becoming unbounded. Formally, the visualization [formula] of a node n is defined as,

[formula]

where [formula] denotes the activation of node n for input [formula]. Depending on the non-linearity g used in equation [\ref=eqn:g], solution to the above equation can be unique or multiple. For example, there exists an unique solution for invertible functions like g  =  σ (sigmoid) or g  =   tanh . Whereas there can be multiple solutions for non-invertible functions such as g(  ·  )  =   max (0,  ·  ) also known as the rectified linear unit (ReLU). The visualization of an internal node of the neural network can be computed using gradient-ascent as described in [\cite=erhan2009visualizing] as activation maximization.

Observe that the pre-activation of a node n in the first hidden layer for an input vector [formula] is [formula], where [formula] denotes the weights of the connections coming into the node n. The pre-activation is maximized when [formula] is aligned in the same direction as [formula] in the appropriate vector space. Since the activation function is an increasing function, maximization of the pre-activation maximizes the activation too. Consequently, we get the following closed form as one of the possible solutions to equation [\ref=eqn:visdef] for nodes n in the first hidden layer.

[formula]

Note that finding a closed form algebraic expression for the visualization of nodes in the higher hidden layers is difficult due to the non-linearity of the activation function.

Figures [\ref=fig:VisL2] and [\ref=fig:VisL2DR] show example visualizations of internal nodes of neural networks trained on the MNIST dataset, without and with dropout respectively.

Proposed visualization based regularizer

We first define the notion of smoothness of a visualization.

Smoothness of a visualization

Intuitively, one can determine whether an image is smooth or noisy by looking at the gradients in the image. An image is smooth if it has small gradients. The gradient of an image can be computed by convoluting it with a high pass filter. Larger the pixel values in the convolution, the larger the gradients in the original image, and noisier the image. We utilize this intuition to give a formal definition of smoothness.

Consider a convolution [formula] of image I with kernel K, where K is a high pass filter like the laplacian kernel. We define the smoothness of an image to be the negative sum of squares of pixel values of [formula]. Equivalently, we can define the visualization loss [formula] of image I as,

[formula]

where "·  " denotes the element-wise product, also known as the Schur or Hadamard product. The visualization loss is the negative of the smoothness of an image. Lower the visualization loss, smoother is the image. Table [\ref=tab:LossValues] shows the visualization loss for some example visualizations.

Visualization loss as a regularizer

Classification tasks using deep neural networks benefit from the high-level of abstractions achieved in the higher layers of the neural network. Deep neural networks are intended to utilize low-level pixels to learn mid-level features and finally high-level features. We propose the visualization regularizer (VR) to constrain the nodes in the first hidden layer to learn features with qualities similar to mid-level visual features. This constraint is intended to facilitate the discovery of high-level abstractions more effectively.

Informally, we define the VR regularizer as a regularizer to reduce the visualization loss of the nodes of the neural network. In other words the VR regularizer makes the nodes learn smooth or less noisy features.

The following sub-sections give a more detailed description of the VR regularizer:

Regularizer expression

Let U(M) denote the set of nodes of the first hidden layer of a neural network M and for a node n∈U(M), let [formula] denote the weights of the connections incoming into the node.

From equation [\ref=eqn:visexp] we know that visualization of a node in the first hidden layer is proportional to the weights of the connections coming into the node. Hence the visualization loss of the node is proportional to the visualization loss of the weight vector coming into the node. Therefore we can use [formula] as a surrogate for the visualization loss of the visualization of the node n. The difficulty of computing an algebraic expression for the visualization of nodes in higher hidden layers, limits the usage of the surrogate to nodes in the first hidden layer only.

We define the visualization loss [formula] of a neural network M as,

[formula]

The network training loss function can thus be defined as,

[formula]

where L2'(M) denotes the L2 norm regularization term for all weights except the weights coming into the first hidden layer. The remaining notation are as described in section 2.

Note that instead of defining the visualization of loss as the sum of squares as in equation [\ref=eqn:VLSqSum], equivalently one can also define it as the mean of squares. The only change required is to divide the sum by the number of elements (a constant) over which the mean is taken. We denote this by [formula]. Analogously, we can also define [formula] (see eqn. [\ref=eqn:RegExpM]) as,

[formula]

Gradient of the visualization regularizer

For the visualization loss to be used as a regularizer, its gradient must be computed with respect to the model parameters. We derive the expression of the derivative for a general kernel of size (2k + 1)  ×  (2k + 1).

For simplicity in computing the expression of the gradient, we index the elements of the kernel relative to the central element as shown in equation [\ref=eqn:KIndex]. The element at the center is indexed (0,0). All other elements are indexed according to their position relative to the central element.

[formula]

Let NK denote the set of indices of the kernel matrix.

[formula]

Consider an image I with dimensions n,m. Let S(i,j), corresponding to the (i,j)th pixel of I, be defined as follows.

[formula]

Informally, S(i,j) contains the set of valid indices (p,q), along with their position r relative to (i,j), that need to be considered while computing the convolution for the (i,j)th pixel.

A full convolution of the image I can be described as

[formula]

It follows from the definition that a pixel Ipq present at a position r, relative to (i,j), has the coefficient ar in I'ij.

The visualization loss is

[formula]

The partial derivative of the visualization loss with respect to a pixel Iij of the image I is

[formula]

Observe that in the above equation Iij occurs in I'pq only for (p,q) such that (r,(p,q))∈S(i,j). Moreover, if (p,q) is present at position r relative to (i,j), then (i,j) is present at position - r relative to (p,q). It follows that Iij has the coefficient a- r in I'pq. Hence the derivative can be computed as,

[formula]

Further, using equation [\ref=eqn:convexp], we can write,

[formula]

where KI denotes the kernel matrix formed by flipping K both horizontally and vertically. Formally,

[formula]

Equation [\ref=eqn:visgrad] allows us to compute the gradient efficiently and in a scalable manner. All popular GPU programming frameworks provide libraries for scalable convolutions. Figure [\ref=fig:VLossDiag] illustrates the gradient computation for the visualization loss.

Regularized training algorithm

Training requires computing the gradient for the regularized loss function with respect to the parameters of the network. As evident from equation [\ref=eqn:LossFunction], the gradient of the loss function can be computed by first computing the gradients of Lc(M,D), L2'(M) and [formula], and then computing their sum. The gradients of Lc(M,D) and L2'(M) can be computed using back-propagation and partial derivatives respectively.

By equation [\ref=eqn:RegExpM], the gradient of [formula] is the sum of gradients of [formula] for n∈U(M). Note that the gradient [formula] is zero if [formula]. In other words, the gradient is zero if w does not belong to the set of weights incoming to node n. Hence we only need to compute the gradients [formula] for all n∈U(M). These can be computed using equation [\ref=eqn:visgrad]. The full algorithm described in figure [\ref=fig:trainingalg]. The algorithm can be extended to using dropout and momentum.

Computing each [formula] in figure [\ref=fig:trainingalg] takes [formula]. Consequently, computing the gradient of the VR regularizer takes [formula] time, which is of the same order as computing the gradient of the L2 norm regularizer. Thus, the VR regularizer does not impose additional overhead in the computational complexity per iteration.

Relationship with Tikhonov regularization

Tikhonov regularization was originally developed for solutions to ill-posed problems [\cite=tikhonov1977solutions]. For example, L2 regularization, a special case of Tikhonov regularization is used to compute solutions to regression problems for which rank deficient matrices are encountered while computing their solutions. The solution to regularized least squares regression is given by,

[formula]

where Γ is the Tikhonov matrix. The L2 regularizer corresponds to Γ  =  I.

Let [formula] be the concatenation of all the weights in [formula] for n∈U(M). From equation [\ref=eqn:VLSum], we can see that [formula] is the sum of squared terms of the form [formula], where [formula], ct∈{ar|ar  =  Kij, 0  ≤  i,j  ≤  2k + 1} and [formula]. For example [formula] can be represented in the given form where ci  =  1,cj  =   - 1,ck  =   - 1, and all other ct are zero.

The Tikhonov matrix Γ can be constructed as follows. Consider the expression of [formula] consisting of the sum of p such squared terms. Let the ith term in this expression be [formula]. Then, Γ and consequently [formula] in terms of Γ are, respectively,

[formula]

The expression of si consists of only a constant number of non-zero cit. The maximum number of non-zero cit is bounded by the size of the kernel matrix K. Hence, the number of non-zero entries in Γ is [formula], whereas the total number of entries in Γ is [formula]. Since [formula] is practically a constant, we can conclude the sparsity of Γ.

Experiments and observations

We experimented on the MNIST [\cite=lecun1998mnist] and CIFAR-10 [\cite=Krizhevsky2009] datasets and compared the classification accuracy of our algorithm using the VR regularizer with other regularizers.

Experimental setting

We used a neural network with two fully connected hidden layers for both the datasets. For the CIFAR-10 dataset, we additionally used a convolution and max pooling layer before the fully connected layers. For simplicity in searching for optimal parameters, we fixed the number of fully connected hidden layers to two, with the number of nodes in each hidden layer equal to 1000. We also fixed the number of feature maps of the convolution layer to 10, and the kernel size to 3  ×  3.

We used the laplacian kernel for the VR regularizer defined as follows.

[formula]

We used the mean cross-entropy loss over the mini-batch examples as the classification loss, mean of squares of the weight parameters as the L2 regularizer, and [formula] as the VR regularizer. We trained the neural network using stochastic gradient descent as described in figure [\ref=fig:trainingalg], and also used Nesterov's accelerated gradient (momentum) [\cite=nesterov1983method]. Note that the first fully connected layer is connected to the input for MNIST, whereas it is connected to the max-pooling layer in the case of CIFAR-10. Thus for the CIFAR-10 network, U(M) is defined as the set of nodes in the first fully connected layer. The VR regularizer utilizes this modified definition of U(M) in the case of CIFAR-10.

We fixed the number of training epochs to 200 and a mini-batch size of 100. For both MNIST and CIFAR-10, we reduced the learning rate by a factor of 10, respectively after every 100 and 70 epochs. We fixed the momentum parameter to 0.9 and dropout rate to 0.3 for both hidden layers.

Accuracy

We compared the different neural networks with combinations of L2, VR, and dropout regularizers. For finding the optimal parameters, we performed a randomized hyper-parameter search with manual fine-tuning. The accuracy and optimal hyper-parameters for various regularizer settings are given in table [\ref=tab:results]. The parameters μ,λ and α respectively denote the VR regularizer weight, the L2 regularizer weight, and the learning rate.

From the table it is observed that the VR regularizer is an improvement over the standard L2 regularizer. This is observed both for MNIST and CIFAR-10.

Convergence

Figures [\ref=fig:MnistAccConvergence] and [\ref=fig:CifarAccConvergence] show the variation of the test set accuracy over the training epochs.

Figures [\ref=fig:MnistConvergence] and [\ref=fig:CifarConvergence] show the variation of the regularization terms over the training epochs. Since loss values for different parameter settings can be of different orders of magnitude, for purposes of visualization, the loss values have been linearly transformed, so as to map to 1 after the first epoch and map to 0 after the last epoch.

Visualizations of hidden nodes

Figure [\ref=fig:MnistFig] shows the visualizations of the internal nodes of the MNIST classifier. The first two rows of the sub-figures correspond to nodes in the first hidden layer, and the last two rows correspond to nodes in the second hidden layer.

The difference between the visualizations of networks trained using the VR regularizer and the ones not trained using it is apparent. The visualizations of architectures using VR regularizer are smoother and less noisy as was expected.

Conclusion and future work

We observe that the VR regularizer is an improvement over the popular L2 regularizer in terms of classification accuracy. It is also observed that the networks trained using a VR regularizer have smoother visualizations. Though the VR regularizer imposes the smoothness constraint only on the first hidden layer nodes, our observations from figure [\ref=fig:MnistFig] show that the smoothness constraint is propagated to the next layer.

The VR regularizer may be extended to a new class of training algorithms which use domain knowledge in the form of regularizers.