Parameterized Compilation Lower Bounds for Restricted CNF-formulas

there are CNF formulas of size n and modular incidence treewidth k whose smallest DNNF-encoding has size nΩ(k), and

there are CNF formulas of size n and incidence neighborhood diversity k whose smallest DNNF-encoding has size [formula].

Introduction

Knowledge compilation is a preprocessing regime that aims to translate or "compile" knowledge bases, generally encoded as CNF formulas, into different representations more convenient for a task at hand. The idea is that many queries one would like to answer on the knowledge base, say clause entailment queries, are intractable in CNF encoding, but tractable for other representations. When there are many queries on the same knowledge base, as for example in product configuration, it makes sense to invest into a costly preprocessing to change the representation once in order to then speed up the queries and thus amortize the time spent on the preprocessing.

One critical question when following this approach is the choice of the representation that the knowledge is encoded into. In general, there is a trade-off between the usefulness of a representation (which queries does it support efficiently?) and succinctness (what is the size of the encoded knowledge base?). This trade-off has been studied systematically [\cite=DarwicheM02], leading to a fine understanding of the different representations. In particular, circuits in decomposable negation normal form (short DNNF) [\cite=Darwiche01] have been identified as a representation that is more succinct than nearly all other representations while still allowing useful queries. Consequently, DNNFs play a central role in knowledge compilation.

This paper should be seen as complementing the findings of [\cite=BovaCMS15]: In that paper, algorithms compiling CNF formulas with restricted underlying graph structure were presented, showing that popular graph width measures like treewidth and cliquewidth can be used in knowledge compilation. More specifically, every CNF formula of incidence treewidth k and size n can be compiled into a DNNF of size 2O(k)n. Moreover, if k is the incidence cliquewidth, the size bound on the encoding becomes nO(k). As has long been observed, 2O(k)n is of course far preferable to nO(k) for nontrivial sizes of n--in fact, this is the main premise of the field of parameterized complexity theory, see e.g. [\cite=FlumG06]. Consequently, the results of [\cite=BovaCMS15] leave open the question if the algorithm for clique-width based compilation of CNF formulas can be improved.

In fact, the paper [\cite=BovaCMS15] already gives a partial answer to this question, proving that there is no compilation algorithm achieving fixed-parameter compilability, i.e., a size bound of f(k)p(|F|) for a function f and a polynomial p. But unfortunately this result is based on the plausible but rather non-standard complexity assumption that not all problem in [formula] have [formula]-size circuits. The result of this paper is that this assumption is not necessary. We prove a lower bound of |F|Ω(k) for formulas of modular incidence treewidth k where modular treewidth is a restriction of cliquewidth proposed in [\cite=PaulusmaSS13]. It follows that the result in [\cite=BovaCMS15] is essentially tight. Moreover, we show a lower bound of [formula] for formulas of neighborhood diversity k [\cite=Lampis10]. This intuitively shows that all graph width measures that are stable under adding modules, i.e., adding a new vertex that has exactly the same neighborhood as an existing vertex, behave qualitatively worse than treewidth for compilation into DNNFs.

Related work.

Parameterized knowledge compilation was first introduced by Chen [\cite=Chen05] and has seen some recent renewed interest, see e.g. [\cite=Chen15] [\cite=Haan15] for work on conditional lower bounds. Unconditional lower bounds based on treewidth can e.g. be found in [\cite=Razgon14] [\cite=Razgon14b], but they are only for different versions of branching programs that are known to be less succinct than DNNF. Moreover, these lower bounds fail for DNNFs as witnessed by the upper bounds of [\cite=BovaCMS15].

There is a long line of research using graph and hypergraph width measures for problems related to propositional satisfiability, see e.g. the extensive discussion in [\cite=Brault-BaronCM15]. The paper [\cite=OrdyniakPS13] gave the first parameterized lower bounds on SAT with respect to graph width measures, in particular cliquewidth. This result was later improved to modular treewidth to complement an upper bound for model counting [\cite=PaulusmaSS13] and very recently to neighborhood diversity [\cite=Dell0LMM15], a width measure introduced in [\cite=Lampis10]. We remark that the latter result could be turned into a conditional parameterized lower bound similar to that in [\cite=BovaCMS15] discussed above.

Our lower bounds strongly rely on the framework for DNNF lower bounds proposed in [\cite=IJCAIversion] and communication theory lower bounds from [\cite=DurisHJSS04], for more details see Section [\ref=sct:statement].

Preliminaries

In the scope of this paper, a linear code C is the solution of a system of linear equations Ax̄  =  0 over the boolean field [formula]. The matrix A is called the parity-check matrix of C. The characteristic function fC is the boolean function that, given a boolean string e, evaluates to 1 if and only if e is in C.

We use the notation [formula] and [formula] to denote integer intervals. We use standard notations from graph theory and assume the reader to have a basic background in in the area [\cite=Diestel12]. By N(v) we denote the open neighborhood of a vertex in a graph.

We say that two vertices u, v in a graph G = (V,E) have the same neighborhood type if and only if [formula]. It can be shown that having the same neighborhood type is an equivalence relation on V [\cite=Lampis10]. The neighborhood diversity of G is defined to be the number of equivalence classes of V with respect to neighborhood types.

A generalization of neighborhood diversity is modular treewidth which is defined as follows: From a graph G we construct a new graph G' by contracting all vertices sharing a neighborhood type, i.e., from every equivalence class we delete all vertices but one. The modular treewidth of G is then defined to be the treewidth of G'. Modular pathwith is defined in the obvious analogous way.

We assume basic familiarity with propositional logic and in particular CNF formulas. We define the size of a CNF formula to be the overall number of occurrences of literals, i.e., the sum of the sizes of the clauses where the size of a clause is the number of literals in the clause. The incidence graph of a CNF formula F has as vertices the variables and clauses of F and an edge between every clause and the vertices contained in it. The projection of an assignment a:X  →  {0,1} to a set Z is the restriction of a to the variable set Z. This definition generalizes to sets of assignments in the obvious way. Moreover, the projection of a boolean function f on X to Z is defined as the boolean function on Z whose satisfying assignments are those of f projected to Z. For the width measures introduced above, we define the with of a formula to be that of its incidence graph.

Statement of the Main Results and Preparation of the Proof

We now state our main results. The first theorem shows that modular pathwith--and thus also more general parameters like cliquewidth and modular treewidth--do not allow fixed-parameter compilation to DNNF.

For every k and for every n big enough there is a CNF formula F of size at most n and modular pathwidth k such that any DNNF computing the same function as F must have size nΩ(k).

We also show lower bounds for neighborhood diversity that are nearly as strong as those for modular pathwidth.

For every k and for every n big enough there is a CNF formula F of size polynomial in n and with neighborhood diversity k such that any DNNF computing the same function as F must have size [formula].

At this point, the attentive reader may be a little concerned because we promise to prove lower bounds for DNNF which we have not even defined in the preliminaries. In fact, it is the main strength of the approach in [\cite=IJCAIversion] that the definition and properties of DNNF are not necessary to show our lower bounds, because we can reduce showing lower bounds on DNNF to a problem in communication complexity. Since we will not use any properties of DNNF, we have decided to leave out the definition out of the main text; the interested reader may find a short overview in Appendix [\ref=app:DNNF]. Here we will only use the following result.

Let f be a function computed by a DNNF of size s. Then f has a multi-partition rectangle cover of size s.

Now the reader might be a little puzzled about what multi-partition rectangle covers of a function are. Since we will also only use them as a black box in our proofs and do not rely on any of their properties, we have opted to leave out their definition the main text. The curious reader may find a very short introduction into the beautiful area of multi-partition communication complexity in Appendix [\ref=app:CC].

We will use a powerful theorem which follows directly from the results in [\cite=DurisHJSS04].

For every [formula] and every m'  ≤  n' / 32 there is a linear code C with a m'  ×  n' parity check matrix such that every multi-partition rectangle cover of the characteristic function fC has size at least [formula].

Accepting Codes by CNF Formulas

In this section we will construct CNF formulas to accept linear codes. We will first start with a naive encoding that will turn out to be of unbounded modular treewidth and thus not directly helpful to us. We will then show how to change the encoding in such a way that the modular treewidth and even the neighborhood diversity are small and the size of the resulting CNF is small enough to show meaningful lower bounds for encodings in DNNF with Theorem [\ref=thm:combinecodes].

The naive approach

In this subsection, we show how we can check m linear equations on variables [formula] efficiently by CNF. The idea is to simply consider one variable after the other and remember the parity for the equations at hand. To this end, fix an m  ×  n matrix A = (aij). We denote the resulting equations of the system Ax̄ = 0 by [formula]. For each equation Ei we introduce variables zij for j∈[n] which intuitively remembers the parity of Ei up to seeing the variable xj.

We encode the computations for each Ei individually: Introduce constraints

[formula]

Note that zi,n yields the parity for equation Ei which can then be checked for 0. This yields a system whose accepted inputs projected to the xi are the code words of the considered code. The constraints have all at most 3 variables, so we can encode them into CNF easily.

Unfortunately, the resulting CNF can be shown to have high modular treewidth, so it is not useful for our considerations. We will see how to reduce the modular treewidth and the neighborhood diversity of the system without blowing up the size of the resulting CNF-encoding too much.

Bounding modular treewidth

The idea for decreasing the modular treewidth is to not encode all constraints on the parities individually but combine them into larger constraints. So fix n and k and set m: = k log (n). For each j, we will combine the constraints from ([\ref=eq:1]) and ([\ref=eq:2]) for blocks of log (n) values of i into one. The resulting constraints are

[formula]

and

[formula]

for [formula].

Note that the constraints [formula] have at most 2 log (n) + 1 boolean variables, so we can encode them into CNF of quadratic size where every clause contains all variables of [formula]. Moreover, the [formula] encode all previous constraints from ([\ref=eq:1]) and ([\ref=eq:2]), so the assignments satisfying all [formula] projected to the xi still are exactly the code words of the code we consider. Call the resulting CNF F.

F has modular pathwidth at most 2k - 1.

Note that the clauses introduced when translating the constraint [formula] into CNF have by construction all the same set of variables. Thus these clauses have the same neighborhood type, and we can for modular treewidth restrict to an instance just having one clause for each [formula]. We call the resulting vertex in the incidence graph [formula]. Next, observe that the variables [formula] and [formula] for i,i'∈[log (n)] appear in exactly the same clauses. Thus these variables have the same neighborhood type as well, so we can delete all but one of them, say [formula] for [formula]. Call the resulting vertices in the incidence graph [formula].

The resulting graph G = (V,E) has

[formula]

We construct a path decomposition of G as follows: The bags are the sets

[formula]

and for [formula]

[formula]

Ordering the bags Bj with respect to their index yields a path decomposition of G of width 2k - 1.

Let us collect the results of the section into one statement.

For every linear code C with a k log (n)  ×  n parity check matrix there is a CNF formula F in variable sets X and Z such that

the solution set of F projected to X is exactly C,

F has size O(kn3 log (n)2), and

F has modular pathwidth at most 2k - 1.

It remains only to show the size bound on F. Note that we have n variables xj and kn log (n) variables zi,j. Moreover, we have kn log (n) constraints [formula]. Each of those has 2 log (n) + 1 variables, so it can be encoded by O(n2) clauses with O( log (n)) variables each. This yields O(kn3 log (n)) clauses with O( log (n)) variables. Consequently, the overall size of F is O(kn3 log (n)2).

Bounding neighborhood diversity

Fix now two positive integers N and k and let n: = 32k log (N) and m: = k log (N) and consider A with these parameters as before. We want to encode the code of A by a CNF with neighborhood diversity O(k2).

To do so, we split the variables zij into O(k2) sets of log (N)2 variables Srs: = {zij|i∈[r log (N)  +  1,(r  +  1) log (N)],j∈[s log (N)  +  1,(s  +  1) log (N)  -  1]} for r∈[k] and s∈[32k]. Now create for all r∈[k], s∈[32k  -  1] a constraint Rrs in the variables [formula] that accepts all assignments to its variables that satisfy all constraints from [\ref=eq:1] and [\ref=eq:2] whose variables are variables of Rrs. Note that the resulting constraints cover all constraints of Section [\ref=sct:naive], so we still accept the code defined by A after projection to X.

The problem now is that, since we have Θ( log (N)2) boolean variables in each constraint, the resulting encoding into CNF could be superpolynomial in N and thus to big for our purposes. This is easily repaired by the observation that fixing the values of xi, zi,s log (N) and zi,s log (N) + 1 determines the values of the other zij in all satisfying assignments. Consequently, we can project out these variables of the individual constraints without changing the accepted assignments to X. Call the resulting constraints R'rs. It is easy to see that every constraint R'rs has only O( log (N)) variables, so the CNF encoding in which every variable of Rr,s' appears in every clause has polynomial size in N.

We claim that the resulting CNF F has neighborhood diversity O(k2). To see this, note that the clauses introduced in the encoding of a fixed R'rs all have the same variables. It follows that the clause vertices in the incidence graph have O(k2) neighborhood types. The variables in X all appear in all clauses, so they are all of the same neighborhood type. Finally, the vertices in each Srs appearing in an Rrs' all appear in the same clauses, so they have O(k2) neighborhood types as well. This show that the incidence graph of the CNF formula F has neighborhood diversity O(k2).

Let us again combine the results of this section into one summary statement.

For every linear code C with a k log (N)  ×  32k log (N) parity check matrix there is a CNF formula F in variable sets X and Z such that

the solution set of F projected to X is exactly C,

F has size polynomial in N and k, and

F has neighborhood diversity O(k2).

Completing the Proof

We now combine the results of the previous sections to get our main results.

Let C be a linear code as in Theorem [\ref=thm:combinecodes] with parameters [formula] and [formula]. Then by Theorem [\ref=thm:combinecodes] we know that every rectangle cover of the characteristic function fC has size at least [formula].

Now apply Lemma [\ref=lem:encodecode] to C to get a CNF-formula F of size less than n and modular pathwidth less than k. Let D be a DNNF representation of F of minimal size s. Since DNNFs allow projection to a subset of variables without any increase of size [\cite=Darwiche01], this yields a DNNF of size s computing fC. But then by Theorem [\ref=thm:communicationDNNF], we get that s  ≥  nΩ(k).

With the same proof but other parameters we get Theorem [\ref=thm:mainnd] from Lemma [\ref=lem:encodecode2].

Connections to Model Counting and Affine Decision Trees

In this section we discuss connections of the findings of this paper to practical model counting. It has been shown that there is a tight connection between compilation and model counting, as runs of exhaustive DPLL-based model counting algorithms can be translated into (restricted) DNNFs [\cite=HuangD05]. Here the size of the resulting DNNF corresponds to the runtime of the model counter. Since state of the art solvers like Cachet [\cite=SangBBKP04] and sharpSAT [\cite=Thurley06] use exhaustive DPLL, the lower bounds in this paper can be seen as lower bounds for these programs: model counting for CNF formulas of size n and, modular treewidth will take time at least nΩ(k) when solved with these state-of-the-art solvers even with perfect caching and optimal branching variable choices. Note that in the light of the general conditional hardness result of [\cite=PaulusmaSS13] this is not surprising, but here we get concrete and unconditional lower bounds for a large class of algorithms used in practice. Naturally, we also directly get lower bounds for approaches that are based on compilation into DNNF as those in [\cite=Darwiche04] [\cite=MuiseMBH12], so we have lower bounds for most practical approaches to model counting.

One further interesting aspect to observe is that, while the instances that we consider are in a certain sense hard for practical model counting algorithms, in fact counting their models is extremely easy. Since we just want to count the number of solutions of a system of linear equations, basic linear algebra will do the job. A similar reasoning translated to compilation is the background for the definition of affine decision trees (ADT) [\cite=KoricheLMT13], a compilation language that intuitively has checking an affine equation as a built-in primitive. Consequently, it is very easy to see that ADTs allow a very succinct compilation of the CNF formulas we consider in this paper. It follows, by setting the right parameters, that there are formulas where ADTs are exponentially more succinct than DNNF. We remark that this superior succinctness can also be observed in experiments when compiling the formulas of Section [\ref=sct:naive] with the compiler from [\cite=KoricheLMT13].

Conclusion

We have shown that parameters like cliquewidth, modular treewidth and even neighborhood diversity behave significantly differently from treewidth for compilation into DNNF by giving lower bounds complementing the results of [\cite=BovaCMS15]. These unconditional lower bounds confirm conditional ones that had been known for some time already and improve them quantitatively. Our proofs heavily relied on the framework proposed in [\cite=IJCAIversion] thus witnessing the strength of this approach. We have also discussed implications for practical model counting.

One consequence of our results is that most graph width measures that allow dense incidence graphs for the input CNF--like modular treewidth or cliquewidth and unlike treewidth which forces a small number of edges--do not allow fixed-parameter compilation into DNNF. A priori, there is no reason why many edges in the incidence graphs, which translates into many big clauses, should necessarily make compilation hard. Thus it would be interesting to see if there are any width measures that allow dense graphs and fixed-parameter compilation at the same time. One width measure that might be worthwhile analyzing is the recently defined measure sm-width [\cite=SaetherT14].

Acknowledgments.

The author would like to thank Florent Capelli for helpful discussions. Moreover, he thanks Jean-Marie Lagniez for helpful discussions and for experiments with the compiler from [\cite=KoricheLMT13].

DNNF

In this section of the appendix, we give a short primer on DNNFs. For more background, we recommend the very influential paper [\cite=DarwicheM02].

A (Boolean) circuit in negation normal form (or NNF) is a directed acyclic graph (DAG) with a single sink node (outdegree 0) where each source node (indegree 0) is labelled by a constant (0 or 1) or by a literal, and each other node is labelled by [formula] (AND) or [formula] (OR). If φ is an NNF and v is a vertex of φ, the sub-NNF of φ rooted at v is the NNF obtained from φ by deleting every vertex from which v cannot be reached along a directed path. We write [formula] for the set of variables occurring in an NNF φ. Let φ be an NNF and let τ be an assignment to [formula]. Relative to τ, we associate each vertex v of φ with a value [formula] as follows. If v is labelled with a constant c∈{0,1} then [formula], and if v is labelled with a literal [formula] then [formula]. If v is an AND node then we let [formula] is a child of v  }, and if v is an OR node we define [formula] is a child of v  }. We say that τ satisfies φ if [formula], where s denotes the (unique) sink of φ. The function computed by φ is defined in the obvious way.

An NNF φ is decomposable (in short, a DNNF) if every AND node v of φ satisfies the following property: if v has incoming edges from v1 and v2, and φ1 and φ2 denote the sub-NNFs of φ rooted at v1 and v2, respectively, then [formula] and [formula] are disjoint. A DNNF φ is deterministic (a d-DNNF) if, for every pair of distinct children v1 and v2 of an OR node, the sub-NNFs rooted at v1 and v2 do not have satisfying assignments in common.

DNNFs have first been defined by Darwiche [\cite=Darwiche01] and since then played a central role in knowledge compilation. There are several reasons for this success: It has been shown [\cite=DarwicheM02] that DNNFs can be seen as a generalization of many other successful representations that are used in knowledge compilation, in particular classical languages like OBDDs and FBDDs. Note however that DNNFs are in general far more succinct than these classical representation. Seeing known compilation languages as subclasses of DNNFs has several advantages. In particular it facilitates the structured and systematic comparison of different representations. Moreover, this systematic understanding allows to easily define new compilation languages as subclasses of DNNFs that have desirable properties for a task at hand. For example, the class of sentential decision diagrams [\cite=Darwiche11] is a subclass of DNNF defined in such a way as to have canonical representations, a property that often plays a central role in practice. Similarly, deterministic DNNFs are a restriction of DNNFs that is useful whenever efficient model counting is required. Arguably, seeing DNNFs as a unifying framework for the creation of compilation languages has been very influential in the field.

Some communication complexity

We introduce some very limited notions of communication complexity. The interested reader is referred to [\cite=KushilevitzN97] for general background and to [\cite=DurisHJSS04] for the rather specific notions and results on multi-partition communication complexity that appear in this paper.

Let f be a boolean function defined on a set X of n boolean variables. Let Π  =  (X1,X2) be a partition of X. We say that Π is β-balanced for β > 0 if min (|X1|,|X2)  ≥  β|X|. The exact value of β is unsubstantial for most of our considerations, and it is most of the time only necessary to assume that there is some constant β for which all partitions that are considered are β-balanced. Consequently one often simply speaks of balanced partitions.

A combinatorial rectangle with respect to the partition Π is a function r:{0,1}n  →  {0,1} that can be written as [formula], where the functions r(1),r(2):{0,1}n  →  {0,1} depend only on the variables in X1 and X2, respectively. We define a (multi-partition) rectangle cover of f of size t to be a set of rectangles [formula] such that [formula]. Note that in a rectangle cover each rectangle may be with respect to its own balanced partition of the variables in X.

Rectangle covers generalize similar notions of covers in in communication complexity by allowing different partitions for the different rectangles. They were originally defined to prove lower bounds for different types of branching programs in which the variables are not met in a fixed order. In [\cite=BovaCMS15] it was shown that lower bounds on the size of rectangle covers also give lower bounds for different versions of DNNFs, see e.g. Theorem [\ref=thm:communicationDNNF].