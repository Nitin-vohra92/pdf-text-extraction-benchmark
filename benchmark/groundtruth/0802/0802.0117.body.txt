Modeling Air Traffic Flow Management

Acknowledgments

I am grateful to my guide, Dr. Pritibhushan Sinha, for his constant support and encouragement. It is due to him, that I could work not only on the theoretical but also on the practical parts of the problem. The procedure for reducing the problem size, mentioned in the "Directions for future work," is a result of his valuable suggestions. This course was indeed a refreshing change from the otherwise descriptive courses at IIM-K. I have benefited a lot from discussions with Dr. Saji Gopinath, regarding puzzles and other applications of Integer Programming, which would be reflected implicitly through this work.

I would like to thank Ms. T.Sunitha, Assistant Librarian at the Library and Information Centre of IIM-Kozhikode for help in procuring reference materials. I was previously a graduate student in Aerospace Engineering at IISc Bangalore and the initial idea for this project was to some extent, a result of discussions with my guide, Professor B.N. Raghunandan. The GNU Mathprog language that we have used here is available freely only because of the Open Source movement and thanks are due to Andrew Makhorin and others who develop and maintain it.

The problem

Air Traffic Flow Management is the regulation of air traffic in order to avoid exceeding airport or flight sector capacity in handling traffic, and to ensure that available capacity is used efficiently. The number of flights taking off or landing from a certain airport or the number of planes traveling in a particular sector are functions of several variables including:

The number of runways available

ATC capacityThe Air Traffic Controllers and the Control centre perform various tasks like: Terminal Approach, Final Approach, Ground (arrivals), Gate operations (arrivals), Airport Surface, Gate operations (departures), Ground (departures) and finally the Take-Off / Transition to Terminal and Center. Thus the number and expertise of ATCs available determines the airport capacity to a certain extent.

Restrictions as to which aircraft can follow an aircraft of a given class This is because an aircraft periodically sheds vortices from the wing tips. These vortices can interact with the boundary layer around the wing of an aircraft following in the first aircraft's wake and destroy the lift. The effect is more pronounced when the following aircraft is of a smaller size class then the leading one. This means that a delay must be imposed such that Ft  ≥  Lt  +  δF,L where Ft and Lt denote the times at which the follower and the leader take-off or land and δF,L denotes the delay.

Airspace restrictions Aircraft have to follow certain "corridors" when traveling in air. This restricts the number of aircraft that can be airborne at any given instant. Finally, most of the restrictions mentioned above, are functions of time too. This makes the problem dynamic in nature.

Existing models

Airport and airspace capacity is the major cause of congestion. The difficulty in dealing with this parameter is its uncertainty heavily influenced by weather conditions among other factors. Short-term solutions (12 hours time horizon) for air traffic flow management include ground-holding policies. These policies are motivated by the fundamental fact that airborne delays are much costlier than ground delays, since the former include fuel, maintenance, depreciation and safety costs. Therefore, the aim of ground-holding policies is to translate anticipated airborne delays to the ground. In addition to ground holding, distributing the traffic efficiently across the airspace helps in reducing congestion in the network.

Several models have been proposed in the literature for problem solving under different real-life hypotheses. The Single-Airport Ground Problem (SAGHP) only considers a single airport and the goal is to produce ground-holding schedules. The Multi-Airport Ground-Holding Problem (MAGHP), Andreatta et.al.[\cite=Andreatta] considers a network of airports such that the ground-holding policies for one of them have impact on the other airport schedules, as can be seen in Vranas et.al. [\cite=Vranas] . The Air Traffic Flow Management Problem (TFMP) is similar to MAGHP but also considers the airspace network besides the airport capacity, Bertsimas et.al. [\cite=Bert]. The main assumption on the problem made by most of the approaches described in the open literature is the deterministic character of the data.

Motivation and Objectives

The present work focuses on the seminal paper, due to Bertsimas et.al [\cite=Bert] in which the polyhedral structure of the TFMP is analyzed. The authors of this paper claim that by using a transformation of the decision variables, a formulation in which some inequalities define the facets of the convex hull of the TFMP was obtained.

This is a significant improvement in the formulation, since Polyhedral theory indicates that under the conditions mentioned above, the LP relaxation of the TFMP, might be integral. This means that we may not need techniques like branch and bound, at least in some of the cases. In this work an attempt has been made to understand and verify the claims made in the paper [\cite=Bert]. To be specific:

The physical problem was studied in terms of the several formulations (SAGHP, MAGHP, TFMP) available.

We tried to understand the main results of of Polyhedral Combinatorics, principally through the textbook by Wolsey and Nemhauser [\cite=Wolsey].

The paper due to Bertsimas et.al [\cite=Bert] was examined in the light of this theory to understand how the formulation helps to achieve integral solutions.

Method

The Traffic Flow Management Problem (TFMP)

This subsection has been reproduced verbatim from Bertsimas et.al [\cite=Bert]. Consider a set of flights, [formula], a set of airports, [formula], a set of time periods, [formula], and a set of pairs of flights that are continued, [formula]. We shall refer to any particular time period t as the "time t". The problem input data are given as follows: Nf = number of sectors in flight f's path P(f,i) = the ith sector in flight f's path Pf  =  {P(f,i):1  ≤  i  ≤  Nf} Dk(t)= departure capacity of airport k at time t Ak(t)= arrival capacity of airport k at time t Sj(t) = capacity of sector j at time t df  =   scheduled departure time of flight f rf  =   scheduled arrival time of flight f sf  =   turnaround time of an airplane after flight f cfg  =   cost of holding flight f on the ground for one unit of time cfa  =   cost of holding flight f in the air for one unit of time lfj  =   number of time units that flight f must spend in sector j Tjf  =   set of feasible times for flight f to be in sector j Note that by "flight," we mean a "flight leg" between two airports. Also, flights referred to as "continued" are those flights whose aircraft is scheduled to perform a later flight within some time interval of its scheduled arrival. Objective: The objective in the TFMP is to decide how much each flight is going to be held on the ground and in the air in order to minimize the total delay cost. We model the problem as follows. Decision variables:

Note that the wjft are defined as being 1 if flight f arrives at sector j by time t. This definition using by and not at is critical to the understanding of the formulation. Also recall that we have also defined for each flight a list Pf of sectors which includes the departure and arrival airports, so that the variable wjft will only be defined for those sectors j in the list Pf. Moreover, we have defined Tjf as the set of feasible times for flight f to be in sector j, so that the variable wjft will only be defined for those times within Tjf. Thus, in the formulation whenever the variable wjft is used, it is assumed that this is a feasible (f,j,t) combination. Furthermore, one variable per flight-sector pair can be eliminated from the formulation by setting wjf = 1 where [formula] is the last time period in the set Tjf . Since flight f has to arrive at sector j by the last possible time in its time window, we can simply set it equal to one as a parameter before solving the problem.

Having defined the variables we can express several quantities of interest as linear functions of these variables as follows:

Noticing that the first sector for every flight represents the departing airport, then the total number of time units that flight f is held on the ground is the actual departure time minus the scheduled departure time, i.e., .

Noticing that the last sector for every flight represents the destination airport, the total number of time units that flight f is held in the air can be expressed as the actual arrival time minus the scheduled arrival time minus the amount of time that the flight has been held on the ground, i.e.,

[formula]

The objective of the formulation is to minimize total delay cost, and the TFMP is hence:

[formula]

[formula]

[formula]

[formula]

[formula]

[formula]

[formula]

[formula]

The first three constraints take into account the capacities of various aspects of the system. The constraint ([\ref=depcap]) ensures that the number of flights which may take off from airport k at time t, will not exceed the departure capacity of airport k at time t. Likewise, the constraint ([\ref=arrvcap]) ensures that the number of flights which may arrive at airport k at time t, will not exceed the arrival capacity of airport k at time t. In each case, the difference will be equal to one only when the first term is one and the second term is zero. Thus, the differences capture the time at which a flight uses a given airport. The constraint ([\ref=sectorcap]) ensures that the sum of all flights which may feasibly be in sector j at time t will not exceed the capacity of sector j at time t. This difference gives the flights which are in sector j at time t, since the first term will be 1 if flight f has arrived in sector j by time t and the second term will be 1 if flight f has arrived at the next sector by time t. So the only flights which will contribute a value 1 to this sum are the flights that have arrived at j and not yet departed by time t. Constraints ([\ref=transit]) represent connectivity between sectors. They stipulate that if a flight arrives at sector j́ by time t  +  lfj, then it must have arrived at sector j by time t where j and j́ are contiguous sectors in flight f's path. In other words, a flight cannot enter the next sector on its path until it has spent lfjtime units (the minimum possible) traveling through sector j, the current sector in its path. Constraints ([\ref=turn]) represent connectivity between airports. They handle the cases in which a flight is continued, i.e., the flight's aircraft is scheduled to perform a later flight within some time interval. We will call the first flight  and the following flight f. Constraints ([\ref=turn]) state that if flight f departs from airport k by time t, then flight  must have arrived at airport k by time t  -  s. The turnaround time, s, takes into account the time that is needed to clean, refuel, unload and load and further prepare the aircraft for the next flight. In other words, flight f cannot depart from airport k, until flight  has arrived and spent at least s time units at airport k. Constraints ([\ref=by]) represent connectivity in time. Thus, if a flight has arrived by time t, then wft, has to have a value of 1 for all later time periods, t́  ≥  t.

Complexity of the TFMP

Bertsimas et.al., [\cite=Bert], proved that the TFMP with all capacities equal to 1 is NP-hard, by showing equivalence with the Job-shop scheduling problem.

Computational results due to Bertsimas et.al. [\cite=Bert]

Bertsimas et.al, solved many instances of the MAGHP and the TFMP using a CPLEX 2.1 solver. They used as many as 1000 flights, varying the number of connected flights from 1/5 to 4/5 of the total flights being flown. The problem was solved over a 24-hour period, with intervals of 15 min. Even at the infeasibility border (which represents the data set such that even a minor change in parameters will make the constraints inconsistent), only 4% of the solutions were found to be non-integral, that too for the MAGHP. All instances of the TFMP had integral solutions.

Polyhedral combinatorics to identify Facet defining constraints

The use of the variables denoting whether a flight has arrived by a certain time rather than at a certain time has advantages, achieved in terms of a "stronger" formulation. Key results from Polyhedral theory, relevant to the present work are included here and are used in sketching a constructive proof of the high incidence of integral solutions even for the LP relaxation of TFMP.

Basic Concepts from Polyhedral Theory

The definitions and theorems in this section, closely follow the development given in Wolsey and Nemhauser [\cite=Wolsey].

A set of k vectors,[formula] is defined to be affinely independent if

A polyhedron [formula] is a set of points that satisfy a finite number of linear inequalities; that is, [formula], where (A,b) is an m  ×  (n + 1) matrix.

The dimension of a Polyhedron P is one less than the cardinality of the maximal set of affinely independent points in P.

If [formula], then dim(P) + rank(A=,b=) = n where (A=,b=) is the equality set consisting of the rows corresponding to [formula].

An inequality πx  ≤  π0 is called valid for polyhedron [formula] if it is satisfied by all points of P.

If πx  ≤  π0 is a valid inequality for P and F = {x∈P:πx = π0} then F is called a face of P, represented by (π,π0). ([formula] iff max {πx:x∈P}  =  π0).

A face of P, is called a facet if dim(F) = dim(P) - 1.

The facets of P are necessary and sufficient for the description of P.

The set S is defined as [formula] where [formula]. The convex hull of S is denoted as conv(S) and [formula], where xi∈S and [formula], with [formula]

If πx  ≤  π0 defines a face of dimension k - 1 of conv(S), [formula] affinely independent points x1,....,xk∈S such that πxi  =  π0, for i = 1,...,k.

A point x∈P is called an extreme point if [formula] such that [formula]

A maximal valid inequality for S, is one that dominates all other valid inequalities. The set of maximal valid inequalities of S contains all the facet-defining inequalities of conv(S), p.207 [\cite=Wolsey].

The development in Wolsey [\cite=Wolsey], uses a theorem relating the extremal points of the convex hull of S, to those of the set S itself. They state a property without proof, for which the following intuitive proof can be given. The point y∈conv(S) is assumed to have the property that [formula] such that [formula]. There are several cases depending on where the point y lies in Figure [\ref=extremal]:

[formula]. This contradicts the assumption that y is an extremal point of conv(S). This is because all strictly interior points can be obtained as (non-trivial) convex combinations of some other points.

[formula]. Refer to Figure [\ref=extremal]. However, such points on the boundary of conv(S) can be obtained as (non-trivial) convex combinations of the extremal points of S, (and S  ⊆  conv(S)), thus contradicting the assumption.

If y does not lie in any of the regions mentioned above, then y∈S and S  ⊆  conv(S). Now, if y is not an extremal point of S, [formula], such that [formula], where x1,x2∈conv(S), contradicting the assumption again leading to the following lemma.

Hence, if such an extremal point of [formula] it must be one of the extremal points of S.

If [formula] is the feasible set of the LP relaxation of the IP max {cx:x∈S} where [formula] and the LP on the convex hull of S, max {cx:x∈conv(S)} has an optimal solution, [formula](which will be an extremal solution, since conv(S) is a polyhedron), then [formula] will be an optimal solution to the IP on S too.

Why the formulation used by Bertsimas et.al., [\cite=Bert] is strong?

We shall now try to explain the logic behind the occurrence of integral solutions when using the particularly strong formulation, given by Bertsimas et.al, [\cite=Bert] using a constructive proof.

Constructive Proof

Try to find the conv(S), which is difficult usually. If we can find the conv(S) uniquely, we are done by Theorem [\ref=main]. Else

Check which of the inequalities governing the IP are facets of the IP. This can be done by choosing each aix  ≤  bi in turn and finding the dim(F) where F is the set of points in IP satisfying aix  ≤  bi as equality. If dim(F) = dim(IP) - 1, F is a facet according to Definition [\ref=facet].

The facets of S are also facets of conv(S) by Property [\ref=facet_S_convS]. If, by using this iterative method, we can find the complete set of facets of conv(S), we are done, as solving the LP on conv(S) for an optimal solution (if it exists) will give an optimal solution to IP too, by Theorem [\ref=main]. However, even if we cannot get all the facets, of conv(S) as is the case in real-life instances, the formulation is strong because of some constraints being facets and there is a high possibility of getting integral solutions.

Implementation

We implemented the TFMP on artificially constructed flight data sets, to assess the computational performance of the model. Gnu Mathprog was used as the translator as it employs symbolic algebraic notation, which has advantages over languages like LINDO, which require that each constraint, alongwith the numerical values of the parameters be explicitly written down. The model was solved using the Open-source GLPK [\cite=Gnu] linear solver. The standalone solver contained within GLPK, glpsol was used for this project.

The Gnu Mathprog code

Gnu Mathprog is an open-source code based on the C language. It is in fact the old version of AMPL as given in the paper by Kernighan et.al. [\cite=kerni]. The data consists of three primary sets:

The set of airports and sectors, denoted as [formula].

[formula]

The set of flights, denoted as [formula].

[formula]

The Mu_Pu_Go flight is continued by the Go_Ca flight. Other flights are independent of each other.

The set of time intervals, [formula] over which the schedule is to be prepared.

The Gnu Mathprog model for the TFMP is shown below. The model is mostly self-explanatory, but the reader is referred to Kernighan et.al  [\cite=kerni] for details.

Gnu Mathprog Model

Sample data for the model

The data file can be maintained separately from the model, to permit different data to be solved using the same model. The data has to be in a certain format for the interpreter-solver (glpsol) to work properly. Refer to [\cite=Gnu] for details.

The data file (unformatted)

Solution

The LP relaxation of the TFMP model is first solved with [formula] to verify if our data set supports the claims made in the paper by Bertsimas et.al  [\cite=Bert].

Solution to the LP relaxation of TFMP with conflicting flights

A set of imaginary flights Pu_Be_Ba and Go_Co_Ba having the same scheduled arrival timings at Bangalore, which has an arrival capacity for only one flight was created, as in Table [\ref=tab_conflict]. However, even for this conflicting data set, the LP relaxation still had integral solutions, lending support to the results due to Bertsimas et.al. The Pu_Be_Ba flight is held for one interval after its scheduled departure from Goa, in order to satisfy the conflicting constraints. The minimal cost is 800 corresponding to the value of the Pu_Be_Ba flight, cgPu_Be_Ba.

Baseline solution without conflicts

The LP relaxation of the TFMP is now solved with the baseline data set, as in Table [\ref=tab_base]. As can be seen from the solution below, the linear program adjusts the departure and arrival timings so that the total cost is minimum. For the baseline data set, the cost is zero, implying that there are no delays of any sort.

Arrivals/Departures before scheduled time: negative costs

A further interesting instance is when the actual arrival/departure timings are before the scheduled timings. Clearly, there is nothing restrictive about the formulation which will prevent such an instance from being considered. However, the economic interpretation is not the same. Moreover, with the objective being of minimization, the solver forces high values of negative air delays. In fact, there might be a situation, where one flight has a very high negative air delay and others have low positive values of ground delay. The real total cost, then is not negative. Actually, wherever a cost variable has a negative value it can be substituted by an auxiliary variable indicating its real value as

[formula]

where Real cost=  α and computed cost=β. The objective function will be β while the problem is to minimize it. The solution sumarized in Table [\ref=tab_negcost], indicates such an instance of a negative cost, due to a negative air delay for the Go_Ca__Ba flight.

Departure of an outgoing flight scheduled before arrival of the incoming connecting flight

This solution, seen in Table [\ref=tab_connect], indicates how the Go_Ca flight is delayed on the ground at Goa airport, because its scheduled departure is before the scheduled arrival of its incoming-connecting Mu_Pu_Go flight at Goa airport.

Conclusions

We have tried to explore the logic behind the claims by Bertsimas et.al about integral solutions to the LP relaxation of the TFMP.

Polyhedral theory only indicates that the stronger TFMP formulation of Bertsimas et.al might lead to integral solutions in some cases. Unless we obtain all facet-defining inequalities of the conv(S), we are not assured of obtaining integral solutions from the LP relaxation. Therefore, only computations can provide a rough estimate of the frequency of integral solutions, in the worst case, which in turn will decide whether the formulation offers practical advantages. Our computations indicate that the encouraging results reported by Bertsimas et.al are not merely fortuitous or due to their specific data set. Indeed, we found that the TFMP had integral solutions even in case of artificial data sets generated to include severe conflicts in the flight schedules. In our limited tests with 4-5 scenarios, we obtained non-integral solutions only once.

This is of significant practical importance because, the LP relaxation can be solved even on small machines with low memory and processor speed. The formulation with 308 variables took less than 0.1 seconds when solved on a regular IBM laptop having 1GB RAM and 1.66 GHz Processor speed. In contrast, the Integer program has to be solved by Branch and Bound which would be much more expensive and difficult to implement on such a machine, especially since the number of variables rises rapidly with addition of new flights. The importance of obtaining integral solutions, using the LP relaxation itself (without the need for Branch and Bound), will be more acutely felt for problems of large sizes.

Directions for future work

An important observation, is that the size of the problem is quite large even for simple cases. E.g. for a data set with 4 flights, 7 sectors and 11 time slots, the formulation already has 308 variables. In a real life data set, the proportion of conflicting flights may not be very high. In such a situation, it is better to solve the LP for only those flights which are in conflict with each other.

One approach could be, to use the scheduled arrival and departure timings,to generate a set of flights which are in conflict with each other, called the set[formula]. The set [formula] then consists of flights which are not in conflict either among themselves or with those in [formula] . The TFMP is solved only for flights [formula]. Then, the entire set [formula] is again checked for conflicts, with the flight timings for those in [formula] now updated to those given by the TFMP solution. If this causes some flights in [formula] to be in conflict with those in [formula], such flights are transferred from [formula] to [formula] . This iterative process is continued till we get a schedule with no conflicts.The problem with such an approach is that the set [formula] might grow, until finally [formula] thus offering no advantages in terms of problem size. Moreover, the TFMP has to be solved once per iteration and further analysis needs to be done to weigh the benefits of solving a reduced problem, against the expense in solving the TFMP several times. The concept, is however very attractive for an initial schedule having very few conflicting flights, if some heuristics can be developed to locally adjust the conflicting set [formula] without affecting the larger, non-conflicting set [formula].