=1

Prediction of Dynamical Systems by Symbolic Regression

Introduction

The prediction of the behavior of dynamical systems is of fundamental importance in all scientific disciplines. Since ancient times, philosophers and scientists have tried to formulate observational models and infer future states of such systems. Applications include topics as diverse as weather forecasting [\cite=9780511817496], the prediction of the motion of the planets [\cite=gauss1809theoria], or the estimation of quantum evolution [\cite=Schroedinger26]. The common ingredient of such systems - at least in natural sciences - is the existence of an underlying mathematical model which can be applied as the predictor. In recent years, the use of artificial intelligence (AI) or machine learning (ML) methods have complemented the formulation of such mathematical models through the application of advanced data analysis algorithms that allow accurate estimation of observed dynamics by learning automatically from the given observations and building models in terms of their own modelling languages. Artificial Neural Networks (ANNs) are one example of such techniques that are popularly applied to model dynamic phenomena. ANNs are structured as networks of soft weights organized in layers or so-called neurons or hidden units. One problem of ANN type approaches is the difficult-to-interpret black-box nature of the learnt models. Symbolic regression-based approaches, such as Genetic Programming (GP), provide alternative ML methods that are recently gaining increasing popularity. These methods, similar to other ML counterparts, learn models from observed data and act as good predictors of the future states of dynamical systems. Their added advantages over other methods include the interpretable nature of their learnt models and a flexible and weakly-typed [\cite=cardelli1985understanding] modelling language that allows them to be applied to a variety of domains and problems.

Undoubtedly, the methods used most often in ML are neural networks. These involve deep learning, in the sense that several layers are used and interpreted as the organization of patterns, as one imagines the human brain to work. In the present study, involving deterministic systems, we want to use a certain branch of ML, namely symbolic regression. This technique joins the classical, equation-oriented approach with its computer-scientific upstart. In this publication we do not present any major improvements in the algorithms; rather we demonstrate how one can apply symbolic regression to identify and predict the future state of dynamical systems.

Symbolic regression algorithms work by exploring a function space, which is generally bounded by a preselected set of mathematical operators and operands (variables, constants, etc.), using a population of randomly generated candidate solutions. Each candidate solution encoded as a tree essentially works as a function and is evaluated based on its fitness or in other words its ability to match the observed output. These candidate solutions are evolved using a fitness-weighted selection mechanism and different recombination and variation operators. One common problem in symbolic regression is the bloating effect which is caused by excessive lengthening of individual solutions or filling of the population by large number of solutions with low fitness. In this work we use a multi-objective function evaluation mechanism to avoid this problem by including minimizing the solution length as an explicit objective in the fitness function.

Symbolic regression subsumes linear regression, generalized linear regression, and generalized additive models into a larger class of methods. Such methods have been used with success to infer equations of dynamical systems directly from data [\cite=Voss-Kolodner-Abel-Kurths-99] [\cite=abel2005additive] [\cite=Abel-04] [\cite=Rey2014869] [\cite=brunton2015discovering]. One problem with deterministic chaotic systems is the sampling of phase space using embedding. For a high-dimensional system, this leads to prohibitively long sampling times. Typical reconstruction methods use delay coordinates and the associated differences, this results in mapping models for the observed systems. Mathematically, differential coordinates are better suited for modelingbut they are not always accessible from data. Both approaches, difference and differential embedding, are discussed in [\cite=Ahnert-Abel-07] with numerical methods to obtain suitable differential variables from data. Modern methods like diffusion maps [\cite=Tenenbaum22122000] [\cite=singer2009detecting] or local linear embedding [\cite=Roweis22122000], including the analysis of stochastic systems, circumvent the curse of dimensionality by working directly on the manifold of the dynamical system.

Apart from prediction and identification of dynamical systems [\cite=schmidt2009distilling] [\cite=rodriguez1998multi], the symbolic regression approach has been used recently for the control of turbulent flow systems [\cite=Gautier-Abel-Duriez-Segond-Abel-15] [\cite=Brunton-Noack-2015]. In that application, we demonstrate how to find the symbolic equations in a very general form combined with subsequent automatic simplification and multiobjective optimization. This yields interpretable equations of a complexity that we can select. We use open-source Python packages for the analysis. Symbolic regression is conducted using an elastic net method provided by the fast function extraction package (FFX) for quick tests, and the more general, but usually slower method implemented as a genetic programming algorithm (GP) based on the deap package. Subsequent simplification is obtained using sympy. Of course, any other programming framework with similar functionality will do.

For a systematic study we examine numerically-generated data from a harmonic oscillator as the simplest system to be predicted, and a more involved system of coupled FitzHugh-Nagumo oscillators, which are known to produce complex behaviour and may serve as a very simple model for neurons. We investigate the capacity of the ML approach to detect an incoming front of activity, and give exact equations for the regression. We compare different sampling and spatio-temporal embedding methods, and discuss the results: it is shown that a space-time embedding has advantages over time-only and space-only embedding.

Our final example concerns a real-world application, the short-term and medium-term forecasting of solar power production. In principle, this could be achieved trivially by a high-resolution weather forecast and knowledge of the transfer of solar energy to solar cells, a very well-understood process [\cite=lorenzo1994solar]. However, such a highly resolved weather forecast does not exist, because it is prohibitively expensive: even the largest meteorological computers are still unable to compute the weather on small spatial scales, let alone with a long time horizon at high accuracy. As the dynamical systems community identified a long time ago, this is mainly due to uncertainties in the initial conditions, as demonstrated by the celebrated Lorenz equations [\cite=Lorenz-63]. Consequently, we follow a data-based approach and improve upon weather predictions using local energy production data as a time series. We are aware that use of the full set of weather data will improve the reported forecast, but increasing the resolution is not our interest here, rather the proof of concept of the ML method and its applicability to real-world problems.

The rest of this paper is organized as follows. In Sec. [\ref=sec:methods] we discuss the methods and explain our approach. This section is followed by a longer section [\ref=sec:results] where results are presented for the above-mentioned example systems. We end the paper with a summary and conclusions, Sec. [\ref=sec:conclusion].

Methods

In the field of dynamical systems (DS), and in particular nonlinear dynamical systems, reconstruction of the characteristics of an observed system from data has been and is a fundamental scientific topic.

In this regard, one can distinguish parameter and structure identification. We first discuss the existing literature on parameter identification which is easier in that there is an established mathematical framework to fit coefficients to known curves representing experimental data, which in turn result from known dynamics. This can be conducted for linear or non-linear functions. For deterministic systems, with the advent of modern computers, quantities like fractal dimensions, Lyapunov exponents and entropies can also be computed to make systems comparable in dynamics [\cite=Kantz-Schreiber-97] [\cite=Ott-94]. These analyses further allow the rough characterization of the type and number of orbits of a DS [\cite=strogatz2014nonlinear]. On the other hand, embedding techniques have been developed to reconstruct the dynamics of a high-dimensional system from lower-dimensional time series [\cite=Whitney36] [\cite=Takens-81] [\cite=Sauer-Yorke-Casdagli-91].

These techniques have a number of limitations with respect to accuracy and the amount of data needed for making good predictive models. A chaotic system with positive Lyapunov exponents has a prediction horizon which depends heavily on accuracy and precision of the data, since chaos "destroys" information. This can be seen very clearly by the shift map example [\cite=Ott-94]. However a system on a regular orbit, even marked with complicated equations, might be predicted accurately. For high-dimensional systems, one needs a large amount of data to address the "curse of dimensionality" [\cite=Kantz-Schreiber-97]. In fact it can be shown that for each dimension, the number of data needed increases on a power-law basis [\cite=Kantz-Schreiber-97] [\cite=Abarbanel-97]. Eventually, the direct inference of the underlying equations of motion from data can be approached using regression methods, like Kalman filtering, general linear models (GLM), generalized additive models (GAM), or more general schemes, see [\cite=gershenfeld1999nature] and references therein. Apart from the equations themselves, partial derivatives often have to be estimated [\cite=Ahnert-Abel-07], which is an additional problem for low-precision data

We also consider structure identification, which as mentioned above is a more complicated task. In the last 10-15 years, powerful new methods from computer science have been applied to this purpose. This includes numerous studies on diffusion maps, local linear embedding, manifold learning, support vector machines, artificial neural networks, and symbolic regression [\cite=Roweis22122000] [\cite=Tenenbaum22122000] [\cite=bishop2006pattern] [\cite=schmidt2009distilling]. Here, we focus on symbolic regression. It must be emphasized that most methods are not unique and their success can only be tested based on their predictive power.

Symbolic Regression

One drawback of many computational-oriented methods is the lack of equations that can be analyzed mathematically in the neighborhood of analyzed trajectories. Symbolic regression is a way to produce such equations. It includes methods that identify the structure or parameters of the searched equation or both of them simultaneously with respect to objective functions Γi.

This means that methods like GLM, or GAM are contained in such a description. A recent implementation of GLMs is Fast Function Extraction (FFX) [\cite=mcconaghy2011ffx], which is explained briefly below. Genetic programming, explained in detail below, is another intuitive method and often used for symbolic regression. Here, the algorithm searches the function space through random combinations and mutations of functions, chosen from a basic set of equations.

Symbolic regression is supposed to be form free and thus unbiased towards human perception. However, human knowledge enters in the meta-rules imposed on the model through the basic building blocks and rules on how they can be combined. Thus, the optimal model is always conditioned on the underlying meta-rules.

Genetic Programming

Genetic programming is an evolutionary algorithm to find an optimal algorithm or program. The term "programming" in optimization is used synonymously with "plan" or algorithm. It was used first by Dantzig, the inventor of linear programming, at a time when computer programs did not exist as we know them today [\cite=dantzig1985mathematical]. The algorithm seeks an optimal algorithm, in our case a function, using evolutionary, or "genetic" strategies, as explained below. The pioneering work was established by [\cite=koza1992genetic]. We can briefly describe it as follows: in GP we can represent formulae as expression trees, such as that shown in Fig. [\ref=fig:CrossoverMutation]. Non-terminal nodes are filled with elements from a basic function set defined by the meta-rules. Terminal nodes consist of variables or parameters. Given the optimization problem

[formula]

we seek the optimal solution f* through optimizing (minimizing or maximizing, or for some cost functionals, finding the supremum or infimum) the fitness (or cost) functional Γ. To find the optimal solution, GP uses a whole population of candidate solutions in parallel which are evolved iteratively through fitness proportionate selection, recombination and mutation operations. The initial generation is created randomly. Afterwards, the algorithm cycles through the following loop until it reaches its convergence or stopping criteria:

breed: Based on the current generation Gt, a new set of size λ of alternative candidate solutions, the offspring Ot, are selected. Several problem-dependent operators are used for this tweaking step, e.g. changing parts of a candidate solution (mutation) or combining two solutions into two new ones (crossover). These tweaking operations may include selection pressure, so that the "fitter" solutions are more likely to produce offspring.

evaluate: The offspring Ot are evaluated, i.e. their fitness is calculated.

select: Based on the fitness value, members of the next generation are selected.

This scheme fits the requirements of symbolic regression. Mutation is typically conducted by replacing a random subtree by a new tree. Crossover takes two trees and swaps random subtrees between them. This procedure is illustrated in Fig. [\ref=fig:CrossoverMutation]. The fitness function uses a typical error metric, e.g. least squares or normalized root mean squared error.

The random mutations sample the vicinity of their parent solution in function space. As a random mutation could likely lead to less optimal solution, it does not ensure a bias towards optimality. However, this is achieved by the selection, because it ensures that favourable mutations are kept in the set while others are not considered in further iterations.

By design and when based on similar meta-rules, GP includes other algorithms like GLMs or linear programming [\cite=bishop2006pattern].

FFX and the Elastic Net

Here we briefly summarize the FFX algorithm of McConaghy et al. [\cite=mcconaghy2011ffx]. This is a symbolic regression algorithm based on a combined generalized linear model and elastic net approach:

[formula]

where {ai} are a set of coefficients to be determined, and {φi} are an overdetermined set of basis functions described by an heuristic, simplicity-driven set of rules (e.g. highest allowed polynomial exponent, products, non-linear functions, [formula]).

In the elastic method, a least squares criterion is used to solve the fitting problem. To avoid overfitting, i.e. high model sensitivity on training data, two regulating terms are added: The [formula], and [formula] norms of the coefficient vector. The [formula] norm favors a sparse model (few coefficients) and simultaneously avoids large coefficients. The [formula] norm ensures a more stable convergence as it allows for several, possibly correlated variables instead of a single one. The resulting objective function written in its explicit form reads [\cite=Zou05regularizationand]:

[formula]

where y are the data, λ  ≥  0 the regularization weight and ρ∈[0,1] is the mixing between [formula] and [formula] norms. A benefit of the regularized objective function is that it implicitly gives rise to models with different complexity, i.e. different number of bases NB.

For large values of λ, the predicted coefficients will all be zero. Reducing λ will result in more complicated combinations of non-zero coefficients. For every point on the (λ,ρ)-grid, the "elastic net", one can obtain a single optimal model using a standard solver like coordinate descent to determine the optimal coefficients [formula].

A small change in the elastic net parameters leads to a small change in [formula] such that one can use the already obtained solution of a neighboring grid point to restart coordinate descent with the new parameters. For the obtained models we can calculate the normalized root mean-squared error and model complexity (number of used basis functions). The FFX algorithm is based purely on deterministic calculations. Hence its runtime compared to a similar GP algorithm is significantly shorter. However, the meta-rules are more stringent.

Multiobjective Fitness

As mentioned above, the solution of the regression problem is not unique in general. A major factor which motivates symbolic regression is its comprehensible white-box nature opposed to the black-box nature of, for example neural networks. Invoking Ockhams razor (lex parsimoniae), a simple solution is considered superior to a complicated one [\cite=blumer1987occam] [\cite=jefferys1992ockham] as it is more easy to comprehend. In addition, more complicated functions are prone to overfitting. This means that complexity should be a criterion in the function search, such that more complex functions are considered less optimal. We therefore seek a solution which satisfies two objectives.

Comparing solutions by more than one metric Γi is not straightforward. One possible approach is to weight these metrics into one objective Γ:

[formula]

making different candidate solutions easily comparable. The elastic net Eq. [\ref=eq:elasticnet] uses such a composite metric. However, a priori it is assumed that there is a linear trade-off between the individual objectives. This has three major flaws:

One needs to determine suitable (problem dependent) wi.

One does not account for non-linear trade-offs (e.g. all-or-nothing in one objective).

Instead of single optimal solution there may be a set of optimal solutions defining the compromise between conflicting objectives (here error vs complexity).

The optimal set is also called the Pareto-front. This is the set of non-dominated candidate solutions, i.e. candidate solutions that are not worse than any other solution in the population when compared on all objectives. For the FFX algorithm, explained above, one can obtain the (Pareto-) optimal set of candidate solutions by sorting the models. The mapping from parameter space to the Pareto-optimal set is called Pareto-filtering.

Interestingly, the concept of non-domination already partly solves the sorting problem in higher dimensions as it maps from RN to M ordered one-dimensional manifolds: Candidate solutions in the Pareto-front are of rank 0. Similarly, one can find models of rank 1, i.e. all models that are dominated only once (or in other words the nondominated models of all models taken out of the original Pareto-front).

Model 1 f1 can be said to be better than Model 2 f2 if its rank is lower: To compare models of the same rank, one has to introduce an additional heuristic criterion, for which there are several choices [\citep=deb2002fast] [\citep=zitzler2001spea2] [\citep=knowles1999pareto]. Usually the criterion promotes uniqueness of a candidate solution to ensure diversity of the population to avoid becoming trapped in a local minimum. As the uniqueness of a solution may depend on its representation and is usually costly to compute, often its projection to fitness space is used. This is conducted to ensure an effective spread of candidate solutions on the Pareto-front.

For example, the non-dominated sorting algorithm II (NSGAII) [\citep=deb2002fast] uses a heuristic metric called crowding distance or sparsity to compare two models of the same rank. The scaled Euclidean distance in fitness space to the neighboring models is used to describe the uniqueness of a model. For NSGAII we have:

[formula]

Out of the current generation and their offspring [formula] the μ best, in terms of [formula], solutions are chosen for the next generation Gt + 1. This selection method ensures elitism, i.e. the best solutions found so far are carried forward in next generations. Looking at the high-level description in Algorithm [\ref=alg:mumu], Gt can be seen as an archive which keeps old members as long as they are not dominated by a new solution from the current offspring Ot.

The different selection strategies were first studied in the context of genetic algorithms, but more recently they have been successfully applied to symbolic regression [\cite=smits2005pareto] [\cite=vladislavleva2009order].

Our GP setup

For all applications below, our function set is [formula]. All discontinuities are defined as zero. Our terminal set consists of the input data xi as well as symbolic constants ci which are determined during evaluation. We set up our multiple objectives as follows: the algorithm runs until the error of the most accurate model is below 0.1%, or for 100 generations. The population size μ as well as the number of offspring per generation λ is set to 500. The depth of individuals of the initial populations varies randomly between 1 and 4. With equal probability we generate the corresponding expression trees where each leaf might have a different depth or each leaf is forced to have the same depth. For mutation we randomly pick a subtree and replace it with a new tree, again using the half and half method, with minimum size 0 and maximum size 2. Crossover is conducted by randomly picking a subtree each and exchanging them. Our breeding step is composed of randomly choosing two individuals from the current population, performing crossover on them with probability p = 0.5 and afterwards always mutating them. Our multiobjective cost functional has the following components

[formula]

where NRMSE is the normalized root mean-squared error of the observed data y and its predictor [formula], and

[formula]

is simply the total number of nodes in the expression tree f. Selection is conducted according to NSGAII. In this paper, a model is called accurate if its error metric Γ1 is small, where "small" depends on the context. For example, numerical data might be modeled accurately if Γ1  ≤  0.05 and measured data might be modeled accurately if Γ1  ≤  0.20. Similarly a model is complicated if its complexity Γ2 is relatively large. "Good" and its comparatives are to be understood in the sense of [formula].

During the generation of the initial population and selection, we force diversity by prohibiting identical solutions. It is very unlikely to randomly create identical solutions. However, offspring may be nearly identical in structure as well as fitness and consequently a crossover between parent and child solution may produce an identical grandchild solution. The probability of such an event grows exponentially with the number of identical solutions in a population and therefore it reduces the diversity of the population in the long-term risking a pre-mature convergence of the algorithm. Thus, by prohibiting identical solutions, the population will have a transient period until it reaches its maximum capacity. This will also reduce the effective number of offspring per generation. This change reduces the probability of becoming trapped in a local minimum because of a steady state in the evolutionary loop.

Our main emphasis is the treatment of the model parameters ci. In standard implementations, e.g. the already mentioned [\cite=smits2005pareto] [\cite=vladislavleva2009order], the parameters are mutated randomly, like all other nodes. Here, using modern computational power we are able to use traditional parameter optimization algorithms. Thus, the calculation of Γ1 becomes another optimization task given the current model fj:

[formula]

with

[formula]

The initial guess for ci is either inherited or set to one. Thus, we effectively have two combined optimization layers. Each run is conducted using 10 restarts of the algorithm. The Pareto front is the joined front of the individual runs. Finally, we can use algebraic frameworks to simplify the obtained formulae. This is useful, since a formula (phenotype, macrostate) may be represented by many different expression trees (genotypes, microstates).

Case Studies

We present here results for three systems with increasing difficulty: first, we demonstrate the principles using a very simple system, the harmonic oscillator; second, we infer a predictive model for a set of coupled oscillators; and finally we show how we can predict a very applied system, namely the power production from a solar panel. For the first two examples we use numerically produced data, where we have full control over the system, while for the demonstration of applicability we use data from a small solar power station [\cite=unisolar].

Harmonic Oscillator

In this subsection we describe the first test of our methodology: an oscillator should be identified correctly and a accurate prediction must be possible. Consequently, we investigate the identification of a prediction model, not necessarily using a differential formalism. This might be interpreted as finding an approximation to the solution of the underlying equation by data analysis. A deep investigation of the validity of the solution for certain classes of systems is rather mathematical and is beyond the scope of this investigation.

Our system reads

[formula]

where x and y are the state variables and ω is a constant. We use the particular analytical solution x(t)  =  x0 sin (ωt), y(t)  =  x0ω cos (ωt). The prediction target is x(t + τ), where τ is a time increment.

Since the analytical solution is a linear combination of the feature inputs, just N = 2 data points are needed to train the model. This holds for infinite accuracy of the data and serves as a trivial test for the method. In general, a learning algorithm is "trained" on some data and the validity of the result is tested on another set, that is as independent as possible. That way, overfitting is avoided. For the same reason one needs to define a stop criterion for the algorithm, e.g. the data accuracy is 10- 5, it is useless and even counterproductive to run an algorithm until a root mean square error of 10- 10 (the cost function used here) is achieved. For the example under consideration, we stop the training once the training error is smaller than 1

Typically, a realistic scenario should include the effect of noise, e.g. in the form of measurement uncertainties. We consequently add "measurement" Gaussian noise with mean zero and variance proportional to the signal amplitude: ξ1  ~  N(0,(σx0)2), ξ2  ~  N(0,(σx0ω)2), hence   =  x  +  ξ1,  =  y  +  ξ2. The training and testing data sets were created as follows: the data are generated between

[formula]

Coupled Oscillators

The harmonic oscillator is an easy case to treat with our methods. Now, we extend the analysis to add a spatial dimension. We study a model of FitzHugh-Nagumo oscillators [\cite=nagumo1962active] on a ring. The oscillators are coupled and generate traveling pulse solutions. The model was originally derived as a simplification of the Hodgkin-Huxley model to describe spikes in axons [\cite=hodgkin1952quantitative], and serves nowadays as a paradigm for excitable dynamics. Here, its spiky behavior is used as an abstraction of a front, observed in real world applications like the human brain, modeled by connected neurons, or a wind power plant network where fronts of different pressure pass through the locations of the wind power plants. The aim is to show that temporal and/or spatial information on the state of some network sites enables an increase in predictability of a chosen site or eventually (if there are waves in the network) to the front detection. The model for the ith oscillator is:

[formula]

where vi and wi, [formula], denote the fast and slower state variables, Ii is an external driving force, D is the coupling strength parameter, and Aij∈{0,1} describes the coupling structure between nodes i and j. The constant parameters ε, a and b determine the dynamics of the system as ε- 1 is the time scale of the slower "recovery variable", and a, and b set the position of the fixed point(s). For Aij we choose diffusive coupling on a ring, i.e. periodic boundary conditions. With the external current Ii we can locally pump energy into the system to create two pulses which will travel with the same speed but in opposite directions, annihilating when they meet.

Using different spatio-temporal sampling strategies, the aim is to detect and predict the arrival of a spike train at a location far enough away from the excitation center (i.e. farther than the wave train diameter). We mark this special location with the index zero.

Note that we do not aim to find a model for a spatio-temporal differential equation, since this would involve the estimation of spatial derivatives, which in turn require a fine sampling. This is definitely not the scope here. Rather we focus on the more application-relevant question to make a prediction based on an equation.

The construction of the data set was similar to the single oscillator case: sensors were restricted to the vi variables. We can record the time series of v0 and use time delayed features for the prediction. Another option is to use information from non-local sensors. We prepare and integrate the system as follows: we consider a ring of N = 200 oscillators. The constants are chosen as a  =  0.7, b  =  0.8, τ  =  12.5 and D  =  1. The system is initialized with vi(0)  =  0 and wi(0)  =   - 1.5. With the characteristic function [formula] we can write the space and time dependent perturbation as Ii(t)  =  5χt  -  ⌊t⌋  ≤  0.4(t)χt  ≤  40(t)χi∈{ - 50, - 49}(i). This periodic perturbation leads to a pair of traveling waves. The data were sampled at times tn  =  nΔt with Δt  =  0.1. The system has multiple time scales: two are associated with the on-site FitzHugh-Nagumo oscillator (τfast  =  1, [formula]), while two more are due to diffusive coupling (τDiff  =  D) and perturbation (τPert behaves as Ii(t) described above). The temporal width of the pulse traveling through a particular site, τP  =  8.4, corresponds to the full width half maximum of the pulse. In Fig. [\ref=fig:spacetime] we show the evolution of the oscillator network. The state of vi is color-coded. The horizontal width of the yellow stripe corresponds to the spatial pulse width ξ≃10.75. The speed of the spike or front is consequently vfront  ~  ξ  /  τP  =  1.28. An animation of this can be found in the supplemental material. The training data, denoted as well feature set, were recorded in three different ways:

site-only: Only v0 is recorded, and time-delayed features v0,Δn  =  v0(t  =  (n  -  Δn)Δt) are also included with ΔnΔt  =   - 1, - 2, - 3, - 4.

spatially extended: We record v0 and additionally vi with [formula] (upstream direction).

mixed: This combines the two approaches above. For each site we also include the time delayed features.

To avoid introducing additional symbols we use state variables with double subscripts for discrete times, where the second index refers to time, and one subscript for continuous time. The respective useage is evident from the context. We choose to predict the state at time t = 2 given the data described above. In other words, the prediction target is v0(tn  +  τ) with τ  =  20≃2.5τP, corresponding to the requirement to be far engouh from the excitation point. Of course, this implies a distance of Δx  ~  2.5ξ. The testing and training sets were selected by using every second point of the recorded time series.

FFX Results

We first discuss the results obtained by FFX (Sec. [\ref=sec:ffx]). In Fig. [\ref=fig:ffxpareto] we display the Pareto fronts using the three different approaches for the training set. All curves have one point in common which represents the best fitting constant (complexity 0). As one would expect, the site only data do not contain enough information to detect a front. Thus, even high complexity models cannot reach an error below 4% and the required error of 1% is never met. In the two other datasets the algorithm has the possibility to find a combination of spatial amd temporal inputs to account for the front velocity. Note that the shape of the front strongly depends on the internal ρ parameter of the elastic net Eq. [\ref=eq:elasticnet]. More information should not lead to a decrease in predictability. Thus, the Pareto front of a data set richer in features dominate the corresponding Pareto front of a data set with less features. Counter-intuitively, using ρ  =  0.95 the front for the mixed dataset becomes non-convex as some good fitting models are hidden by the regularizer. Thus, we can use ρ to influence the shape of the front. Despite that, the most accurate model of the mixed data set is still the most accurate model overall.

In the following we discuss the results for the best models for each feature set.

If we take the perspective of an observer sitting at i = 0, we see the spike passing: first the state is zero, then a slow increase is observed followed by a rapid increase and decrease around the spike maximum. Eventually the state returns slowly to zero. Statistically, the algorithm is trained by long quiet times and a short, complicated spike form which is hard to model by a reduced set of state variables. This is illustrated in Fig. [\ref=fig:ffx_diffa] where for any feature set the biggest differences occur in the spike region. Apparently, the model with site-only variables shows worse results than the spatial one, and the spatio-temporal set models best the passing spike. We note that in a direct confrontation, the true and modeled signal would hard to be distinguished. In Fig. [\ref=fig:ffx_diffb] we confront the time derivative for the model from mixed variables. The true and modeled spike are indistinguishable by eye.

The formulae of the most accurate models are shown in Table [\ref=table:ffxeq]. For site-only features, quadratic combinations of points at different times occur. This reflects the approximation of the incoming front by a quadratic term. If, however only spatial points are used, the dynamics far away are used to predict the incoming front. If the small terms are neglected, the model consists of the signal at the target site itself, and the previous site (-2) which carries the largest weight. Physically, it means that despite being far away the front is already felt at 2 sites away. Since the front is stationary in a co-moving frame, spatio-temporal embedding is best, namely sampling the spike train in space and moving in time with the train velocity. Then we have a simple and compact linear dependence as seen in the last row of Table [\ref=table:ffxeq]. Let us inspect the possible physics in the model approximating the constants a0,a1,a2,a3 roughly as 0, 0.45, 0.35, 0.175 such that a2 = 2a3 . We first notice that τp = 8.4≃10. The last terms can then be recombined to a3v- 2, - 10  +  a3v- 2, - 10 + v- 2,0 as a mean value of the state with time distance of approximately one typical time scale. The state at - 30 is at the backside of the front and together the most important information, namely the increase and decrease of the incoming signal is selected by the model. Alternatively, since v(0,t)  =  v( - vfτP,t  -  τP) the best model in Table [\ref=table:ffxeq] can be interpreted as the weighted average of the closest combination (Δi,Δt) to represent the front velocity ([formula]). This demonstrates how powerful the algorithm works in selecting important features.

GP Results

We again examine the Pareto-optimal models illustrated in Fig. [\ref=fig:gppareto]. For each feature set we obtain a non-convex Pareto front. The shape and the values of the fronts are broadly similar to the results obtained by FFX. Because GP is an evolutionary method and relies on random breeding rules, we display averaged results: we initialize the algorithm with different seeds of the random number generator, calculate the Pareto fronts and average the errors for the non dominated models of the same complexity. Note that not all complexities occur on each particular front. This way, we obtain a generic Pareto front and avoid atypical models which may occur by chance. The specific model given below in the tables is not averaged, but the best result for one specific seed (42). The errors of the models reachable by the different sets are again decreasing from site only over spatially extended to mixed. However, the mixed model reaches almost zero error which is quite remarkable!

The difference plots for the method are given in Fig. [\ref=fig:gp_diff]. While the site only set is not able to give a convincing model for an incoming front, the spatially extended set gives a reasonable model with little error. The mixed model is very good with perfect coincidence of model and true dynamics. This model cannot be distinguished by eye from the observed signal.

The models provided by the GP algorithm with seed 42 are given in Table [\ref=table:res_gp]. Due to the very general character of GP these can be overwhelming at first glance. However, we can simplify them down by using computer algebra systems like sympy or mathematica (here we use sympy).

The interpretation of the GP results requires a bit more thinking. In essence, they follow a logic similar to the FFX results. The site-only model is complicated, and instead of a square operator a trigonometric function is used to mimic the incoming pulse. Since the data do not include directly all information needed, the algorithm tries to fit unphysical functions. This is clearly a non-deterministic and overfitting result, mirrored by the high complexity of the functions involved. For spatially extended models, we obtain a linear and sinusoidal components, and the model uses only three features, namely the on-site values and the ones at two and four units left on our site under consideration. Remarkably, a sinusoidal behavior detected with an exponential decrease, which is our intuition. Eventually, the spatio-temporal embedding yields a very simple model which approximates the front velocity vf to be between [formula] and 1. The accuracy of this model is very high.

Summarizing, when given enough input information, both methods find a linear model for the predictor 0(t + τ) by finding the most suitable combination of temporal and spatial shift to mimic the constant front velocity. If this information is not available in the input data, nonlinear functions are used.

Solar Power Data

In this section, we describe the results obtained for one-day-ahead forecasting of solar power production. The input data used for training are taken from the unisolar solar panel installation at Potsdam University with about 30 kW installed. Details are found at [\cite=unisolar]. We join the solar power data with meteorological forecast data from the freely available European Centre for Medium-Range Weather Forecasts (ECMWF) portal [\cite=ecmwf] as well as the actual observed weather data. These public data are of limited quality and serve for our proof of concept with real data and all their deficiencies.

The solar panel data P(t) were recorded every five minutes, at geoposition 52.41 latitude, 12.98 longitude. The information about the weather can be split into two categories: weather observations of a station near the power source W(t) and the weather forecast Ŵ(t + τ), where τ is the time difference to the prediction target. We do not have weather data from the station directly, but can use data from a weather station nearby (ID: 10379). The weather forecast data are obtained every six hours at the closest location publicly accessible, 52.5 latitude and 13 longitude. Typical meteorological data contain, but are not limited to, the wind speed and direction, pressure at different levels, the irradiation, cloud coverage, temperature and humidity. However, in this example, we only use temperature and cloudiness as well as their forecasts as features for our model. The latter is obtained by minimizing

[formula]

with f the model under consideration. Our prediction target is P̂(t  +  τ) with τ  =  24, the one-day-ahead power production. We create our datasets with a sampling of 1h. While additional information from the solar power data remains unused, the prediction variables have to be interpolated. The quality of the forecast depends on quality of the weather measurement and weather forecast. As we use publicly available data, we can only demonstrate the procedure and cannot attain errors as low as those used in commercial products, which will be discussed elsewhere. The features of the the data set are listed in Table [\ref=table:features] Furthermore, we scale each feature to have its minimum equal zero and maximum equal to one. The models are trained with data from June and July of 2014. Testing is conducted for August 2014. To obtain first impression (assuming no prior knowledge), we calculate the mutual correlation of the data. The power produced the next day is heavily correlated with the predicted solar irradiation. This is a confirmation that the physics involved is mirrored in the model and that weather prediction is good in average. Quantitative statements on the quality of weather prediction is not easy and can be found in the literature [\cite=ecmwf].

GP Results

Let us consider the results of our forecasting with GP shown in Fig. [\ref=fig:gpPareto]. The Pareto fronts are shown for both the training and testing set. As above, for the coupled oscillators, we have conducted 10 runs with different seeds and display the averaged result. Of course, for the training set (filled diamonds), increasing complexity means decreasing error. We see a strong deviation for very complicated models of the testing data (filled circles). This may be an indication of a small testing sample, or indicate overfitting. The outlier at Γ = 18 is a result of the particular realization of the evolutionary optimization. With a different setting, e.g. more iterations, or multiple runs such outliers are eliminated. To clarify this question, we show the functions found as solution of our procedure with increasing complexity and one specific seed (42) in Table [\ref=table:solar_results_gp].

From Table [\ref=table:solar_results_gp] we see that GP follows a very reasonable strategy: First, it recognizes that the persistence method is a very reasonable thing, with production tomorrow being the same as today (x1 = P(t)). Veto a complexity of 5, the identified models only depend on the solar power x1 and describe with increasing accuracy the conditioned average daily profile. The more complex models include the weather data and forecast. The geometric mean of current power and predicted temperature is present. However, due to the low quality weather forecast as well as the seasonal weather difference between training and testing data, there is no net gain in prediction quality.

Without any further analysis, the model with the lowest testing error is chosen. In Fig. [\ref=fig:gpresult] (a) we confront the real time series with the prediction from GP for the model of complexity 4. One clearly finds the already mentioned conditioned average profile. This predicts the production onset a bit too early. The error distribution is shown in Fig. [\ref=fig:gpresult] (b), where we recognize an asymmetric error distribution with more probable under- than overprediction.

FFX Results

The results of the FFX method are shown in Fig. [\ref=fig:ffx_pareto_solar]-[\ref=fig:ffxScatterAndTS] and the models in Table [\ref=table:solar_results_ffx]. As shown, the FFX method is less capable of predicting longer inactive periods, such as at night, where no solar power is produced. This is clearly visible in Fig. [\ref=fig:ffxScatterAndTS].

Analyzing the equations of Table [\ref=table:solar_results_ffx], we notice that the best FFX function is a quadratic form with maxima to limit the signal above zero. This amounts to recover the mean shape of the signal as a quadratic function. Unfortunately this seems almost trivial since one could obtain this mean shape by purely geometrical considerations with a factor for the cloud coverage.

Summarizing the results for the solar power curves, both methods are able to reproduce the true curve to approximately 20% which is reasonable for a nonoptimized method. The detection of changes when clear sky switches to partially or fully clouded one is not entirely satisfactory and one needs to investigate the improvement of weather predictions for a single location. As said in the introduction, a perfect weather prediction with high resolution would render this work useless for power production forecast (although not for other questions).

Nevertheless, we note that the results in the form of analytic models are highly valuable, because interpretations and further mathematical analysis are possible.

Conclusion

We have demonstrated the use of symbolic regression combined with complexity analysis of the resulting models for the future prediction of dynamical systems. More precisely, we identify a system of equations yielding optimal forecasts in terms of a minimized normalized root mean squared error of the difference between model forecast and observation of the system state. We did not investigate theoretical aspects such as the underlying state space, nor what implications of the functions on the model. These will be subject of future investigations. Such work is to be carried out carefully to find the limitations of the approach, in particular of genetic programming, which is rather uncontrolled in the way the search space is explored. On the other hand, the methods stand in line with a large collection of methods from regression and classification and one can use much of this previous knowledge. In our opinion, the multiobjective analysis is crucial to identify models to a degree such that they can be used in practice. Probably, this approach will prove very helpful if used in combination with scale analysis, e.g. by prefiltering the data on a selected spatio-temporal scale and then identify equations for this level.

We have tried to show the possible power by three examples of increasing complexity: a trivial one - the harmonic oscillator with an almost perfect predictive power, a collection of excitable oscillators where we demonstrated that the methods can perform a kind of multi-scale analysis based on the data. Thirdly, examine the one-day-ahead forecasting of solar power production we have shown that even for messy data we can improve the classical methods by a few percent (in NRMSE). For theoretical considerations, this might be negligible, for real world applications, a few percent might translate into a considerable advantage, since the usage of rare resources can be optimized.

A question for further research is how we can use simplification during the GP iteration to alter the complexity. It may be even a viable choice to control the complexity growth over time, the so-called bloat, in single objective genetic programming - a topic of ongoing interest [\citep=gardner2014controlling]. Additionally, we introduced an intermediate step to only allow for one of many identical solutions for further evolution. One could consider to expand the idea of identical expression trees to include symmetries. We conclude that symbolic regression is very useful for the prediction of dynamical systems, based on observations only. Our future research will focus on the use of equations couple the systems to other macroscopic ones (e.g. finance, in the case of wind power), and on the analysis of system stability and other fundamental properties using the found equations, which is scientifically a very crucial point.

Acknowledgements

We acknowledge discussion with C. Cornaro and M. Pierro on solar power forecast, helpful words on machine learning by M. Segond. We thank the unisolar initiative for their provision of the data. M. Quade and M. Abel acknowledge support by the German ministry of economy, ZIM project "green energy forecast", grant ID KF2768302ED4.