The Daala Directional Deringing Filter

Introduction

The main goal of deringing is to filter out ringing, while retaining all the details of the image. The amount of ringing tends to be roughly proportional to the quantization step size. The amount of detail is a property of the input image, but the smallest detail actually retained in the decoded image tends to be roughly proportional to the quantization step size. For a given quantization step size, the amplitude of the ringing is generally less than the amplitude of the details.

A standard linear filter works by averaging nearby values of the input to produce an output. For example, a 3-tap filter can be as simple as averaging the sample x(n) being filtered with its two neighbors: y(n) = (x(n - 1) + x(n) + x(n + 1)) / 3. This works well when we want to eliminate all high frequencies, but in the video context, it has the side effect of blurring out all details.

This paper describes a deringing filter that takes into account the direction of edges and patterns being filtered. The filter works by identifying the direction of each block and then adaptively filtering along the identified direction. In a second pass, the blocks are also filtered in a different direction, with more conservative thresholds to avoid blurring edges. The deringing filter is also designed to be easy to vectorize, requiring no per-pixel scalar operation. An high-level interactive demonstration of the algorithm is available at [\cite=Demo].

Direction Search

The first step is to divide the image into blocks of fixed or variable size. Variable-size blocks make it possible to use large blocks on long, continuous edges and small blocks where edges intersect or change direction. A fixed block size is easier to implement and does not require signaling the sizes on a block-by-block basis. For this work, we consider a fixed block size of 8x8 since it is fine enough to follow non-straight edges, but large enough to reliably estimate directions.

Once the image is divided into blocks, we determine which direction best matches the pattern in each block. One way to determine the direction is to minimize sum of squared differences (SSD) between the input block and a perfectly directional block. A perfectly directional block is a block for which each line along a certain direction has a constant value. For each direction, we assign a line number to each pixel, as shown in Fig. [\ref=fig:Lines-for-direction].

For each direction d, the SSD is defined as:

[formula]

where xp is the value of pixel p, Pd,k is the set of pixels in line k following direction d, and μk is the pixel average for line k:

[formula]

where Nd,k is the cardinality of Pd,k. Substituting ([\ref=eq:pixel-average]) into ([\ref=eq:direction-variance0]) and simplifying, we get

[formula]

Considering that the first term of Eq. ([\ref=eq:direction-variance1]) is constant with respect to d, we simply find the optimal direction dopt by maximizing the second term:

[formula]

where

[formula]

Fig. [\ref=fig:Example-of-direction] shows an example of a direction search for an 8x8 block containing a line.

Conditional Replacement Filter

Just like the median filter [\cite=Median] and the bilateral filter [\cite=Bilateral], the conditional replacement filter is designed to remove noise without blurring sharp edges. However, it is simpler to compute and is easier to vectorize than the median filter or the bilateral filter. A regular linear filter with [formula] taps is defined as

[formula]

where [formula].

The main difference between a regular filter and the conditional replacement filter is that for each tap, if [formula] differs from [formula] by more than a threshold T, then we use [formula] instead for the tap. The filter computation is illustrated in Fig. [\ref=fig:Conditional-filter-computation] and an example is shown in Fig. [\ref=fig:Conditional-filter-example].

Through algebraic simplifications, the filter definition can be written in terms of the differences [formula], which yields

[formula]

with the threshold function

[formula]

The advantage of this formulation is that the normalization by [formula] can be approximated without causing any bias, even when W is not a power of two. Also, because W does not depend on the number of pixels being replaced, the normalization is easy to vectorize over a row (or column) of pixels.

Directional Filtering

The directional filter for pixel [formula] is defined as the 7-tap conditional replacement filter where dx and dy define the direction, W is a constant normalizing factor, Td is the filtering threshold for the block. The direction parameters are shown in Table [\ref=tab:Direction-parameters]. The weights wk can be chosen so that W is a power of two. For example, Daala currently uses [formula] with W = 16. Since the direction is constant over 8x8 blocks, all operations in this filter are directly vectorizable over the blocks.

Second Stage Filter

The 7-tap directional filter is sometimes not enough to eliminate all ringing, so we use an additional filtering step that operates across the direction lines used in the first filter. Considering that the input of the second filter has considerably less ringing than the input of the second filter, and the fact that the second filter risks blurring edges, the position-dependent threshold [formula] for the second filter is set lower than that of the first filter Td. The filter structure is the same as the one in Eq. ([\ref=eq:directional_filter]). The direction parameters for the second stage filter are shown in Table ([\ref=tab:Ortho-parameters]) and the filter weights are [formula] with W = 16 / 3. Considering that each input pixel from the second filter is itself the output of the 7-tap directional filter, the combination of the two filters is effectively a 35-tap separable filter.

Setting Thresholds

The thresholds Td and T2 must be set high enough to smooth out ringing artifacts, but low enough to avoid blurring important details in the image. Although the ringing is roughly proportional to the quantization step size Q, as the quantizer increases the error grows slightly less than linearly because the unquantized coefficients become very small compared to Q. As a starting point for determining the thresholds, Daala uses a power model of the form

[formula]

with β = 0.842 in Daala, and where α1 depends on the input scaling. The deringing level [formula] is a threshold adjustment coded for each superblock (64x64). In the AV1 codec, a global threshold is selected by the encoder instead of using a function of the quantizer, so

[formula]

.

Another factor that affects the optimal filtering threshold is the presence of strong directional edges/patterns. These can be estimated from the sd parameters computed in Eq. ([\ref=eq:direction-variance3]) as

[formula]

where [formula]. We compute the direction filtering threshold for each block as

[formula]

where α2 also depends on the input scaling. For the second filter, we use a more conservative threshold that depends on the amount of change caused by the directional filter.

[formula]

As a special case, when the pixels corresponding to the 8x8 block being filtered are all skipped, then Td = T2 = 0, so no deringing is performed.

Superblocks and Signaling

The filtering is applied one superblock at a time, in a way that depends on the level [formula]. The level can take one of 6 values:

[formula]

where [formula] disables the deringing filter for the current superblock. The level is the only information coded in the bitstream by the deringing filter. On keyframes, it is entropy-coded based on the neighbor values. On inter-predicted frames, the level is only coded for superblocks that are not skipped and is entropy-coded based on a single adapted probability distribution (no context from the neighbors). Superblocks where no level is coded have deringing disabled. Similarly, any skipped block within a superblock has deringing disabled, even if it is signaled enabled for the superblock.

The level of the deringing filter in AV1 is handled similarly, except that only four levels are currently available and there is no entropy coding yet.

The deringing process sometimes reads pixels that lie outside of the superblock being processed. When these pixels belong to another superblock, the filtering always uses the unfiltered pixel values - even for the second stage filter - so that no dependency is added between the superblocks. This makes it possible to filter all superblocks in parallel. When the pixels used for a filter lie outside of the viewable image, we set [formula] in Eq. ([\ref=eq:threshold-function]).

Results

The deringing filter described here has been implemented for the Daala [\cite=Daala] codec and is available in the master branch of the Daala Git repository [\cite=Daala-Git]. Its implementation lies in the src/dering.c file. An example of the effect of the deringing filter at low bitrate on a still image is shown in Fig. [\ref=fig:Visual-effect].

We tested the deringing filter using the Are We Compressed Yet? [\cite=AWCY] online testing tool. The results for still images are shown in Table. [\ref=tab:bd-rate-subset1] for the subset1 test set and those for video are shown in Table [\ref=tab:bd-rate-ntt-short1] for the ntt-short1 test set. Visual inspection confirms that the quality is greatly improved, despite the regression in the FAST-SSIM results.

Conclusion

We have demonstrated an effective algorithm for removing ringing artifacts from coded images and videos. The proposed filter is based on the conditional replacement filter (CRF) and takes into account the direction of the patterns it is filtering to reduce the risk of blurring. Objective results show a bit-rate reduction between 4% and 8% on video sequences.