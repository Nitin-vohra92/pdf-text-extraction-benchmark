=.05em =1.25ex =2ex =3 ="3A3B

Syntactically, classical logic decomposes thus [\cite=Gir87]:

Classical logic   =   MLL  +  Superposition

where MLL is Multiplicative Linear Logic, and superposition means contraction (binary case) and weakening (nullary case). Proof nets for classical logic have been proposed [\cite=Gir91] [\cite=Rob03], containing explicit contraction and weakening nodes. Just as the logical sequent rules of conjuction (tensor) and disjunction (par) are represented explicitly in the net, so are the structural rules, contraction and weakening. Unfortunately, this explicit representation of structural rules retains some of the redundancy (or 'syntactic bureaucracy') of sequent calculus. For example, in the net presentation of classical categories in [\cite=FP05] one has to quotient by equations on nets, involving contraction and weakening. Thus, proof nets for classical logic fail to achieve the same elegance as the proof nets for MLL.

We present a representation of a proof which is more abstract than a proof net, which we call a combinatorial proof: superposition is modelled mathematically, as a lax form of fibration, rather than syntactically (as in proof nets, which involve contraction and weakening nodes). This draws a nice boundary between logical rules and structural rules: the former are modeled with explicit nodes, the latter as actual superposition, in an abstract mathematical sense, without nodes. We can summarise the situation thus:

The arrows represent the abstraction from sequent calculus to proof nets, and from proof nets to combinatorial proofs. To the right, we list the form of 'bureaucracy' present at that layer, that is, the connectives involved in representation redundancy, i.e., sensible rule transpositions for identifying proofs. ([formula] and [formula] stand for contraction and weakening.)

The definition of combinatorial proof is very simple, so we can give it in full here. Let A be a formula of propositional classical logic, generated by [formula] and [formula] from literals (variables [formula] and their negations [formula]). We identify a formula A with its parse tree, a tree labelled with literals at the leaves and [formula] or [formula] at internal vertices. An [formula]-resolution (or [formula]-strategy) of A is any result of deleting one argument subtree from each [formula] (cf. [\cite=HG03]). A set L of leaves of A is a clique of A if it is the set of leaves of a [formula]-resolution of A. A combinatorial proof of A is an MLL proof net on a formula A' (viewed as an MLL formula, i.e., [formula] = tensor, [formula] = par), equipped with a label- and clique-preserving function from the leaves of A' to the leaves of A. For example, here is a combinatorial proof of Peirce's law, [formula] : The MLL proof net is drawn above, with two axiom links. The label- and clique-preserving function is shown by the vertical lines.

A formula of classical propositional logic is true (valid) iff it has a combinatorial proof.

The label- and clique-preserving function is a lax form of fibration. (We prove this via [\cite=Hug04b]). Thus a combinatorial proof is a 'fibred' MLL proof net, and we obtain the slogan in the title of the paper:

Classical logic    =    Fibred MLL

Any sequent calculus proof translates to a combinatorial proof in a relatively obvious way. For a suitable variant of sequent calculus, one obtains a surjection (i.e., sequentialisation theorem). Cut elimination for combinatorial proofs retains the richness of sequent calculus: its non-determinism is not confluent. In contrast, direct translation of a sequent proof to a linking (the set of axiom links traced down from the axioms) leads to a certain degeneracy: cut elimination becomes confluent [\cite=LS05]. Also in contrast to [\cite=LS05], the MIX rule in this setting is optional.

Combinatorial proofs, in a somewhat different guise, were first presented in [\cite=Hug04b], with MIX implicit.