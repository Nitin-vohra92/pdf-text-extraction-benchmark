Using Information Theory Approach to Randomness Testing

Keywords:

Introduction

The randomness testing of random number and pseudorandom number generators is used for many purposes including cryptographic, modeling and simulation applications; see, for example, Knuth, 1981; L'Ecuyer, 1994; Maurer,1992; Menezes A. and others, 1996. For such applications a required bit sequence should be true random, i.e., by definition, such a sequence could be interpreted as the result of the flips of a "fair" coin with sides that are labeled "0" and "1" (for short, it is called a random sequence; see Rukhin and others, 2001). More formally, we will consider the main hypothesis H0 that a bit sequence is generated by the Bernoulli source with equal probabilities of 0's and 1's. Associated with this null hypothesis is the alternative hypothesis H1 that the sequence is generated by a stationary and ergodic source which generates letters from {0,1} and differs from the source under H0.

In this paper we will consider some tests which are based on results and ideas of Information Theory and, in particular, the source coding theory. First, we show that a universal code can be used for randomness testing. (Let us recall that, by definition, the universal code can compress a sequence asymptotically till the Shannon entropy per letter when the sequence is generated by a stationary and ergodic source). If we take into account that the Shannon per-bit entropy is maximal (1 bit) if H0 is true and is less than 1 if H1 is true (Billingsley, 1965; Gallager, 1968), we see that it is natural to use this property and universal codes for randomness testing because, in principle, such a test can distinguish each deviation from randomness, which can be described in a framework of the stationary and ergodic source model. Loosely speaking, the test rejects H0 if a binary sequence can be compressed by a considered universal code (or a data compression method.)

It should be noted that the idea to use the compressibility as a measure of randomness has a long history in mathematics. The point is that, on the one hand, the problem of randomness testing is quite important for practice, but, on the other hand, this problem is closely connected with such deep theoretical issues as the definition of randomness, the logical basis of probability theory, randomness and complexity, etc; see Kolmogorov, 1965; Li and Vitanyi, 1997; Knuth, 1981; Maurer,1992. Thus, Kolmogorov suggested to define the randomness of a sequence, informally, as the length of the shortest program, which can create the sequence (if one of the universal Turing machines is used as a computer). So, loosely speaking, the randomness (or Kolmogorov complexity) of the finite sequence is equal to its shortest description. It is known that the Kolmogorov complexity is not computable and, therefore, cannot be used for randomness testing. On the other hand, each lossless data compression code can be considered as a method for upper bounding the Kolmogorov complexity. Indeed, if x is a binary word, φ is a data compression code and φ(x) is the codeword of x, then the length of the codeword |φ(x)| is the upper bound for the Kolmogorov complexity of the word x. So, again we see that the codeword length of the lossless data compression method can be used for randomness testing.

In this paper we suggest tests for randomness, which are based on results and ideas of the source coding theory.

Firstly, we show how to build a test basing on any data compression method and give some examples of application of such test to PRNG's testing. It should be noted that data compression methods were considered as a basis for randomness testing in literature. For example, Maurer's Universal Statistical Test, Lempel-Ziv Compression Test and Approximate Entropy Test are connected with universal codes and are quite popular in practice, see, for example, Rukhin and others, 2001. In contrast to known methods, the suggested approach gives a possibility to make a test for randomness, basing on any lossless data compression method even if a distribution law of the codeword lengths is not known.

Secondly, we describe two new tests, conceptually connected with universal codes. When both tests are applied, a tested sequence x1x2...xn is divided into subwords x1x2...xs, [formula] s  ≥  1, and the hypothesis H*0 that the subwords obey the uniform distribution (i.e. each subword is generated with the probability 2- s) is tested against [formula]. The key idea of the new tests is as follows. All subwords from the set {0,1}s are ordered and this order changes after processing each subword [formula] in such a way that, loosely speaking, the more frequent subwords have small ordinals. When the new tests are applied, the frequency of different ordinals are estimated (instead of frequencies of the subwords as for, say, chi- square test).

The natural question is how to choose the block length s in such schemes. We show that, informally speaking, the block length s should be taken quite large due to the existence of so called two-faced processes. More precisely, it is shown that for each integer s* there exists such a process ξ that for each binary word u the process ξ creates u with the probability 2- |u| if the length of the u (|u|) is less than or equal to s*, but, on the other hand, the probability distribution ξ(v) is very far from uniform if the length of the words v is greater than s*. (So, if we use a test with the block length s  ≤  s*, the sequences generated by ξ will look like random, in spite of ξ is far from being random.)

The outline of the paper is as follows. In Section 2 the general method for construction randomness testing algorithms basing on lossless data compressors is described. Two new tests for randomness, which are based on constructions of universal coding, as well as the two-faced processes, are described in the Section 3. In Section 4 the new tests are experimentally compared with methods from " A statistical test suite for random and pseudorandom number generators for cryptographic applications", which was recently suggested by Rukhin and others, 2001. It turns out that the new tests are more powerful than known ones.

Data compression methods as a basis for randomness testing

2.1. Randomness testing based on data compression

Let A be a finite alphabet and An be the set of all words of the length n over A, where n is an integer. By definition, [formula] and A∞ is the set of all infinite words [formula] over the alphabet A. A data compression method (or code) φ is defined as a set of mappings φn such that [formula] and for each pair of different words x,y∈An   φn(x)  ≠  φn(y). Informally, it means that the code φ can be applied for compression of each message of any length n,n  >  0 over alphabet A and the message can be decoded if its code is known.

Now we can describe a statistical test which can be constructed basing on any code φ. Let n be an integer and Ĥ0 be a hypothesis that the words from the set An obey the uniform distribution, i.e., p(u) = |A|- n   for each   u∈{0,1}n. (Here and below |x| is the length if x is a word, and the number of elements if x is a set.) Let a required level of significance (or a Type I error) be α,  α∈(0,1). The following main idea of a suggested test is quite natural: The well compressed words should be considered as non- random and Ĥ0 should be rejected. More exactly, we define a critical value of the suggested test by

[formula]

(Here and below log x  =   log 2x.)

Let u be a word from An. By definition, the hypothesis Ĥ0 is accepted if |φn(u)|  >  tα and rejected, if |φn(u)|  ≤  tα. We denote this test by Γ(n)α,  φ.

Theorem 1.

Proof is given in Appendix.

Comment 1. The described test can be modified in such a way that the Type I error will be equal to α. For this purpose we define the set Aγ by

[formula]

and an integer g for which the two following inequalities are valid:

[formula]

Now the modified test can be described as follows:

If for x∈An    |φn(x)|  ≤  g     then Ĥ0 is rejected, if |φn(x)|  >  (g + 1)   then Ĥ0 is accepted and if |φn(x)|  =  (g + 1)   the hypothesis Ĥ0 is accepted with the probability

[formula]

and rejected with the probability

[formula]

(Here we used a randomized criterion, see for definition, for example, Kendall and Stuart, 1961, part 22.11.) We denote this test by Υ(n)α,  φ.

Claim 1. For each integer n and a code φ, the Type I error of the described test Υ(n)α,  φ is equal to α.

Proof is given in Appendix.

We can see that this criterion has the level of significance (or Type I error) exactly α, whereas the first criterion, which is based on critical value ([\ref=cr]), has the level of significance that could be less than α. In spite of this drawback, the first criterion may be more useful due to its simplicity. Moreover, such an approach gives a possibility to use a data compression method ψ for testing even in case where the distribution of the length |ψn(x)|,x∈An is not known.

Comment 2. We have considered codes, for which different words of the same length have different codewords (In Information Theory sometimes such codes are called non- singular.) Quite often a stronger restriction is required in Information Theory. Namely, it is required that each sequence φn(x1)φn(x2)...φ(xr),r  ≥  1, of encoded words from the set An,n  ≥  1, can be uniquely decoded into x1x2...xr. Such codes are called uniquely decodable. For example, let A = {a,b}, the code ψ1(a)  =  0,ψ1(b)  =  00, obviously, is non- singular, but is not uniquely decodable. (Indeed, the word 000 can be decoded in both ab and ba.) It is well known in Information Theory that a code φ can be uniquely decoded if the following Kraft inequality is valid:

[formula]

see, for ex., Gallager, 1968.

If it is known that the code is uniquely decodable, the suggested critical value ([\ref=cr]) can be changed. Let us define

[formula]

Let, as before, u be a word from An. By definition, the hypothesis Ĥ0 is accepted if |φn(u)|  >  α and rejected, if |φn(u)|  ≤  α. We denote this test by (n)α,φ.

Claim 2.

Proof is given in Appendix.

So, we can see from ([\ref=cr]) and ([\ref=cr2]) that the critical value is larger, if the code is uniquely decodable. On the other hand, the difference is quite small and ([\ref=cr]) can be used without a large loose of the test power even in a case of the uniquely decodable codes.

It should not be a surprise that the level of significance (or a Type I error) does not depend on the alternative hypothesis H1, but, of course, the power of a test (and the Type II error) will be determined by H1.

The examples of testing by real data compression methods will be given in Section 4.

2.2. Randomness testing based on universal codes.

We will consider the main hypothesis H0 that the letters of a given sequence x1x2...xt,  xi∈A,   are independent and identically distributed (i.i.d.) with equal probabilities of all a∈A and the alternative hypothesis H1 that the sequence is generated by a stationary and ergodic source, which generates letters from A and differs from the source under H0. (If A = {0,1}, i.i.d. coincides with Bernoulli source.) The definition of the stationary and ergodic source and the Shannon entropy of such sources can be found in Billingsley, 1965, and Gallager, 1968.

We will consider statistical tests, which are based on universal coding and universal prediction. First we define a universal code.

By definition, φ is a universal code if for each stationary and ergodic source (or a process) π the following equality is valid with probability 1 (according to the measure π  )

[formula]

where h(π) is the Shannon entropy. ( Such codes exist, see Ryabko, 1984.) It is well known in Information Theory that h(π) =  log |A| if H0 is true, and h(π) <  log |A| if H1 is true, see, for ex., Billingsley, 1965; Gallager, 1968. From this property and ([\ref=un]) we can easily yield the following theorem.

Theorem 2.

So, we can see that each good universal code can be used as a basis for randomness testing. But converse proposition is not true. Let, for example, there be a code, whose codeword length is asymptotically equal to (0.5 + h(π)  /  2) for each source π (with probability 1, where, as before, h(π) is the Shannon entropy). This code is not good, because its codeword length does not tend to the entropy, but, obviously, such code could be used as a basis for a test of randomness. So, informally speaking, the set of tests is larger than the set of universal codes.

Note that the close problems were considered by Bailey (1974), who obtained many important results in this field.

Two new tests for randomness and two-faced processes

Firstly, we suggest two tests which are based on ideas of universal coding, but they are described in such a way that can be understood without any knowledge of Information Theory.

3.1. The "book stack" test

Let, as before, there be given an alphabet A = {a1,...,aS}, a source, which generates letters from A, and two following hypotheses: the source is i.i.d. and p(a1) = .... = p(aS)  =  1 / S   (H0) and [formula] We should test the hypotheses basing on a sample x1x2  ...  xn,  n  ≥  1  ,   generated by the source. When the "book stack" test is applied, all letters from A are ordered from 1 to S and this order is changed after observing each letter xt according to the formula

[formula]

where νt is the order after observing x1x2  ...  xt,  t  =  1  ,,...  ,n  , ν1 is defined arbitrarily. (For ex., we can define ν1  =  {a1,...,aS}.) Let us explain ([\ref=nu]) informally. Suppose that the letters of A make a stack, like a stack of books and ν1(a) is a position of a in the stack. Let the first letter x1 of the word x1x2  ...  xn be a. If it takes i1  -  th position in the stack (ν1(a) = i1), then take a out of the stack and put it on the top. (It means that the order is changed according to ([\ref=nu]).) Repeat the procedure with the second letter x2 and the stack obtained, etc.

It can help to understand the main idea of the suggested method if we take into account that, if H1 is true, then frequent letters from A (as frequently used books) will have relatively small numbers (will spend more time next to the top of the stack). On the other hand, if H0 is true, the probability to find each letter xi at each position j is equal to 1 / S.

Let us proceed with the description of the test. The set of all indexes [formula] is divided into r,r  ≥  2, subsets [formula] [formula] Then, using x1x2  ...  xn, we calculate how many νt(xt), t = 1,...,n, belong to a subset Ak,k = 1,...,r. We define this number as nk (or, more formally, [formula]) Obviously, if H0 is true, the probability of the event νt(xt)∈Ak is equal to |Aj| / S. Then, using a "common" chi- square test we test the hypothesis Ĥ0  =  P{νt(xt)∈Ak}  =  |Ak| / S basing on the empirical frequencies [formula], against [formula] Let us recall that the value

[formula]

is calculated, when chi- square test is applied, see, for ex., Kendall and Stuart, 1961. It is known that x2 asymptotically follows the χ-square distribution with (k - 1) degrees of freedom (χ2k - 1) if Ĥ0 is true. If the level of significance (or a Type I error) of the χ2 test is α,α∈(0,1), the hypothesis Ĥ0 is accepted when x2 from ([\ref=x2]) is less than the (1 - α) -value of the χ2k - 1 distribution; see, for ex., Kendall, Stuart, 1961.

We do not describe the exact rule how to construct the subsets {A1,A2, [formula] Ar}, but we recommend to perform some experiments for finding the parameters, which make the sample size minimal (or, at least, acceptable). The point is that there are many cryptographic and other applications where it is possible to implement some experiments for optimizing the parameter values and, then, to test hypothesis basing on independent data. For example, in case of testing a PRNG it is possible to seek suitable parameters using a part of generated sequence and then to test the PRNG using a new part of the sequence.

Let us consider a simple example. Let [formula] r = 2,A1  =  {a1,a2,a3},A2  =  {a4,a5,a6}, [formula] a3a6a3a3a6a1a6a1. If ν1  =  1,2,3,4, 5,6, then ν2  =  3,1,2,4,5,6, ν3  =  6,3,1,2,4,5, etc., and n1  =  7,n2  =  1. We can see that the letters a3 and a6 are quite frequent and the "book stack" indicates this nonuniformity quite well. (Indeed, the average values of n1 and n2 equal 4, whereas the real values are 7 and 1, correspondingly.)

Examples of practical applications of this test will be given in Section 4, but here we make two notes. Firstly, we pay attention to the complexity of this algorithm. The "naive" method of transformation according to ([\ref=nu]) could take the number of operations proportional to S, but there exist algorithms, which can perform all operations in ([\ref=nu]) using O( log S) operations. Such algorithms can be based on AVL- trees, see, for ex., Aho,Hopcroft and Ulman, 1976.

The last comment concerns with the name of the method. The "book stack" structure is quite popular in Information Theory and Computer Science. In Information Theory this structure was firstly suggested as a basis of an universal code by Ryabko, 1980, and was rediscovered by Bently, Sleator, Tarjan, Wei in 1986, and Elias in 1987 (see also a comment of Ryabko (1987) about a history of this code). In English language literature this code is frequently called as "Move-to-Front" (MTF) scheme as it was suggested by Bently, Sleator, Tarjan and Wei. Now this data structure is used in a caching and many other algorithms in Computer Science under the name "Move-to-Front". It is also worth noting that the book stack was firstly considered by a soviet mathematician M.L. Cetlin as an example of a self- adaptive system in 1960's, see Rozanov, 1971.

3.2. The order test

This test is also based on changing the order νt(a) of alphabet letters but the rule of the order change differs from ([\ref=nu]). To describe the rule we first define λt + 1(a) as a count of occurrences of a in the word [formula] At each moment t the alphabet letters are ordered according to νt in such a way that, by definition, for each pair of letters a and b [formula] if λt(a)  ≤  λt(b). For example, if A = {a1,a2,a3} and x1x2x3  =  a3a2a3, the possible orders can be as follows: ν1 = (1,2,3), ν2 = (3,1,2), ν3 = (3,2,1), ν4 = (3,2,1). In all other respects this method coincides with the book stack. (The set of all indexes [formula] is divided into r subsets, etc.)

Obviously, after observing each letter xt the value λt(xt) should be increased and the order νt should be changed. It is worth noting that there exist a data structure and algorithm, which allow maintaining the alphabet letters ordered in such a way that the number of operations spent is constant, independently of the size of the alphabet. This data structure was described by Moffat, 1999 and Ryabko, Rissanen, 2003.

3.3. Two- faced processes and the choice of the block length for a process testing

There are quite many methods for testing H0 and H1, where the bit stream is divided into words (blocks) of the length s,s  ≥  1, and the sequence of the blocks [formula], [formula] is considered as letters, where each letter belongs to the alphabet Bs  =  {0,1}s and has the probability 2- s, if H0 is true. For instance, both above described tests, methods from Ryabko, Stognienko and Shokin (2003) and quite many other algorithms belong to this kind. That is why the questions of choosing the block length s will be considered here.

As it was mentioned in the introduction there exist two-faced processes, which, on the one hand, are far from being truly random, but, on the other hand, they can be distinguished from truly random only in the case when the block length s is large. From the information theoretical point of view the two- faced processes can be simply described as follows. For a two- faced process, which generates letters from {0,1}, the limit Shannon entropy is (much) less than 1 and, on the other hand, the s -  order entropy (hs) is maximal (hs = 1 bit per letter) for relatively large s.

We describe two families of two- faced processes T(k,π) and (k,π), where [formula] and π∈(0,1) are parameters. The processes T(k,π) and (k,π) are Markov chains of the connectivity (memory) k, which generate letters from {0,1}. It is convenient to define them inductively. The process T(1,π) is defined by conditional probabilities PT(1,π)(0 / 0)  =  π,PT(1,π)(0 / 1)  =  1 - π (obviously, PT(1,π)(1 / 0) = 1 - π,PT(1,π)(1 / 1)  =  π). The process (1,π) is defined by P(1,π)(0 / 0) = 1 - π,P(1,π)(0 / 1)  =  π. Assume that T(k,π) and (k,π) are defined and describe T(k + 1,π) and (k + 1,π) as follows

[formula]

[formula]

and, vice versa,

[formula]

[formula]

for each u∈Bk (here vu is a concatenation of the words v and u). For example,

[formula]

The following theorem shows that the two-faced processes exist.

Theorem 3.

The proofs of the theorem is given in Appendix, but here we consider examples of "typical" sequences of the processes T(1,π) and (1,π) for π, say, 1/5. Examples are: 010101101010100101... and 000011111000111111000..... We can see that each sequence contains approximately one half of 1's and one half of 0's. (That is why the first order Shannon entropy is 1 per a letter.) On the other hand, both sequences do not look like truly random, because they, obviously, have too long subwords like either 101010.. or 000..11111... (In other words, the second order Shannon entropy is much less than 1 per letter.) Hence, if a randomness test is based on estimation of frequencies of 0's and 1's only, then such a test will not be able to find deviations from randomness.

So, if we revert to the question about the block length of tests and take into account the existence of two- faced processes, it seems that the block length could be taken as large as possible. But it is not so. The following informal consideration could be useful for choosing the block length. The point is that statistical tests can be applied if words from the sequence

[formula]

are repeated (at least a few times) with high probability (here ms is the sample length). Otherwise, if all words in ([\ref=s]) are unique (with high probability) when H0 is true, a sensible test cannot be constructed basing on a division into s - letter words. So, the word length s should be chosen in such a way that some words from the sequence ([\ref=s]) are repeated with high probability, when H0 is true. So, now our problem can be formulated as follows. There is a binary sequence [formula] generated by the Bernoulli source with P(xi = 0) = P(xi = 1) = 1 / 2 and we want to find such a block length s that the sequence ([\ref=s]) with m = ⌊n / s⌋, contains some repetitions (with high probability). This problem is well known in the probability theory and sometimes called as the birthday problem. Namely, the standard statement of the problem is as follows. There are S = 2s cells and m  ( = n / s) pellets. Each pellet is put in one of the cells with the probability 1 / S. It is known in Probability Theory that, if [formula] then the average number of cells with at least two pellets equals [formula] where S goes to ∞    ; see Kolchin, Sevast'yanov and Chistyakov, 1976. In our case the number of cells with at least two pellets is equal to the number of the words from the sequence ([\ref=s]) which are met two (or more) times. Having into account that S = 2s,m = n / s, we obtain from [formula] an informal rule for choosing the length of words in ([\ref=s]):

[formula]

where n is the length of a sample x1x2...xn, s is the block length. If s is much larger, the sequence ([\ref=s]) does not have repeated words (in case H0 ) and it is difficult to build a a sensible test. On the other hand, if s is much smaller, large classes of the alternative hypotheses cannot be tested (due to existence of the two-faced processes). It is worth noting that it is impossible to have a universal choice of s, because it is impossible to avoid the two- faced phenomenon. In other words this fact can be explained basing on the following known result of Information Theory: it is impossible to have guaranteed rate of code convergence universally for all ergodic sources; see Bailey, 1976, Ryabko, 1984. That is why, it is impossible to choose a universal length s. On the other hand, there are many applications where the word length s can be chosen experimentally. (But, of course, such experiments should be performed on the independent data.)

The experiments

In this part we describe some experiments carried out to compare new tests with known ones. We will compare order test, book stack test, tests which are based on standard data compression methods, and tests from Rukhin and others, 2001. The point is that the tests from Rukhin and others are selected basing on comprehensive theoretical and experimental analysis and can be considered as the state-of-the-art in randomness testing. Besides, we will also test the method recently published by Ryabko, Stognienko, Shokin, (2004), because it was published later than the book of Rukhin and others.

We used data generated by the PRNG "RANDU" (described in Dudewicz and Ralley, 1981) and random bits from "The Marsaglia Random Number CDROM", see: http://stat.fsu.edu/diehard/cdrom/ ). RANDU is a linear congruent generators (LCG), which is defined by the following equality

[formula]

where Xn is n-th generated number. RANDU is defined by parameters A = 216 + 3,C = 0,M = 231,X0  =  1. Those kinds of sources of random data were chosen because random bits from "The Marsaglia Random Number CDROM" are considered as good random numbers, whereas it is known that RANDU is not a good PRNG. It is known that the lowest digits of Xn are "less random" than the leading digits (Knuth, 1981), that is why in our experiments with RANDU we extract an eight-bit word from each generated Xi by formula X̂i  =  ⌊Xi / 223⌋.

The behavior of the tests was investigated for files of different lengths (see the tables below). We generated 100 different files of each length and applied each mentioned above test to each file with level of significance 0.01 (or less, see below). So, if a test is applied to a truly random bit sequence, on average 1 file from 100 should be rejected. All results are given in the tables, where integers in boxes are the number of rejected files (from 100). If a number of the rejections is not given for a certain length and test, it means that the test cannot be applied for files of such a length.

The table 1 contains information about testing of sequences of different lengths generated by RANDU, whereas the table 2 contains results of application of all tests to 5 000 000- bit sequences either generated by RANDU or taken from "The Marsaglia Random Number CDROM". For example, the first number of the second row of the table 1 is 56. It means that there were 100 files of the length 5  104 bits generated by PRNG RANDU. When the Order test was applied, the hypothesis H0 was rejected 56 times from 100 (and, correspondingly, H0 was accepted 44 times.) The first number of the third line shows that H0 was rejected 42 times, when the Book stack test was applied to the same 100 files. The third number of the second line shows that the hypothesis H0 was rejected 100 times, when the Order test was applied for testing of 100 100000 - bit files generated by RANDU, etc.

Let us first give some comments about the tests, which are based on popular data compression methods RAR and ARJ. In those cases we applied each method to a file and first estimated the length of compressed data. Then we use the test Γ(n)α,  φ with the critical value ([\ref=cr]) as follows. The alphabet size |A| = 28  =  256, n log |A| is simply the length of file (in bits) before compression, (whereas n is the length in bytes). So, taking α  =  0.01, from ([\ref=cr]), we see that the hypothesis about randomness (H0) should be rejected, if the length of compressed file is less than or equal to n log |A|  -  8 bits. (Strictly speaking, in this case α  ≤  2- 7  =  1 / 128.) So, taking into account that the length of computer files is measured in bytes, this rule is very simple: if the n - byte file is really compressed (i.e. the length of the encoded file is n - 1 bytes or less), this file is not random (and H0 is rejected). So, the following tables contain numbers of cases, where files were really compressed.

Let us now give some comments about parameters of the considered methods. As it was mentioned, we investigated all methods from the book of Rukhin and others (2001), the test of Ryabko, Stognienko and Shokin, 2004 (RSS test for short), the described above two tests based on data compression algorithms, the order tests and the book stack test. For some tests there are parameters, which should be specified. In such cases the values of parameters are given in the table in the row, which follows the test results. There are some tests from the book of Rukhin and others, where parameters can be chosen from a certain interval. In such cases we repeated all calculations three times, taking the minimal possible value of the parameter, the maximal one and the average one. Then the data for the case when the number of rejections of the hypothesis H0 is maximal, is given in the table.

The choice of parameters for RSS, the book stack test and the order test was made on the basis of special experiments, which were carried out for independent data. (Those algorithms are implemented as a Java program and can be found on the internet, see http: /  / web.ict.nsc.ru /     rng / .) In all cases such experiments have shown that for all three algorithms the optimal blocklength is close to the one defined by informal equality ([\ref=sn]).

We can see from the tables that the new tests can detect non-randomness more efficiently than the known ones. Seemingly, the main reason is that RSS, book stack tests and order test deal with such large blocklength as it is possible, whereas many other tests are focused on other goals. The second reason could be an ability for adaptation. The point is that the new tests can find subwords, which are more frequent than others, and use them for testing, whereas many other tests are looking for particular deviations from randomness.

In conclusion, we can say that the obtained results show that the new tests, as well as the ideas of Information Theory in general, can be useful tools for randomness testing.

Appendix.

Proof of Theorem 1. First we estimate the number of words φn(u) whose length is less than or equal to an integer τ. Obviously, at most one word can be encoded by the empty codeword, at most two words by the words of the length 1, ..., at most 2i can be encoded by the words of length i, etc. Having taken into account that the codewords φn(u)  ≠  φn(v) for different u and v, we obtain the inequality

[formula]

From this inequality and ([\ref=cr]) we can see that the number of words from the set {An}, whose codelength is less than or equal to tα  =  n log |A|  -   log (1 / α)  -  1, is not greater than 2n log |A|  -   log (1 / α). So, we obtained that

[formula]

Taking into account that all words from An have equal probabilities if H0 is true, we obtain from the last inequality, ([\ref=cr]) and the description of the test Γ(n)α,φ that

[formula]

if H0 is true. The theorem is proved.

Proof of Claim 1. The proof is based on a direct calculation of the probability of rejection for a case where H0 is true. From the description of the test Υ(n)α,φ and definition of g (see ([\ref=s])) we obtain the following chain of equalities.

[formula]

[formula]

[formula]

The claim is proved.

Proof of Claim 2. We can think that α in ([\ref=cr2]) is an integer. (Otherwise, we obtain the same test taking ⌊α⌋ as a new critical value of the test.) From the Kraft inequality ([\ref=KRAFT]) we obtain that

[formula]

This inequality and ([\ref=cr2]) yield:

[formula]

If H0 is true then the probability of each u∈An equals |A|- n and from the last inequality we obtain that

[formula]

if H0 is true. The claim is proved.

Proof of Theorem 3. We prove the theorem for the process T(k,π), but this proof is valid for (k,π), too. First we show that

[formula]

(x1...xd)∈{0,1}d, d = 1,...,k, is a stationary distribution for the processes T(k,π) (and (k,π)) for all [formula] and π∈(0,1). For any values of k,k  ≥  1, ([\ref=a3]) will be proved if we show that the system of equations

[formula]

[formula]

has the solution p(x1...xd) = 2- d, (x1...xd)∈{0,1}d, [formula]. It can be easily seen for d  =  k, if we take into account that, by definition of T(k,π) and (k,π), the equality PT(k,π)(xk / 0x1...xk - 1)    +    PT(k,π)(xk / 1x1...xk - 1) = 1 is valid for all (x1...xk)∈{0,1}k. From this equality and the law of total probability we immediately obtain ([\ref=a3]) for d  <  k.

Let us prove the second claim of the theorem. From the definition T(k,π) and (k,π) we can see that either PT(k,π)(0 / x1...xk) = π,  PT(k,π)(1 / x1...xk) = 1 - π or PT(k,π)(0 / x1...xk) = 1 - π,  PT(k,π)(1 / x1...xk) =   π. That is why h(xk + 1 / x1...xk)  =    -  (π log 2π  +  (1 - π) log 2(1 - π)) and, hence, h∞  =    -  (π log 2π  +  (1 - π) log 2(1 - π)). The theorem is proved.

Acknowledgment

The authors wish to thank one of anonymous reviewers for information about a unpublished thesis of David Harold Bailey.